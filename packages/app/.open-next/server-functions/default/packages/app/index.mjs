globalThis.monorepoPackagePath = "packages/app";
import process from "node:process";
import { Buffer } from "node:buffer";
import { createRequire as topLevelCreateRequire } from "module";
const require = topLevelCreateRequire(import.meta.url);
import bannerUrl from "url";
const __dirname = bannerUrl.fileURLToPath(new URL(".", import.meta.url));
globalThis.openNextDebug = false;
globalThis.openNextVersion = "3.6.5";
var R7e = Object.create;
var nO = Object.defineProperty;
var I7e = Object.getOwnPropertyDescriptor;
var P7e = Object.getOwnPropertyNames;
var v7e = Object.getPrototypeOf,
  O7e = Object.prototype.hasOwnProperty;
var Mi = ((e) =>
  typeof require < "u"
    ? require
    : typeof Proxy < "u"
      ? new Proxy(e, { get: (t, r) => (typeof require < "u" ? require : t)[r] })
      : e)(function (e) {
  if (typeof require < "u") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + e + '" is not supported');
});
var s = (e, t) => () => (e && (t = e((e = 0))), t);
var To = (e, t) => () => (t || e((t = { exports: {} }).exports, t), t.exports),
  It = (e, t) => {
    for (var r in t) nO(e, r, { get: t[r], enumerable: !0 });
  },
  k7e = (e, t, r, o) => {
    if ((t && typeof t == "object") || typeof t == "function")
      for (let n of P7e(t))
        !O7e.call(e, n) &&
          n !== r &&
          nO(e, n, {
            get: () => t[n],
            enumerable: !(o = I7e(t, n)) || o.enumerable,
          });
    return e;
  };
var sO = (e, t, r) => (
  (r = e != null ? R7e(v7e(e)) : {}),
  k7e(
    t || !e || !e.__esModule
      ? nO(r, "default", { value: e, enumerable: !0 })
      : r,
    e
  )
);
function xh(e) {
  try {
    return "__openNextInternal" in e;
  } catch {
    return !1;
  }
}
var O4 = s(() => {});
function He(...e) {
  globalThis.openNextDebug && console.log(...e);
}
function k4(...e) {
  console.warn(...e);
}
function kr(...e) {
  if (e.some((t) => N7e(t))) return He(...e);
  if (e.some((t) => xh(t))) {
    let t = e.find((r) => xh(r));
    return t.logLevel < B7e()
      ? void 0
      : t.logLevel === 0
        ? console.log(...e.map((r) => (xh(r) ? `${r.name}: ${r.message}` : r)))
        : t.logLevel === 1
          ? k4(...e.map((r) => (xh(r) ? `${r.name}: ${r.message}` : r)))
          : console.error(...e);
  }
  console.error(...e);
}
function B7e() {
  switch ((process.env.OPEN_NEXT_ERROR_LOG_LEVEL ?? "1").toLowerCase()) {
    case "debug":
    case "0":
      return 0;
    case "error":
    case "2":
      return 2;
    default:
      return 1;
  }
}
var D7e,
  N7e,
  Qm,
  mo = s(() => {
    O4();
    (D7e = [
      {
        clientName: "S3Client",
        commandName: "GetObjectCommand",
        errorName: "NoSuchKey",
      },
    ]),
      (N7e = (e) =>
        D7e.some(
          (t) =>
            t.clientName === e?.clientName &&
            t.commandName === e?.commandName &&
            (t.errorName === e?.error?.name || t.errorName === e?.error?.Code)
        ));
    Qm = { trace: () => {}, debug: () => {}, info: He, warn: k4, error: kr };
  });
import ei from "node:fs";
import Li from "node:path";
function D4(e) {
  let t = Li.join(e, "required-server-files.json"),
    r = ei.readFileSync(t, "utf-8"),
    { config: o } = JSON.parse(r);
  return o;
}
function N4(e) {
  let t = Li.join(e, "BUILD_ID");
  return ei.readFileSync(t, "utf-8").trim();
}
function iO(e) {
  let t = Li.join(e, "server/pages-manifest.json"),
    r = ei.readFileSync(t, "utf-8");
  return JSON.parse(r);
}
function B4(e) {
  return Object.entries(iO(e))
    .filter(([t, r]) => r.endsWith(".html"))
    .map(([t]) => t);
}
function M4(e) {
  let t = Li.join(e, "routes-manifest.json"),
    r = ei.readFileSync(t, "utf-8"),
    o = JSON.parse(r),
    n = o.dataRoutes ?? [],
    i = {
      static: n.filter((a) => a.routeKeys === void 0),
      dynamic: n.filter((a) => a.routeKeys !== void 0),
    };
  return {
    basePath: o.basePath,
    rewrites: Array.isArray(o.rewrites)
      ? { beforeFiles: [], afterFiles: o.rewrites, fallback: [] }
      : {
          beforeFiles: o.rewrites.beforeFiles ?? [],
          afterFiles: o.rewrites.afterFiles ?? [],
          fallback: o.rewrites.fallback ?? [],
        },
    redirects: o.redirects ?? [],
    routes: {
      static: o.staticRoutes ?? [],
      dynamic: o.dynamicRoutes ?? [],
      data: i,
    },
    locales: o.i18n?.locales ?? [],
  };
}
function L4(e) {
  let t = Li.join(e, "routes-manifest.json"),
    r = ei.readFileSync(t, "utf-8");
  return JSON.parse(r).headers;
}
function F4(e) {
  let t = Li.join(e, "prerender-manifest.json"),
    r = ei.readFileSync(t, "utf-8");
  return JSON.parse(r);
}
function U4(e) {
  let t = Li.join(e, "app-path-routes-manifest.json");
  return ei.existsSync(t) ? JSON.parse(ei.readFileSync(t, "utf-8")) : {};
}
function $4(e) {
  let t = Li.join(e, "server/middleware-manifest.json"),
    r = ei.readFileSync(t, "utf-8");
  return JSON.parse(r);
}
function H4(e) {
  let t = Li.join(e, "server/functions-config-manifest.json");
  try {
    let r = ei.readFileSync(t, "utf-8");
    return JSON.parse(r);
  } catch {
    return { functions: {}, version: 1 };
  }
}
var z4 = s(() => {});
import q4 from "node:path";
var Os,
  M7e,
  it,
  Xm,
  j4,
  vn,
  G4,
  Fi,
  V4,
  W4,
  aO,
  K4,
  ks = s(() => {
    mo();
    z4();
    (Os = q4.join(__dirname, ".next")),
      (M7e = q4.join(__dirname, ".open-next"));
    He({ NEXT_DIR: Os, OPEN_NEXT_DIR: M7e });
    (it = D4(Os)),
      (Xm = N4(Os)),
      (j4 = B4(Os)),
      (vn = M4(Os)),
      (G4 = L4(Os)),
      (Fi = F4(Os)),
      (V4 = iO(Os)),
      (W4 = $4(Os)),
      (aO = U4(Os)),
      (K4 = H4(Os));
  });
function Y4() {
  let e = process.env;
  e.NODE_ENV = process.env.NODE_ENV ?? "production";
}
function Q4() {
  return Math.random().toString(36).slice(2, 8);
}
function cO(e, t) {
  return e.reduce((o, n, i) => {
    let a = Math.floor(i / t);
    return (o[a] = [...(o[a] ?? []), n]), o;
  }, new Array());
}
function wx(e) {
  if (typeof e != "string") return e;
  let t = Number.parseInt(e);
  return Number.isNaN(t) ? void 0 : t;
}
var Eh = s(() => {});
function Ax(e) {
  return e
    ? typeof e == "string"
      ? e.split(/(?<!Expires=\w+),/i).map((t) => t.trim())
      : e
    : [];
}
function Rx(e) {
  let t = {};
  for (let [r, o] of e)
    r in t
      ? Array.isArray(t[r])
        ? t[r].push(o)
        : (t[r] = [t[r], o])
      : (t[r] = o);
  return t;
}
var Tx,
  L7e,
  Sh = s(() => {
    (Tx = (e) => {
      let t = {};
      if (!e) return t;
      for (let [r, o] of Object.entries(e))
        o !== void 0 && (t[r.toLowerCase()] = L7e(o));
      return t;
    }),
      (L7e = (e) =>
        typeof e == "string" ? e : Array.isArray(e) ? e.join(",") : String(e));
  });
import { Transform as F7e } from "node:stream";
var Kc,
  Yc,
  Ix,
  dO = s(() => {
    mo();
    Sh();
    (Kc = "set-cookie"),
      (Yc = "This cannot be used in OpenNext"),
      (Ix = class extends F7e {
        fixHeaders;
        onEnd;
        streamCreator;
        initialHeaders;
        statusCode;
        statusMessage = "";
        headers = {};
        _cookies = [];
        responseStream;
        headersSent = !1;
        _chunks = [];
        strictContentLength = !1;
        assignSocket(t) {
          throw new Error(Yc);
        }
        detachSocket(t) {
          throw new Error(Yc);
        }
        writeContinue(t) {
          throw new Error(Yc);
        }
        writeEarlyHints(t, r) {
          throw new Error(Yc);
        }
        writeProcessing() {
          throw new Error(Yc);
        }
        req;
        chunkedEncoding = !1;
        shouldKeepAlive = !0;
        useChunkedEncodingByDefault = !0;
        sendDate = !1;
        connection = null;
        socket = null;
        setTimeout(t, r) {
          throw new Error(Yc);
        }
        addTrailers(t) {
          throw new Error(Yc);
        }
        constructor(t, r, o, n) {
          super(),
            (this.fixHeaders = t),
            (this.onEnd = r),
            (this.streamCreator = o),
            (this.initialHeaders = n);
        }
        get originalResponse() {
          return this;
        }
        get finished() {
          return this.responseStream
            ? this.responseStream?.writableFinished
            : this.writableFinished;
        }
        setHeader(t, r) {
          let o = t.toLowerCase();
          return (
            o === Kc &&
              (Array.isArray(r) ? (this._cookies = r) : (this._cookies = [r])),
            (this.headers[o] = r),
            this
          );
        }
        removeHeader(t) {
          let r = t.toLowerCase();
          return r === Kc ? (this._cookies = []) : delete this.headers[r], this;
        }
        hasHeader(t) {
          let r = t.toLowerCase();
          return r === Kc
            ? this._cookies.length > 0
            : this.headers[r] !== void 0;
        }
        getHeaders() {
          return this.headers;
        }
        getHeader(t) {
          return this.headers[t.toLowerCase()];
        }
        getHeaderNames() {
          return Object.keys(this.headers);
        }
        flushHeaders() {
          this.headersSent = !0;
          let t =
            globalThis.__openNextAls?.getStore()?.mergeHeadersPriority ??
            "middleware";
          if (this.initialHeaders) {
            this.headers =
              t === "middleware"
                ? { ...this.headers, ...this.initialHeaders }
                : { ...this.initialHeaders, ...this.headers };
            let o = Ax(this.initialHeaders[Kc]?.toString());
            this._cookies =
              t === "middleware"
                ? [...this._cookies, ...o]
                : [...o, ...this._cookies];
          }
          this.fixHeaders(this.headers),
            this.fixHeadersForError(),
            (this.headers[Kc] = this._cookies);
          let r = Tx(this.headers);
          delete r[Kc],
            this.streamCreator &&
              ((this.responseStream = this.streamCreator?.writeHeaders({
                statusCode: this.statusCode ?? 200,
                cookies: this._cookies,
                headers: r,
              })),
              this.pipe(this.responseStream));
        }
        appendHeader(t, r) {
          let o = t.toLowerCase();
          if (!this.hasHeader(o)) return this.setHeader(o, r);
          let n = this.getHeader(o),
            i = Array.isArray(r) ? r : [r],
            a = Array.isArray(n) ? [...n, ...i] : [n, ...i];
          return this.setHeader(o, a);
        }
        writeHead(t, r, o) {
          let n = o,
            i;
          typeof r == "string" ? (i = r) : (n = r);
          let a = this.headers;
          if (n)
            if (Array.isArray(n))
              for (let c = 0; c < n.length; c += 2) a[n[c]] = n[c + 1];
            else for (let c of Object.keys(n)) a[c] = n[c];
          return (
            (this.statusCode = t),
            o && (this.headers = a),
            this.flushHeaders(),
            this
          );
        }
        getFixedHeaders() {
          return (
            this.fixHeaders(this.headers),
            this.fixHeadersForError(),
            (this.headers[Kc] = this._cookies),
            this.headers
          );
        }
        getBody() {
          return Buffer.concat(this._chunks);
        }
        _internalWrite(t, r) {
          this._chunks.push(Buffer.from(t, r)),
            this.push(t, r),
            this.streamCreator?.onWrite?.();
        }
        _transform(t, r, o) {
          this.headersSent || this.flushHeaders(),
            this._internalWrite(t, r),
            o();
        }
        _flush(t) {
          this.headersSent || this.flushHeaders(),
            globalThis.__openNextAls
              ?.getStore()
              ?.pendingPromiseRunner.add(this.onEnd(this.headers));
          let r = this.getBody().length;
          this.streamCreator?.onFinish?.(r),
            r === 0 &&
              process.env.OPEN_NEXT_FORCE_NON_EMPTY_RESPONSE === "true" &&
              (He('Force writing "SOMETHING" to the response body'),
              this.push("SOMETHING")),
            t();
        }
        setHeaders(t) {
          return (
            t.forEach((r, o) => {
              this.setHeader(o, Array.isArray(r) ? r : r.toString());
            }),
            this
          );
        }
        get sent() {
          return this.finished || this.headersSent;
        }
        getHeaderValues(t) {
          let r = this.getHeader(t);
          if (r !== void 0)
            return (Array.isArray(r) ? r : [r]).map((o) => o.toString());
        }
        send() {
          let t = this.getBody();
          this.end(t);
        }
        body(t) {
          return this.write(t), this;
        }
        onClose(t) {
          this.on("close", t);
        }
        redirect(t, r) {
          return (
            this.setHeader("Location", t),
            (this.statusCode = r),
            r === 308 && this.setHeader("Refresh", `0;url=${t}`),
            this
          );
        }
        fixHeadersForError() {
          process.env.OPEN_NEXT_DANGEROUSLY_SET_ERROR_HEADERS !== "true" &&
            (this.statusCode === 404 || this.statusCode === 500) &&
            (this.headers["cache-control"] =
              "private, no-cache, no-store, max-age=0, must-revalidate");
        }
      });
  });
function vx(e) {
  if (!e) return !1;
  let t = e?.split(";")[0] ?? "";
  return q7e.has(t);
}
var q7e,
  lO = s(() => {
    q7e = new Set([
      "application/octet-stream",
      "application/epub+zip",
      "application/msword",
      "application/pdf",
      "application/rtf",
      "application/vnd.amazon.ebook",
      "application/vnd.ms-excel",
      "application/vnd.ms-powerpoint",
      "application/vnd.openxmlformats-officedocument.presentationml.presentation",
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
      "font/otf",
      "font/woff",
      "font/woff2",
      "image/bmp",
      "image/gif",
      "image/jpeg",
      "image/png",
      "image/tiff",
      "image/vnd.microsoft.icon",
      "image/webp",
      "audio/3gpp",
      "audio/aac",
      "audio/basic",
      "audio/flac",
      "audio/mpeg",
      "audio/ogg",
      "audio/wavaudio/webm",
      "audio/x-aiff",
      "audio/x-midi",
      "audio/x-wav",
      "video/3gpp",
      "video/mp2t",
      "video/mpeg",
      "video/ogg",
      "video/quicktime",
      "video/webm",
      "video/x-msvideo",
      "application/java-archive",
      "application/vnd.apple.installer+xml",
      "application/x-7z-compressed",
      "application/x-apple-diskimage",
      "application/x-bzip",
      "application/x-bzip2",
      "application/x-gzip",
      "application/x-java-archive",
      "application/x-rar-compressed",
      "application/x-tar",
      "application/x-zip",
      "application/zip",
      "application/x-protobuf",
    ]);
  });
import { Readable as Jm } from "node:stream";
function J4(e, t) {
  let r = e.getReader(),
    o = [];
  return new Promise((n, i) => {
    function a() {
      r.read()
        .then(({ done: c, value: d }) => {
          if (c) {
            n(Buffer.concat(o).toString(t ? "base64" : "utf8"));
            return;
          }
          o.push(d), a();
        })
        .catch(i);
    }
    a();
  });
}
function Ox(e, t) {
  return Jm.toWeb(Jm.from(Buffer.from(e, t ? "base64" : "utf8")));
}
function Ds() {
  return process.env.OPEN_NEXT_FORCE_NON_EMPTY_RESPONSE === "true"
    ? Jm.toWeb(Jm.from([Buffer.from("SOMETHING")]))
    : Jm.toWeb(Jm.from([]));
}
var Zm = s(() => {});
function j7e(e, t, r) {
  let o = new Map(),
    n = e.replace(/[ \t]/g, "");
  if (t) {
    let f = 0;
    for (let l of t) {
      let u = l.toLowerCase();
      if ((o.set(u, { orig: l, pos: f++ }), r.prefixMatch)) {
        let h = u.split("-");
        for (; h.pop(), h.length > 0; ) {
          let y = h.join("-");
          o.has(y) || o.set(y, { orig: l, pos: f++ });
        }
      }
    }
  }
  let i = n.split(","),
    a = [],
    c = new Set();
  for (let f = 0; f < i.length; ++f) {
    let l = i[f];
    if (!l) continue;
    let u = l.split(";");
    if (u.length > 2) throw new Error(`Invalid ${r.type} header`);
    let h = u[0].toLowerCase();
    if (!h) throw new Error(`Invalid ${r.type} header`);
    let y = { token: h, pos: f, q: 1 };
    if (
      (t && o.has(h) && (y.pref = o.get(h).pos), c.add(y.token), u.length === 2)
    ) {
      let S = u[1],
        [E, b] = S.split("=");
      if (!b || (E !== "q" && E !== "Q"))
        throw new Error(`Invalid ${r.type} header`);
      let v = Number.parseFloat(b);
      if (v === 0) continue;
      Number.isFinite(v) && v <= 1 && v >= 0.001 && (y.q = v);
    }
    a.push(y);
  }
  a.sort((f, l) =>
    l.q !== f.q
      ? l.q - f.q
      : l.pref !== f.pref
        ? f.pref === void 0
          ? 1
          : l.pref === void 0
            ? -1
            : f.pref - l.pref
        : f.pos - l.pos
  );
  let d = a.map((f) => f.token);
  if (!t || !t.length) return d;
  let m = [];
  for (let f of d)
    if (f === "*") for (let [l, u] of o) c.has(l) || m.push(u.orig);
    else {
      let l = f.toLowerCase();
      o.has(l) && m.push(o.get(l).orig);
    }
  return m;
}
function fO(e = "", t) {
  return j7e(e, t, { type: "accept-language", prefixMatch: !0 })[0] || void 0;
}
var Z4 = s(() => {});
function G7e(e) {
  return it.i18n?.locales.includes(e.split("/")[1].toLowerCase()) ?? !1;
}
function V7e(e) {
  let t = it.i18n,
    r = e.NEXT_LOCALE?.toLowerCase();
  return r ? t?.locales.find((o) => r === o.toLowerCase()) : void 0;
}
function uO({ hostname: e, detectedLocale: t }) {
  let o = it.i18n?.domains;
  if (!o) return;
  let n = t?.toLowerCase();
  for (let i of o) {
    let a = i.domain.split(":", 1)[0].toLowerCase();
    if (
      e === a ||
      n === i.defaultLocale.toLowerCase() ||
      i.locales?.some((c) => n === c.toLowerCase())
    )
      return i;
  }
}
function bh(e, t) {
  let r = uO({ hostname: e.headers.host });
  if (t.localeDetection === !1) return r?.defaultLocale ?? t.defaultLocale;
  let o = V7e(e.cookies),
    n = fO(e.headers["accept-language"], t?.locales);
  return (
    He({
      cookiesLocale: o,
      preferredLocale: n,
      defaultLocale: t.defaultLocale,
      domainLocale: r,
    }),
    r?.defaultLocale ?? o ?? n ?? t.defaultLocale
  );
}
function Ui(e) {
  let t = it.i18n;
  return !t || G7e(e.rawPath) ? e.rawPath : `/${bh(e, t)}${e.rawPath}`;
}
function eV(e) {
  let t = it.i18n;
  if (!t || t.localeDetection === !1 || e.rawPath !== "/") return !1;
  let r = fO(e.headers["accept-language"], t?.locales),
    o = bh(e, t),
    n = uO({ hostname: e.headers.host }),
    i = uO({ detectedLocale: r });
  if (n && i) {
    let c = i.domain === n.domain,
      d = i.defaultLocale === r;
    if (!c || !d) {
      let m = `http${i.http ? "" : "s"}`,
        f = d ? "" : r;
      return {
        type: "core",
        statusCode: 307,
        headers: { Location: `${m}://${i.domain}/${f}` },
        body: Ds(),
        isBase64Encoded: !1,
      };
    }
  }
  let a = n?.defaultLocale ?? t.defaultLocale;
  return o.toLowerCase() !== a.toLowerCase()
    ? {
        type: "core",
        statusCode: 307,
        headers: { Location: $i(e.url, `/${o}`) },
        body: Ds(),
        isBase64Encoded: !1,
      }
    : !1;
}
var el = s(() => {
  ks();
  Zm();
  mo();
  Qc();
  Z4();
});
function W7e(e, t, r) {
  let o = K7e(e),
    n = (o += 1831565813);
  (n = Math.imul(n ^ (n >>> 15), n | 1)),
    (n ^= n + Math.imul(n ^ (n >>> 7), n | 61));
  let i = ((n ^ (n >>> 14)) >>> 0) / 4294967296,
    a = Math.floor(i * t);
  return `${r}-${a}`;
}
function kx(e) {
  let t = Number.parseInt(process.env.MAX_REVALIDATE_CONCURRENCY ?? "10");
  return W7e(e, t, "revalidate");
}
function K7e(e) {
  let t = 1779033703,
    r = 3144134277,
    o = 1013904242,
    n = 2773480762;
  for (let i = 0, a; i < e.length; i++)
    (a = e.charCodeAt(i)),
      (t = r ^ Math.imul(t ^ a, 597399067)),
      (r = o ^ Math.imul(r ^ a, 2869860233)),
      (o = n ^ Math.imul(o ^ a, 951274213)),
      (n = t ^ Math.imul(n ^ a, 2716044179));
  return (
    (t = Math.imul(o ^ (t >>> 18), 597399067)),
    (r = Math.imul(n ^ (r >>> 22), 2869860233)),
    (o = Math.imul(t ^ (o >>> 17), 951274213)),
    (n = Math.imul(r ^ (n >>> 19), 2716044179)),
    (t ^= r ^ o ^ n),
    (r ^= t),
    (o ^= t),
    (n ^= t),
    t >>> 0
  );
}
var pO = s(() => {});
import Y7e from "node:crypto";
import { Readable as tV } from "node:stream";
function Dx(e, t) {
  if (!e) return !1;
  let r = /^https?:\/\//;
  return t ? r.test(e) && !e.includes(t) : r.test(e);
}
function rV(e) {
  if (e === "") return {};
  let t = e.split("&");
  return Rx(
    t.map((r) => {
      let [o, n] = r.split("=");
      return [o, n];
    })
  );
}
function oV(e, t) {
  if (!t) {
    let n = /\/([^?]*)\??(.*)/,
      i = e.match(n);
    return {
      hostname: "",
      pathname: i?.[1] ? `/${i[1]}` : e,
      protocol: "",
      queryString: i?.[2] ?? "",
    };
  }
  let r = /^(https?:)\/\/?([^\/\s]+)(\/[^?]*)?(\?.*)?/,
    o = e.match(r);
  if (!o) throw new Error(`Invalid external URL: ${e}`);
  return {
    protocol: o[1] ?? "https:",
    hostname: o[2],
    pathname: o[3] ?? "",
    queryString: o[4]?.slice(1) ?? "",
  };
}
function $i(e, t) {
  let r = it.basePath ?? "";
  return new URL(`${r}${t}`, e).href;
}
function nV(e) {
  let t = e.statusCode || 200,
    r = Tx(e.getFixedHeaders()),
    o = vx(r["content-type"]) || !!r["content-encoding"],
    n = tV.toWeb(tV.from(e.getBody()));
  return {
    type: "core",
    statusCode: t,
    headers: r,
    body: n,
    isBase64Encoded: o,
  };
}
function hO(e) {
  let t = [];
  return (
    Object.entries(e).forEach(([r, o]) => {
      Array.isArray(o)
        ? o.forEach((n) => t.push(`${r}=${n}`))
        : t.push(`${r}=${o}`);
    }),
    t.length > 0 ? `?${t.join("&")}` : ""
  );
}
function Nx(e) {
  let t = new URLSearchParams(e),
    r = {};
  for (let o of t.keys()) {
    let n = t.getAll(o);
    r[o] = n.length > 1 ? n : n[0];
  }
  return r;
}
function sV(e, t) {
  if (t?.functions?.["/_middleware"])
    return (
      t.functions["/_middleware"].matchers?.map(
        ({ regexp: o }) => new RegExp(o)
      ) ?? [/.*/]
    );
  let r = e.middleware["/"];
  return r?.matchers ? r.matchers.map(({ regexp: o }) => new RegExp(o)) : [];
}
function _h(e, { isPath: t } = {}) {
  let r = e
    .replaceAll("(.)", "_\xB51_")
    .replaceAll("(..)", "_\xB52_")
    .replaceAll("(...)", "_\xB53_");
  return t ? r : r.replaceAll("+", "_\xB54_");
}
function Bx(e) {
  return e
    .replaceAll("_\xB51_", "(.)")
    .replaceAll("_\xB52_", "(..)")
    .replaceAll("_\xB53_", "(...)")
    .replaceAll("_\xB54_", "+");
}
function iV(e, t) {
  return e === "GET" || e === "HEAD" || !t
    ? void 0
    : new ReadableStream({
        start(o) {
          o.enqueue(t), o.close();
        },
      });
}
function Q7e(e, t) {
  if (e.rawPath === "/404" || e.rawPath === "/500") {
    if (process.env.OPEN_NEXT_DANGEROUSLY_SET_ERROR_HEADERS === "true") return;
    t[tn.CACHE_CONTROL] =
      "private, no-cache, no-store, max-age=0, must-revalidate";
    return;
  }
  let r = Ui(e);
  j4.includes(r) &&
    !e.headers["x-middleware-prefetch"] &&
    (t[tn.CACHE_CONTROL] =
      "public, max-age=0, s-maxage=31536000, must-revalidate");
}
function X7e(e) {
  let t = e[tn.CACHE_CONTROL];
  t &&
    (Array.isArray(t) && (t = t.join(",")),
    typeof t == "string" &&
      (e[tn.CACHE_CONTROL] = t.replace(
        /\bstale-while-revalidate(?!=)/,
        "stale-while-revalidate=2592000"
      )));
}
function J7e(e) {
  it.poweredByHeader && (e["X-OpenNext"] = "1"),
    globalThis.openNextDebug &&
      ((e["X-OpenNext-Version"] = globalThis.openNextVersion),
      (e["X-OpenNext-RequestId"] =
        globalThis.__openNextAls.getStore()?.requestId));
}
async function Z7e(e, t, r, o) {
  if (r[tn.NEXT_CACHE] === "STALE") {
    let n = o?.[Symbol.for("NextInternalRequestMeta")],
      i = n?._nextDidRewrite
        ? t.startsWith("/_next/data/")
          ? `/_next/data/${Xm}${n?._nextRewroteUrl}.json`
          : n?._nextRewroteUrl
        : t;
    try {
      let a = (m) => Y7e.createHash("md5").update(m).digest("hex"),
        c = globalThis.__openNextAls.getStore()?.lastModified ?? 0,
        d = `${r.etag ?? r.ETag ?? ""}`;
      await globalThis.queue.send({
        MessageBody: { host: e, url: i, eTag: d, lastModified: c },
        MessageDeduplicationId: a(`${t}-${c}-${d}`),
        MessageGroupId: kx(t),
      });
    } catch (a) {
      kr(`Failed to revalidate stale page ${t}`, a);
    }
  }
}
function eXe(e) {
  if (e[tn.NEXT_CACHE] === "REVALIDATED") {
    e[tn.CACHE_CONTROL] =
      "private, no-cache, no-store, max-age=0, must-revalidate";
    return;
  }
  let t = globalThis.__openNextAls.getStore()?.lastModified ?? 0;
  if (e[tn.NEXT_CACHE] === "HIT" && t > 0) {
    let r = Math.round((Date.now() - t) / 1e3),
      o = /s-maxage=(\d+)/,
      n = e[tn.CACHE_CONTROL];
    if ((He("cache-control", n, t, Date.now()), typeof n != "string")) return;
    let i = n.match(o),
      a = i ? Number.parseInt(i[1]) : void 0;
    if (a && a !== 31536e3) {
      let c = Math.max(a - r, 1);
      e[tn.CACHE_CONTROL] = `s-maxage=${c}, stale-while-revalidate=2592000`;
    }
  }
  e[tn.NEXT_CACHE] === "STALE" &&
    (e[tn.CACHE_CONTROL] = "s-maxage=2, stale-while-revalidate=2592000");
}
function gO(e, t, r) {
  let o = e.internalEvent;
  return new Ix(
    (n) => {
      Q7e(o, n), X7e(n), J7e(n), eXe(n);
    },
    async (n) => {
      await Z7e(o.headers.host, o.rawPath, n), await tXe(e, n);
    },
    r,
    t
  );
}
async function tXe(e, t) {
  let { internalEvent: r, resolvedRoutes: o, initialURL: n } = e,
    i = new URL(n).pathname;
  !(r.headers["x-isr"] === "1") &&
    t[tn.NEXT_CACHE] === "REVALIDATED" &&
    (await globalThis.cdnInvalidationHandler.invalidatePaths([
      { initialPath: i, rawPath: r.rawPath, resolvedRoutes: o },
    ]));
}
var tn,
  Qc = s(() => {
    ks();
    dO();
    Sh();
    mo();
    lO();
    el();
    pO();
    (function (e) {
      (e.CACHE_CONTROL = "cache-control"), (e.NEXT_CACHE = "x-nextjs-cache");
    })(tn || (tn = {}));
  });
function bV(e) {
  let t = {};
  for (let [r, o] of Object.entries(e)) o !== void 0 && (t[r] = o);
  return t;
}
function _V(e) {
  return e["x-forwarded-host"] ?? e.host ?? "on";
}
function wV(e) {
  return Rx(e.entries());
}
var EO = s(() => {
  Sh();
});
var OV = {};
It(OV, { default: () => LXe });
function DXe(e) {
  let { body: t, isBase64Encoded: r } = e;
  return Buffer.isBuffer(t)
    ? t
    : typeof t == "string"
      ? Buffer.from(t, r ? "base64" : "utf8")
      : typeof t == "object"
        ? Buffer.from(JSON.stringify(t))
        : Buffer.from("", "utf8");
}
function NXe(e) {
  let { headers: t, cookies: r } = e,
    o = {};
  Array.isArray(r) && (o.cookie = r.join("; "));
  for (let [n, i] of Object.entries(t || {})) o[n.toLowerCase()] = i;
  return o;
}
async function BXe(e) {
  let { rawPath: t, rawQueryString: r, requestContext: o } = e,
    n = NXe(e);
  return {
    type: "core",
    method: o.http.method,
    rawPath: t,
    url: `https://${_V(n)}${t}${r ? `?${r}` : ""}`,
    body: DXe(e),
    headers: n,
    remoteAddress: o.http.sourceIp,
    query: bV(Nx(r)),
    cookies:
      e.cookies?.reduce((i, a) => {
        let [c, d] = a.split("=");
        return (i[c] = d), i;
      }, {}) ?? {},
  };
}
async function MXe(e) {
  let t = {};
  Object.entries(e.headers)
    .map(([n, i]) => [n.toLowerCase(), i])
    .filter(
      ([n]) => !kXe.some((i) => (typeof i == "string" ? i === n : i.test(n)))
    )
    .forEach(([n, i]) => {
      if (i == null) {
        t[n] = "";
        return;
      }
      t[n] = Array.isArray(i) ? i.join(", ") : `${i}`;
    });
  let r = await J4(e.body, e.isBase64Encoded),
    o = {
      statusCode: e.statusCode,
      headers: t,
      cookies: Ax(e.headers["set-cookie"]),
      body: r,
      isBase64Encoded: e.isBase64Encoded,
    };
  return He(o), o;
}
var kXe,
  LXe,
  kV = s(() => {
    Sh();
    Zm();
    mo();
    Qc();
    EO();
    kXe = [
      "connection",
      "expect",
      "keep-alive",
      "proxy-authenticate",
      "proxy-authorization",
      "proxy-connection",
      "trailer",
      "upgrade",
      "x-accel-buffering",
      "x-accel-charset",
      "x-accel-limit-rate",
      "x-accel-redirect",
      /x-amz-cf-(.*)/,
      /x-amzn-(.*)/,
      /x-edge-(.*)/,
      "x-cache",
      "x-forwarded-proto",
      "x-real-ip",
      "set-cookie",
      "age",
      "via",
    ];
    LXe = { convertFrom: BXe, convertTo: MXe, name: "aws-apigw-v2" };
  });
var NV = {};
It(NV, { default: () => $Xe, formatWarmerResponse: () => DV });
import { Writable as FXe } from "node:stream";
function DV(e) {
  return new Promise((t) => {
    setTimeout(() => {
      t({ serverId, type: "warmer" });
    }, e.delay);
  });
}
var UXe,
  $Xe,
  BV = s(() => {
    (UXe = async (e, t) => async (r) => {
      if ("type" in r) return DV(r);
      let o = await t.convertFrom(r),
        i = await e(o, {
          streamCreator: {
            writeHeaders: () =>
              new FXe({
                write: (a, c, d) => {
                  d();
                },
              }),
          },
        });
      return t.convertTo(i, r);
    }),
      ($Xe = { wrapper: UXe, name: "aws-lambda", supportStreaming: !1 });
  });
var MV = s(() => {});
var LV,
  FV = s(() => {
    (function (e) {
      (e.HEADER = "header"), (e.QUERY = "query");
    })(LV || (LV = {}));
  });
var UV,
  $V = s(() => {
    (function (e) {
      (e.HEADER = "header"), (e.QUERY = "query");
    })(UV || (UV = {}));
  });
var HV = s(() => {});
var zV = s(() => {});
var qV = s(() => {});
var jV = s(() => {});
var GV = s(() => {
  FV();
  $V();
  HV();
  zV();
  qV();
  jV();
});
var VV = s(() => {});
var WV = s(() => {});
var KV = s(() => {});
var YV = s(() => {});
var QV = s(() => {});
var XV = s(() => {});
var JV = s(() => {});
var ZV = s(() => {
  QV();
  XV();
  JV();
});
var e8 = s(() => {});
var t8 = s(() => {});
var r8,
  o8 = s(() => {
    (function (e) {
      (e.HTTP = "http"), (e.HTTPS = "https");
    })(r8 || (r8 = {}));
  });
var n8 = s(() => {});
var s8 = s(() => {});
var i8 = s(() => {});
var a8 = s(() => {});
var c8 = s(() => {});
var d8 = s(() => {
  n8();
  s8();
  i8();
  a8();
  c8();
});
var m8 = s(() => {});
var bO,
  _O = s(() => {
    (function (e) {
      (e.MD5 = "md5"),
        (e.CRC32 = "crc32"),
        (e.CRC32C = "crc32c"),
        (e.SHA1 = "sha1"),
        (e.SHA256 = "sha256");
    })(bO || (bO = {}));
  });
var l8 = s(() => {
  _O();
});
var f8 = s(() => {});
var u8 = s(() => {
  l8();
  f8();
  _O();
});
var p8 = s(() => {});
var h8,
  g8 = s(() => {
    (function (e) {
      (e[(e.HEADER = 0)] = "HEADER"), (e[(e.TRAILER = 1)] = "TRAILER");
    })(h8 || (h8 = {}));
  });
var y8 = s(() => {});
var x8 = s(() => {});
var E8 = s(() => {});
var S8 = s(() => {});
var C8 = s(() => {});
var b8 = s(() => {
  x8();
  E8();
  S8();
  C8();
});
var _8 = s(() => {});
var wO,
  w8 = s(() => {
    wO = "__smithy_context";
  });
var T8 = s(() => {});
var A8,
  R8 = s(() => {
    (function (e) {
      (e.PROFILE = "profile"),
        (e.SSO_SESSION = "sso-session"),
        (e.SERVICES = "services");
    })(A8 || (A8 = {}));
  });
var I8 = s(() => {});
var P8 = s(() => {});
var v8 = s(() => {});
var O8 = s(() => {});
var k8 = s(() => {});
var D8 = s(() => {});
var N8 = s(() => {});
var B8 = s(() => {});
var M8 = s(() => {});
var L8 = s(() => {});
var F8 = s(() => {});
var U8,
  $8 = s(() => {
    (function (e) {
      (e.HTTP_0_9 = "http/0.9"),
        (e.HTTP_1_0 = "http/1.0"),
        (e.TDS_8_0 = "tds/8.0");
    })(U8 || (U8 = {}));
  });
var H8 = s(() => {});
var z8 = s(() => {});
var q8 = s(() => {});
var j8 = s(() => {});
var G8 = s(() => {});
var V8 = s(() => {});
var W8 = s(() => {});
var K8 = s(() => {
  MV();
  GV();
  VV();
  WV();
  KV();
  YV();
  ZV();
  e8();
  t8();
  o8();
  d8();
  m8();
  u8();
  p8();
  g8();
  y8();
  b8();
  _8();
  w8();
  T8();
  R8();
  I8();
  P8();
  v8();
  O8();
  k8();
  D8();
  N8();
  B8();
  M8();
  L8();
  F8();
  $8();
  H8();
  z8();
  q8();
  j8();
  G8();
  V8();
  W8();
});
var bt,
  Y8 = s(() => {
    K8();
    bt = (e) => e[wO] || (e[wO] = {});
  });
var pe,
  Q8 = s(() => {
    pe = (e) => {
      if (typeof e == "function") return e;
      let t = Promise.resolve(e);
      return () => t;
    };
  });
var ct = s(() => {
  Y8();
  Q8();
});
function Ph(e) {
  return HXe.includes(e);
}
var $x,
  HXe,
  Hx = s(() => {
    ($x = "preferred"), (HXe = ["disabled", "preferred", "required"]);
  });
var X8,
  J8 = s(() => {
    ct();
    Hx();
    X8 = (e) => {
      let { accountIdEndpointMode: t } = e,
        r = pe(t ?? $x);
      return Object.assign(e, {
        accountIdEndpointMode: async () => {
          let o = await r();
          if (!Ph(o))
            throw new Error(
              `Invalid value for accountIdEndpointMode: ${o}. Valid values are: "required", "preferred", "disabled".`
            );
          return o;
        },
      });
    };
  });
var Z8,
  eW,
  zXe,
  qXe,
  tW,
  rW = s(() => {
    Hx();
    (Z8 = "Invalid AccountIdEndpointMode value"),
      (eW = (e) => {
        throw new Error(e);
      }),
      (zXe = "AWS_ACCOUNT_ID_ENDPOINT_MODE"),
      (qXe = "account_id_endpoint_mode"),
      (tW = {
        environmentVariableSelector: (e) => {
          let t = e[zXe];
          return t && !Ph(t) && eW(Z8), t;
        },
        configFileSelector: (e) => {
          let t = e[qXe];
          return t && !Ph(t) && eW(Z8), t;
        },
        default: $x,
      });
  });
var TO = s(() => {
  J8();
  Hx();
  rW();
});
var oW,
  AO,
  nW,
  sW,
  iW = s(() => {
    (oW = ["AWS_ENABLE_ENDPOINT_DISCOVERY", "AWS_ENDPOINT_DISCOVERY_ENABLED"]),
      (AO = "endpoint_discovery_enabled"),
      (nW = (e) => ["false", "0"].indexOf(e) >= 0),
      (sW = {
        environmentVariableSelector: (e) => {
          for (let t = 0; t < oW.length; t++) {
            let r = oW[t];
            if (r in e) {
              let o = e[r];
              if (o === "")
                throw Error(
                  `Environment variable ${r} can't be empty of undefined, got "${o}"`
                );
              return !nW(o);
            }
          }
        },
        configFileSelector: (e) => {
          if (AO in e) {
            let t = e[AO];
            if (t === void 0)
              throw Error(
                `Shared config entry ${AO} can't be undefined, got "${t}"`
              );
            return !nW(t);
          }
        },
        default: void 0,
      });
  });
var aW = s(() => {});
var cW = s(() => {
  aW();
});
var dW = s(() => {});
var mW,
  lW = s(() => {
    (function (e) {
      (e.HEADER = "header"), (e.QUERY = "query");
    })(mW || (mW = {}));
  });
var fW,
  uW = s(() => {
    (function (e) {
      (e.HEADER = "header"), (e.QUERY = "query");
    })(fW || (fW = {}));
  });
var pW = s(() => {});
var hW = s(() => {});
var gW = s(() => {});
var yW = s(() => {});
var xW = s(() => {
  lW();
  uW();
  pW();
  hW();
  gW();
  yW();
});
var EW = s(() => {});
var SW = s(() => {});
var CW = s(() => {});
var bW = s(() => {});
var _W = s(() => {});
var wW = s(() => {});
var TW = s(() => {});
var AW = s(() => {
  _W();
  wW();
  TW();
});
var RW = s(() => {});
var IW = s(() => {});
var PW,
  vW = s(() => {
    (function (e) {
      (e.HTTP = "http"), (e.HTTPS = "https");
    })(PW || (PW = {}));
  });
var OW = s(() => {});
var kW = s(() => {});
var DW = s(() => {});
var NW = s(() => {});
var BW = s(() => {});
var MW = s(() => {
  OW();
  kW();
  DW();
  NW();
  BW();
});
var LW = s(() => {});
var RO,
  IO = s(() => {
    (function (e) {
      (e.MD5 = "md5"),
        (e.CRC32 = "crc32"),
        (e.CRC32C = "crc32c"),
        (e.SHA1 = "sha1"),
        (e.SHA256 = "sha256");
    })(RO || (RO = {}));
  });
var FW = s(() => {
  IO();
});
var UW = s(() => {});
var $W = s(() => {
  FW();
  UW();
  IO();
});
var HW = s(() => {});
var PO,
  zW = s(() => {
    (function (e) {
      (e[(e.HEADER = 0)] = "HEADER"), (e[(e.TRAILER = 1)] = "TRAILER");
    })(PO || (PO = {}));
  });
var qW = s(() => {});
var jW = s(() => {});
var GW = s(() => {});
var VW = s(() => {});
var WW = s(() => {});
var KW = s(() => {
  jW();
  GW();
  VW();
  WW();
});
var YW = s(() => {});
var QW = s(() => {});
var XW = s(() => {});
var JW,
  ZW = s(() => {
    (function (e) {
      (e.PROFILE = "profile"),
        (e.SSO_SESSION = "sso-session"),
        (e.SERVICES = "services");
    })(JW || (JW = {}));
  });
var e6 = s(() => {});
var t6 = s(() => {});
var r6 = s(() => {});
var o6 = s(() => {});
var n6 = s(() => {});
var s6 = s(() => {});
var i6 = s(() => {});
var a6 = s(() => {});
var c6 = s(() => {});
var d6 = s(() => {});
var m6 = s(() => {});
var l6,
  f6 = s(() => {
    (function (e) {
      (e.HTTP_0_9 = "http/0.9"),
        (e.HTTP_1_0 = "http/1.0"),
        (e.TDS_8_0 = "tds/8.0");
    })(l6 || (l6 = {}));
  });
var u6 = s(() => {});
var p6 = s(() => {});
var h6 = s(() => {});
var g6 = s(() => {});
var y6 = s(() => {});
var x6 = s(() => {});
var E6 = s(() => {});
var S6 = s(() => {
  dW();
  xW();
  EW();
  SW();
  CW();
  bW();
  AW();
  RW();
  IW();
  vW();
  MW();
  LW();
  $W();
  HW();
  zW();
  qW();
  KW();
  YW();
  QW();
  XW();
  ZW();
  e6();
  t6();
  r6();
  o6();
  n6();
  s6();
  i6();
  a6();
  c6();
  d6();
  m6();
  f6();
  u6();
  p6();
  h6();
  g6();
  y6();
  x6();
  E6();
});
var C6 = s(() => {
  S6();
});
var b6 = s(() => {});
var _6 = s(() => {});
var w6 = s(() => {});
var T6 = s(() => {});
var A6 = s(() => {});
var R6 = s(() => {});
var I6 = s(() => {
  cW();
  C6();
  b6();
  _6();
  w6();
  T6();
  A6();
  R6();
});
var P6 = s(() => {});
var v6 = s(() => {});
var O6 = s(() => {
  I6();
  P6();
  v6();
});
var k6 = s(() => {
  O6();
});
var D6 = s(() => {});
var B6 = To((NDt, N6) => {
  function Hi(e) {
    Object.defineProperty(this, "_next", {
      writable: !1,
      enumerable: !1,
      value: e,
    }),
      (this.done = !1);
  }
  Hi.prototype.next = function () {
    if (this.done) return { done: !0 };
    var e = this._next();
    return e.done && (this.done = !0), e;
  };
  typeof Symbol < "u" &&
    (Hi.prototype[Symbol.iterator] = function () {
      return this;
    });
  Hi.of = function () {
    var e = arguments,
      t = e.length,
      r = 0;
    return new Hi(function () {
      return r >= t ? { done: !0 } : { done: !1, value: e[r++] };
    });
  };
  Hi.empty = function () {
    var e = new Hi(null);
    return (e.done = !0), e;
  };
  Hi.is = function (e) {
    return e instanceof Hi
      ? !0
      : typeof e == "object" && e !== null && typeof e.next == "function";
  };
  N6.exports = Hi;
});
var vO = To((BDt, U6) => {
  var M6 = typeof ArrayBuffer < "u",
    L6 = typeof Symbol < "u";
  function F6(e, t) {
    var r, o, n, i, a;
    if (!e) throw new Error("obliterator/forEach: invalid iterable.");
    if (typeof t != "function")
      throw new Error("obliterator/forEach: expecting a callback.");
    if (
      Array.isArray(e) ||
      (M6 && ArrayBuffer.isView(e)) ||
      typeof e == "string" ||
      e.toString() === "[object Arguments]"
    ) {
      for (n = 0, i = e.length; n < i; n++) t(e[n], n);
      return;
    }
    if (typeof e.forEach == "function") {
      e.forEach(t);
      return;
    }
    if (
      (L6 &&
        Symbol.iterator in e &&
        typeof e.next != "function" &&
        (e = e[Symbol.iterator]()),
      typeof e.next == "function")
    ) {
      for (r = e, n = 0; (a = r.next()), a.done !== !0; ) t(a.value, n), n++;
      return;
    }
    for (o in e) e.hasOwnProperty(o) && t(e[o], o);
  }
  F6.forEachWithNullKeys = function (e, t) {
    var r, o, n, i, a;
    if (!e)
      throw new Error("obliterator/forEachWithNullKeys: invalid iterable.");
    if (typeof t != "function")
      throw new Error("obliterator/forEachWithNullKeys: expecting a callback.");
    if (
      Array.isArray(e) ||
      (M6 && ArrayBuffer.isView(e)) ||
      typeof e == "string" ||
      e.toString() === "[object Arguments]"
    ) {
      for (n = 0, i = e.length; n < i; n++) t(e[n], null);
      return;
    }
    if (e instanceof Set) {
      e.forEach(function (c) {
        t(c, null);
      });
      return;
    }
    if (typeof e.forEach == "function") {
      e.forEach(t);
      return;
    }
    if (
      (L6 &&
        Symbol.iterator in e &&
        typeof e.next != "function" &&
        (e = e[Symbol.iterator]()),
      typeof e.next == "function")
    ) {
      for (r = e, n = 0; (a = r.next()), a.done !== !0; ) t(a.value, null), n++;
      return;
    }
    for (o in e) e.hasOwnProperty(o) && t(e[o], o);
  };
  U6.exports = F6;
});
var OO = To((ti) => {
  var jXe = Math.pow(2, 8) - 1,
    GXe = Math.pow(2, 16) - 1,
    VXe = Math.pow(2, 32) - 1,
    WXe = Math.pow(2, 7) - 1,
    KXe = Math.pow(2, 15) - 1,
    YXe = Math.pow(2, 31) - 1;
  ti.getPointerArray = function (e) {
    var t = e - 1;
    return t <= jXe
      ? Uint8Array
      : t <= GXe
        ? Uint16Array
        : t <= VXe
          ? Uint32Array
          : Float64Array;
  };
  ti.getSignedPointerArray = function (e) {
    var t = e - 1;
    return t <= WXe
      ? Int8Array
      : t <= KXe
        ? Int16Array
        : t <= YXe
          ? Int32Array
          : Float64Array;
  };
  ti.getNumberType = function (e) {
    return e === (e | 0)
      ? Math.sign(e) === -1
        ? e <= 127 && e >= -128
          ? Int8Array
          : e <= 32767 && e >= -32768
            ? Int16Array
            : Int32Array
        : e <= 255
          ? Uint8Array
          : e <= 65535
            ? Uint16Array
            : Uint32Array
      : Float64Array;
  };
  var QXe = {
    Uint8Array: 1,
    Int8Array: 2,
    Uint16Array: 3,
    Int16Array: 4,
    Uint32Array: 5,
    Int32Array: 6,
    Float32Array: 7,
    Float64Array: 8,
  };
  ti.getMinimalRepresentation = function (e, t) {
    var r = null,
      o = 0,
      n,
      i,
      a,
      c,
      d;
    for (c = 0, d = e.length; c < d; c++)
      (a = t ? t(e[c]) : e[c]),
        (i = ti.getNumberType(a)),
        (n = QXe[i.name]),
        n > o && ((o = n), (r = i));
    return r;
  };
  ti.isTypedArray = function (e) {
    return typeof ArrayBuffer < "u" && ArrayBuffer.isView(e);
  };
  ti.concat = function () {
    var e = 0,
      t,
      r,
      o;
    for (t = 0, o = arguments.length; t < o; t++) e += arguments[t].length;
    var n = new arguments[0].constructor(e);
    for (t = 0, r = 0; t < o; t++)
      n.set(arguments[t], r), (r += arguments[t].length);
    return n;
  };
  ti.indices = function (e) {
    for (var t = ti.getPointerArray(e), r = new t(e), o = 0; o < e; o++)
      r[o] = o;
    return r;
  };
});
var z6 = To((vh) => {
  var $6 = vO(),
    H6 = OO();
  function XXe(e) {
    return Array.isArray(e) || H6.isTypedArray(e);
  }
  function kO(e) {
    if (typeof e.length == "number") return e.length;
    if (typeof e.size == "number") return e.size;
  }
  function JXe(e) {
    var t = kO(e),
      r = typeof t == "number" ? new Array(t) : [],
      o = 0;
    return (
      $6(e, function (n) {
        r[o++] = n;
      }),
      r
    );
  }
  function ZXe(e) {
    var t = kO(e),
      r = typeof t == "number" ? H6.getPointerArray(t) : Array,
      o = typeof t == "number" ? new Array(t) : [],
      n = typeof t == "number" ? new r(t) : [],
      i = 0;
    return (
      $6(e, function (a) {
        (o[i] = a), (n[i] = i++);
      }),
      [o, n]
    );
  }
  vh.isArrayLike = XXe;
  vh.guessLength = kO;
  vh.toArray = JXe;
  vh.toArrayWithIndices = ZXe;
});
var j6 = To((FDt, q6) => {
  var DO = B6(),
    eJe = vO(),
    tJe = OO(),
    rJe = z6();
  function zr(e, t, r) {
    if (
      (arguments.length < 2 && ((r = e), (e = null), (t = null)),
      (this.capacity = r),
      typeof this.capacity != "number" || this.capacity <= 0)
    )
      throw new Error(
        "mnemonist/lru-cache: capacity should be positive number."
      );
    var o = tJe.getPointerArray(r);
    (this.forward = new o(r)),
      (this.backward = new o(r)),
      (this.K = typeof e == "function" ? new e(r) : new Array(r)),
      (this.V = typeof t == "function" ? new t(r) : new Array(r)),
      (this.size = 0),
      (this.head = 0),
      (this.tail = 0),
      (this.items = {});
  }
  zr.prototype.clear = function () {
    (this.size = 0), (this.head = 0), (this.tail = 0), (this.items = {});
  };
  zr.prototype.splayOnTop = function (e) {
    var t = this.head;
    if (this.head === e) return this;
    var r = this.backward[e],
      o = this.forward[e];
    return (
      this.tail === e ? (this.tail = r) : (this.backward[o] = r),
      (this.forward[r] = o),
      (this.backward[t] = e),
      (this.head = e),
      (this.forward[e] = t),
      this
    );
  };
  zr.prototype.set = function (e, t) {
    var r = this.items[e];
    if (typeof r < "u") {
      this.splayOnTop(r), (this.V[r] = t);
      return;
    }
    this.size < this.capacity
      ? (r = this.size++)
      : ((r = this.tail),
        (this.tail = this.backward[r]),
        delete this.items[this.K[r]]),
      (this.items[e] = r),
      (this.K[r] = e),
      (this.V[r] = t),
      (this.forward[r] = this.head),
      (this.backward[this.head] = r),
      (this.head = r);
  };
  zr.prototype.setpop = function (e, t) {
    var r = null,
      o = null,
      n = this.items[e];
    return typeof n < "u"
      ? (this.splayOnTop(n),
        (r = this.V[n]),
        (this.V[n] = t),
        { evicted: !1, key: e, value: r })
      : (this.size < this.capacity
          ? (n = this.size++)
          : ((n = this.tail),
            (this.tail = this.backward[n]),
            (r = this.V[n]),
            (o = this.K[n]),
            delete this.items[this.K[n]]),
        (this.items[e] = n),
        (this.K[n] = e),
        (this.V[n] = t),
        (this.forward[n] = this.head),
        (this.backward[this.head] = n),
        (this.head = n),
        o ? { evicted: !0, key: o, value: r } : null);
  };
  zr.prototype.has = function (e) {
    return e in this.items;
  };
  zr.prototype.get = function (e) {
    var t = this.items[e];
    if (!(typeof t > "u")) return this.splayOnTop(t), this.V[t];
  };
  zr.prototype.peek = function (e) {
    var t = this.items[e];
    if (!(typeof t > "u")) return this.V[t];
  };
  zr.prototype.forEach = function (e, t) {
    t = arguments.length > 1 ? t : this;
    for (
      var r = 0,
        o = this.size,
        n = this.head,
        i = this.K,
        a = this.V,
        c = this.forward;
      r < o;

    )
      e.call(t, a[n], i[n], this), (n = c[n]), r++;
  };
  zr.prototype.keys = function () {
    var e = 0,
      t = this.size,
      r = this.head,
      o = this.K,
      n = this.forward;
    return new DO(function () {
      if (e >= t) return { done: !0 };
      var i = o[r];
      return e++, e < t && (r = n[r]), { done: !1, value: i };
    });
  };
  zr.prototype.values = function () {
    var e = 0,
      t = this.size,
      r = this.head,
      o = this.V,
      n = this.forward;
    return new DO(function () {
      if (e >= t) return { done: !0 };
      var i = o[r];
      return e++, e < t && (r = n[r]), { done: !1, value: i };
    });
  };
  zr.prototype.entries = function () {
    var e = 0,
      t = this.size,
      r = this.head,
      o = this.K,
      n = this.V,
      i = this.forward;
    return new DO(function () {
      if (e >= t) return { done: !0 };
      var a = o[r],
        c = n[r];
      return e++, e < t && (r = i[r]), { done: !1, value: [a, c] };
    });
  };
  typeof Symbol < "u" && (zr.prototype[Symbol.iterator] = zr.prototype.entries);
  zr.prototype.inspect = function () {
    for (var e = new Map(), t = this.entries(), r; (r = t.next()), !r.done; )
      e.set(r.value[0], r.value[1]);
    return (
      Object.defineProperty(e, "constructor", { value: zr, enumerable: !1 }), e
    );
  };
  typeof Symbol < "u" &&
    (zr.prototype[Symbol.for("nodejs.util.inspect.custom")] =
      zr.prototype.inspect);
  zr.from = function (e, t, r, o) {
    if (arguments.length < 2) {
      if (((o = rJe.guessLength(e)), typeof o != "number"))
        throw new Error(
          "mnemonist/lru-cache.from: could not guess iterable length. Please provide desired capacity as last argument."
        );
    } else arguments.length === 2 && ((o = t), (t = null), (r = null));
    var n = new zr(t, r, o);
    return (
      eJe(e, function (i, a) {
        n.set(a, i);
      }),
      n
    );
  };
  q6.exports = zr;
});
var G6,
  zx,
  V6 = s(() => {
    (G6 = sO(j6())),
      (zx = class {
        cache;
        constructor(t) {
          this.cache = new G6.default(t);
        }
        getEndpoint(t) {
          let r = this.get(t);
          if (!r || r.length === 0) return;
          let o = r.map((n) => n.Address);
          return o[Math.floor(Math.random() * o.length)];
        }
        get(t) {
          if (!this.has(t)) return;
          let r = this.cache.get(t);
          if (!r) return;
          let o = Date.now(),
            n = r.filter((i) => o < i.Expires);
          if (n.length === 0) {
            this.delete(t);
            return;
          }
          return n;
        }
        set(t, r) {
          let o = Date.now();
          this.cache.set(
            t,
            r.map(({ Address: n, CachePeriodInMinutes: i }) => ({
              Address: n,
              Expires: o + i * 60 * 1e3,
            }))
          );
        }
        delete(t) {
          this.cache.set(t, []);
        }
        has(t) {
          if (!this.cache.has(t)) return !1;
          let r = this.cache.peek(t);
          return r ? r.length > 0 : !1;
        }
        clear() {
          this.cache.clear();
        }
      });
  });
var W6 = s(() => {
  D6();
  V6();
});
var K6,
  Y6 = s(() => {
    W6();
    K6 = (e, { endpointDiscoveryCommandCtor: t }) => {
      let {
        endpointCacheSize: r,
        endpointDiscoveryEnabled: o,
        endpointDiscoveryEnabledProvider: n,
      } = e;
      return Object.assign(e, {
        endpointDiscoveryCommandCtor: t,
        endpointCache: new zx(r ?? 1e3),
        endpointDiscoveryEnabled: o !== void 0 ? () => Promise.resolve(o) : n,
        isClientEndpointDiscoveryEnabled: o !== void 0,
      });
    };
  });
var NO = s(() => {
  iW();
  k6();
  Y6();
});
var qx,
  jx,
  Q6 = s(() => {
    (qx = (e) => ({
      setHttpHandler(t) {
        e.httpHandler = t;
      },
      httpHandler() {
        return e.httpHandler;
      },
      updateHttpClientConfig(t, r) {
        e.httpHandler?.updateHttpClientConfig(t, r);
      },
      httpHandlerConfigs() {
        return e.httpHandler.httpHandlerConfigs();
      },
    })),
      (jx = (e) => ({ httpHandler: e.httpHandler() }));
  });
var X6 = s(() => {
  Q6();
});
var J6 = s(() => {});
var Z6,
  eK = s(() => {
    (function (e) {
      (e.HEADER = "header"), (e.QUERY = "query");
    })(Z6 || (Z6 = {}));
  });
var tK,
  rK = s(() => {
    (function (e) {
      (e.HEADER = "header"), (e.QUERY = "query");
    })(tK || (tK = {}));
  });
var oK = s(() => {});
var nK = s(() => {});
var sK = s(() => {});
var iK = s(() => {});
var aK = s(() => {
  eK();
  rK();
  oK();
  nK();
  sK();
  iK();
});
var cK = s(() => {});
var dK = s(() => {});
var mK = s(() => {});
var lK = s(() => {});
var fK = s(() => {});
var uK = s(() => {});
var pK = s(() => {});
var hK = s(() => {
  fK();
  uK();
  pK();
});
var gK = s(() => {});
var yK = s(() => {});
var xK,
  EK = s(() => {
    (function (e) {
      (e.HTTP = "http"), (e.HTTPS = "https");
    })(xK || (xK = {}));
  });
var SK = s(() => {});
var CK = s(() => {});
var bK = s(() => {});
var _K = s(() => {});
var wK = s(() => {});
var TK = s(() => {
  SK();
  CK();
  bK();
  _K();
  wK();
});
var AK = s(() => {});
var nl,
  BO = s(() => {
    (function (e) {
      (e.MD5 = "md5"),
        (e.CRC32 = "crc32"),
        (e.CRC32C = "crc32c"),
        (e.SHA1 = "sha1"),
        (e.SHA256 = "sha256");
    })(nl || (nl = {}));
  });
var RK = s(() => {
  BO();
});
var IK = s(() => {});
var PK = s(() => {
  RK();
  IK();
  BO();
});
var vK = s(() => {});
var MO,
  OK = s(() => {
    (function (e) {
      (e[(e.HEADER = 0)] = "HEADER"), (e[(e.TRAILER = 1)] = "TRAILER");
    })(MO || (MO = {}));
  });
var kK = s(() => {});
var DK = s(() => {});
var NK = s(() => {});
var BK = s(() => {});
var MK = s(() => {});
var LK = s(() => {
  DK();
  NK();
  BK();
  MK();
});
var FK = s(() => {});
var UK,
  $K = s(() => {
    UK = "__smithy_context";
  });
var HK = s(() => {});
var zi,
  zK = s(() => {
    (function (e) {
      (e.PROFILE = "profile"),
        (e.SSO_SESSION = "sso-session"),
        (e.SERVICES = "services");
    })(zi || (zi = {}));
  });
var qK = s(() => {});
var jK = s(() => {});
var GK = s(() => {});
var VK = s(() => {});
var WK = s(() => {});
var KK = s(() => {});
var YK = s(() => {});
var QK = s(() => {});
var XK = s(() => {});
var JK = s(() => {});
var ZK = s(() => {});
var e5,
  t5 = s(() => {
    (function (e) {
      (e.HTTP_0_9 = "http/0.9"),
        (e.HTTP_1_0 = "http/1.0"),
        (e.TDS_8_0 = "tds/8.0");
    })(e5 || (e5 = {}));
  });
var r5 = s(() => {});
var o5 = s(() => {});
var n5 = s(() => {});
var s5 = s(() => {});
var i5 = s(() => {});
var a5 = s(() => {});
var c5 = s(() => {});
var Xc = s(() => {
  J6();
  aK();
  cK();
  dK();
  mK();
  lK();
  hK();
  gK();
  yK();
  EK();
  TK();
  AK();
  PK();
  vK();
  OK();
  kK();
  LK();
  FK();
  $K();
  HK();
  zK();
  qK();
  jK();
  GK();
  VK();
  WK();
  KK();
  YK();
  QK();
  XK();
  JK();
  ZK();
  t5();
  r5();
  o5();
  n5();
  s5();
  i5();
  a5();
  c5();
});
var d5 = s(() => {
  Xc();
});
var m5 = s(() => {});
var l5 = s(() => {});
function oJe(e) {
  return Object.keys(e).reduce((t, r) => {
    let o = e[r];
    return { ...t, [r]: Array.isArray(o) ? [...o] : o };
  }, {});
}
var Bo,
  f5 = s(() => {
    Bo = class e {
      constructor(t) {
        (this.method = t.method || "GET"),
          (this.hostname = t.hostname || "localhost"),
          (this.port = t.port),
          (this.query = t.query || {}),
          (this.headers = t.headers || {}),
          (this.body = t.body),
          (this.protocol = t.protocol
            ? t.protocol.slice(-1) !== ":"
              ? `${t.protocol}:`
              : t.protocol
            : "https:"),
          (this.path = t.path
            ? t.path.charAt(0) !== "/"
              ? `/${t.path}`
              : t.path
            : "/"),
          (this.username = t.username),
          (this.password = t.password),
          (this.fragment = t.fragment);
      }
      static clone(t) {
        let r = new e({ ...t, headers: { ...t.headers } });
        return r.query && (r.query = oJe(r.query)), r;
      }
      static isInstance(t) {
        if (!t) return !1;
        let r = t;
        return (
          "method" in r &&
          "protocol" in r &&
          "hostname" in r &&
          "path" in r &&
          typeof r.query == "object" &&
          typeof r.headers == "object"
        );
      }
      clone() {
        return e.clone(this);
      }
    };
  });
var ri,
  u5 = s(() => {
    ri = class {
      constructor(t) {
        (this.statusCode = t.statusCode),
          (this.reason = t.reason),
          (this.headers = t.headers || {}),
          (this.body = t.body);
      }
      static isInstance(t) {
        if (!t) return !1;
        let r = t;
        return typeof r.statusCode == "number" && typeof r.headers == "object";
      }
    };
  });
var p5 = s(() => {});
var h5 = s(() => {});
var pn = s(() => {
  X6();
  d5();
  m5();
  l5();
  f5();
  u5();
  p5();
  h5();
});
var nJe,
  sJe,
  Gx,
  LO = s(() => {
    pn();
    (nJe = (e) => (t) => async (r) => {
      if (!Bo.isInstance(r.request)) return t(r);
      let { request: o } = r,
        { handlerProtocol: n = "" } = e.requestHandler.metadata || {};
      if (n.indexOf("h2") >= 0 && !o.headers[":authority"])
        delete o.headers.host,
          (o.headers[":authority"] = o.hostname + (o.port ? ":" + o.port : ""));
      else if (!o.headers.host) {
        let i = o.hostname;
        o.port != null && (i += `:${o.port}`), (o.headers.host = i);
      }
      return t(r);
    }),
      (sJe = {
        name: "hostHeaderMiddleware",
        step: "build",
        priority: "low",
        tags: ["HOST"],
        override: !0,
      }),
      (Gx = (e) => ({
        applyToStack: (t) => {
          t.add(nJe(e), sJe);
        },
      }));
  });
var iJe,
  aJe,
  Vx,
  g5 = s(() => {
    (iJe = () => (e, t) => async (r) => {
      try {
        let o = await e(r),
          {
            clientName: n,
            commandName: i,
            logger: a,
            dynamoDbDocumentClientOptions: c = {},
          } = t,
          {
            overrideInputFilterSensitiveLog: d,
            overrideOutputFilterSensitiveLog: m,
          } = c,
          f = d ?? t.inputFilterSensitiveLog,
          l = m ?? t.outputFilterSensitiveLog,
          { $metadata: u, ...h } = o.output;
        return (
          a?.info?.({
            clientName: n,
            commandName: i,
            input: f(r.input),
            output: l(h),
            metadata: u,
          }),
          o
        );
      } catch (o) {
        let {
            clientName: n,
            commandName: i,
            logger: a,
            dynamoDbDocumentClientOptions: c = {},
          } = t,
          { overrideInputFilterSensitiveLog: d } = c,
          m = d ?? t.inputFilterSensitiveLog;
        throw (
          (a?.error?.({
            clientName: n,
            commandName: i,
            input: m(r.input),
            error: o,
            metadata: o.$metadata,
          }),
          o)
        );
      }
    }),
      (aJe = {
        name: "loggerMiddleware",
        tags: ["LOGGER"],
        step: "initialize",
        override: !0,
      }),
      (Vx = (e) => ({
        applyToStack: (t) => {
          t.add(iJe(), aJe);
        },
      }));
  });
var FO = s(() => {
  g5();
});
var UO,
  cJe,
  dJe,
  mJe,
  lJe,
  Wx,
  $O = s(() => {
    pn();
    (UO = "X-Amzn-Trace-Id"),
      (cJe = "AWS_LAMBDA_FUNCTION_NAME"),
      (dJe = "_X_AMZN_TRACE_ID"),
      (mJe = (e) => (t) => async (r) => {
        let { request: o } = r;
        if (!Bo.isInstance(o) || e.runtime !== "node") return t(r);
        let n =
          Object.keys(o.headers ?? {}).find(
            (d) => d.toLowerCase() === UO.toLowerCase()
          ) ?? UO;
        if (o.headers.hasOwnProperty(n)) return t(r);
        let i = process.env[cJe],
          a = process.env[dJe],
          c = (d) => typeof d == "string" && d.length > 0;
        return c(i) && c(a) && (o.headers[UO] = a), t({ ...r, request: o });
      }),
      (lJe = {
        step: "build",
        tags: ["RECURSION_DETECTION"],
        name: "recursionDetectionMiddleware",
        override: !0,
        priority: "low",
      }),
      (Wx = (e) => ({
        applyToStack: (t) => {
          t.add(mJe(e), lJe);
        },
      }));
  });
var y5 = s(() => {});
var x5,
  E5 = s(() => {
    (function (e) {
      (e.HEADER = "header"), (e.QUERY = "query");
    })(x5 || (x5 = {}));
  });
var HO,
  S5 = s(() => {
    (function (e) {
      (e.HEADER = "header"), (e.QUERY = "query");
    })(HO || (HO = {}));
  });
var C5 = s(() => {});
var b5 = s(() => {});
var _5 = s(() => {});
var w5 = s(() => {});
var T5 = s(() => {
  E5();
  S5();
  C5();
  b5();
  _5();
  w5();
});
var A5 = s(() => {});
var R5 = s(() => {});
var I5 = s(() => {});
var P5 = s(() => {});
var v5 = s(() => {});
var O5 = s(() => {});
var k5 = s(() => {});
var D5 = s(() => {
  v5();
  O5();
  k5();
});
var N5 = s(() => {});
var B5 = s(() => {});
var M5,
  L5 = s(() => {
    (function (e) {
      (e.HTTP = "http"), (e.HTTPS = "https");
    })(M5 || (M5 = {}));
  });
var F5 = s(() => {});
var U5 = s(() => {});
var $5 = s(() => {});
var H5 = s(() => {});
var z5 = s(() => {});
var q5 = s(() => {
  F5();
  U5();
  $5();
  H5();
  z5();
});
var j5 = s(() => {});
var zO,
  qO = s(() => {
    (function (e) {
      (e.MD5 = "md5"),
        (e.CRC32 = "crc32"),
        (e.CRC32C = "crc32c"),
        (e.SHA1 = "sha1"),
        (e.SHA256 = "sha256");
    })(zO || (zO = {}));
  });
var G5 = s(() => {
  qO();
});
var V5 = s(() => {});
var W5 = s(() => {
  G5();
  V5();
  qO();
});
var K5 = s(() => {});
var jO,
  Y5 = s(() => {
    (function (e) {
      (e[(e.HEADER = 0)] = "HEADER"), (e[(e.TRAILER = 1)] = "TRAILER");
    })(jO || (jO = {}));
  });
var Q5 = s(() => {});
var X5 = s(() => {});
var J5 = s(() => {});
var Z5 = s(() => {});
var e9 = s(() => {});
var t9 = s(() => {
  X5();
  J5();
  Z5();
  e9();
});
var r9 = s(() => {});
var o9 = s(() => {});
var n9 = s(() => {});
var s9,
  i9 = s(() => {
    (function (e) {
      (e.PROFILE = "profile"),
        (e.SSO_SESSION = "sso-session"),
        (e.SERVICES = "services");
    })(s9 || (s9 = {}));
  });
var a9 = s(() => {});
var c9 = s(() => {});
var d9 = s(() => {});
var m9 = s(() => {});
var l9 = s(() => {});
var f9 = s(() => {});
var u9 = s(() => {});
var p9 = s(() => {});
var h9 = s(() => {});
var g9 = s(() => {});
var y9 = s(() => {});
var x9,
  E9 = s(() => {
    (function (e) {
      (e.HTTP_0_9 = "http/0.9"),
        (e.HTTP_1_0 = "http/1.0"),
        (e.TDS_8_0 = "tds/8.0");
    })(x9 || (x9 = {}));
  });
var S9 = s(() => {});
var C9 = s(() => {});
var b9 = s(() => {});
var _9 = s(() => {});
var w9 = s(() => {});
var T9 = s(() => {});
var A9 = s(() => {});
var sl = s(() => {
  y5();
  T5();
  A5();
  R5();
  I5();
  P5();
  D5();
  N5();
  B5();
  L5();
  q5();
  j5();
  W5();
  K5();
  Y5();
  Q5();
  t9();
  r9();
  o9();
  n9();
  i9();
  a9();
  c9();
  d9();
  m9();
  l9();
  f9();
  u9();
  p9();
  h9();
  g9();
  y9();
  E9();
  S9();
  C9();
  b9();
  _9();
  w9();
  T9();
  A9();
});
var R9 = s(() => {
  sl();
});
var I9,
  P9 = s(() => {
    I9 = (e, t) => {
      if (!t || t.length === 0) return e;
      let r = [];
      for (let o of t)
        for (let n of e) n.schemeId.split("#")[1] === o && r.push(n);
      for (let o of e)
        r.find(({ schemeId: n }) => n === o.schemeId) || r.push(o);
      return r;
    };
  });
function fJe(e) {
  let t = new Map();
  for (let r of e) t.set(r.schemeId, r);
  return t;
}
var GO,
  Kx = s(() => {
    sl();
    ct();
    P9();
    GO = (e, t) => (r, o) => async (n) => {
      let i = e.httpAuthSchemeProvider(
          await t.httpAuthSchemeParametersProvider(e, o, n.input)
        ),
        a = e.authSchemePreference ? await e.authSchemePreference() : [],
        c = I9(i, a),
        d = fJe(e.httpAuthSchemes),
        m = bt(o),
        f = [];
      for (let l of c) {
        let u = d.get(l.schemeId);
        if (!u) {
          f.push(
            `HttpAuthScheme \`${l.schemeId}\` was not enabled for this service.`
          );
          continue;
        }
        let h = u.identityProvider(await t.identityProviderConfigProvider(e));
        if (!h) {
          f.push(
            `HttpAuthScheme \`${l.schemeId}\` did not have an IdentityProvider configured.`
          );
          continue;
        }
        let { identityProperties: y = {}, signingProperties: S = {} } =
          l.propertiesExtractor?.(e, o) || {};
        (l.identityProperties = Object.assign(l.identityProperties || {}, y)),
          (l.signingProperties = Object.assign(l.signingProperties || {}, S)),
          (m.selectedHttpAuthScheme = {
            httpAuthOption: l,
            identity: await h(l.identityProperties),
            signer: u.signer,
          });
        break;
      }
      if (!m.selectedHttpAuthScheme)
        throw new Error(
          f.join(`
`)
        );
      return r(n);
    };
  });
var uJe,
  Mo,
  v9 = s(() => {
    Kx();
    (uJe = {
      step: "serialize",
      tags: ["HTTP_AUTH_SCHEME"],
      name: "httpAuthSchemeMiddleware",
      override: !0,
      relation: "before",
      toMiddleware: "endpointV2Middleware",
    }),
      (Mo = (
        e,
        {
          httpAuthSchemeParametersProvider: t,
          identityProviderConfigProvider: r,
        }
      ) => ({
        applyToStack: (o) => {
          o.addRelativeTo(
            GO(e, {
              httpAuthSchemeParametersProvider: t,
              identityProviderConfigProvider: r,
            }),
            uJe
          );
        },
      }));
  });
var O9 = s(() => {});
var k9 = s(() => {
  O9();
});
var D9 = s(() => {
  sl();
});
var N9 = s(() => {});
var B9 = s(() => {});
function pJe(e) {
  return Object.keys(e).reduce((t, r) => {
    let o = e[r];
    return { ...t, [r]: Array.isArray(o) ? [...o] : o };
  }, {});
}
var Ns,
  M9 = s(() => {
    Ns = class e {
      constructor(t) {
        (this.method = t.method || "GET"),
          (this.hostname = t.hostname || "localhost"),
          (this.port = t.port),
          (this.query = t.query || {}),
          (this.headers = t.headers || {}),
          (this.body = t.body),
          (this.protocol = t.protocol
            ? t.protocol.slice(-1) !== ":"
              ? `${t.protocol}:`
              : t.protocol
            : "https:"),
          (this.path = t.path
            ? t.path.charAt(0) !== "/"
              ? `/${t.path}`
              : t.path
            : "/"),
          (this.username = t.username),
          (this.password = t.password),
          (this.fragment = t.fragment);
      }
      static clone(t) {
        let r = new e({ ...t, headers: { ...t.headers } });
        return r.query && (r.query = pJe(r.query)), r;
      }
      static isInstance(t) {
        if (!t) return !1;
        let r = t;
        return (
          "method" in r &&
          "protocol" in r &&
          "hostname" in r &&
          "path" in r &&
          typeof r.query == "object" &&
          typeof r.headers == "object"
        );
      }
      clone() {
        return e.clone(this);
      }
    };
  });
var L9 = s(() => {});
var F9 = s(() => {});
var U9 = s(() => {});
var On = s(() => {
  k9();
  D9();
  N9();
  B9();
  M9();
  L9();
  F9();
  U9();
});
var VO = s(() => {
  On();
});
var WO = s(() => {});
var $9,
  H9 = s(() => {
    VO();
    WO();
    $9 = {
      name: "serializerMiddleware",
      step: "serialize",
      tags: ["SERIALIZER"],
      override: !0,
    };
  });
var z9 = s(() => {
  VO();
  H9();
  WO();
});
var ZLt,
  q9 = s(() => {
    z9();
    Kx();
    ZLt = {
      step: "serialize",
      tags: ["HTTP_AUTH_SCHEME"],
      name: "httpAuthSchemeMiddleware",
      override: !0,
      relation: "before",
      toMiddleware: $9.name,
    };
  });
var j9 = s(() => {
  Kx();
  v9();
  q9();
});
var hJe,
  gJe,
  G9,
  KO = s(() => {
    On();
    sl();
    ct();
    (hJe = (e) => (t) => {
      throw t;
    }),
      (gJe = (e, t) => {}),
      (G9 = (e) => (t, r) => async (o) => {
        if (!Ns.isInstance(o.request)) return t(o);
        let i = bt(r).selectedHttpAuthScheme;
        if (!i)
          throw new Error(
            "No HttpAuthScheme was selected: unable to sign request"
          );
        let {
            httpAuthOption: { signingProperties: a = {} },
            identity: c,
            signer: d,
          } = i,
          m = await t({ ...o, request: await d.sign(o.request, c, a) }).catch(
            (d.errorHandler || hJe)(a)
          );
        return (d.successHandler || gJe)(m.response, a), m;
      });
  });
var YO,
  Lo,
  V9 = s(() => {
    KO();
    (YO = {
      step: "finalizeRequest",
      tags: ["HTTP_SIGNING"],
      name: "httpSigningMiddleware",
      aliases: ["apiKeyMiddleware", "tokenMiddleware", "awsAuthMiddleware"],
      override: !0,
      relation: "after",
      toMiddleware: "retryMiddleware",
    }),
      (Lo = (e) => ({
        applyToStack: (t) => {
          t.addRelativeTo(G9(e), YO);
        },
      }));
  });
var W9 = s(() => {
  KO();
  V9();
});
var rn,
  K9 = s(() => {
    rn = (e) => {
      if (typeof e == "function") return e;
      let t = Promise.resolve(e);
      return () => t;
    };
  });
function dt(e, t, r, o, n) {
  return async function* (a, c, ...d) {
    let m = c,
      f = a.startingToken ?? m[r],
      l = !0,
      u;
    for (; l; ) {
      if (((m[r] = f), n && (m[n] = m[n] ?? a.pageSize), a.client instanceof e))
        u = await yJe(t, a.client, c, a.withCommand, ...d);
      else throw new Error(`Invalid client, expected instance of ${e.name}`);
      yield u;
      let h = f;
      (f = xJe(u, o)), (l = !!(f && (!a.stopOnSameToken || f !== h)));
    }
    return void 0;
  };
}
var yJe,
  xJe,
  Y9 = s(() => {
    yJe = async (e, t, r, o = (i) => i, ...n) => {
      let i = new e(r);
      return (i = o(i) ?? i), await t.send(i, ...n);
    };
    xJe = (e, t) => {
      let r = e,
        o = t.split(".");
      for (let n of o) {
        if (!r || typeof r != "object") return;
        r = r[n];
      }
      return r;
    };
  });
var Ke,
  cr = s(() => {
    Ke = (e) =>
      (typeof ArrayBuffer == "function" && e instanceof ArrayBuffer) ||
      Object.prototype.toString.call(e) === "[object ArrayBuffer]";
  });
import { Buffer as QO } from "buffer";
var kh,
  Yx,
  il = s(() => {
    cr();
    (kh = (e, t = 0, r = e.byteLength - t) => {
      if (!Ke(e))
        throw new TypeError(
          `The "input" argument must be ArrayBuffer. Received type ${typeof e} (${e})`
        );
      return QO.from(e, t, r);
    }),
      (Yx = (e, t) => {
        if (typeof e != "string")
          throw new TypeError(
            `The "input" argument must be of type string. Received type ${typeof e} (${e})`
          );
        return t ? QO.from(e, t) : QO.from(e);
      });
  });
var EJe,
  Qx,
  Q9 = s(() => {
    il();
    (EJe = /^[A-Za-z0-9+/]*={0,2}$/),
      (Qx = (e) => {
        if ((e.length * 3) % 4 !== 0)
          throw new TypeError("Incorrect padding on base64 string.");
        if (!EJe.exec(e)) throw new TypeError("Invalid base64 string.");
        let t = Yx(e, "base64");
        return new Uint8Array(t.buffer, t.byteOffset, t.byteLength);
      });
  });
var al,
  XO = s(() => {
    il();
    al = (e) => {
      let t = Yx(e, "utf8");
      return new Uint8Array(
        t.buffer,
        t.byteOffset,
        t.byteLength / Uint8Array.BYTES_PER_ELEMENT
      );
    };
  });
var X9 = s(() => {
  XO();
});
var Dh,
  J9 = s(() => {
    il();
    Dh = (e) => {
      if (typeof e == "string") return e;
      if (
        typeof e != "object" ||
        typeof e.byteOffset != "number" ||
        typeof e.byteLength != "number"
      )
        throw new Error(
          "@smithy/util-utf8: toUtf8 encoder function only accepts string | Uint8Array."
        );
      return kh(e.buffer, e.byteOffset, e.byteLength).toString("utf8");
    };
  });
var cl = s(() => {
  XO();
  X9();
  J9();
});
var dl,
  Z9 = s(() => {
    il();
    cl();
    dl = (e) => {
      let t;
      if (
        (typeof e == "string" ? (t = al(e)) : (t = e),
        typeof t != "object" ||
          typeof t.byteOffset != "number" ||
          typeof t.byteLength != "number")
      )
        throw new Error(
          "@smithy/util-base64: toBase64 encoder function only accepts string | Uint8Array."
        );
      return kh(t.buffer, t.byteOffset, t.byteLength).toString("base64");
    };
  });
var ba = s(() => {
  Q9();
  Z9();
});
function eY(e, t = "utf-8") {
  return t === "base64" ? dl(e) : Dh(e);
}
function tY(e, t) {
  return t === "base64" ? qi.mutate(Qx(e)) : qi.mutate(al(e));
}
var rY = s(() => {
  ba();
  cl();
  JO();
});
var qi,
  JO = s(() => {
    rY();
    qi = class e extends Uint8Array {
      static fromString(t, r = "utf-8") {
        switch (typeof t) {
          case "string":
            return tY(t, r);
          default:
            throw new Error(
              `Unsupported conversion from ${typeof t} to Uint8ArrayBlobAdapter.`
            );
        }
      }
      static mutate(t) {
        return Object.setPrototypeOf(t, e.prototype), t;
      }
      transformToString(t = "utf-8") {
        return eY(this, t);
      }
    };
  });
var ZO = s(() => {
  ba();
});
var _a = s(() => {});
var oY = s(() => {});
var nY = s(() => {
  ba();
  _a();
  oY();
});
var sY = s(() => {
  _a();
  ZO();
  nY();
});
var ek = s(() => {});
var iY = s(() => {
  ek();
});
var aY = s(() => {
  ek();
  iY();
  _a();
});
var cY = s(() => {});
var dY = s(() => {});
var mY = s(() => {
  dY();
  _a();
});
var tk = s(() => {});
var lY = s(() => {
  tk();
});
var fY = s(() => {
  tk();
  lY();
});
var Xx = s(() => {
  fY();
});
var uY = s(() => {});
var rk = s(() => {});
var ml = s(() => {});
var pY = s(() => {
  ml();
});
var hY = s(() => {
  ml();
});
var gY = s(() => {
  ok();
  ml();
});
var nk = s(() => {
  ml();
});
var ok = s(() => {
  On();
  Xx();
  uY();
  rk();
  pY();
  hY();
  gY();
  ml();
  nk();
});
var xY = s(() => {});
var EY = s(() => {
  xY();
});
var SY = s(() => {
  On();
  Xx();
  rk();
  EY();
  nk();
});
var CY = s(() => {});
var bY = s(() => {
  CY();
});
var _Y = s(() => {
  ok();
  SY();
  bY();
});
var wY = s(() => {});
var TY = s(() => {});
var AY = s(() => {
  On();
  Xx();
  wY();
  TY();
});
var RY = s(() => {
  ba();
});
var IY = s(() => {
  AY();
  RY();
});
function Zx(e) {
  if (e.length % 2 !== 0)
    throw new Error("Hex encoded strings must have an even number length");
  let t = new Uint8Array(e.length / 2);
  for (let r = 0; r < e.length; r += 2) {
    let o = e.slice(r, r + 2).toLowerCase();
    if (o in sk) t[r / 2] = sk[o];
    else
      throw new Error(
        `Cannot decode unrecognized sequence ${o} as hexadecimal`
      );
  }
  return t;
}
function _t(e) {
  let t = "";
  for (let r = 0; r < e.byteLength; r++) t += PY[e[r]];
  return t;
}
var PY,
  sk,
  Fo = s(() => {
    (PY = {}), (sk = {});
    for (let e = 0; e < 256; e++) {
      let t = e.toString(16).toLowerCase();
      t.length === 1 && (t = `0${t}`), (PY[e] = t), (sk[t] = e);
    }
  });
var vY = s(() => {
  IY();
  ba();
  Fo();
  cl();
  _a();
});
var OY = s(() => {
  _Y();
  il();
  vY();
});
var kY = s(() => {});
var DY = s(() => {
  kY();
  _a();
});
var ik = s(() => {
  JO();
  ZO();
  sY();
  aY();
  cY();
  mY();
  OY();
  DY();
  _a();
});
var ne,
  Bh = s(() => {
    ik();
    ne = async (e = new Uint8Array(), t) => {
      if (e instanceof Uint8Array) return qi.mutate(e);
      if (!e) return qi.mutate(new Uint8Array());
      let r = t.streamCollector(e);
      return qi.mutate(await r);
    };
  });
function on(e) {
  return encodeURIComponent(e).replace(/[!'()*]/g, function (t) {
    return "%" + t.charCodeAt(0).toString(16).toUpperCase();
  });
}
var eE = s(() => {});
var ak = s(() => {});
var NY = s(() => {
  On();
  ct();
});
var BY = s(() => {
  ct();
});
var MY = s(() => {
  NY();
  BY();
});
var kn,
  wa = s(() => {
    kn = class e {
      constructor(t, r = new Map()) {
        (this.namespace = t), (this.schemas = r);
      }
      static for(t) {
        return (
          e.registries.has(t) || e.registries.set(t, new e(t)),
          e.registries.get(t)
        );
      }
      register(t, r) {
        let o = this.normalizeShapeId(t);
        e.for(this.getNamespace(t)).schemas.set(o, r);
      }
      getSchema(t) {
        let r = this.normalizeShapeId(t);
        if (!this.schemas.has(r))
          throw new Error(`@smithy/core/schema - schema not found for ${r}`);
        return this.schemas.get(r);
      }
      getBaseException() {
        for (let [t, r] of this.schemas.entries())
          if (
            t.startsWith("smithy.ts.sdk.synthetic.") &&
            t.endsWith("ServiceException")
          )
            return r;
      }
      find(t) {
        return [...this.schemas.values()].find(t);
      }
      destroy() {
        e.registries.delete(this.namespace), this.schemas.clear();
      }
      normalizeShapeId(t) {
        return t.includes("#") ? t : this.namespace + "#" + t;
      }
      getNamespace(t) {
        return this.normalizeShapeId(t).split("#")[0];
      }
    };
    kn.registries = new Map();
  });
var Jc = s(() => {});
var ck = s(() => {
  wa();
  Jc();
});
var dk = s(() => {
  wa();
  Jc();
});
var LY = s(() => {
  wa();
  Jc();
});
var rE = s(() => {
  wa();
  Jc();
});
var FY = s(() => {
  wa();
  rE();
});
var mk = s(() => {});
var lk = s(() => {
  wa();
  Jc();
});
var $Y = s(() => {
  ak();
  ck();
  dk();
  mk();
  lk();
  rE();
});
var lo = s(() => {
  ak();
  MY();
  ck();
  dk();
  LY();
  FY();
  $Y();
  Jc();
  lk();
  rE();
  mk();
  wa();
});
var HY = s(() => {
  lo();
});
var mt,
  Bs,
  Pt,
  TJe,
  zY,
  Xt,
  $n,
  qY,
  jY,
  fk,
  AJe,
  F,
  Se,
  p,
  Mh,
  GY,
  VY,
  RJe,
  ll,
  ji,
  IJe,
  Jr,
  wt,
  fl,
  WY,
  oE,
  nE,
  uk = s(() => {
    (mt = (e) => {
      switch (e) {
        case "true":
          return !0;
        case "false":
          return !1;
        default:
          throw new Error(`Unable to parse boolean value "${e}"`);
      }
    }),
      (Bs = (e) => {
        if (e != null) {
          if (typeof e == "number") {
            if (
              ((e === 0 || e === 1) &&
                nE.warn(oE(`Expected boolean, got ${typeof e}: ${e}`)),
              e === 0)
            )
              return !1;
            if (e === 1) return !0;
          }
          if (typeof e == "string") {
            let t = e.toLowerCase();
            if (
              ((t === "false" || t === "true") &&
                nE.warn(oE(`Expected boolean, got ${typeof e}: ${e}`)),
              t === "false")
            )
              return !1;
            if (t === "true") return !0;
          }
          if (typeof e == "boolean") return e;
          throw new TypeError(`Expected boolean, got ${typeof e}: ${e}`);
        }
      }),
      (Pt = (e) => {
        if (e != null) {
          if (typeof e == "string") {
            let t = parseFloat(e);
            if (!Number.isNaN(t))
              return (
                String(t) !== String(e) &&
                  nE.warn(oE(`Expected number but observed string: ${e}`)),
                t
              );
          }
          if (typeof e == "number") return e;
          throw new TypeError(`Expected number, got ${typeof e}: ${e}`);
        }
      }),
      (TJe = Math.ceil(34028234663852886e22)),
      (zY = (e) => {
        let t = Pt(e);
        if (
          t !== void 0 &&
          !Number.isNaN(t) &&
          t !== 1 / 0 &&
          t !== -1 / 0 &&
          Math.abs(t) > TJe
        )
          throw new TypeError(`Expected 32-bit float, got ${e}`);
        return t;
      }),
      (Xt = (e) => {
        if (e != null) {
          if (Number.isInteger(e) && !Number.isNaN(e)) return e;
          throw new TypeError(`Expected integer, got ${typeof e}: ${e}`);
        }
      }),
      ($n = (e) => fk(e, 32)),
      (qY = (e) => fk(e, 16)),
      (jY = (e) => fk(e, 8)),
      (fk = (e, t) => {
        let r = Xt(e);
        if (r !== void 0 && AJe(r, t) !== r)
          throw new TypeError(`Expected ${t}-bit integer, got ${e}`);
        return r;
      }),
      (AJe = (e, t) => {
        switch (t) {
          case 32:
            return Int32Array.of(e)[0];
          case 16:
            return Int16Array.of(e)[0];
          case 8:
            return Int8Array.of(e)[0];
        }
      }),
      (F = (e, t) => {
        if (e == null)
          throw t
            ? new TypeError(`Expected a non-null value for ${t}`)
            : new TypeError("Expected a non-null value");
        return e;
      }),
      (Se = (e) => {
        if (e == null) return;
        if (typeof e == "object" && !Array.isArray(e)) return e;
        let t = Array.isArray(e) ? "array" : typeof e;
        throw new TypeError(`Expected object, got ${t}: ${e}`);
      }),
      (p = (e) => {
        if (e != null) {
          if (typeof e == "string") return e;
          if (["boolean", "number", "bigint"].includes(typeof e))
            return (
              nE.warn(oE(`Expected string, got ${typeof e}: ${e}`)), String(e)
            );
          throw new TypeError(`Expected string, got ${typeof e}: ${e}`);
        }
      }),
      (Mh = (e) => {
        if (e == null) return;
        let t = Se(e),
          r = Object.entries(t)
            .filter(([, o]) => o != null)
            .map(([o]) => o);
        if (r.length === 0)
          throw new TypeError(
            "Unions must have exactly one non-null member. None were found."
          );
        if (r.length > 1)
          throw new TypeError(
            `Unions must have exactly one non-null member. Keys ${r} were not null.`
          );
        return t;
      }),
      (GY = (e) => Pt(typeof e == "string" ? ll(e) : e)),
      (VY = (e) => zY(typeof e == "string" ? ll(e) : e)),
      (RJe =
        /(-?(?:0|[1-9]\d*)(?:\.\d+)?(?:[eE][+-]?\d+)?)|(-?Infinity)|(NaN)/g),
      (ll = (e) => {
        let t = e.match(RJe);
        if (t === null || t[0].length !== e.length)
          throw new TypeError("Expected real number, got implicit NaN");
        return parseFloat(e);
      }),
      (ji = (e) => (typeof e == "string" ? IJe(e) : Pt(e))),
      (IJe = (e) => {
        switch (e) {
          case "NaN":
            return NaN;
          case "Infinity":
            return 1 / 0;
          case "-Infinity":
            return -1 / 0;
          default:
            throw new Error(`Unable to parse float value: ${e}`);
        }
      }),
      (Jr = (e) => Xt(typeof e == "string" ? ll(e) : e)),
      (wt = (e) => $n(typeof e == "string" ? ll(e) : e)),
      (fl = (e) => qY(typeof e == "string" ? ll(e) : e)),
      (WY = (e) => jY(typeof e == "string" ? ll(e) : e)),
      (oE = (e) =>
        String(new TypeError(e).stack || e)
          .split(
            `
`
          )
          .slice(0, 5)
          .filter((t) => !t.includes("stackTraceWarning")).join(`
`)),
      (nE = { warn: console.warn });
  });
function dr(e) {
  let t = e.getUTCFullYear(),
    r = e.getUTCMonth(),
    o = e.getUTCDay(),
    n = e.getUTCDate(),
    i = e.getUTCHours(),
    a = e.getUTCMinutes(),
    c = e.getUTCSeconds(),
    d = n < 10 ? `0${n}` : `${n}`,
    m = i < 10 ? `0${i}` : `${i}`,
    f = a < 10 ? `0${a}` : `${a}`,
    l = c < 10 ? `0${c}` : `${c}`;
  return `${PJe[o]}, ${d} ${hk[r]} ${t} ${m}:${f}:${l} GMT`;
}
var PJe,
  hk,
  vJe,
  KY,
  OJe,
  qr,
  kJe,
  DJe,
  NJe,
  Hn,
  Mt,
  Lh,
  BJe,
  MJe,
  LJe,
  pk,
  FJe,
  UJe,
  $Je,
  oi,
  HJe,
  zJe,
  ul,
  YY = s(() => {
    uk();
    (PJe = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"]),
      (hk = [
        "Jan",
        "Feb",
        "Mar",
        "Apr",
        "May",
        "Jun",
        "Jul",
        "Aug",
        "Sep",
        "Oct",
        "Nov",
        "Dec",
      ]);
    (vJe = new RegExp(
      /^(\d{4})-(\d{2})-(\d{2})[tT](\d{2}):(\d{2}):(\d{2})(?:\.(\d+))?[zZ]$/
    )),
      (KY = (e) => {
        if (e == null) return;
        if (typeof e != "string")
          throw new TypeError(
            "RFC-3339 date-times must be expressed as strings"
          );
        let t = vJe.exec(e);
        if (!t) throw new TypeError("Invalid RFC-3339 date-time value");
        let [r, o, n, i, a, c, d, m] = t,
          f = fl(ul(o)),
          l = oi(n, "month", 1, 12),
          u = oi(i, "day", 1, 31);
        return Lh(f, l, u, {
          hours: a,
          minutes: c,
          seconds: d,
          fractionalMilliseconds: m,
        });
      }),
      (OJe = new RegExp(
        /^(\d{4})-(\d{2})-(\d{2})[tT](\d{2}):(\d{2}):(\d{2})(?:\.(\d+))?(([-+]\d{2}\:\d{2})|[zZ])$/
      )),
      (qr = (e) => {
        if (e == null) return;
        if (typeof e != "string")
          throw new TypeError(
            "RFC-3339 date-times must be expressed as strings"
          );
        let t = OJe.exec(e);
        if (!t) throw new TypeError("Invalid RFC-3339 date-time value");
        let [r, o, n, i, a, c, d, m, f] = t,
          l = fl(ul(o)),
          u = oi(n, "month", 1, 12),
          h = oi(i, "day", 1, 31),
          y = Lh(l, u, h, {
            hours: a,
            minutes: c,
            seconds: d,
            fractionalMilliseconds: m,
          });
        return f.toUpperCase() != "Z" && y.setTime(y.getTime() - zJe(f)), y;
      }),
      (kJe = new RegExp(
        /^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d{2}) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? GMT$/
      )),
      (DJe = new RegExp(
        /^(?:Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d{2})-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d{2}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? GMT$/
      )),
      (NJe = new RegExp(
        /^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( [1-9]|\d{2}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? (\d{4})$/
      )),
      (Hn = (e) => {
        if (e == null) return;
        if (typeof e != "string")
          throw new TypeError(
            "RFC-7231 date-times must be expressed as strings"
          );
        let t = kJe.exec(e);
        if (t) {
          let [r, o, n, i, a, c, d, m] = t;
          return Lh(fl(ul(i)), pk(n), oi(o, "day", 1, 31), {
            hours: a,
            minutes: c,
            seconds: d,
            fractionalMilliseconds: m,
          });
        }
        if (((t = DJe.exec(e)), t)) {
          let [r, o, n, i, a, c, d, m] = t;
          return LJe(
            Lh(BJe(i), pk(n), oi(o, "day", 1, 31), {
              hours: a,
              minutes: c,
              seconds: d,
              fractionalMilliseconds: m,
            })
          );
        }
        if (((t = NJe.exec(e)), t)) {
          let [r, o, n, i, a, c, d, m] = t;
          return Lh(fl(ul(m)), pk(o), oi(n.trimLeft(), "day", 1, 31), {
            hours: i,
            minutes: a,
            seconds: c,
            fractionalMilliseconds: d,
          });
        }
        throw new TypeError("Invalid RFC-7231 date-time value");
      }),
      (Mt = (e) => {
        if (e == null) return;
        let t;
        if (typeof e == "number") t = e;
        else if (typeof e == "string") t = GY(e);
        else if (typeof e == "object" && e.tag === 1) t = e.value;
        else
          throw new TypeError(
            "Epoch timestamps must be expressed as floating point numbers or their string representation"
          );
        if (Number.isNaN(t) || t === 1 / 0 || t === -1 / 0)
          throw new TypeError(
            "Epoch timestamps must be valid, non-Infinite, non-NaN numerics"
          );
        return new Date(Math.round(t * 1e3));
      }),
      (Lh = (e, t, r, o) => {
        let n = t - 1;
        return (
          UJe(e, n, r),
          new Date(
            Date.UTC(
              e,
              n,
              r,
              oi(o.hours, "hour", 0, 23),
              oi(o.minutes, "minute", 0, 59),
              oi(o.seconds, "seconds", 0, 60),
              HJe(o.fractionalMilliseconds)
            )
          )
        );
      }),
      (BJe = (e) => {
        let t = new Date().getUTCFullYear(),
          r = Math.floor(t / 100) * 100 + fl(ul(e));
        return r < t ? r + 100 : r;
      }),
      (MJe = 50 * 365 * 24 * 60 * 60 * 1e3),
      (LJe = (e) =>
        e.getTime() - new Date().getTime() > MJe
          ? new Date(
              Date.UTC(
                e.getUTCFullYear() - 100,
                e.getUTCMonth(),
                e.getUTCDate(),
                e.getUTCHours(),
                e.getUTCMinutes(),
                e.getUTCSeconds(),
                e.getUTCMilliseconds()
              )
            )
          : e),
      (pk = (e) => {
        let t = hk.indexOf(e);
        if (t < 0) throw new TypeError(`Invalid month: ${e}`);
        return t + 1;
      }),
      (FJe = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]),
      (UJe = (e, t, r) => {
        let o = FJe[t];
        if ((t === 1 && $Je(e) && (o = 29), r > o))
          throw new TypeError(`Invalid day for ${hk[t]} in ${e}: ${r}`);
      }),
      ($Je = (e) => e % 4 === 0 && (e % 100 !== 0 || e % 400 === 0)),
      (oi = (e, t, r, o) => {
        let n = WY(ul(e));
        if (n < r || n > o)
          throw new TypeError(`${t} must be between ${r} and ${o}, inclusive`);
        return n;
      }),
      (HJe = (e) => (e == null ? 0 : VY("0." + e) * 1e3)),
      (zJe = (e) => {
        let t = e[0],
          r = 1;
        if (t == "+") r = 1;
        else if (t == "-") r = -1;
        else throw new TypeError(`Offset direction, ${t}, must be "+" or "-"`);
        let o = Number(e.substring(1, 3)),
          n = Number(e.substring(4, 6));
        return r * (o * 60 + n) * 60 * 1e3;
      }),
      (ul = (e) => {
        let t = 0;
        for (; t < e.length - 1 && e.charAt(t) === "0"; ) t++;
        return t === 0 ? e : e.slice(t);
      });
  });
var ni,
  QY = s(() => {
    ni = function (t) {
      return Object.assign(new String(t), {
        deserializeJSON() {
          return JSON.parse(String(t));
        },
        toString() {
          return String(t);
        },
        toJSON() {
          return String(t);
        },
      });
    };
    ni.from = (e) =>
      e && typeof e == "object" && (e instanceof ni || "deserializeJSON" in e)
        ? e
        : typeof e == "string" || Object.getPrototypeOf(e) === String.prototype
          ? ni(String(e))
          : ni(JSON.stringify(e));
    ni.fromObject = ni.from;
  });
function pl(e) {
  return (
    (e.includes(",") || e.includes('"')) && (e = `"${e.replace(/"/g, '\\"')}"`),
    e
  );
}
var XY = s(() => {});
var JY = s(() => {});
var ZY = s(() => {});
var eQ = s(() => {});
var Uo = s(() => {
  HY();
  YY();
  QY();
  uk();
  XY();
  JY();
  ZY();
  eQ();
});
var gk = s(() => {
  lo();
  Uo();
  On();
  ik();
  Bh();
});
var tQ = s(() => {
  lo();
  On();
  Bh();
  eE();
  gk();
});
var rQ = s(() => {
  lo();
  On();
  Bh();
  gk();
});
var si,
  yk = s(() => {
    eE();
    si = (e, t, r, o, n, i) => {
      if (t != null && t[r] !== void 0) {
        let a = o();
        if (a.length <= 0)
          throw new Error(
            "Empty value provided for input HTTP label: " + r + "."
          );
        e = e.replace(
          n,
          i
            ? a
                .split("/")
                .map((c) => on(c))
                .join("/")
            : on(a)
        );
      } else
        throw new Error("No value provided for input HTTP label: " + r + ".");
      return e;
    };
  });
function G(e, t) {
  return new xk(e, t);
}
var xk,
  oQ = s(() => {
    On();
    yk();
    xk = class {
      constructor(t, r) {
        (this.input = t),
          (this.context = r),
          (this.query = {}),
          (this.method = ""),
          (this.headers = {}),
          (this.path = ""),
          (this.body = null),
          (this.hostname = ""),
          (this.resolvePathStack = []);
      }
      async build() {
        let {
          hostname: t,
          protocol: r = "https",
          port: o,
          path: n,
        } = await this.context.endpoint();
        this.path = n;
        for (let i of this.resolvePathStack) i(this.path);
        return new Ns({
          protocol: r,
          hostname: this.hostname || t,
          port: o,
          method: this.method,
          path: this.path,
          query: this.query,
          body: this.body,
          headers: this.headers,
        });
      }
      hn(t) {
        return (this.hostname = t), this;
      }
      bp(t) {
        return (
          this.resolvePathStack.push((r) => {
            this.path = `${r?.endsWith("/") ? r.slice(0, -1) : r || ""}` + t;
          }),
          this
        );
      }
      p(t, r, o, n) {
        return (
          this.resolvePathStack.push((i) => {
            this.path = si(i, this.input, t, r, o, n);
          }),
          this
        );
      }
      h(t) {
        return (this.headers = t), this;
      }
      q(t) {
        return (this.query = t), this;
      }
      b(t) {
        return (this.body = t), this;
      }
      m(t) {
        return (this.method = t), this;
      }
    };
  });
var sE = s(() => {
  lo();
});
var Ek = s(() => {
  lo();
  Uo();
  ba();
  cl();
  sE();
});
var sQ = s(() => {
  lo();
  cl();
  Ek();
});
var Sk = s(() => {
  lo();
  Uo();
  ba();
  sE();
});
var iQ = s(() => {
  lo();
  Sk();
});
var Dt = s(() => {
  Bh();
  eE();
  tQ();
  rQ();
  oQ();
  yk();
  Ek();
  sQ();
  iQ();
  Sk();
  sE();
});
var aQ = s(() => {
  Dt();
});
function Ta(e, t, r) {
  e.__smithy_context
    ? e.__smithy_context.features || (e.__smithy_context.features = {})
    : (e.__smithy_context = { features: {} }),
    (e.__smithy_context.features[t] = r);
}
var cQ = s(() => {});
var fo,
  dQ = s(() => {
    fo = class {
      constructor(t) {
        this.authSchemes = new Map();
        for (let [r, o] of Object.entries(t))
          o !== void 0 && this.authSchemes.set(r, o);
      }
      getIdentityProvider(t) {
        return this.authSchemes.get(t);
      }
    };
  });
var mQ = s(() => {
  On();
  sl();
});
var lQ = s(() => {
  On();
});
var hn,
  fQ = s(() => {
    hn = class {
      async sign(t, r, o) {
        return t;
      }
    };
  });
var uQ = s(() => {
  mQ();
  lQ();
  fQ();
});
var WJe,
  pQ,
  Ck,
  hQ,
  gQ = s(() => {
    (WJe = (e) => (t) => Ck(t) && t.expiration.getTime() - Date.now() < e),
      (pQ = WJe(3e5)),
      (Ck = (e) => e.expiration !== void 0),
      (hQ = (e, t, r) => {
        if (e === void 0) return;
        let o = typeof e != "function" ? async () => Promise.resolve(e) : e,
          n,
          i,
          a,
          c = !1,
          d = async (m) => {
            i || (i = o(m));
            try {
              (n = await i), (a = !0), (c = !1);
            } finally {
              i = void 0;
            }
            return n;
          };
        return t === void 0
          ? async (m) => ((!a || m?.forceRefresh) && (n = await d(m)), n)
          : async (m) => (
              (!a || m?.forceRefresh) && (n = await d(m)),
              c ? n : r(n) ? (t(n) && (await d(m)), n) : ((c = !0), n)
            );
      });
  });
var yQ = s(() => {
  dQ();
  uQ();
  gQ();
});
var Ue = s(() => {
  R9();
  j9();
  W9();
  K9();
  Y9();
  aQ();
  cQ();
  yQ();
});
function KJe(e) {
  return e === void 0 ? !0 : typeof e == "string" && e.length <= 50;
}
function iE(e) {
  let t = rn(e.userAgentAppId ?? bk),
    { customUserAgent: r } = e;
  return Object.assign(e, {
    customUserAgent: typeof r == "string" ? [[r]] : r,
    userAgentAppId: async () => {
      let o = await t();
      if (!KJe(o)) {
        let n =
          e.logger?.constructor?.name === "NoOpLogger" || !e.logger
            ? console
            : e.logger;
        typeof o != "string"
          ? n?.warn("userAgentAppId must be a string or undefined.")
          : o.length > 50 &&
            n?.warn(
              "The provided userAgentAppId exceeds the maximum length of 50 characters."
            );
      }
      return o;
    },
  });
}
var bk,
  xQ = s(() => {
    Ue();
    bk = void 0;
  });
var uo,
  EQ = s(() => {
    uo = class {
      constructor({ size: t, params: r }) {
        (this.data = new Map()),
          (this.parameters = []),
          (this.capacity = t ?? 50),
          r && (this.parameters = r);
      }
      get(t, r) {
        let o = this.hash(t);
        if (o === !1) return r();
        if (!this.data.has(o)) {
          if (this.data.size > this.capacity + 10) {
            let n = this.data.keys(),
              i = 0;
            for (;;) {
              let { value: a, done: c } = n.next();
              if ((this.data.delete(a), c || ++i > 10)) break;
            }
          }
          this.data.set(o, r());
        }
        return this.data.get(o);
      }
      size() {
        return this.data.size;
      }
      hash(t) {
        let r = "",
          { parameters: o } = this;
        if (o.length === 0) return !1;
        for (let n of o) {
          let i = String(t[n] ?? "");
          if (i.includes("|;")) return !1;
          r += i + "|;";
        }
        return r;
      }
    };
  });
var YJe,
  gn,
  _k = s(() => {
    (YJe = new RegExp(
      "^(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}$"
    )),
      (gn = (e) => YJe.test(e) || (e.startsWith("[") && e.endsWith("]")));
  });
var QJe,
  Ms,
  wk = s(() => {
    (QJe = new RegExp("^(?!.*-$)(?!-)[a-zA-Z0-9-]{1,63}$")),
      (Ms = (e, t = !1) => {
        if (!t) return QJe.test(e);
        let r = e.split(".");
        for (let o of r) if (!Ms(o)) return !1;
        return !0;
      });
  });
var Jt,
  aE = s(() => {
    Jt = {};
  });
var Gi,
  SQ = s(() => {
    Gi = "endpoints";
  });
function zn(e) {
  return typeof e != "object" || e == null
    ? e
    : "ref" in e
      ? `$${zn(e.ref)}`
      : "fn" in e
        ? `${e.fn}(${(e.argv || []).map(zn).join(", ")})`
        : JSON.stringify(e, null, 2);
}
var CQ = s(() => {});
var Fh = s(() => {
  SQ();
  CQ();
});
var Ut,
  bQ = s(() => {
    Ut = class extends Error {
      constructor(t) {
        super(t), (this.name = "EndpointError");
      }
    };
  });
var _Q = s(() => {});
var wQ = s(() => {});
var TQ = s(() => {});
var AQ = s(() => {});
var RQ = s(() => {});
var IQ = s(() => {});
var qn = s(() => {
  bQ();
  _Q();
  wQ();
  TQ();
  AQ();
  RQ();
  IQ();
});
var PQ,
  vQ = s(() => {
    PQ = (e, t) => e === t;
  });
var OQ,
  kQ = s(() => {
    qn();
    OQ = (e) => {
      let t = e.split("."),
        r = [];
      for (let o of t) {
        let n = o.indexOf("[");
        if (n !== -1) {
          if (o.indexOf("]") !== o.length - 1)
            throw new Ut(`Path: '${e}' does not end with ']'`);
          let i = o.slice(n + 1, -1);
          if (Number.isNaN(parseInt(i)))
            throw new Ut(`Invalid array index: '${i}' in path: '${e}'`);
          n !== 0 && r.push(o.slice(0, n)), r.push(i);
        } else r.push(o);
      }
      return r;
    };
  });
var cE,
  DQ = s(() => {
    qn();
    kQ();
    cE = (e, t) =>
      OQ(t).reduce((r, o) => {
        if (typeof r != "object")
          throw new Ut(
            `Index '${o}' in '${t}' not found in '${JSON.stringify(e)}'`
          );
        return Array.isArray(r) ? r[parseInt(o)] : r[o];
      }, e);
  });
var NQ,
  BQ = s(() => {
    NQ = (e) => e != null;
  });
var MQ,
  LQ = s(() => {
    MQ = (e) => !e;
  });
var FQ = s(() => {});
var UQ,
  $Q = s(() => {
    (function (e) {
      (e.HEADER = "header"), (e.QUERY = "query");
    })(UQ || (UQ = {}));
  });
var HQ,
  zQ = s(() => {
    (function (e) {
      (e.HEADER = "header"), (e.QUERY = "query");
    })(HQ || (HQ = {}));
  });
var qQ = s(() => {});
var jQ = s(() => {});
var GQ = s(() => {});
var VQ = s(() => {});
var WQ = s(() => {
  $Q();
  zQ();
  qQ();
  jQ();
  GQ();
  VQ();
});
var KQ = s(() => {});
var YQ = s(() => {});
var QQ = s(() => {});
var XQ = s(() => {});
var JQ = s(() => {});
var ZQ = s(() => {});
var e7 = s(() => {});
var t7 = s(() => {
  JQ();
  ZQ();
  e7();
});
var r7 = s(() => {});
var o7 = s(() => {});
var hl,
  n7 = s(() => {
    (function (e) {
      (e.HTTP = "http"), (e.HTTPS = "https");
    })(hl || (hl = {}));
  });
var s7 = s(() => {});
var i7 = s(() => {});
var a7 = s(() => {});
var c7 = s(() => {});
var d7 = s(() => {});
var m7 = s(() => {
  s7();
  i7();
  a7();
  c7();
  d7();
});
var l7 = s(() => {});
var Tk,
  Ak = s(() => {
    (function (e) {
      (e.MD5 = "md5"),
        (e.CRC32 = "crc32"),
        (e.CRC32C = "crc32c"),
        (e.SHA1 = "sha1"),
        (e.SHA256 = "sha256");
    })(Tk || (Tk = {}));
  });
var f7 = s(() => {
  Ak();
});
var u7 = s(() => {});
var p7 = s(() => {
  f7();
  u7();
  Ak();
});
var h7 = s(() => {});
var g7,
  y7 = s(() => {
    (function (e) {
      (e[(e.HEADER = 0)] = "HEADER"), (e[(e.TRAILER = 1)] = "TRAILER");
    })(g7 || (g7 = {}));
  });
var x7 = s(() => {});
var E7 = s(() => {});
var S7 = s(() => {});
var C7 = s(() => {});
var b7 = s(() => {});
var _7 = s(() => {
  E7();
  S7();
  C7();
  b7();
});
var w7 = s(() => {});
var T7 = s(() => {});
var A7 = s(() => {});
var R7,
  I7 = s(() => {
    (function (e) {
      (e.PROFILE = "profile"),
        (e.SSO_SESSION = "sso-session"),
        (e.SERVICES = "services");
    })(R7 || (R7 = {}));
  });
var P7 = s(() => {});
var v7 = s(() => {});
var O7 = s(() => {});
var k7 = s(() => {});
var D7 = s(() => {});
var N7 = s(() => {});
var B7 = s(() => {});
var M7 = s(() => {});
var L7 = s(() => {});
var F7 = s(() => {});
var U7 = s(() => {});
var $7,
  H7 = s(() => {
    (function (e) {
      (e.HTTP_0_9 = "http/0.9"),
        (e.HTTP_1_0 = "http/1.0"),
        (e.TDS_8_0 = "tds/8.0");
    })($7 || ($7 = {}));
  });
var z7 = s(() => {});
var q7 = s(() => {});
var j7 = s(() => {});
var G7 = s(() => {});
var V7 = s(() => {});
var W7 = s(() => {});
var K7 = s(() => {});
var Y7 = s(() => {
  FQ();
  WQ();
  KQ();
  YQ();
  QQ();
  XQ();
  t7();
  r7();
  o7();
  n7();
  m7();
  l7();
  p7();
  h7();
  y7();
  x7();
  _7();
  w7();
  T7();
  A7();
  I7();
  P7();
  v7();
  O7();
  k7();
  D7();
  N7();
  B7();
  M7();
  L7();
  F7();
  U7();
  H7();
  z7();
  q7();
  j7();
  G7();
  V7();
  W7();
  K7();
});
var Rk,
  Q7,
  X7 = s(() => {
    Y7();
    _k();
    (Rk = { [hl.HTTP]: 80, [hl.HTTPS]: 443 }),
      (Q7 = (e) => {
        let t = (() => {
          try {
            if (e instanceof URL) return e;
            if (typeof e == "object" && "hostname" in e) {
              let {
                  hostname: u,
                  port: h,
                  protocol: y = "",
                  path: S = "",
                  query: E = {},
                } = e,
                b = new URL(`${y}//${u}${h ? `:${h}` : ""}${S}`);
              return (
                (b.search = Object.entries(E)
                  .map(([v, I]) => `${v}=${I}`)
                  .join("&")),
                b
              );
            }
            return new URL(e);
          } catch {
            return null;
          }
        })();
        if (!t)
          return (
            console.error(
              `Unable to parse ${JSON.stringify(e)} as a whatwg URL.`
            ),
            null
          );
        let r = t.href,
          { host: o, hostname: n, pathname: i, protocol: a, search: c } = t;
        if (c) return null;
        let d = a.slice(0, -1);
        if (!Object.values(hl).includes(d)) return null;
        let m = gn(n),
          f =
            r.includes(`${o}:${Rk[d]}`) ||
            (typeof e == "string" && e.includes(`${o}:${Rk[d]}`)),
          l = `${o}${f ? `:${Rk[d]}` : ""}`;
        return {
          scheme: d,
          authority: l,
          path: i,
          normalizedPath: i.endsWith("/") ? i : `${i}/`,
          isIp: m,
        };
      });
  });
var J7,
  Z7 = s(() => {
    J7 = (e, t) => e === t;
  });
var eX,
  tX = s(() => {
    eX = (e, t, r, o) =>
      t >= r || e.length < r
        ? null
        : o
          ? e.substring(e.length - r, e.length - t)
          : e.substring(t, r);
  });
var rX,
  oX = s(() => {
    rX = (e) =>
      encodeURIComponent(e).replace(
        /[!*'()]/g,
        (t) => `%${t.charCodeAt(0).toString(16).toUpperCase()}`
      );
  });
var Ik = s(() => {
  vQ();
  DQ();
  BQ();
  wk();
  LQ();
  X7();
  Z7();
  tX();
  oX();
});
var nX,
  sX = s(() => {
    Ik();
    nX = {
      booleanEquals: PQ,
      getAttr: cE,
      isSet: NQ,
      isValidHostLabel: Ms,
      not: MQ,
      parseURL: Q7,
      stringEquals: J7,
      substring: eX,
      uriEncode: rX,
    };
  });
var dE,
  Pk = s(() => {
    Ik();
    dE = (e, t) => {
      let r = [],
        o = { ...t.endpointParams, ...t.referenceRecord },
        n = 0;
      for (; n < e.length; ) {
        let i = e.indexOf("{", n);
        if (i === -1) {
          r.push(e.slice(n));
          break;
        }
        r.push(e.slice(n, i));
        let a = e.indexOf("}", i);
        if (a === -1) {
          r.push(e.slice(i));
          break;
        }
        e[i + 1] === "{" &&
          e[a + 1] === "}" &&
          (r.push(e.slice(i + 1, a)), (n = a + 2));
        let c = e.substring(i + 1, a);
        if (c.includes("#")) {
          let [d, m] = c.split("#");
          r.push(cE(o[d], m));
        } else r.push(o[c]);
        n = a + 1;
      }
      return r.join("");
    };
  });
var iX,
  aX = s(() => {
    iX = ({ ref: e }, t) => ({ ...t.endpointParams, ...t.referenceRecord })[e];
  });
var Aa,
  Uh = s(() => {
    qn();
    vk();
    Pk();
    aX();
    Aa = (e, t, r) => {
      if (typeof e == "string") return dE(e, r);
      if (e.fn) return mE(e, r);
      if (e.ref) return iX(e, r);
      throw new Ut(
        `'${t}': ${String(e)} is not a string, function or reference.`
      );
    };
  });
var mE,
  vk = s(() => {
    aE();
    sX();
    Uh();
    mE = ({ fn: e, argv: t }, r) => {
      let o = t.map((i) =>
          ["boolean", "number"].includes(typeof i) ? i : Aa(i, "arg", r)
        ),
        n = e.split(".");
      return n[0] in Jt && n[1] != null ? Jt[n[0]][n[1]](...o) : nX[e](...o);
    };
  });
var cX,
  dX = s(() => {
    Fh();
    qn();
    vk();
    cX = ({ assign: e, ...t }, r) => {
      if (e && e in r.referenceRecord)
        throw new Ut(`'${e}' is already defined in Reference Record.`);
      let o = mE(t, r);
      return (
        r.logger?.debug?.(`${Gi} evaluateCondition: ${zn(t)} = ${zn(o)}`),
        {
          result: o === "" ? !0 : !!o,
          ...(e != null && { toAssign: { name: e, value: o } }),
        }
      );
    };
  });
var gl,
  lE = s(() => {
    Fh();
    dX();
    gl = (e = [], t) => {
      let r = {};
      for (let o of e) {
        let { result: n, toAssign: i } = cX(o, {
          ...t,
          referenceRecord: { ...t.referenceRecord, ...r },
        });
        if (!n) return { result: n };
        i &&
          ((r[i.name] = i.value),
          t.logger?.debug?.(`${Gi} assign: ${i.name} := ${zn(i.value)}`));
      }
      return { result: !0, referenceRecord: r };
    };
  });
var mX,
  lX = s(() => {
    qn();
    Uh();
    mX = (e, t) =>
      Object.entries(e).reduce(
        (r, [o, n]) => ({
          ...r,
          [o]: n.map((i) => {
            let a = Aa(i, "Header value entry", t);
            if (typeof a != "string")
              throw new Ut(`Header '${o}' value '${a}' is not a string`);
            return a;
          }),
        }),
        {}
      );
  });
var Ok,
  fX = s(() => {
    qn();
    Pk();
    kk();
    Ok = (e, t) => {
      if (Array.isArray(e)) return e.map((r) => Ok(r, t));
      switch (typeof e) {
        case "string":
          return dE(e, t);
        case "object":
          if (e === null) throw new Ut(`Unexpected endpoint property: ${e}`);
          return fE(e, t);
        case "boolean":
          return e;
        default:
          throw new Ut(`Unexpected endpoint property type: ${typeof e}`);
      }
    };
  });
var fE,
  kk = s(() => {
    fX();
    fE = (e, t) =>
      Object.entries(e).reduce((r, [o, n]) => ({ ...r, [o]: Ok(n, t) }), {});
  });
var uX,
  pX = s(() => {
    qn();
    Uh();
    uX = (e, t) => {
      let r = Aa(e, "Endpoint URL", t);
      if (typeof r == "string")
        try {
          return new URL(r);
        } catch (o) {
          throw (console.error(`Failed to construct URL with ${r}`, o), o);
        }
      throw new Ut(`Endpoint URL must be a string, got ${typeof r}`);
    };
  });
var hX,
  gX = s(() => {
    Fh();
    lE();
    lX();
    kk();
    pX();
    hX = (e, t) => {
      let { conditions: r, endpoint: o } = e,
        { result: n, referenceRecord: i } = gl(r, t);
      if (!n) return;
      let a = { ...t, referenceRecord: { ...t.referenceRecord, ...i } },
        { url: c, properties: d, headers: m } = o;
      return (
        t.logger?.debug?.(`${Gi} Resolving endpoint from template: ${zn(o)}`),
        {
          ...(m != null && { headers: mX(m, a) }),
          ...(d != null && { properties: fE(d, a) }),
          url: uX(c, a),
        }
      );
    };
  });
var yX,
  xX = s(() => {
    qn();
    lE();
    Uh();
    yX = (e, t) => {
      let { conditions: r, error: o } = e,
        { result: n, referenceRecord: i } = gl(r, t);
      if (n)
        throw new Ut(
          Aa(o, "Error", {
            ...t,
            referenceRecord: { ...t.referenceRecord, ...i },
          })
        );
    };
  });
var EX,
  SX = s(() => {
    lE();
    Dk();
    EX = (e, t) => {
      let { conditions: r, rules: o } = e,
        { result: n, referenceRecord: i } = gl(r, t);
      if (n)
        return uE(o, { ...t, referenceRecord: { ...t.referenceRecord, ...i } });
    };
  });
var uE,
  Dk = s(() => {
    qn();
    gX();
    xX();
    SX();
    uE = (e, t) => {
      for (let r of e)
        if (r.type === "endpoint") {
          let o = hX(r, t);
          if (o) return o;
        } else if (r.type === "error") yX(r, t);
        else if (r.type === "tree") {
          let o = EX(r, t);
          if (o) return o;
        } else throw new Ut(`Unknown endpoint rule: ${r}`);
      throw new Ut("Rules evaluation failed");
    };
  });
var CX = s(() => {
  aE();
  Dk();
});
var jr,
  bX = s(() => {
    Fh();
    qn();
    CX();
    jr = (e, t) => {
      let { endpointParams: r, logger: o } = t,
        { parameters: n, rules: i } = e;
      t.logger?.debug?.(`${Gi} Initial EndpointParams: ${zn(r)}`);
      let a = Object.entries(n)
        .filter(([, m]) => m.default != null)
        .map(([m, f]) => [m, f.default]);
      if (a.length > 0) for (let [m, f] of a) r[m] = r[m] ?? f;
      let c = Object.entries(n)
        .filter(([, m]) => m.required)
        .map(([m]) => m);
      for (let m of c)
        if (r[m] == null) throw new Ut(`Missing required parameter: '${m}'`);
      let d = uE(i, { endpointParams: r, logger: o, referenceRecord: {} });
      return t.logger?.debug?.(`${Gi} Resolved endpoint: ${zn(d)}`), d;
    };
  });
var $t = s(() => {
  EQ();
  _k();
  wk();
  aE();
  bX();
  qn();
});
var Nk = s(() => {
  $t();
});
var Bk,
  _X = s(() => {
    $t();
    Nk();
    Bk = (e, t = !1) => {
      if (t) {
        for (let r of e.split(".")) if (!Bk(r)) return !1;
        return !0;
      }
      return !(
        !Ms(e) ||
        e.length < 3 ||
        e.length > 63 ||
        e !== e.toLowerCase() ||
        gn(e)
      );
    };
  });
var wX,
  XJe,
  TX,
  AX = s(() => {
    (wX = ":"),
      (XJe = "/"),
      (TX = (e) => {
        let t = e.split(wX);
        if (t.length < 6) return null;
        let [r, o, n, i, a, ...c] = t;
        if (r !== "arn" || o === "" || n === "" || c.join(wX) === "")
          return null;
        let d = c.map((m) => m.split(XJe)).flat();
        return {
          partition: o,
          service: n,
          region: i,
          accountId: a,
          resourceId: d,
        };
      });
  });
var IX,
  RX = s(() => {
    IX = {
      partitions: [
        {
          id: "aws",
          outputs: {
            dnsSuffix: "amazonaws.com",
            dualStackDnsSuffix: "api.aws",
            implicitGlobalRegion: "us-east-1",
            name: "aws",
            supportsDualStack: !0,
            supportsFIPS: !0,
          },
          regionRegex: "^(us|eu|ap|sa|ca|me|af|il|mx)\\-\\w+\\-\\d+$",
          regions: {
            "af-south-1": { description: "Africa (Cape Town)" },
            "ap-east-1": { description: "Asia Pacific (Hong Kong)" },
            "ap-east-2": { description: "Asia Pacific (Taipei)" },
            "ap-northeast-1": { description: "Asia Pacific (Tokyo)" },
            "ap-northeast-2": { description: "Asia Pacific (Seoul)" },
            "ap-northeast-3": { description: "Asia Pacific (Osaka)" },
            "ap-south-1": { description: "Asia Pacific (Mumbai)" },
            "ap-south-2": { description: "Asia Pacific (Hyderabad)" },
            "ap-southeast-1": { description: "Asia Pacific (Singapore)" },
            "ap-southeast-2": { description: "Asia Pacific (Sydney)" },
            "ap-southeast-3": { description: "Asia Pacific (Jakarta)" },
            "ap-southeast-4": { description: "Asia Pacific (Melbourne)" },
            "ap-southeast-5": { description: "Asia Pacific (Malaysia)" },
            "ap-southeast-7": { description: "Asia Pacific (Thailand)" },
            "aws-global": { description: "AWS Standard global region" },
            "ca-central-1": { description: "Canada (Central)" },
            "ca-west-1": { description: "Canada West (Calgary)" },
            "eu-central-1": { description: "Europe (Frankfurt)" },
            "eu-central-2": { description: "Europe (Zurich)" },
            "eu-north-1": { description: "Europe (Stockholm)" },
            "eu-south-1": { description: "Europe (Milan)" },
            "eu-south-2": { description: "Europe (Spain)" },
            "eu-west-1": { description: "Europe (Ireland)" },
            "eu-west-2": { description: "Europe (London)" },
            "eu-west-3": { description: "Europe (Paris)" },
            "il-central-1": { description: "Israel (Tel Aviv)" },
            "me-central-1": { description: "Middle East (UAE)" },
            "me-south-1": { description: "Middle East (Bahrain)" },
            "mx-central-1": { description: "Mexico (Central)" },
            "sa-east-1": { description: "South America (Sao Paulo)" },
            "us-east-1": { description: "US East (N. Virginia)" },
            "us-east-2": { description: "US East (Ohio)" },
            "us-west-1": { description: "US West (N. California)" },
            "us-west-2": { description: "US West (Oregon)" },
          },
        },
        {
          id: "aws-cn",
          outputs: {
            dnsSuffix: "amazonaws.com.cn",
            dualStackDnsSuffix: "api.amazonwebservices.com.cn",
            implicitGlobalRegion: "cn-northwest-1",
            name: "aws-cn",
            supportsDualStack: !0,
            supportsFIPS: !0,
          },
          regionRegex: "^cn\\-\\w+\\-\\d+$",
          regions: {
            "aws-cn-global": { description: "AWS China global region" },
            "cn-north-1": { description: "China (Beijing)" },
            "cn-northwest-1": { description: "China (Ningxia)" },
          },
        },
        {
          id: "aws-us-gov",
          outputs: {
            dnsSuffix: "amazonaws.com",
            dualStackDnsSuffix: "api.aws",
            implicitGlobalRegion: "us-gov-west-1",
            name: "aws-us-gov",
            supportsDualStack: !0,
            supportsFIPS: !0,
          },
          regionRegex: "^us\\-gov\\-\\w+\\-\\d+$",
          regions: {
            "aws-us-gov-global": {
              description: "AWS GovCloud (US) global region",
            },
            "us-gov-east-1": { description: "AWS GovCloud (US-East)" },
            "us-gov-west-1": { description: "AWS GovCloud (US-West)" },
          },
        },
        {
          id: "aws-iso",
          outputs: {
            dnsSuffix: "c2s.ic.gov",
            dualStackDnsSuffix: "c2s.ic.gov",
            implicitGlobalRegion: "us-iso-east-1",
            name: "aws-iso",
            supportsDualStack: !1,
            supportsFIPS: !0,
          },
          regionRegex: "^us\\-iso\\-\\w+\\-\\d+$",
          regions: {
            "aws-iso-global": { description: "AWS ISO (US) global region" },
            "us-iso-east-1": { description: "US ISO East" },
            "us-iso-west-1": { description: "US ISO WEST" },
          },
        },
        {
          id: "aws-iso-b",
          outputs: {
            dnsSuffix: "sc2s.sgov.gov",
            dualStackDnsSuffix: "sc2s.sgov.gov",
            implicitGlobalRegion: "us-isob-east-1",
            name: "aws-iso-b",
            supportsDualStack: !1,
            supportsFIPS: !0,
          },
          regionRegex: "^us\\-isob\\-\\w+\\-\\d+$",
          regions: {
            "aws-iso-b-global": { description: "AWS ISOB (US) global region" },
            "us-isob-east-1": { description: "US ISOB East (Ohio)" },
          },
        },
        {
          id: "aws-iso-e",
          outputs: {
            dnsSuffix: "cloud.adc-e.uk",
            dualStackDnsSuffix: "cloud.adc-e.uk",
            implicitGlobalRegion: "eu-isoe-west-1",
            name: "aws-iso-e",
            supportsDualStack: !1,
            supportsFIPS: !0,
          },
          regionRegex: "^eu\\-isoe\\-\\w+\\-\\d+$",
          regions: {
            "aws-iso-e-global": {
              description: "AWS ISOE (Europe) global region",
            },
            "eu-isoe-west-1": { description: "EU ISOE West" },
          },
        },
        {
          id: "aws-iso-f",
          outputs: {
            dnsSuffix: "csp.hci.ic.gov",
            dualStackDnsSuffix: "csp.hci.ic.gov",
            implicitGlobalRegion: "us-isof-south-1",
            name: "aws-iso-f",
            supportsDualStack: !1,
            supportsFIPS: !0,
          },
          regionRegex: "^us\\-isof\\-\\w+\\-\\d+$",
          regions: {
            "aws-iso-f-global": { description: "AWS ISOF global region" },
            "us-isof-east-1": { description: "US ISOF EAST" },
            "us-isof-south-1": { description: "US ISOF SOUTH" },
          },
        },
        {
          id: "aws-eusc",
          outputs: {
            dnsSuffix: "amazonaws.eu",
            dualStackDnsSuffix: "amazonaws.eu",
            implicitGlobalRegion: "eusc-de-east-1",
            name: "aws-eusc",
            supportsDualStack: !1,
            supportsFIPS: !0,
          },
          regionRegex: "^eusc\\-(de)\\-\\w+\\-\\d+$",
          regions: { "eusc-de-east-1": { description: "EU (Germany)" } },
        },
      ],
      version: "1.1",
    };
  });
var ZJe,
  eZe,
  PX,
  vX,
  Mk = s(() => {
    RX();
    (ZJe = IX),
      (eZe = ""),
      (PX = (e) => {
        let { partitions: t } = ZJe;
        for (let o of t) {
          let { regions: n, outputs: i } = o;
          for (let [a, c] of Object.entries(n))
            if (a === e) return { ...i, ...c };
        }
        for (let o of t) {
          let { regionRegex: n, outputs: i } = o;
          if (new RegExp(n).test(e)) return { ...i };
        }
        let r = t.find((o) => o.id === "aws");
        if (!r)
          throw new Error(
            "Provided region was not found in the partition array or regex, and default partition with id 'aws' doesn't exist."
          );
        return { ...r.outputs };
      }),
      (vX = () => eZe);
  });
var $h,
  OX = s(() => {
    $t();
    _X();
    AX();
    Mk();
    $h = { isVirtualHostableS3Bucket: Bk, parseArn: TX, partition: PX };
    Jt.aws = $h;
  });
var kX = s(() => {
  $t();
});
var DX = s(() => {
  $t();
});
var NX = s(() => {});
var BX = s(() => {});
var MX = s(() => {});
var LX = s(() => {});
var FX = s(() => {});
var UX = s(() => {
  DX();
  NX();
  BX();
  MX();
  LX();
  FX();
});
var pE = s(() => {
  OX();
  Mk();
  Nk();
  kX();
  UX();
});
var $X,
  $o,
  HX = s(() => {
    ($X = { warningEmitted: !1 }),
      ($o = (e) => {
        e &&
          !$X.warningEmitted &&
          parseInt(e.substring(1, e.indexOf("."))) < 18 &&
          (($X.warningEmitted = !0),
          process.emitWarning(`NodeDeprecationWarning: The AWS SDK for JavaScript (v3) will
no longer support Node.js 16.x on January 6, 2025.

To continue receiving updates to AWS services, bug fixes, and security
updates please upgrade to a supported Node.js LTS version.

More information can be found at: https://a.co/74kJMmI`));
      });
  });
function ce(e, t, r) {
  return e.$source || (e.$source = {}), (e.$source[t] = r), e;
}
var zX = s(() => {});
function _e(e, t, r) {
  e.__aws_sdk_context
    ? e.__aws_sdk_context.features || (e.__aws_sdk_context.features = {})
    : (e.__aws_sdk_context = { features: {} }),
    (e.__aws_sdk_context.features[t] = r);
}
var qX = s(() => {});
var xt = s(() => {
  HX();
  zX();
  qX();
});
var jX = s(() => {});
var GX = s(() => {
  jX();
});
var VX = s(() => {});
var WX,
  KX = s(() => {
    (function (e) {
      (e.HEADER = "header"), (e.QUERY = "query");
    })(WX || (WX = {}));
  });
var YX,
  QX = s(() => {
    (function (e) {
      (e.HEADER = "header"), (e.QUERY = "query");
    })(YX || (YX = {}));
  });
var XX = s(() => {});
var JX = s(() => {});
var ZX = s(() => {});
var eJ = s(() => {});
var tJ = s(() => {
  KX();
  QX();
  XX();
  JX();
  ZX();
  eJ();
});
var rJ = s(() => {});
var oJ = s(() => {});
var nJ = s(() => {});
var sJ = s(() => {});
var iJ = s(() => {});
var aJ = s(() => {});
var cJ = s(() => {});
var dJ = s(() => {
  iJ();
  aJ();
  cJ();
});
var mJ = s(() => {});
var lJ = s(() => {});
var fJ,
  uJ = s(() => {
    (function (e) {
      (e.HTTP = "http"), (e.HTTPS = "https");
    })(fJ || (fJ = {}));
  });
var pJ = s(() => {});
var hJ = s(() => {});
var gJ = s(() => {});
var yJ = s(() => {});
var xJ = s(() => {});
var EJ = s(() => {
  pJ();
  hJ();
  gJ();
  yJ();
  xJ();
});
var SJ = s(() => {});
var hE,
  Lk = s(() => {
    (function (e) {
      (e.MD5 = "md5"),
        (e.CRC32 = "crc32"),
        (e.CRC32C = "crc32c"),
        (e.SHA1 = "sha1"),
        (e.SHA256 = "sha256");
    })(hE || (hE = {}));
  });
var CJ = s(() => {
  Lk();
});
var bJ = s(() => {});
var _J = s(() => {
  CJ();
  bJ();
  Lk();
});
var wJ = s(() => {});
var Fk,
  TJ = s(() => {
    (function (e) {
      (e[(e.HEADER = 0)] = "HEADER"), (e[(e.TRAILER = 1)] = "TRAILER");
    })(Fk || (Fk = {}));
  });
var AJ = s(() => {});
var RJ = s(() => {});
var IJ = s(() => {});
var PJ = s(() => {});
var vJ = s(() => {});
var OJ = s(() => {
  RJ();
  IJ();
  PJ();
  vJ();
});
var kJ = s(() => {});
var DJ = s(() => {});
var NJ = s(() => {});
var BJ,
  MJ = s(() => {
    (function (e) {
      (e.PROFILE = "profile"),
        (e.SSO_SESSION = "sso-session"),
        (e.SERVICES = "services");
    })(BJ || (BJ = {}));
  });
var LJ = s(() => {});
var FJ = s(() => {});
var UJ = s(() => {});
var $J = s(() => {});
var HJ = s(() => {});
var zJ = s(() => {});
var qJ = s(() => {});
var jJ = s(() => {});
var GJ = s(() => {});
var VJ = s(() => {});
var WJ = s(() => {});
var KJ,
  YJ = s(() => {
    (function (e) {
      (e.HTTP_0_9 = "http/0.9"),
        (e.HTTP_1_0 = "http/1.0"),
        (e.TDS_8_0 = "tds/8.0");
    })(KJ || (KJ = {}));
  });
var QJ = s(() => {});
var XJ = s(() => {});
var JJ = s(() => {});
var ZJ = s(() => {});
var eZ = s(() => {});
var tZ = s(() => {});
var rZ = s(() => {});
var gE = s(() => {
  VX();
  tJ();
  rJ();
  oJ();
  nJ();
  sJ();
  dJ();
  mJ();
  lJ();
  uJ();
  EJ();
  SJ();
  _J();
  wJ();
  TJ();
  AJ();
  OJ();
  kJ();
  DJ();
  NJ();
  MJ();
  LJ();
  FJ();
  UJ();
  $J();
  HJ();
  zJ();
  qJ();
  jJ();
  GJ();
  VJ();
  WJ();
  YJ();
  QJ();
  XJ();
  JJ();
  ZJ();
  eZ();
  tZ();
  rZ();
});
var oZ = s(() => {
  gE();
});
var nZ = s(() => {});
var sZ = s(() => {});
function tZe(e) {
  return Object.keys(e).reduce((t, r) => {
    let o = e[r];
    return { ...t, [r]: Array.isArray(o) ? [...o] : o };
  }, {});
}
var yl,
  iZ = s(() => {
    yl = class e {
      constructor(t) {
        (this.method = t.method || "GET"),
          (this.hostname = t.hostname || "localhost"),
          (this.port = t.port),
          (this.query = t.query || {}),
          (this.headers = t.headers || {}),
          (this.body = t.body),
          (this.protocol = t.protocol
            ? t.protocol.slice(-1) !== ":"
              ? `${t.protocol}:`
              : t.protocol
            : "https:"),
          (this.path = t.path
            ? t.path.charAt(0) !== "/"
              ? `/${t.path}`
              : t.path
            : "/"),
          (this.username = t.username),
          (this.password = t.password),
          (this.fragment = t.fragment);
      }
      static clone(t) {
        let r = new e({ ...t, headers: { ...t.headers } });
        return r.query && (r.query = tZe(r.query)), r;
      }
      static isInstance(t) {
        if (!t) return !1;
        let r = t;
        return (
          "method" in r &&
          "protocol" in r &&
          "hostname" in r &&
          "path" in r &&
          typeof r.query == "object" &&
          typeof r.headers == "object"
        );
      }
      clone() {
        return e.clone(this);
      }
    };
  });
var yE,
  aZ = s(() => {
    yE = class {
      constructor(t) {
        (this.statusCode = t.statusCode),
          (this.reason = t.reason),
          (this.headers = t.headers || {}),
          (this.body = t.body);
      }
      static isInstance(t) {
        if (!t) return !1;
        let r = t;
        return typeof r.statusCode == "number" && typeof r.headers == "object";
      }
    };
  });
var cZ = s(() => {});
var dZ = s(() => {});
var xE = s(() => {
  GX();
  oZ();
  nZ();
  sZ();
  iZ();
  aZ();
  cZ();
  dZ();
});
var Uk,
  mZ = s(() => {
    xE();
    Uk = (e) =>
      yE.isInstance(e) ? (e.headers?.date ?? e.headers?.Date) : void 0;
  });
var xl,
  $k = s(() => {
    xl = (e) => new Date(Date.now() + e);
  });
var lZ,
  fZ = s(() => {
    $k();
    lZ = (e, t) => Math.abs(xl(t).getTime() - e) >= 3e5;
  });
var Hk,
  uZ = s(() => {
    fZ();
    Hk = (e, t) => {
      let r = Date.parse(e);
      return lZ(r, t) ? r - Date.now() : t;
    };
  });
var zk = s(() => {
  mZ();
  $k();
  uZ();
});
var Hh,
  EE,
  wr,
  qk = s(() => {
    xE();
    zk();
    (Hh = (e, t) => {
      if (!t)
        throw new Error(
          `Property \`${e}\` is not resolved for AWS SDK SigV4Auth`
        );
      return t;
    }),
      (EE = async (e) => {
        let t = Hh("context", e.context),
          r = Hh("config", e.config),
          o = t.endpointV2?.properties?.authSchemes?.[0],
          i = await Hh("signer", r.signer)(o),
          a = e?.signingRegion,
          c = e?.signingRegionSet,
          d = e?.signingName;
        return {
          config: r,
          signer: i,
          signingRegion: a,
          signingRegionSet: c,
          signingName: d,
        };
      }),
      (wr = class {
        async sign(t, r, o) {
          if (!yl.isInstance(t))
            throw new Error(
              "The request is not an instance of `HttpRequest` and cannot be signed"
            );
          let n = await EE(o),
            { config: i, signer: a } = n,
            { signingRegion: c, signingName: d } = n,
            m = o.context;
          if (m?.authSchemes?.length ?? !1) {
            let [l, u] = m.authSchemes;
            l?.name === "sigv4a" &&
              u?.name === "sigv4" &&
              ((c = u?.signingRegion ?? c), (d = u?.signingName ?? d));
          }
          return await a.sign(t, {
            signingDate: xl(i.systemClockOffset),
            signingRegion: c,
            signingService: d,
          });
        }
        errorHandler(t) {
          return (r) => {
            let o = r.ServerTime ?? Uk(r.$response);
            if (o) {
              let n = Hh("config", t.config),
                i = n.systemClockOffset;
              (n.systemClockOffset = Hk(o, n.systemClockOffset)),
                n.systemClockOffset !== i &&
                  r.$metadata &&
                  (r.$metadata.clockSkewCorrected = !0);
            }
            throw r;
          };
        }
        successHandler(t, r) {
          let o = Uk(t);
          if (o) {
            let n = Hh("config", r.config);
            n.systemClockOffset = Hk(o, n.systemClockOffset);
          }
        }
      });
  });
var zh,
  pZ = s(() => {
    xE();
    zk();
    qk();
    zh = class extends wr {
      async sign(t, r, o) {
        if (!yl.isInstance(t))
          throw new Error(
            "The request is not an instance of `HttpRequest` and cannot be signed"
          );
        let {
            config: n,
            signer: i,
            signingRegion: a,
            signingRegionSet: c,
            signingName: d,
          } = await EE(o),
          f = ((await n.sigv4aSigningRegionSet?.()) ?? c ?? [a]).join(",");
        return await i.sign(t, {
          signingDate: xl(n.systemClockOffset),
          signingRegion: f,
          signingService: d,
        });
      }
    };
  });
var jk,
  hZ = s(() => {
    jk = (e) =>
      typeof e == "string" && e.length > 0
        ? e.split(",").map((t) => t.trim())
        : [];
  });
var gZ,
  Gk = s(() => {
    gZ = (e) => `AWS_BEARER_TOKEN_${e.replace(/[\s-]/g, "_").toUpperCase()}`;
  });
var yZ,
  xZ,
  Ho,
  EZ = s(() => {
    hZ();
    Gk();
    (yZ = "AWS_AUTH_SCHEME_PREFERENCE"),
      (xZ = "auth_scheme_preference"),
      (Ho = {
        environmentVariableSelector: (e, t) => {
          if (t?.signingName && gZ(t.signingName) in e)
            return ["httpBearerAuth"];
          if (yZ in e) return jk(e[yZ]);
        },
        configFileSelector: (e) => {
          if (xZ in e) return jk(e[xZ]);
        },
        default: [],
      });
  });
var Zt,
  qh = s(() => {
    Zt = class e extends Error {
      constructor(t, r = !0) {
        let o,
          n = !0;
        typeof r == "boolean"
          ? ((o = void 0), (n = r))
          : r != null &&
            typeof r == "object" &&
            ((o = r.logger), (n = r.tryNextLink ?? !0)),
          super(t),
          (this.name = "ProviderError"),
          (this.tryNextLink = n),
          Object.setPrototypeOf(this, e.prototype),
          o?.debug?.(`@smithy/property-provider ${n ? "->" : "(!)"} ${t}`);
      }
      static from(t, r = !0) {
        return Object.assign(new this(t.message, r), t);
      }
    };
  });
var P,
  SZ = s(() => {
    qh();
    P = class e extends Zt {
      constructor(t, r = !0) {
        super(t, r),
          (this.name = "CredentialsProviderError"),
          Object.setPrototypeOf(this, e.prototype);
      }
    };
  });
var Je,
  CZ = s(() => {
    qh();
    Je = class e extends Zt {
      constructor(t, r = !0) {
        super(t, r),
          (this.name = "TokenProviderError"),
          Object.setPrototypeOf(this, e.prototype);
      }
    };
  });
var Ht,
  bZ = s(() => {
    qh();
    Ht =
      (...e) =>
      async () => {
        if (e.length === 0) throw new Zt("No providers in chain");
        let t;
        for (let r of e)
          try {
            return await r();
          } catch (o) {
            if (((t = o), o?.tryNextLink)) continue;
            throw o;
          }
        throw t;
      };
  });
var Ra,
  _Z = s(() => {
    Ra = (e) => () => Promise.resolve(e);
  });
var gr,
  wZ = s(() => {
    gr = (e, t, r) => {
      let o,
        n,
        i,
        a = !1,
        c = async () => {
          n || (n = e());
          try {
            (o = await n), (i = !0), (a = !1);
          } finally {
            n = void 0;
          }
          return o;
        };
      return t === void 0
        ? async (d) => ((!i || d?.forceRefresh) && (o = await c()), o)
        : async (d) => (
            (!i || d?.forceRefresh) && (o = await c()),
            a ? o : r && !r(o) ? ((a = !0), o) : (t(o) && (await c()), o)
          );
    };
  });
var re = s(() => {
  SZ();
  qh();
  CZ();
  bZ();
  _Z();
  wZ();
});
var TZ,
  AZ,
  RZ = s(() => {
    Ue();
    re();
    (TZ = (e) => (
      (e.sigv4aSigningRegionSet = rn(e.sigv4aSigningRegionSet)), e
    )),
      (AZ = {
        environmentVariableSelector(e) {
          if (e.AWS_SIGV4A_SIGNING_REGION_SET)
            return e.AWS_SIGV4A_SIGNING_REGION_SET.split(",").map((t) =>
              t.trim()
            );
          throw new Zt("AWS_SIGV4A_SIGNING_REGION_SET not set in env.", {
            tryNextLink: !0,
          });
        },
        configFileSelector(e) {
          if (e.sigv4a_signing_region_set)
            return (e.sigv4a_signing_region_set ?? "")
              .split(",")
              .map((t) => t.trim());
          throw new Zt("sigv4a_signing_region_set not set in profile.", {
            tryNextLink: !0,
          });
        },
        default: void 0,
      });
  });
import { Buffer as IZ } from "buffer";
var PZ,
  Vk = s(() => {
    cr();
    PZ = (e, t) => {
      if (typeof e != "string")
        throw new TypeError(
          `The "input" argument must be of type string. Received type ${typeof e} (${e})`
        );
      return t ? IZ.from(e, t) : IZ.from(e);
    };
  });
var jh,
  Wk = s(() => {
    Vk();
    jh = (e) => {
      let t = PZ(e, "utf8");
      return new Uint8Array(
        t.buffer,
        t.byteOffset,
        t.byteLength / Uint8Array.BYTES_PER_ELEMENT
      );
    };
  });
var Vi,
  vZ = s(() => {
    Wk();
    Vi = (e) =>
      typeof e == "string"
        ? jh(e)
        : ArrayBuffer.isView(e)
          ? new Uint8Array(
              e.buffer,
              e.byteOffset,
              e.byteLength / Uint8Array.BYTES_PER_ELEMENT
            )
          : new Uint8Array(e);
  });
var OZ = s(() => {
  Vk();
});
var El = s(() => {
  Wk();
  vZ();
  OZ();
});
var kZ,
  DZ,
  Kk,
  NZ,
  BZ,
  Yk,
  Qk,
  Xk,
  Jk,
  rZe,
  MZ,
  LZ,
  Gh,
  FZ,
  UZ,
  $Z,
  HZ,
  SE,
  zZ,
  qZ,
  jZ,
  Zk,
  GZ,
  Ia = s(() => {
    (kZ = "X-Amz-Algorithm"),
      (DZ = "X-Amz-Credential"),
      (Kk = "X-Amz-Date"),
      (NZ = "X-Amz-SignedHeaders"),
      (BZ = "X-Amz-Expires"),
      (Yk = "X-Amz-Signature"),
      (Qk = "X-Amz-Security-Token"),
      (Xk = "authorization"),
      (Jk = Kk.toLowerCase()),
      (rZe = "date"),
      (MZ = [Xk, Jk, rZe]),
      (LZ = Yk.toLowerCase()),
      (Gh = "x-amz-content-sha256"),
      (FZ = Qk.toLowerCase()),
      (UZ = {
        authorization: !0,
        "cache-control": !0,
        connection: !0,
        expect: !0,
        from: !0,
        "keep-alive": !0,
        "max-forwards": !0,
        pragma: !0,
        referer: !0,
        te: !0,
        trailer: !0,
        "transfer-encoding": !0,
        upgrade: !0,
        "user-agent": !0,
        "x-amzn-trace-id": !0,
      }),
      ($Z = /^proxy-/),
      (HZ = /^sec-/),
      (SE = "AWS4-HMAC-SHA256"),
      (zZ = "AWS4-HMAC-SHA256-PAYLOAD"),
      (qZ = "UNSIGNED-PAYLOAD"),
      (jZ = 50),
      (Zk = "aws4_request"),
      (GZ = 60 * 60 * 24 * 7);
  });
var CE,
  eD,
  bE,
  WZ,
  VZ,
  tD = s(() => {
    Fo();
    El();
    Ia();
    (CE = {}),
      (eD = []),
      (bE = (e, t, r) => `${e}/${t}/${r}/${Zk}`),
      (WZ = async (e, t, r, o, n) => {
        let i = await VZ(e, t.secretAccessKey, t.accessKeyId),
          a = `${r}:${o}:${n}:${_t(i)}:${t.sessionToken}`;
        if (a in CE) return CE[a];
        for (eD.push(a); eD.length > jZ; ) delete CE[eD.shift()];
        let c = `AWS4${t.secretAccessKey}`;
        for (let d of [r, o, n, Zk]) c = await VZ(e, c, d);
        return (CE[a] = c);
      }),
      (VZ = (e, t, r) => {
        let o = new e(t);
        return o.update(Vi(r)), o.digest();
      });
  });
var _E,
  rD = s(() => {
    Ia();
    _E = ({ headers: e }, t, r) => {
      let o = {};
      for (let n of Object.keys(e).sort()) {
        if (e[n] == null) continue;
        let i = n.toLowerCase();
        ((i in UZ || t?.has(i) || $Z.test(i) || HZ.test(i)) &&
          (!r || (r && !r.has(i)))) ||
          (o[i] = e[n].trim().replace(/\s+/g, " "));
      }
      return o;
    };
  });
var Vh,
  oD = s(() => {
    cr();
    Fo();
    El();
    Ia();
    Vh = async ({ headers: e, body: t }, r) => {
      for (let o of Object.keys(e)) if (o.toLowerCase() === Gh) return e[o];
      if (t == null)
        return "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855";
      if (typeof t == "string" || ArrayBuffer.isView(t) || Ke(t)) {
        let o = new r();
        return o.update(Vi(t)), _t(await o.digest());
      }
      return qZ;
    };
  });
function YZ(e) {
  for (let t = 0; t < 8; t++) e[t] ^= 255;
  for (let t = 7; t > -1 && (e[t]++, e[t] === 0); t--);
}
var wE,
  KZ,
  oZe,
  nD,
  QZ = s(() => {
    Fo();
    El();
    wE = class {
      format(t) {
        let r = [];
        for (let i of Object.keys(t)) {
          let a = jh(i);
          r.push(
            Uint8Array.from([a.byteLength]),
            a,
            this.formatHeaderValue(t[i])
          );
        }
        let o = new Uint8Array(r.reduce((i, a) => i + a.byteLength, 0)),
          n = 0;
        for (let i of r) o.set(i, n), (n += i.byteLength);
        return o;
      }
      formatHeaderValue(t) {
        switch (t.type) {
          case "boolean":
            return Uint8Array.from([t.value ? 0 : 1]);
          case "byte":
            return Uint8Array.from([2, t.value]);
          case "short":
            let r = new DataView(new ArrayBuffer(3));
            return (
              r.setUint8(0, 3),
              r.setInt16(1, t.value, !1),
              new Uint8Array(r.buffer)
            );
          case "integer":
            let o = new DataView(new ArrayBuffer(5));
            return (
              o.setUint8(0, 4),
              o.setInt32(1, t.value, !1),
              new Uint8Array(o.buffer)
            );
          case "long":
            let n = new Uint8Array(9);
            return (n[0] = 5), n.set(t.value.bytes, 1), n;
          case "binary":
            let i = new DataView(new ArrayBuffer(3 + t.value.byteLength));
            i.setUint8(0, 6), i.setUint16(1, t.value.byteLength, !1);
            let a = new Uint8Array(i.buffer);
            return a.set(t.value, 3), a;
          case "string":
            let c = jh(t.value),
              d = new DataView(new ArrayBuffer(3 + c.byteLength));
            d.setUint8(0, 7), d.setUint16(1, c.byteLength, !1);
            let m = new Uint8Array(d.buffer);
            return m.set(c, 3), m;
          case "timestamp":
            let f = new Uint8Array(9);
            return (
              (f[0] = 8), f.set(nD.fromNumber(t.value.valueOf()).bytes, 1), f
            );
          case "uuid":
            if (!oZe.test(t.value))
              throw new Error(`Invalid UUID received: ${t.value}`);
            let l = new Uint8Array(17);
            return (l[0] = 9), l.set(Zx(t.value.replace(/\-/g, "")), 1), l;
        }
      }
    };
    (function (e) {
      (e[(e.boolTrue = 0)] = "boolTrue"),
        (e[(e.boolFalse = 1)] = "boolFalse"),
        (e[(e.byte = 2)] = "byte"),
        (e[(e.short = 3)] = "short"),
        (e[(e.integer = 4)] = "integer"),
        (e[(e.long = 5)] = "long"),
        (e[(e.byteArray = 6)] = "byteArray"),
        (e[(e.string = 7)] = "string"),
        (e[(e.timestamp = 8)] = "timestamp"),
        (e[(e.uuid = 9)] = "uuid");
    })(KZ || (KZ = {}));
    (oZe = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/),
      (nD = class e {
        constructor(t) {
          if (((this.bytes = t), t.byteLength !== 8))
            throw new Error("Int64 buffers must be exactly 8 bytes");
        }
        static fromNumber(t) {
          if (t > 9223372036854776e3 || t < -9223372036854776e3)
            throw new Error(
              `${t} is too large (or, if negative, too small) to represent as an Int64`
            );
          let r = new Uint8Array(8);
          for (
            let o = 7, n = Math.abs(Math.round(t));
            o > -1 && n > 0;
            o--, n /= 256
          )
            r[o] = n;
          return t < 0 && YZ(r), new e(r);
        }
        valueOf() {
          let t = this.bytes.slice(0),
            r = t[0] & 128;
          return r && YZ(t), parseInt(_t(t), 16) * (r ? -1 : 1);
        }
        toString() {
          return String(this.valueOf());
        }
      });
  });
var sD,
  iD = s(() => {
    sD = (e, t) => {
      e = e.toLowerCase();
      for (let r of Object.keys(t)) if (e === r.toLowerCase()) return !0;
      return !1;
    };
  });
var XZ = s(() => {});
var JZ = s(() => {
  XZ();
});
var ZZ = s(() => {});
var eee,
  tee = s(() => {
    (function (e) {
      (e.HEADER = "header"), (e.QUERY = "query");
    })(eee || (eee = {}));
  });
var ree,
  oee = s(() => {
    (function (e) {
      (e.HEADER = "header"), (e.QUERY = "query");
    })(ree || (ree = {}));
  });
var nee = s(() => {});
var see = s(() => {});
var iee = s(() => {});
var aee = s(() => {});
var cee = s(() => {
  tee();
  oee();
  nee();
  see();
  iee();
  aee();
});
var dee = s(() => {});
var mee = s(() => {});
var lee = s(() => {});
var fee = s(() => {});
var uee = s(() => {});
var pee = s(() => {});
var hee = s(() => {});
var gee = s(() => {
  uee();
  pee();
  hee();
});
var yee = s(() => {});
var xee = s(() => {});
var Eee,
  See = s(() => {
    (function (e) {
      (e.HTTP = "http"), (e.HTTPS = "https");
    })(Eee || (Eee = {}));
  });
var Cee = s(() => {});
var bee = s(() => {});
var _ee = s(() => {});
var wee = s(() => {});
var Tee = s(() => {});
var Aee = s(() => {
  Cee();
  bee();
  _ee();
  wee();
  Tee();
});
var Ree = s(() => {});
var aD,
  cD = s(() => {
    (function (e) {
      (e.MD5 = "md5"),
        (e.CRC32 = "crc32"),
        (e.CRC32C = "crc32c"),
        (e.SHA1 = "sha1"),
        (e.SHA256 = "sha256");
    })(aD || (aD = {}));
  });
var Iee = s(() => {
  cD();
});
var Pee = s(() => {});
var vee = s(() => {
  Iee();
  Pee();
  cD();
});
var Oee = s(() => {});
var dD,
  kee = s(() => {
    (function (e) {
      (e[(e.HEADER = 0)] = "HEADER"), (e[(e.TRAILER = 1)] = "TRAILER");
    })(dD || (dD = {}));
  });
var Dee = s(() => {});
var Nee = s(() => {});
var Bee = s(() => {});
var Mee = s(() => {});
var Lee = s(() => {});
var Fee = s(() => {
  Nee();
  Bee();
  Mee();
  Lee();
});
var Uee = s(() => {});
var $ee = s(() => {});
var Hee = s(() => {});
var zee,
  qee = s(() => {
    (function (e) {
      (e.PROFILE = "profile"),
        (e.SSO_SESSION = "sso-session"),
        (e.SERVICES = "services");
    })(zee || (zee = {}));
  });
var jee = s(() => {});
var Gee = s(() => {});
var Vee = s(() => {});
var Wee = s(() => {});
var Kee = s(() => {});
var Yee = s(() => {});
var Qee = s(() => {});
var Xee = s(() => {});
var Jee = s(() => {});
var Zee = s(() => {});
var ete = s(() => {});
var tte,
  rte = s(() => {
    (function (e) {
      (e.HTTP_0_9 = "http/0.9"),
        (e.HTTP_1_0 = "http/1.0"),
        (e.TDS_8_0 = "tds/8.0");
    })(tte || (tte = {}));
  });
var ote = s(() => {});
var nte = s(() => {});
var ste = s(() => {});
var ite = s(() => {});
var ate = s(() => {});
var cte = s(() => {});
var dte = s(() => {});
var mte = s(() => {
  ZZ();
  cee();
  dee();
  mee();
  lee();
  fee();
  gee();
  yee();
  xee();
  See();
  Aee();
  Ree();
  vee();
  Oee();
  kee();
  Dee();
  Fee();
  Uee();
  $ee();
  Hee();
  qee();
  jee();
  Gee();
  Vee();
  Wee();
  Kee();
  Yee();
  Qee();
  Xee();
  Jee();
  Zee();
  ete();
  rte();
  ote();
  nte();
  ste();
  ite();
  ate();
  cte();
  dte();
});
var lte = s(() => {
  mte();
});
var fte = s(() => {});
var ute = s(() => {});
function nZe(e) {
  return Object.keys(e).reduce((t, r) => {
    let o = e[r];
    return { ...t, [r]: Array.isArray(o) ? [...o] : o };
  }, {});
}
var Sl,
  pte = s(() => {
    Sl = class e {
      constructor(t) {
        (this.method = t.method || "GET"),
          (this.hostname = t.hostname || "localhost"),
          (this.port = t.port),
          (this.query = t.query || {}),
          (this.headers = t.headers || {}),
          (this.body = t.body),
          (this.protocol = t.protocol
            ? t.protocol.slice(-1) !== ":"
              ? `${t.protocol}:`
              : t.protocol
            : "https:"),
          (this.path = t.path
            ? t.path.charAt(0) !== "/"
              ? `/${t.path}`
              : t.path
            : "/"),
          (this.username = t.username),
          (this.password = t.password),
          (this.fragment = t.fragment);
      }
      static clone(t) {
        let r = new e({ ...t, headers: { ...t.headers } });
        return r.query && (r.query = nZe(r.query)), r;
      }
      static isInstance(t) {
        if (!t) return !1;
        let r = t;
        return (
          "method" in r &&
          "protocol" in r &&
          "hostname" in r &&
          "path" in r &&
          typeof r.query == "object" &&
          typeof r.headers == "object"
        );
      }
      clone() {
        return e.clone(this);
      }
    };
  });
var hte = s(() => {});
var gte = s(() => {});
var yte = s(() => {});
var mD = s(() => {
  JZ();
  lte();
  fte();
  ute();
  pte();
  hte();
  gte();
  yte();
});
var lD,
  fD = s(() => {
    mD();
    lD = (e, t = {}) => {
      let { headers: r, query: o = {} } = Sl.clone(e);
      for (let n of Object.keys(r)) {
        let i = n.toLowerCase();
        ((i.slice(0, 6) === "x-amz-" && !t.unhoistableHeaders?.has(i)) ||
          t.hoistableHeaders?.has(i)) &&
          ((o[n] = r[n]), delete r[n]);
      }
      return { ...e, headers: r, query: o };
    };
  });
var TE,
  uD = s(() => {
    mD();
    Ia();
    TE = (e) => {
      e = Sl.clone(e);
      for (let t of Object.keys(e.headers))
        MZ.indexOf(t.toLowerCase()) > -1 && delete e.headers[t];
      return e;
    };
  });
var Zc,
  sZe,
  pD = s(() => {
    (Zc = (e) => encodeURIComponent(e).replace(/[!'()*]/g, sZe)),
      (sZe = (e) => `%${e.charCodeAt(0).toString(16).toUpperCase()}`);
  });
var xte = s(() => {
  pD();
});
var hD = s(() => {
  pD();
  xte();
});
var gD,
  yD = s(() => {
    hD();
    Ia();
    gD = ({ query: e = {} }) => {
      let t = [],
        r = {};
      for (let o of Object.keys(e)) {
        if (o.toLowerCase() === LZ) continue;
        let n = Zc(o);
        t.push(n);
        let i = e[o];
        typeof i == "string"
          ? (r[n] = `${n}=${Zc(i)}`)
          : Array.isArray(i) &&
            (r[n] = i
              .slice(0)
              .reduce((a, c) => a.concat([`${n}=${Zc(c)}`]), [])
              .sort()
              .join("&"));
      }
      return t
        .sort()
        .map((o) => r[o])
        .filter((o) => o)
        .join("&");
    };
  });
var Ete,
  iZe,
  Ste = s(() => {
    (Ete = (e) =>
      iZe(e)
        .toISOString()
        .replace(/\.\d{3}Z$/, "Z")),
      (iZe = (e) =>
        typeof e == "number"
          ? new Date(e * 1e3)
          : typeof e == "string"
            ? Number(e)
              ? new Date(Number(e) * 1e3)
              : new Date(e)
            : e);
  });
var Wh,
  xD = s(() => {
    Fo();
    ct();
    hD();
    El();
    yD();
    Ste();
    Wh = class {
      constructor({
        applyChecksum: t,
        credentials: r,
        region: o,
        service: n,
        sha256: i,
        uriEscapePath: a = !0,
      }) {
        (this.service = n),
          (this.sha256 = i),
          (this.uriEscapePath = a),
          (this.applyChecksum = typeof t == "boolean" ? t : !0),
          (this.regionProvider = pe(o)),
          (this.credentialProvider = pe(r));
      }
      createCanonicalRequest(t, r, o) {
        let n = Object.keys(r).sort();
        return `${t.method}
${this.getCanonicalPath(t)}
${gD(t)}
${n.map((i) => `${i}:${r[i]}`).join(`
`)}

${n.join(";")}
${o}`;
      }
      async createStringToSign(t, r, o, n) {
        let i = new this.sha256();
        i.update(Vi(o));
        let a = await i.digest();
        return `${n}
${t}
${r}
${_t(a)}`;
      }
      getCanonicalPath({ path: t }) {
        if (this.uriEscapePath) {
          let r = [];
          for (let i of t.split("/"))
            i?.length !== 0 && i !== "." && (i === ".." ? r.pop() : r.push(i));
          let o = `${t?.startsWith("/") ? "/" : ""}${r.join("/")}${r.length > 0 && t?.endsWith("/") ? "/" : ""}`;
          return Zc(o).replace(/%2F/g, "/");
        }
        return t;
      }
      validateResolvedCredentials(t) {
        if (
          typeof t != "object" ||
          typeof t.accessKeyId != "string" ||
          typeof t.secretAccessKey != "string"
        )
          throw new Error("Resolved credential object is not valid");
      }
      formatDate(t) {
        let r = Ete(t).replace(/[\-:]/g, "");
        return { longDate: r, shortDate: r.slice(0, 8) };
      }
      getCanonicalHeaderList(t) {
        return Object.keys(t).sort().join(";");
      }
    };
  });
var ed,
  Cte = s(() => {
    Fo();
    El();
    Ia();
    tD();
    rD();
    oD();
    QZ();
    iD();
    fD();
    uD();
    xD();
    ed = class extends Wh {
      constructor({
        applyChecksum: t,
        credentials: r,
        region: o,
        service: n,
        sha256: i,
        uriEscapePath: a = !0,
      }) {
        super({
          applyChecksum: t,
          credentials: r,
          region: o,
          service: n,
          sha256: i,
          uriEscapePath: a,
        }),
          (this.headerFormatter = new wE());
      }
      async presign(t, r = {}) {
        let {
            signingDate: o = new Date(),
            expiresIn: n = 3600,
            unsignableHeaders: i,
            unhoistableHeaders: a,
            signableHeaders: c,
            hoistableHeaders: d,
            signingRegion: m,
            signingService: f,
          } = r,
          l = await this.credentialProvider();
        this.validateResolvedCredentials(l);
        let u = m ?? (await this.regionProvider()),
          { longDate: h, shortDate: y } = this.formatDate(o);
        if (n > GZ)
          return Promise.reject(
            "Signature version 4 presigned URLs must have an expiration date less than one week in the future"
          );
        let S = bE(y, u, f ?? this.service),
          E = lD(TE(t), { unhoistableHeaders: a, hoistableHeaders: d });
        l.sessionToken && (E.query[Qk] = l.sessionToken),
          (E.query[kZ] = SE),
          (E.query[DZ] = `${l.accessKeyId}/${S}`),
          (E.query[Kk] = h),
          (E.query[BZ] = n.toString(10));
        let b = _E(E, i, c);
        return (
          (E.query[NZ] = this.getCanonicalHeaderList(b)),
          (E.query[Yk] = await this.getSignature(
            h,
            S,
            this.getSigningKey(l, u, y, f),
            this.createCanonicalRequest(E, b, await Vh(t, this.sha256))
          )),
          E
        );
      }
      async sign(t, r) {
        return typeof t == "string"
          ? this.signString(t, r)
          : t.headers && t.payload
            ? this.signEvent(t, r)
            : t.message
              ? this.signMessage(t, r)
              : this.signRequest(t, r);
      }
      async signEvent(
        { headers: t, payload: r },
        {
          signingDate: o = new Date(),
          priorSignature: n,
          signingRegion: i,
          signingService: a,
        }
      ) {
        let c = i ?? (await this.regionProvider()),
          { shortDate: d, longDate: m } = this.formatDate(o),
          f = bE(d, c, a ?? this.service),
          l = await Vh({ headers: {}, body: r }, this.sha256),
          u = new this.sha256();
        u.update(t);
        let h = _t(await u.digest()),
          y = [zZ, m, f, n, h, l].join(`
`);
        return this.signString(y, {
          signingDate: o,
          signingRegion: c,
          signingService: a,
        });
      }
      async signMessage(
        t,
        { signingDate: r = new Date(), signingRegion: o, signingService: n }
      ) {
        return this.signEvent(
          {
            headers: this.headerFormatter.format(t.message.headers),
            payload: t.message.body,
          },
          {
            signingDate: r,
            signingRegion: o,
            signingService: n,
            priorSignature: t.priorSignature,
          }
        ).then((a) => ({ message: t.message, signature: a }));
      }
      async signString(
        t,
        {
          signingDate: r = new Date(),
          signingRegion: o,
          signingService: n,
        } = {}
      ) {
        let i = await this.credentialProvider();
        this.validateResolvedCredentials(i);
        let a = o ?? (await this.regionProvider()),
          { shortDate: c } = this.formatDate(r),
          d = new this.sha256(await this.getSigningKey(i, a, c, n));
        return d.update(Vi(t)), _t(await d.digest());
      }
      async signRequest(
        t,
        {
          signingDate: r = new Date(),
          signableHeaders: o,
          unsignableHeaders: n,
          signingRegion: i,
          signingService: a,
        } = {}
      ) {
        let c = await this.credentialProvider();
        this.validateResolvedCredentials(c);
        let d = i ?? (await this.regionProvider()),
          m = TE(t),
          { longDate: f, shortDate: l } = this.formatDate(r),
          u = bE(l, d, a ?? this.service);
        (m.headers[Jk] = f), c.sessionToken && (m.headers[FZ] = c.sessionToken);
        let h = await Vh(m, this.sha256);
        !sD(Gh, m.headers) && this.applyChecksum && (m.headers[Gh] = h);
        let y = _E(m, n, o),
          S = await this.getSignature(
            f,
            u,
            this.getSigningKey(c, d, l, a),
            this.createCanonicalRequest(m, y, h)
          );
        return (
          (m.headers[Xk] =
            `${SE} Credential=${c.accessKeyId}/${u}, SignedHeaders=${this.getCanonicalHeaderList(y)}, Signature=${S}`),
          m
        );
      }
      async getSignature(t, r, o, n) {
        let i = await this.createStringToSign(t, r, n, SE),
          a = new this.sha256(await o);
        return a.update(Vi(i)), _t(await a.digest());
      }
      getSigningKey(t, r, o, n) {
        return WZ(this.sha256, t, o, r, n || this.service);
      }
    };
  });
var ED,
  bte = s(() => {
    ED = { SignatureV4a: null };
  });
var AE = s(() => {
  Cte();
  Ia();
  rD();
  yD();
  oD();
  fD();
  uD();
  tD();
  xD();
  iD();
  bte();
});
function aZe(e, { credentials: t, credentialDefaultProvider: r }) {
  let o;
  return (
    t
      ? t?.memoized
        ? (o = t)
        : (o = hQ(t, pQ, Ck))
      : r
        ? (o = rn(r(Object.assign({}, e, { parentClientConfig: e }))))
        : (o = async () => {
            throw new Error(
              "@aws-sdk/core::resolveAwsSdkSigV4Config - `credentials` not provided and no credentialDefaultProvider was configured."
            );
          }),
    (o.memoized = !0),
    o
  );
}
function cZe(e, t) {
  if (t.configBound) return t;
  let r = async (o) => t({ ...o, callerClientConfig: e });
  return (r.memoized = t.memoized), (r.configBound = !0), r;
}
var zo,
  _te = s(() => {
    xt();
    Ue();
    AE();
    zo = (e) => {
      let t = e.credentials,
        r = !!e.credentials,
        o;
      Object.defineProperty(e, "credentials", {
        set(m) {
          m && m !== t && m !== o && (r = !0), (t = m);
          let f = aZe(e, {
              credentials: t,
              credentialDefaultProvider: e.credentialDefaultProvider,
            }),
            l = cZe(e, f);
          r && !l.attributed
            ? ((o = async (u) =>
                l(u).then((h) => ce(h, "CREDENTIALS_CODE", "e"))),
              (o.memoized = l.memoized),
              (o.configBound = l.configBound),
              (o.attributed = !0))
            : (o = l);
        },
        get() {
          return o;
        },
        enumerable: !0,
        configurable: !0,
      }),
        (e.credentials = t);
      let {
          signingEscapePath: n = !0,
          systemClockOffset: i = e.systemClockOffset || 0,
          sha256: a,
        } = e,
        c;
      return (
        e.signer
          ? (c = rn(e.signer))
          : e.regionInfoProvider
            ? (c = () =>
                rn(e.region)()
                  .then(async (m) => [
                    (await e.regionInfoProvider(m, {
                      useFipsEndpoint: await e.useFipsEndpoint(),
                      useDualstackEndpoint: await e.useDualstackEndpoint(),
                    })) || {},
                    m,
                  ])
                  .then(([m, f]) => {
                    let { signingRegion: l, signingService: u } = m;
                    (e.signingRegion = e.signingRegion || l || f),
                      (e.signingName = e.signingName || u || e.serviceId);
                    let h = {
                        ...e,
                        credentials: e.credentials,
                        region: e.signingRegion,
                        service: e.signingName,
                        sha256: a,
                        uriEscapePath: n,
                      },
                      y = e.signerConstructor || ed;
                    return new y(h);
                  }))
            : (c = async (m) => {
                m = Object.assign(
                  {},
                  {
                    name: "sigv4",
                    signingName: e.signingName || e.defaultSigningName,
                    signingRegion: await rn(e.region)(),
                    properties: {},
                  },
                  m
                );
                let f = m.signingRegion,
                  l = m.signingName;
                (e.signingRegion = e.signingRegion || f),
                  (e.signingName = e.signingName || l || e.serviceId);
                let u = {
                    ...e,
                    credentials: e.credentials,
                    region: e.signingRegion,
                    service: e.signingName,
                    sha256: a,
                    uriEscapePath: n,
                  },
                  h = e.signerConstructor || ed;
                return new h(u);
              }),
        Object.assign(e, {
          systemClockOffset: i,
          signingEscapePath: n,
          signer: c,
        })
      );
    };
  });
var wte = s(() => {
  qk();
  pZ();
  EZ();
  RZ();
  _te();
});
var Tte = s(() => {
  wte();
  Gk();
});
var we,
  jn,
  Ate = s(() => {
    (we = (e) => {
      if (e == null) return e;
      if (typeof e == "number" || typeof e == "bigint") {
        let t = new Error(`Received number ${e} where a string was expected.`);
        return (t.name = "Warning"), console.warn(t), String(e);
      }
      if (typeof e == "boolean") {
        let t = new Error(`Received boolean ${e} where a string was expected.`);
        return (t.name = "Warning"), console.warn(t), String(e);
      }
      return e;
    }),
      (jn = (e) => {
        if (e == null) return e;
        if (typeof e == "string") {
          let t = Number(e);
          if (t.toString() !== e) {
            let r = new Error(
              `Received string "${e}" where a number was expected.`
            );
            return (r.name = "Warning"), console.warn(r), e;
          }
          return t;
        }
        return e;
      });
  });
var EKt,
  Rte = s(() => {
    EKt = typeof TextEncoder == "function" ? new TextEncoder() : null;
  });
var Kh = s(() => {
  Rte();
});
var Yh = s(() => {
  cr();
});
var Ite = s(() => {
  Yh();
});
var SD = s(() => {
  Yh();
});
var Pte = s(() => {
  SD();
});
var vte = s(() => {
  Yh();
});
var CD = s(() => {
  SD();
  Pte();
  vte();
});
var Ote = s(() => {
  Yh();
  CD();
});
var bD = s(() => {
  Ite();
  Ote();
});
var kte = s(() => {});
var _D = s(() => {
  kte();
});
var Dte = s(() => {
  _D();
});
var Nte = s(() => {
  Dt();
});
var Bte = s(() => {
  _D();
  gE();
});
var Mte = s(() => {});
var Lte = s(() => {});
var wD = s(() => {});
var Fte = s(() => {
  wD();
});
var Ute = s(() => {});
var $te = s(() => {});
var Hte = s(() => {
  Dt();
});
var zte = s(() => {
  gE();
});
var qte = s(() => {});
var jte = s(() => {
  zte();
  qte();
});
var Gte = s(() => {
  jte();
});
var Vte = s(() => {});
var RE,
  Wte = s(() => {
    RE = (e) => {
      let t = "#text";
      for (let r in e)
        e.hasOwnProperty(r) && e[r][t] !== void 0
          ? (e[r] = e[r][t])
          : typeof e[r] == "object" && e[r] !== null && (e[r] = RE(e[r]));
      return e;
    };
  });
var Kte = s(() => {});
var Yte = s(() => {});
var Qte = s(() => {});
var Xte = s(() => {
  Dt();
});
var Jte = s(() => {});
var Zte = s(() => {});
var Cl = s(() => {
  Dte();
  Nte();
  Bte();
  Mte();
  Lte();
  Fte();
  Ute();
  $te();
  wD();
  Hte();
  Gte();
  Vte();
  Wte();
  Kte();
  Yte();
  Qte();
  Xte();
  Jte();
  Zte();
  Uo();
});
var IE,
  TD = s(() => {
    Cl();
    IE = (e, t) => ne(e, t).then((r) => t.utf8Encoder(r));
  });
var ie,
  Gn,
  Vn,
  ere = s(() => {
    TD();
    (ie = (e, t) =>
      IE(e, t).then((r) => {
        if (r.length)
          try {
            return JSON.parse(r);
          } catch (o) {
            throw (
              (o?.name === "SyntaxError" &&
                Object.defineProperty(o, "$responseBodyText", { value: r }),
              o)
            );
          }
        return {};
      })),
      (Gn = async (e, t) => {
        let r = await ie(e, t);
        return (r.message = r.message ?? r.Message), r;
      }),
      (Vn = (e, t) => {
        let r = (i, a) =>
            Object.keys(i).find((c) => c.toLowerCase() === a.toLowerCase()),
          o = (i) => {
            let a = i;
            return (
              typeof a == "number" && (a = a.toString()),
              a.indexOf(",") >= 0 && (a = a.split(",")[0]),
              a.indexOf(":") >= 0 && (a = a.split(":")[0]),
              a.indexOf("#") >= 0 && (a = a.split("#")[1]),
              a
            );
          },
          n = r(e.headers, "x-amzn-errortype");
        if (n !== void 0) return o(e.headers[n]);
        if (t && typeof t == "object") {
          let i = r(t, "code");
          if (i && t[i] !== void 0) return o(t[i]);
          if (t.__type !== void 0) return o(t.__type);
        }
      });
  });
var tre = s(() => {
  lo();
  Uo();
  bD();
});
var rre = s(() => {
  lo();
  Uo();
  Uo();
});
var ore = s(() => {});
var nre = s(() => {
  Dt();
  lo();
  Kh();
});
var sre = s(() => {});
var ire = s(() => {});
var are = s(() => {
  Dt();
  lo();
  Kh();
});
var td,
  cre = s(() => {
    Cl();
    td = (e) => {
      if (e != null)
        return typeof e == "object" && "__type" in e && delete e.__type, Mh(e);
    };
  });
var PE = To((Wi) => {
  "use strict";
  var dre =
      ":A-Za-z_\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD",
    xZe = dre + "\\-.\\d\\u00B7\\u0300-\\u036F\\u203F-\\u2040",
    mre = "[" + dre + "][" + xZe + "]*",
    EZe = new RegExp("^" + mre + "$"),
    SZe = function (e, t) {
      let r = [],
        o = t.exec(e);
      for (; o; ) {
        let n = [];
        n.startIndex = t.lastIndex - o[0].length;
        let i = o.length;
        for (let a = 0; a < i; a++) n.push(o[a]);
        r.push(n), (o = t.exec(e));
      }
      return r;
    },
    CZe = function (e) {
      let t = EZe.exec(e);
      return !(t === null || typeof t > "u");
    };
  Wi.isExist = function (e) {
    return typeof e < "u";
  };
  Wi.isEmptyObject = function (e) {
    return Object.keys(e).length === 0;
  };
  Wi.merge = function (e, t, r) {
    if (t) {
      let o = Object.keys(t),
        n = o.length;
      for (let i = 0; i < n; i++)
        r === "strict" ? (e[o[i]] = [t[o[i]]]) : (e[o[i]] = t[o[i]]);
    }
  };
  Wi.getValue = function (e) {
    return Wi.isExist(e) ? e : "";
  };
  Wi.isName = CZe;
  Wi.getAllMatches = SZe;
  Wi.nameRegexp = mre;
});
var ID = To((hre) => {
  "use strict";
  var RD = PE(),
    bZe = { allowBooleanAttributes: !1, unpairedTags: [] };
  hre.validate = function (e, t) {
    t = Object.assign({}, bZe, t);
    let r = [],
      o = !1,
      n = !1;
    e[0] === "\uFEFF" && (e = e.substr(1));
    for (let i = 0; i < e.length; i++)
      if (e[i] === "<" && e[i + 1] === "?") {
        if (((i += 2), (i = fre(e, i)), i.err)) return i;
      } else if (e[i] === "<") {
        let a = i;
        if ((i++, e[i] === "!")) {
          i = ure(e, i);
          continue;
        } else {
          let c = !1;
          e[i] === "/" && ((c = !0), i++);
          let d = "";
          for (
            ;
            i < e.length &&
            e[i] !== ">" &&
            e[i] !== " " &&
            e[i] !== "	" &&
            e[i] !==
              `
` &&
            e[i] !== "\r";
            i++
          )
            d += e[i];
          if (
            ((d = d.trim()),
            d[d.length - 1] === "/" &&
              ((d = d.substring(0, d.length - 1)), i--),
            !vZe(d))
          ) {
            let l;
            return (
              d.trim().length === 0
                ? (l = "Invalid space after '<'.")
                : (l = "Tag '" + d + "' is an invalid name."),
              Lr("InvalidTag", l, sn(e, i))
            );
          }
          let m = TZe(e, i);
          if (m === !1)
            return Lr(
              "InvalidAttr",
              "Attributes for '" + d + "' have open quote.",
              sn(e, i)
            );
          let f = m.value;
          if (((i = m.index), f[f.length - 1] === "/")) {
            let l = i - f.length;
            f = f.substring(0, f.length - 1);
            let u = pre(f, t);
            if (u === !0) o = !0;
            else return Lr(u.err.code, u.err.msg, sn(e, l + u.err.line));
          } else if (c)
            if (m.tagClosed) {
              if (f.trim().length > 0)
                return Lr(
                  "InvalidTag",
                  "Closing tag '" +
                    d +
                    "' can't have attributes or invalid starting.",
                  sn(e, a)
                );
              if (r.length === 0)
                return Lr(
                  "InvalidTag",
                  "Closing tag '" + d + "' has not been opened.",
                  sn(e, a)
                );
              {
                let l = r.pop();
                if (d !== l.tagName) {
                  let u = sn(e, l.tagStartPos);
                  return Lr(
                    "InvalidTag",
                    "Expected closing tag '" +
                      l.tagName +
                      "' (opened in line " +
                      u.line +
                      ", col " +
                      u.col +
                      ") instead of closing tag '" +
                      d +
                      "'.",
                    sn(e, a)
                  );
                }
                r.length == 0 && (n = !0);
              }
            } else
              return Lr(
                "InvalidTag",
                "Closing tag '" + d + "' doesn't have proper closing.",
                sn(e, i)
              );
          else {
            let l = pre(f, t);
            if (l !== !0)
              return Lr(
                l.err.code,
                l.err.msg,
                sn(e, i - f.length + l.err.line)
              );
            if (n === !0)
              return Lr(
                "InvalidXml",
                "Multiple possible root nodes found.",
                sn(e, i)
              );
            t.unpairedTags.indexOf(d) !== -1 ||
              r.push({ tagName: d, tagStartPos: a }),
              (o = !0);
          }
          for (i++; i < e.length; i++)
            if (e[i] === "<")
              if (e[i + 1] === "!") {
                i++, (i = ure(e, i));
                continue;
              } else if (e[i + 1] === "?") {
                if (((i = fre(e, ++i)), i.err)) return i;
              } else break;
            else if (e[i] === "&") {
              let l = IZe(e, i);
              if (l == -1)
                return Lr("InvalidChar", "char '&' is not expected.", sn(e, i));
              i = l;
            } else if (n === !0 && !lre(e[i]))
              return Lr("InvalidXml", "Extra text at the end", sn(e, i));
          e[i] === "<" && i--;
        }
      } else {
        if (lre(e[i])) continue;
        return Lr(
          "InvalidChar",
          "char '" + e[i] + "' is not expected.",
          sn(e, i)
        );
      }
    if (o) {
      if (r.length == 1)
        return Lr(
          "InvalidTag",
          "Unclosed tag '" + r[0].tagName + "'.",
          sn(e, r[0].tagStartPos)
        );
      if (r.length > 0)
        return Lr(
          "InvalidXml",
          "Invalid '" +
            JSON.stringify(
              r.map((i) => i.tagName),
              null,
              4
            ).replace(/\r?\n/g, "") +
            "' found.",
          { line: 1, col: 1 }
        );
    } else return Lr("InvalidXml", "Start tag expected.", 1);
    return !0;
  };
  function lre(e) {
    return (
      e === " " ||
      e === "	" ||
      e ===
        `
` ||
      e === "\r"
    );
  }
  function fre(e, t) {
    let r = t;
    for (; t < e.length; t++)
      if (e[t] == "?" || e[t] == " ") {
        let o = e.substr(r, t - r);
        if (t > 5 && o === "xml")
          return Lr(
            "InvalidXml",
            "XML declaration allowed only at the start of the document.",
            sn(e, t)
          );
        if (e[t] == "?" && e[t + 1] == ">") {
          t++;
          break;
        } else continue;
      }
    return t;
  }
  function ure(e, t) {
    if (e.length > t + 5 && e[t + 1] === "-" && e[t + 2] === "-") {
      for (t += 3; t < e.length; t++)
        if (e[t] === "-" && e[t + 1] === "-" && e[t + 2] === ">") {
          t += 2;
          break;
        }
    } else if (
      e.length > t + 8 &&
      e[t + 1] === "D" &&
      e[t + 2] === "O" &&
      e[t + 3] === "C" &&
      e[t + 4] === "T" &&
      e[t + 5] === "Y" &&
      e[t + 6] === "P" &&
      e[t + 7] === "E"
    ) {
      let r = 1;
      for (t += 8; t < e.length; t++)
        if (e[t] === "<") r++;
        else if (e[t] === ">" && (r--, r === 0)) break;
    } else if (
      e.length > t + 9 &&
      e[t + 1] === "[" &&
      e[t + 2] === "C" &&
      e[t + 3] === "D" &&
      e[t + 4] === "A" &&
      e[t + 5] === "T" &&
      e[t + 6] === "A" &&
      e[t + 7] === "["
    ) {
      for (t += 8; t < e.length; t++)
        if (e[t] === "]" && e[t + 1] === "]" && e[t + 2] === ">") {
          t += 2;
          break;
        }
    }
    return t;
  }
  var _Ze = '"',
    wZe = "'";
  function TZe(e, t) {
    let r = "",
      o = "",
      n = !1;
    for (; t < e.length; t++) {
      if (e[t] === _Ze || e[t] === wZe)
        o === "" ? (o = e[t]) : o !== e[t] || (o = "");
      else if (e[t] === ">" && o === "") {
        n = !0;
        break;
      }
      r += e[t];
    }
    return o !== "" ? !1 : { value: r, index: t, tagClosed: n };
  }
  var AZe = new RegExp(
    `(\\s*)([^\\s=]+)(\\s*=)?(\\s*(['"])(([\\s\\S])*?)\\5)?`,
    "g"
  );
  function pre(e, t) {
    let r = RD.getAllMatches(e, AZe),
      o = {};
    for (let n = 0; n < r.length; n++) {
      if (r[n][1].length === 0)
        return Lr(
          "InvalidAttr",
          "Attribute '" + r[n][2] + "' has no space in starting.",
          Qh(r[n])
        );
      if (r[n][3] !== void 0 && r[n][4] === void 0)
        return Lr(
          "InvalidAttr",
          "Attribute '" + r[n][2] + "' is without value.",
          Qh(r[n])
        );
      if (r[n][3] === void 0 && !t.allowBooleanAttributes)
        return Lr(
          "InvalidAttr",
          "boolean attribute '" + r[n][2] + "' is not allowed.",
          Qh(r[n])
        );
      let i = r[n][2];
      if (!PZe(i))
        return Lr(
          "InvalidAttr",
          "Attribute '" + i + "' is an invalid name.",
          Qh(r[n])
        );
      if (!o.hasOwnProperty(i)) o[i] = 1;
      else
        return Lr(
          "InvalidAttr",
          "Attribute '" + i + "' is repeated.",
          Qh(r[n])
        );
    }
    return !0;
  }
  function RZe(e, t) {
    let r = /\d/;
    for (e[t] === "x" && (t++, (r = /[\da-fA-F]/)); t < e.length; t++) {
      if (e[t] === ";") return t;
      if (!e[t].match(r)) break;
    }
    return -1;
  }
  function IZe(e, t) {
    if ((t++, e[t] === ";")) return -1;
    if (e[t] === "#") return t++, RZe(e, t);
    let r = 0;
    for (; t < e.length; t++, r++)
      if (!(e[t].match(/\w/) && r < 20)) {
        if (e[t] === ";") break;
        return -1;
      }
    return t;
  }
  function Lr(e, t, r) {
    return { err: { code: e, msg: t, line: r.line || r, col: r.col } };
  }
  function PZe(e) {
    return RD.isName(e);
  }
  function vZe(e) {
    return RD.isName(e);
  }
  function sn(e, t) {
    let r = e.substring(0, t).split(/\r?\n/);
    return { line: r.length, col: r[r.length - 1].length + 1 };
  }
  function Qh(e) {
    return e.startIndex + e[1].length;
  }
});
var yre = To((PD) => {
  var gre = {
      preserveOrder: !1,
      attributeNamePrefix: "@_",
      attributesGroupName: !1,
      textNodeName: "#text",
      ignoreAttributes: !0,
      removeNSPrefix: !1,
      allowBooleanAttributes: !1,
      parseTagValue: !0,
      parseAttributeValue: !1,
      trimValues: !0,
      cdataPropName: !1,
      numberParseOptions: { hex: !0, leadingZeros: !0, eNotation: !0 },
      tagValueProcessor: function (e, t) {
        return t;
      },
      attributeValueProcessor: function (e, t) {
        return t;
      },
      stopNodes: [],
      alwaysCreateTextNode: !1,
      isArray: () => !1,
      commentPropName: !1,
      unpairedTags: [],
      processEntities: !0,
      htmlEntities: !1,
      ignoreDeclaration: !1,
      ignorePiTags: !1,
      transformTagName: !1,
      transformAttributeName: !1,
      updateTag: function (e, t, r) {
        return e;
      },
    },
    OZe = function (e) {
      return Object.assign({}, gre, e);
    };
  PD.buildOptions = OZe;
  PD.defaultOptions = gre;
});
var Ere = To((A9t, xre) => {
  "use strict";
  var vD = class {
    constructor(t) {
      (this.tagname = t), (this.child = []), (this[":@"] = {});
    }
    add(t, r) {
      t === "__proto__" && (t = "#__proto__"), this.child.push({ [t]: r });
    }
    addChild(t) {
      t.tagname === "__proto__" && (t.tagname = "#__proto__"),
        t[":@"] && Object.keys(t[":@"]).length > 0
          ? this.child.push({ [t.tagname]: t.child, ":@": t[":@"] })
          : this.child.push({ [t.tagname]: t.child });
    }
  };
  xre.exports = vD;
});
var Cre = To((R9t, Sre) => {
  var kZe = PE();
  function DZe(e, t) {
    let r = {};
    if (
      e[t + 3] === "O" &&
      e[t + 4] === "C" &&
      e[t + 5] === "T" &&
      e[t + 6] === "Y" &&
      e[t + 7] === "P" &&
      e[t + 8] === "E"
    ) {
      t = t + 9;
      let o = 1,
        n = !1,
        i = !1,
        a = "";
      for (; t < e.length; t++)
        if (e[t] === "<" && !i) {
          if (n && MZe(e, t))
            (t += 7),
              ([entityName, val, t] = NZe(e, t + 1)),
              val.indexOf("&") === -1 &&
                (r[$Ze(entityName)] = {
                  regx: RegExp(`&${entityName};`, "g"),
                  val,
                });
          else if (n && LZe(e, t)) t += 8;
          else if (n && FZe(e, t)) t += 8;
          else if (n && UZe(e, t)) t += 9;
          else if (BZe) i = !0;
          else throw new Error("Invalid DOCTYPE");
          o++, (a = "");
        } else if (e[t] === ">") {
          if (
            (i ? e[t - 1] === "-" && e[t - 2] === "-" && ((i = !1), o--) : o--,
            o === 0)
          )
            break;
        } else e[t] === "[" ? (n = !0) : (a += e[t]);
      if (o !== 0) throw new Error("Unclosed DOCTYPE");
    } else throw new Error("Invalid Tag instead of DOCTYPE");
    return { entities: r, i: t };
  }
  function NZe(e, t) {
    let r = "";
    for (; t < e.length && e[t] !== "'" && e[t] !== '"'; t++) r += e[t];
    if (((r = r.trim()), r.indexOf(" ") !== -1))
      throw new Error("External entites are not supported");
    let o = e[t++],
      n = "";
    for (; t < e.length && e[t] !== o; t++) n += e[t];
    return [r, n, t];
  }
  function BZe(e, t) {
    return e[t + 1] === "!" && e[t + 2] === "-" && e[t + 3] === "-";
  }
  function MZe(e, t) {
    return (
      e[t + 1] === "!" &&
      e[t + 2] === "E" &&
      e[t + 3] === "N" &&
      e[t + 4] === "T" &&
      e[t + 5] === "I" &&
      e[t + 6] === "T" &&
      e[t + 7] === "Y"
    );
  }
  function LZe(e, t) {
    return (
      e[t + 1] === "!" &&
      e[t + 2] === "E" &&
      e[t + 3] === "L" &&
      e[t + 4] === "E" &&
      e[t + 5] === "M" &&
      e[t + 6] === "E" &&
      e[t + 7] === "N" &&
      e[t + 8] === "T"
    );
  }
  function FZe(e, t) {
    return (
      e[t + 1] === "!" &&
      e[t + 2] === "A" &&
      e[t + 3] === "T" &&
      e[t + 4] === "T" &&
      e[t + 5] === "L" &&
      e[t + 6] === "I" &&
      e[t + 7] === "S" &&
      e[t + 8] === "T"
    );
  }
  function UZe(e, t) {
    return (
      e[t + 1] === "!" &&
      e[t + 2] === "N" &&
      e[t + 3] === "O" &&
      e[t + 4] === "T" &&
      e[t + 5] === "A" &&
      e[t + 6] === "T" &&
      e[t + 7] === "I" &&
      e[t + 8] === "O" &&
      e[t + 9] === "N"
    );
  }
  function $Ze(e) {
    if (kZe.isName(e)) return e;
    throw new Error(`Invalid entity name ${e}`);
  }
  Sre.exports = DZe;
});
var _re = To((I9t, bre) => {
  var HZe = /^[-+]?0x[a-fA-F0-9]+$/,
    zZe = /^([\-\+])?(0*)([0-9]*(\.[0-9]*)?)$/,
    qZe = { hex: !0, leadingZeros: !0, decimalPoint: ".", eNotation: !0 };
  function jZe(e, t = {}) {
    if (((t = Object.assign({}, qZe, t)), !e || typeof e != "string")) return e;
    let r = e.trim();
    if (t.skipLike !== void 0 && t.skipLike.test(r)) return e;
    if (e === "0") return 0;
    if (t.hex && HZe.test(r)) return VZe(r, 16);
    if (r.search(/[eE]/) !== -1) {
      let o = r.match(/^([-\+])?(0*)([0-9]*(\.[0-9]*)?[eE][-\+]?[0-9]+)$/);
      if (o) {
        if (t.leadingZeros) r = (o[1] || "") + o[3];
        else if (!(o[2] === "0" && o[3][0] === ".")) return e;
        return t.eNotation ? Number(r) : e;
      } else return e;
    } else {
      let o = zZe.exec(r);
      if (o) {
        let n = o[1],
          i = o[2],
          a = GZe(o[3]);
        if (!t.leadingZeros && i.length > 0 && n && r[2] !== ".") return e;
        if (!t.leadingZeros && i.length > 0 && !n && r[1] !== ".") return e;
        if (t.leadingZeros && i === e) return 0;
        {
          let c = Number(r),
            d = "" + c;
          return d.search(/[eE]/) !== -1
            ? t.eNotation
              ? c
              : e
            : r.indexOf(".") !== -1
              ? (d === "0" && a === "") || d === a || (n && d === "-" + a)
                ? c
                : e
              : i
                ? a === d || n + a === d
                  ? c
                  : e
                : r === d || r === n + d
                  ? c
                  : e;
        }
      } else return e;
    }
  }
  function GZe(e) {
    return (
      e &&
        e.indexOf(".") !== -1 &&
        ((e = e.replace(/0+$/, "")),
        e === "."
          ? (e = "0")
          : e[0] === "."
            ? (e = "0" + e)
            : e[e.length - 1] === "." && (e = e.substr(0, e.length - 1))),
      e
    );
  }
  function VZe(e, t) {
    if (parseInt) return parseInt(e, t);
    if (Number.parseInt) return Number.parseInt(e, t);
    if (window && window.parseInt) return window.parseInt(e, t);
    throw new Error(
      "parseInt, Number.parseInt, window.parseInt are not supported"
    );
  }
  bre.exports = jZe;
});
var Are = To((P9t, Tre) => {
  "use strict";
  var wre = PE(),
    Xh = Ere(),
    WZe = Cre(),
    KZe = _re(),
    OD = class {
      constructor(t) {
        (this.options = t),
          (this.currentNode = null),
          (this.tagsNodeStack = []),
          (this.docTypeEntities = {}),
          (this.lastEntities = {
            apos: { regex: /&(apos|#39|#x27);/g, val: "'" },
            gt: { regex: /&(gt|#62|#x3E);/g, val: ">" },
            lt: { regex: /&(lt|#60|#x3C);/g, val: "<" },
            quot: { regex: /&(quot|#34|#x22);/g, val: '"' },
          }),
          (this.ampEntity = { regex: /&(amp|#38|#x26);/g, val: "&" }),
          (this.htmlEntities = {
            space: { regex: /&(nbsp|#160);/g, val: " " },
            cent: { regex: /&(cent|#162);/g, val: "\xA2" },
            pound: { regex: /&(pound|#163);/g, val: "\xA3" },
            yen: { regex: /&(yen|#165);/g, val: "\xA5" },
            euro: { regex: /&(euro|#8364);/g, val: "\u20AC" },
            copyright: { regex: /&(copy|#169);/g, val: "\xA9" },
            reg: { regex: /&(reg|#174);/g, val: "\xAE" },
            inr: { regex: /&(inr|#8377);/g, val: "\u20B9" },
            num_dec: {
              regex: /&#([0-9]{1,7});/g,
              val: (r, o) => String.fromCharCode(Number.parseInt(o, 10)),
            },
            num_hex: {
              regex: /&#x([0-9a-fA-F]{1,6});/g,
              val: (r, o) => String.fromCharCode(Number.parseInt(o, 16)),
            },
          }),
          (this.addExternalEntities = YZe),
          (this.parseXml = eet),
          (this.parseTextData = QZe),
          (this.resolveNameSpace = XZe),
          (this.buildAttributesMap = ZZe),
          (this.isItStopNode = net),
          (this.replaceEntitiesValue = ret),
          (this.readStopNodeData = iet),
          (this.saveTextToParentTag = oet),
          (this.addChild = tet);
      }
    };
  function YZe(e) {
    let t = Object.keys(e);
    for (let r = 0; r < t.length; r++) {
      let o = t[r];
      this.lastEntities[o] = {
        regex: new RegExp("&" + o + ";", "g"),
        val: e[o],
      };
    }
  }
  function QZe(e, t, r, o, n, i, a) {
    if (
      e !== void 0 &&
      (this.options.trimValues && !o && (e = e.trim()), e.length > 0)
    ) {
      a || (e = this.replaceEntitiesValue(e));
      let c = this.options.tagValueProcessor(t, e, r, n, i);
      return c == null
        ? e
        : typeof c != typeof e || c !== e
          ? c
          : this.options.trimValues
            ? DD(e, this.options.parseTagValue, this.options.numberParseOptions)
            : e.trim() === e
              ? DD(
                  e,
                  this.options.parseTagValue,
                  this.options.numberParseOptions
                )
              : e;
    }
  }
  function XZe(e) {
    if (this.options.removeNSPrefix) {
      let t = e.split(":"),
        r = e.charAt(0) === "/" ? "/" : "";
      if (t[0] === "xmlns") return "";
      t.length === 2 && (e = r + t[1]);
    }
    return e;
  }
  var JZe = new RegExp(`([^\\s=]+)\\s*(=\\s*(['"])([\\s\\S]*?)\\3)?`, "gm");
  function ZZe(e, t, r) {
    if (!this.options.ignoreAttributes && typeof e == "string") {
      let o = wre.getAllMatches(e, JZe),
        n = o.length,
        i = {};
      for (let a = 0; a < n; a++) {
        let c = this.resolveNameSpace(o[a][1]),
          d = o[a][4],
          m = this.options.attributeNamePrefix + c;
        if (c.length)
          if (
            (this.options.transformAttributeName &&
              (m = this.options.transformAttributeName(m)),
            m === "__proto__" && (m = "#__proto__"),
            d !== void 0)
          ) {
            this.options.trimValues && (d = d.trim()),
              (d = this.replaceEntitiesValue(d));
            let f = this.options.attributeValueProcessor(c, d, t);
            f == null
              ? (i[m] = d)
              : typeof f != typeof d || f !== d
                ? (i[m] = f)
                : (i[m] = DD(
                    d,
                    this.options.parseAttributeValue,
                    this.options.numberParseOptions
                  ));
          } else this.options.allowBooleanAttributes && (i[m] = !0);
      }
      if (!Object.keys(i).length) return;
      if (this.options.attributesGroupName) {
        let a = {};
        return (a[this.options.attributesGroupName] = i), a;
      }
      return i;
    }
  }
  var eet = function (e) {
    e = e.replace(
      /\r\n?/g,
      `
`
    );
    let t = new Xh("!xml"),
      r = t,
      o = "",
      n = "";
    for (let i = 0; i < e.length; i++)
      if (e[i] === "<")
        if (e[i + 1] === "/") {
          let c = rd(e, ">", i, "Closing Tag is not closed."),
            d = e.substring(i + 2, c).trim();
          if (this.options.removeNSPrefix) {
            let l = d.indexOf(":");
            l !== -1 && (d = d.substr(l + 1));
          }
          this.options.transformTagName &&
            (d = this.options.transformTagName(d)),
            r && (o = this.saveTextToParentTag(o, r, n));
          let m = n.substring(n.lastIndexOf(".") + 1);
          if (d && this.options.unpairedTags.indexOf(d) !== -1)
            throw new Error(
              `Unpaired tag can not be used as closing tag: </${d}>`
            );
          let f = 0;
          m && this.options.unpairedTags.indexOf(m) !== -1
            ? ((f = n.lastIndexOf(".", n.lastIndexOf(".") - 1)),
              this.tagsNodeStack.pop())
            : (f = n.lastIndexOf(".")),
            (n = n.substring(0, f)),
            (r = this.tagsNodeStack.pop()),
            (o = ""),
            (i = c);
        } else if (e[i + 1] === "?") {
          let c = kD(e, i, !1, "?>");
          if (!c) throw new Error("Pi Tag is not closed.");
          if (
            ((o = this.saveTextToParentTag(o, r, n)),
            !(
              (this.options.ignoreDeclaration && c.tagName === "?xml") ||
              this.options.ignorePiTags
            ))
          ) {
            let d = new Xh(c.tagName);
            d.add(this.options.textNodeName, ""),
              c.tagName !== c.tagExp &&
                c.attrExpPresent &&
                (d[":@"] = this.buildAttributesMap(c.tagExp, n, c.tagName)),
              this.addChild(r, d, n);
          }
          i = c.closeIndex + 1;
        } else if (e.substr(i + 1, 3) === "!--") {
          let c = rd(e, "-->", i + 4, "Comment is not closed.");
          if (this.options.commentPropName) {
            let d = e.substring(i + 4, c - 2);
            (o = this.saveTextToParentTag(o, r, n)),
              r.add(this.options.commentPropName, [
                { [this.options.textNodeName]: d },
              ]);
          }
          i = c;
        } else if (e.substr(i + 1, 2) === "!D") {
          let c = WZe(e, i);
          (this.docTypeEntities = c.entities), (i = c.i);
        } else if (e.substr(i + 1, 2) === "![") {
          let c = rd(e, "]]>", i, "CDATA is not closed.") - 2,
            d = e.substring(i + 9, c);
          o = this.saveTextToParentTag(o, r, n);
          let m = this.parseTextData(d, r.tagname, n, !0, !1, !0, !0);
          m == null && (m = ""),
            this.options.cdataPropName
              ? r.add(this.options.cdataPropName, [
                  { [this.options.textNodeName]: d },
                ])
              : r.add(this.options.textNodeName, m),
            (i = c + 2);
        } else {
          let c = kD(e, i, this.options.removeNSPrefix),
            d = c.tagName,
            m = c.rawTagName,
            f = c.tagExp,
            l = c.attrExpPresent,
            u = c.closeIndex;
          this.options.transformTagName &&
            (d = this.options.transformTagName(d)),
            r &&
              o &&
              r.tagname !== "!xml" &&
              (o = this.saveTextToParentTag(o, r, n, !1));
          let h = r;
          if (
            (h &&
              this.options.unpairedTags.indexOf(h.tagname) !== -1 &&
              ((r = this.tagsNodeStack.pop()),
              (n = n.substring(0, n.lastIndexOf(".")))),
            d !== t.tagname && (n += n ? "." + d : d),
            this.isItStopNode(this.options.stopNodes, n, d))
          ) {
            let y = "";
            if (f.length > 0 && f.lastIndexOf("/") === f.length - 1)
              d[d.length - 1] === "/"
                ? ((d = d.substr(0, d.length - 1)),
                  (n = n.substr(0, n.length - 1)),
                  (f = d))
                : (f = f.substr(0, f.length - 1)),
                (i = c.closeIndex);
            else if (this.options.unpairedTags.indexOf(d) !== -1)
              i = c.closeIndex;
            else {
              let E = this.readStopNodeData(e, m, u + 1);
              if (!E) throw new Error(`Unexpected end of ${m}`);
              (i = E.i), (y = E.tagContent);
            }
            let S = new Xh(d);
            d !== f && l && (S[":@"] = this.buildAttributesMap(f, n, d)),
              y && (y = this.parseTextData(y, d, n, !0, l, !0, !0)),
              (n = n.substr(0, n.lastIndexOf("."))),
              S.add(this.options.textNodeName, y),
              this.addChild(r, S, n);
          } else {
            if (f.length > 0 && f.lastIndexOf("/") === f.length - 1) {
              d[d.length - 1] === "/"
                ? ((d = d.substr(0, d.length - 1)),
                  (n = n.substr(0, n.length - 1)),
                  (f = d))
                : (f = f.substr(0, f.length - 1)),
                this.options.transformTagName &&
                  (d = this.options.transformTagName(d));
              let y = new Xh(d);
              d !== f && l && (y[":@"] = this.buildAttributesMap(f, n, d)),
                this.addChild(r, y, n),
                (n = n.substr(0, n.lastIndexOf(".")));
            } else {
              let y = new Xh(d);
              this.tagsNodeStack.push(r),
                d !== f && l && (y[":@"] = this.buildAttributesMap(f, n, d)),
                this.addChild(r, y, n),
                (r = y);
            }
            (o = ""), (i = u);
          }
        }
      else o += e[i];
    return t.child;
  };
  function tet(e, t, r) {
    let o = this.options.updateTag(t.tagname, r, t[":@"]);
    o === !1 || (typeof o == "string" && (t.tagname = o), e.addChild(t));
  }
  var ret = function (e) {
    if (this.options.processEntities) {
      for (let t in this.docTypeEntities) {
        let r = this.docTypeEntities[t];
        e = e.replace(r.regx, r.val);
      }
      for (let t in this.lastEntities) {
        let r = this.lastEntities[t];
        e = e.replace(r.regex, r.val);
      }
      if (this.options.htmlEntities)
        for (let t in this.htmlEntities) {
          let r = this.htmlEntities[t];
          e = e.replace(r.regex, r.val);
        }
      e = e.replace(this.ampEntity.regex, this.ampEntity.val);
    }
    return e;
  };
  function oet(e, t, r, o) {
    return (
      e &&
        (o === void 0 && (o = Object.keys(t.child).length === 0),
        (e = this.parseTextData(
          e,
          t.tagname,
          r,
          !1,
          t[":@"] ? Object.keys(t[":@"]).length !== 0 : !1,
          o
        )),
        e !== void 0 && e !== "" && t.add(this.options.textNodeName, e),
        (e = "")),
      e
    );
  }
  function net(e, t, r) {
    let o = "*." + r;
    for (let n in e) {
      let i = e[n];
      if (o === i || t === i) return !0;
    }
    return !1;
  }
  function set(e, t, r = ">") {
    let o,
      n = "";
    for (let i = t; i < e.length; i++) {
      let a = e[i];
      if (o) a === o && (o = "");
      else if (a === '"' || a === "'") o = a;
      else if (a === r[0])
        if (r[1]) {
          if (e[i + 1] === r[1]) return { data: n, index: i };
        } else return { data: n, index: i };
      else a === "	" && (a = " ");
      n += a;
    }
  }
  function rd(e, t, r, o) {
    let n = e.indexOf(t, r);
    if (n === -1) throw new Error(o);
    return n + t.length - 1;
  }
  function kD(e, t, r, o = ">") {
    let n = set(e, t + 1, o);
    if (!n) return;
    let i = n.data,
      a = n.index,
      c = i.search(/\s/),
      d = i,
      m = !0;
    c !== -1 && ((d = i.substring(0, c)), (i = i.substring(c + 1).trimStart()));
    let f = d;
    if (r) {
      let l = d.indexOf(":");
      l !== -1 && ((d = d.substr(l + 1)), (m = d !== n.data.substr(l + 1)));
    }
    return {
      tagName: d,
      tagExp: i,
      closeIndex: a,
      attrExpPresent: m,
      rawTagName: f,
    };
  }
  function iet(e, t, r) {
    let o = r,
      n = 1;
    for (; r < e.length; r++)
      if (e[r] === "<")
        if (e[r + 1] === "/") {
          let i = rd(e, ">", r, `${t} is not closed`);
          if (e.substring(r + 2, i).trim() === t && (n--, n === 0))
            return { tagContent: e.substring(o, r), i };
          r = i;
        } else if (e[r + 1] === "?")
          r = rd(e, "?>", r + 1, "StopNode is not closed.");
        else if (e.substr(r + 1, 3) === "!--")
          r = rd(e, "-->", r + 3, "StopNode is not closed.");
        else if (e.substr(r + 1, 2) === "![")
          r = rd(e, "]]>", r, "StopNode is not closed.") - 2;
        else {
          let i = kD(e, r, ">");
          i &&
            ((i && i.tagName) === t &&
              i.tagExp[i.tagExp.length - 1] !== "/" &&
              n++,
            (r = i.closeIndex));
        }
  }
  function DD(e, t, r) {
    if (t && typeof e == "string") {
      let o = e.trim();
      return o === "true" ? !0 : o === "false" ? !1 : KZe(e, r);
    } else return wre.isExist(e) ? e : "";
  }
  Tre.exports = OD;
});
var Pre = To((Ire) => {
  "use strict";
  function aet(e, t) {
    return Rre(e, t);
  }
  function Rre(e, t, r) {
    let o,
      n = {};
    for (let i = 0; i < e.length; i++) {
      let a = e[i],
        c = cet(a),
        d = "";
      if ((r === void 0 ? (d = c) : (d = r + "." + c), c === t.textNodeName))
        o === void 0 ? (o = a[c]) : (o += "" + a[c]);
      else {
        if (c === void 0) continue;
        if (a[c]) {
          let m = Rre(a[c], t, d),
            f = met(m, t);
          a[":@"]
            ? det(m, a[":@"], d, t)
            : Object.keys(m).length === 1 &&
                m[t.textNodeName] !== void 0 &&
                !t.alwaysCreateTextNode
              ? (m = m[t.textNodeName])
              : Object.keys(m).length === 0 &&
                (t.alwaysCreateTextNode ? (m[t.textNodeName] = "") : (m = "")),
            n[c] !== void 0 && n.hasOwnProperty(c)
              ? (Array.isArray(n[c]) || (n[c] = [n[c]]), n[c].push(m))
              : t.isArray(c, d, f)
                ? (n[c] = [m])
                : (n[c] = m);
        }
      }
    }
    return (
      typeof o == "string"
        ? o.length > 0 && (n[t.textNodeName] = o)
        : o !== void 0 && (n[t.textNodeName] = o),
      n
    );
  }
  function cet(e) {
    let t = Object.keys(e);
    for (let r = 0; r < t.length; r++) {
      let o = t[r];
      if (o !== ":@") return o;
    }
  }
  function det(e, t, r, o) {
    if (t) {
      let n = Object.keys(t),
        i = n.length;
      for (let a = 0; a < i; a++) {
        let c = n[a];
        o.isArray(c, r + "." + c, !0, !0) ? (e[c] = [t[c]]) : (e[c] = t[c]);
      }
    }
  }
  function met(e, t) {
    let { textNodeName: r } = t,
      o = Object.keys(e).length;
    return !!(
      o === 0 ||
      (o === 1 && (e[r] || typeof e[r] == "boolean" || e[r] === 0))
    );
  }
  Ire.prettify = aet;
});
var Ore = To((O9t, vre) => {
  var { buildOptions: fet } = yre(),
    uet = Are(),
    { prettify: pet } = Pre(),
    het = ID(),
    ND = class {
      constructor(t) {
        (this.externalEntities = {}), (this.options = fet(t));
      }
      parse(t, r) {
        if (typeof t != "string")
          if (t.toString) t = t.toString();
          else
            throw new Error("XML data is accepted in String or Bytes[] form.");
        if (r) {
          r === !0 && (r = {});
          let i = het.validate(t, r);
          if (i !== !0) throw Error(`${i.err.msg}:${i.err.line}:${i.err.col}`);
        }
        let o = new uet(this.options);
        o.addExternalEntities(this.externalEntities);
        let n = o.parseXml(t);
        return this.options.preserveOrder || n === void 0
          ? n
          : pet(n, this.options);
      }
      addEntity(t, r) {
        if (r.indexOf("&") !== -1)
          throw new Error("Entity value can't have '&'");
        if (t.indexOf("&") !== -1 || t.indexOf(";") !== -1)
          throw new Error(
            "An entity must be set without '&' and ';'. Eg. use '#xD' for '&#xD;'"
          );
        if (r === "&")
          throw new Error("An entity with value '&' is not permitted");
        this.externalEntities[t] = r;
      }
    };
  vre.exports = ND;
});
var Mre = To((k9t, Bre) => {
  var get = `
`;
  function yet(e, t) {
    let r = "";
    return t.format && t.indentBy.length > 0 && (r = get), Dre(e, t, "", r);
  }
  function Dre(e, t, r, o) {
    let n = "",
      i = !1;
    for (let a = 0; a < e.length; a++) {
      let c = e[a],
        d = xet(c);
      if (d === void 0) continue;
      let m = "";
      if (
        (r.length === 0 ? (m = d) : (m = `${r}.${d}`), d === t.textNodeName)
      ) {
        let y = c[d];
        Eet(m, t) || ((y = t.tagValueProcessor(d, y)), (y = Nre(y, t))),
          i && (n += o),
          (n += y),
          (i = !1);
        continue;
      } else if (d === t.cdataPropName) {
        i && (n += o),
          (n += `<![CDATA[${c[d][0][t.textNodeName]}]]>`),
          (i = !1);
        continue;
      } else if (d === t.commentPropName) {
        (n += o + `<!--${c[d][0][t.textNodeName]}-->`), (i = !0);
        continue;
      } else if (d[0] === "?") {
        let y = kre(c[":@"], t),
          S = d === "?xml" ? "" : o,
          E = c[d][0][t.textNodeName];
        (E = E.length !== 0 ? " " + E : ""),
          (n += S + `<${d}${E}${y}?>`),
          (i = !0);
        continue;
      }
      let f = o;
      f !== "" && (f += t.indentBy);
      let l = kre(c[":@"], t),
        u = o + `<${d}${l}`,
        h = Dre(c[d], t, m, f);
      t.unpairedTags.indexOf(d) !== -1
        ? t.suppressUnpairedNode
          ? (n += u + ">")
          : (n += u + "/>")
        : (!h || h.length === 0) && t.suppressEmptyNode
          ? (n += u + "/>")
          : h && h.endsWith(">")
            ? (n += u + `>${h}${o}</${d}>`)
            : ((n += u + ">"),
              h && o !== "" && (h.includes("/>") || h.includes("</"))
                ? (n += o + t.indentBy + h + o)
                : (n += h),
              (n += `</${d}>`)),
        (i = !0);
    }
    return n;
  }
  function xet(e) {
    let t = Object.keys(e);
    for (let r = 0; r < t.length; r++) {
      let o = t[r];
      if (e.hasOwnProperty(o) && o !== ":@") return o;
    }
  }
  function kre(e, t) {
    let r = "";
    if (e && !t.ignoreAttributes)
      for (let o in e) {
        if (!e.hasOwnProperty(o)) continue;
        let n = t.attributeValueProcessor(o, e[o]);
        (n = Nre(n, t)),
          n === !0 && t.suppressBooleanAttributes
            ? (r += ` ${o.substr(t.attributeNamePrefix.length)}`)
            : (r += ` ${o.substr(t.attributeNamePrefix.length)}="${n}"`);
      }
    return r;
  }
  function Eet(e, t) {
    e = e.substr(0, e.length - t.textNodeName.length - 1);
    let r = e.substr(e.lastIndexOf(".") + 1);
    for (let o in t.stopNodes)
      if (t.stopNodes[o] === e || t.stopNodes[o] === "*." + r) return !0;
    return !1;
  }
  function Nre(e, t) {
    if (e && e.length > 0 && t.processEntities)
      for (let r = 0; r < t.entities.length; r++) {
        let o = t.entities[r];
        e = e.replace(o.regex, o.val);
      }
    return e;
  }
  Bre.exports = yet;
});
var Fre = To((D9t, Lre) => {
  "use strict";
  var Cet = Mre(),
    bet = {
      attributeNamePrefix: "@_",
      attributesGroupName: !1,
      textNodeName: "#text",
      ignoreAttributes: !0,
      cdataPropName: !1,
      format: !1,
      indentBy: "  ",
      suppressEmptyNode: !1,
      suppressUnpairedNode: !0,
      suppressBooleanAttributes: !0,
      tagValueProcessor: function (e, t) {
        return t;
      },
      attributeValueProcessor: function (e, t) {
        return t;
      },
      preserveOrder: !1,
      commentPropName: !1,
      unpairedTags: [],
      entities: [
        { regex: new RegExp("&", "g"), val: "&amp;" },
        { regex: new RegExp(">", "g"), val: "&gt;" },
        { regex: new RegExp("<", "g"), val: "&lt;" },
        { regex: new RegExp("'", "g"), val: "&apos;" },
        { regex: new RegExp('"', "g"), val: "&quot;" },
      ],
      processEntities: !0,
      stopNodes: [],
      oneListGroup: !1,
    };
  function Pa(e) {
    (this.options = Object.assign({}, bet, e)),
      this.options.ignoreAttributes || this.options.attributesGroupName
        ? (this.isAttribute = function () {
            return !1;
          })
        : ((this.attrPrefixLen = this.options.attributeNamePrefix.length),
          (this.isAttribute = Tet)),
      (this.processTextOrObjNode = _et),
      this.options.format
        ? ((this.indentate = wet),
          (this.tagEndChar = `>
`),
          (this.newLine = `
`))
        : ((this.indentate = function () {
            return "";
          }),
          (this.tagEndChar = ">"),
          (this.newLine = ""));
  }
  Pa.prototype.build = function (e) {
    return this.options.preserveOrder
      ? Cet(e, this.options)
      : (Array.isArray(e) &&
          this.options.arrayNodeName &&
          this.options.arrayNodeName.length > 1 &&
          (e = { [this.options.arrayNodeName]: e }),
        this.j2x(e, 0).val);
  };
  Pa.prototype.j2x = function (e, t) {
    let r = "",
      o = "";
    for (let n in e)
      if (Object.prototype.hasOwnProperty.call(e, n))
        if (typeof e[n] > "u") this.isAttribute(n) && (o += "");
        else if (e[n] === null)
          this.isAttribute(n)
            ? (o += "")
            : n[0] === "?"
              ? (o += this.indentate(t) + "<" + n + "?" + this.tagEndChar)
              : (o += this.indentate(t) + "<" + n + "/" + this.tagEndChar);
        else if (e[n] instanceof Date)
          o += this.buildTextValNode(e[n], n, "", t);
        else if (typeof e[n] != "object") {
          let i = this.isAttribute(n);
          if (i) r += this.buildAttrPairStr(i, "" + e[n]);
          else if (n === this.options.textNodeName) {
            let a = this.options.tagValueProcessor(n, "" + e[n]);
            o += this.replaceEntitiesValue(a);
          } else o += this.buildTextValNode(e[n], n, "", t);
        } else if (Array.isArray(e[n])) {
          let i = e[n].length,
            a = "",
            c = "";
          for (let d = 0; d < i; d++) {
            let m = e[n][d];
            if (!(typeof m > "u"))
              if (m === null)
                n[0] === "?"
                  ? (o += this.indentate(t) + "<" + n + "?" + this.tagEndChar)
                  : (o += this.indentate(t) + "<" + n + "/" + this.tagEndChar);
              else if (typeof m == "object")
                if (this.options.oneListGroup) {
                  let f = this.j2x(m, t + 1);
                  (a += f.val),
                    this.options.attributesGroupName &&
                      m.hasOwnProperty(this.options.attributesGroupName) &&
                      (c += f.attrStr);
                } else a += this.processTextOrObjNode(m, n, t);
              else if (this.options.oneListGroup) {
                let f = this.options.tagValueProcessor(n, m);
                (f = this.replaceEntitiesValue(f)), (a += f);
              } else a += this.buildTextValNode(m, n, "", t);
          }
          this.options.oneListGroup && (a = this.buildObjectNode(a, n, c, t)),
            (o += a);
        } else if (
          this.options.attributesGroupName &&
          n === this.options.attributesGroupName
        ) {
          let i = Object.keys(e[n]),
            a = i.length;
          for (let c = 0; c < a; c++)
            r += this.buildAttrPairStr(i[c], "" + e[n][i[c]]);
        } else o += this.processTextOrObjNode(e[n], n, t);
    return { attrStr: r, val: o };
  };
  Pa.prototype.buildAttrPairStr = function (e, t) {
    return (
      (t = this.options.attributeValueProcessor(e, "" + t)),
      (t = this.replaceEntitiesValue(t)),
      this.options.suppressBooleanAttributes && t === "true"
        ? " " + e
        : " " + e + '="' + t + '"'
    );
  };
  function _et(e, t, r) {
    let o = this.j2x(e, r + 1);
    return e[this.options.textNodeName] !== void 0 &&
      Object.keys(e).length === 1
      ? this.buildTextValNode(e[this.options.textNodeName], t, o.attrStr, r)
      : this.buildObjectNode(o.val, t, o.attrStr, r);
  }
  Pa.prototype.buildObjectNode = function (e, t, r, o) {
    if (e === "")
      return t[0] === "?"
        ? this.indentate(o) + "<" + t + r + "?" + this.tagEndChar
        : this.indentate(o) + "<" + t + r + this.closeTag(t) + this.tagEndChar;
    {
      let n = "</" + t + this.tagEndChar,
        i = "";
      return (
        t[0] === "?" && ((i = "?"), (n = "")),
        (r || r === "") && e.indexOf("<") === -1
          ? this.indentate(o) + "<" + t + r + i + ">" + e + n
          : this.options.commentPropName !== !1 &&
              t === this.options.commentPropName &&
              i.length === 0
            ? this.indentate(o) + `<!--${e}-->` + this.newLine
            : this.indentate(o) +
              "<" +
              t +
              r +
              i +
              this.tagEndChar +
              e +
              this.indentate(o) +
              n
      );
    }
  };
  Pa.prototype.closeTag = function (e) {
    let t = "";
    return (
      this.options.unpairedTags.indexOf(e) !== -1
        ? this.options.suppressUnpairedNode || (t = "/")
        : this.options.suppressEmptyNode
          ? (t = "/")
          : (t = `></${e}`),
      t
    );
  };
  Pa.prototype.buildTextValNode = function (e, t, r, o) {
    if (this.options.cdataPropName !== !1 && t === this.options.cdataPropName)
      return this.indentate(o) + `<![CDATA[${e}]]>` + this.newLine;
    if (
      this.options.commentPropName !== !1 &&
      t === this.options.commentPropName
    )
      return this.indentate(o) + `<!--${e}-->` + this.newLine;
    if (t[0] === "?")
      return this.indentate(o) + "<" + t + r + "?" + this.tagEndChar;
    {
      let n = this.options.tagValueProcessor(t, e);
      return (
        (n = this.replaceEntitiesValue(n)),
        n === ""
          ? this.indentate(o) + "<" + t + r + this.closeTag(t) + this.tagEndChar
          : this.indentate(o) +
            "<" +
            t +
            r +
            ">" +
            n +
            "</" +
            t +
            this.tagEndChar
      );
    }
  };
  Pa.prototype.replaceEntitiesValue = function (e) {
    if (e && e.length > 0 && this.options.processEntities)
      for (let t = 0; t < this.options.entities.length; t++) {
        let r = this.options.entities[t];
        e = e.replace(r.regex, r.val);
      }
    return e;
  };
  function wet(e) {
    return this.options.indentBy.repeat(e);
  }
  function Tet(e) {
    return e.startsWith(this.options.attributeNamePrefix) &&
      e !== this.options.textNodeName
      ? e.substr(this.attrPrefixLen)
      : !1;
  }
  Lre.exports = Pa;
});
var BD = To((N9t, Ure) => {
  "use strict";
  var Aet = ID(),
    Ret = Ore(),
    Iet = Fre();
  Ure.exports = { XMLParser: Ret, XMLValidator: Aet, XMLBuilder: Iet };
});
var Pet,
  $re = s(() => {
    Dt();
    lo();
    Cl();
    CD();
    Pet = sO(BD());
  });
var Hre = s(() => {
  Dt();
  lo();
  Kh();
});
var zre = s(() => {});
var qre,
  De,
  vE,
  jre,
  Gre = s(() => {
    Cl();
    qre = sO(BD());
    TD();
    (De = (e, t) =>
      IE(e, t).then((r) => {
        if (r.length) {
          let o = new qre.XMLParser({
            attributeNamePrefix: "",
            htmlEntities: !0,
            ignoreAttributes: !1,
            ignoreDeclaration: !0,
            parseTagValue: !1,
            trimValues: !1,
            tagValueProcessor: (d, m) =>
              m.trim() === "" &&
              m.includes(`
`)
                ? ""
                : void 0,
          });
          o.addEntity("#xD", "\r"),
            o.addEntity(
              "#10",
              `
`
            );
          let n;
          try {
            n = o.parse(r, !0);
          } catch (d) {
            throw (
              (d &&
                typeof d == "object" &&
                Object.defineProperty(d, "$responseBodyText", { value: r }),
              d)
            );
          }
          let i = "#text",
            a = Object.keys(n)[0],
            c = n[a];
          return c[i] && ((c[a] = c[i]), delete c[i]), RE(c);
        }
        return {};
      })),
      (vE = async (e, t) => {
        let r = await De(e, t);
        return (
          r.Error && (r.Error.message = r.Error.message ?? r.Error.Message), r
        );
      }),
      (jre = (e, t) => {
        if (t?.Error?.Code !== void 0) return t.Error.Code;
        if (t?.Code !== void 0) return t.Code;
        if (e.statusCode == 404) return "NotFound";
      });
  });
var Vre = s(() => {});
var Wre = s(() => {});
var MD = s(() => {
  Wre();
});
var Kre = s(() => {
  Vre();
  MD();
});
var Yre = s(() => {
  Kre();
  MD();
});
var Qre = s(() => {
  Yre();
  lo();
  Uo();
  Cl();
  bD();
});
var Xre = s(() => {});
var Jre = s(() => {
  Dt();
  lo();
  Kh();
});
var Zre = s(() => {
  Ate();
  sre();
  ire();
  nre();
  are();
  ore();
  tre();
  rre();
  cre();
  ere();
  zre();
  Hre();
  Jre();
  Xre();
  $re();
  Qre();
  Gre();
});
var rt = s(() => {
  xt();
  Tte();
  Zre();
});
async function eoe(e, t, r) {
  if (
    (r.request?.headers?.["smithy-protocol"] === "rpc-v2-cbor" &&
      _e(e, "PROTOCOL_RPC_V2_CBOR", "M"),
    typeof t.retryStrategy == "function")
  ) {
    let i = await t.retryStrategy();
    typeof i.acquireInitialRetryToken == "function"
      ? i.constructor?.name?.includes("Adaptive")
        ? _e(e, "RETRY_MODE_ADAPTIVE", "F")
        : _e(e, "RETRY_MODE_STANDARD", "E")
      : _e(e, "RETRY_MODE_LEGACY", "D");
  }
  if (typeof t.accountIdEndpointMode == "function") {
    let i = e.endpointV2;
    switch (
      (String(i?.url?.hostname).match(Oet) && _e(e, "ACCOUNT_ID_ENDPOINT", "O"),
      await t.accountIdEndpointMode?.())
    ) {
      case "disabled":
        _e(e, "ACCOUNT_ID_MODE_DISABLED", "Q");
        break;
      case "preferred":
        _e(e, "ACCOUNT_ID_MODE_PREFERRED", "P");
        break;
      case "required":
        _e(e, "ACCOUNT_ID_MODE_REQUIRED", "R");
        break;
    }
  }
  let n = e.__smithy_context?.selectedHttpAuthScheme?.identity;
  if (n?.$source) {
    let i = n;
    i.accountId && _e(e, "RESOLVED_ACCOUNT_ID", "T");
    for (let [a, c] of Object.entries(i.$source ?? {})) _e(e, a, c);
  }
}
var Oet,
  toe = s(() => {
    rt();
    Oet = /\d{12}\.ddb/;
  });
var LD,
  OE,
  FD,
  kE,
  roe,
  ooe,
  UD,
  noe = s(() => {
    (LD = "user-agent"),
      (OE = "x-amz-user-agent"),
      (FD = " "),
      (kE = "/"),
      (roe = /[^\!\$\%\&\'\*\+\-\.\^\_\`\|\~\d\w]/g),
      (ooe = /[^\!\$\%\&\'\*\+\-\.\^\_\`\|\~\d\w\#]/g),
      (UD = "-");
  });
function soe(e) {
  let t = "";
  for (let r in e) {
    let o = e[r];
    if (t.length + o.length + 1 <= 1024) {
      t.length ? (t += "," + o) : (t += o);
      continue;
    }
    break;
  }
  return t;
}
var ioe = s(() => {});
var ket,
  DE,
  Det,
  NE,
  aoe = s(() => {
    pE();
    pn();
    toe();
    noe();
    ioe();
    (ket = (e) => (t, r) => async (o) => {
      let { request: n } = o;
      if (!Bo.isInstance(n)) return t(o);
      let { headers: i } = n,
        a = r?.userAgent?.map(DE) || [],
        c = (await e.defaultUserAgentProvider()).map(DE);
      await eoe(r, e, o);
      let d = r;
      c.push(
        `m/${soe(Object.assign({}, r.__smithy_context?.features, d.__aws_sdk_context?.features))}`
      );
      let m = e?.customUserAgent?.map(DE) || [],
        f = await e.userAgentAppId();
      f && c.push(DE([`app/${f}`]));
      let l = vX(),
        u = (l ? [l] : []).concat([...c, ...a, ...m]).join(FD),
        h = [...c.filter((y) => y.startsWith("aws-sdk-")), ...m].join(FD);
      return (
        e.runtime !== "browser"
          ? (h && (i[OE] = i[OE] ? `${i[LD]} ${h}` : h), (i[LD] = u))
          : (i[OE] = u),
        t({ ...o, request: n })
      );
    }),
      (DE = (e) => {
        let t = e[0]
            .split(kE)
            .map((a) => a.replace(roe, UD))
            .join(kE),
          r = e[1]?.replace(ooe, UD),
          o = t.indexOf(kE),
          n = t.substring(0, o),
          i = t.substring(o + 1);
        return (
          n === "api" && (i = i.toLowerCase()),
          [n, i, r]
            .filter((a) => a && a.length > 0)
            .reduce((a, c, d) => {
              switch (d) {
                case 0:
                  return c;
                case 1:
                  return `${a}/${c}`;
                default:
                  return `${a}#${c}`;
              }
            }, "")
        );
      }),
      (Det = {
        name: "getUserAgentMiddleware",
        step: "build",
        priority: "low",
        tags: ["SET_USER_AGENT", "USER_AGENT"],
        override: !0,
      }),
      (NE = (e) => ({
        applyToStack: (t) => {
          t.add(ket(e), Det);
        },
      }));
  });
var BE = s(() => {
  xQ();
  aoe();
});
var Nt,
  coe = s(() => {
    Nt = (e, t, r) => {
      if (t in e) {
        if (e[t] === "true") return !0;
        if (e[t] === "false") return !1;
        throw new Error(
          `Cannot load ${r} "${t}". Expected "true" or "false", got ${e[t]}.`
        );
      }
    };
  });
var doe = s(() => {});
var Tt,
  moe = s(() => {
    (function (e) {
      (e.ENV = "env"), (e.CONFIG = "shared config entry");
    })(Tt || (Tt = {}));
  });
var Wn = s(() => {
  coe();
  doe();
  moe();
});
var Net,
  Bet,
  ME,
  loe = s(() => {
    Wn();
    (Net = "AWS_USE_DUALSTACK_ENDPOINT"),
      (Bet = "use_dualstack_endpoint"),
      (ME = {
        environmentVariableSelector: (e) => Nt(e, Net, Tt.ENV),
        configFileSelector: (e) => Nt(e, Bet, Tt.CONFIG),
        default: !1,
      });
  });
var Met,
  Let,
  LE,
  foe = s(() => {
    Wn();
    (Met = "AWS_USE_FIPS_ENDPOINT"),
      (Let = "use_fips_endpoint"),
      (LE = {
        environmentVariableSelector: (e) => Nt(e, Met, Tt.ENV),
        configFileSelector: (e) => Nt(e, Let, Tt.CONFIG),
        default: !1,
      });
  });
var uoe = s(() => {
  ct();
});
var poe = s(() => {});
var hoe = s(() => {
  ct();
  poe();
});
var goe = s(() => {
  loe();
  foe();
  uoe();
  hoe();
});
var Fet,
  Uet,
  bl,
  FE,
  yoe = s(() => {
    (Fet = "AWS_REGION"),
      (Uet = "region"),
      (bl = {
        environmentVariableSelector: (e) => e[Fet],
        configFileSelector: (e) => e[Uet],
        default: () => {
          throw new Error("Region is missing");
        },
      }),
      (FE = { preferredFile: "credentials" });
  });
var UE,
  $D = s(() => {
    UE = (e) =>
      typeof e == "string" && (e.startsWith("fips-") || e.endsWith("-fips"));
  });
var HD,
  xoe = s(() => {
    $D();
    HD = (e) =>
      UE(e)
        ? ["fips-aws-global", "aws-fips"].includes(e)
          ? "us-east-1"
          : e.replace(/fips-(dkr-|prod-)?|-fips/, "")
        : e;
  });
var $E,
  Eoe = s(() => {
    xoe();
    $D();
    $E = (e) => {
      let { region: t, useFipsEndpoint: r } = e;
      if (!t) throw new Error("Region is missing");
      return Object.assign(e, {
        region: async () => {
          if (typeof t == "string") return HD(t);
          let o = await t();
          return HD(o);
        },
        useFipsEndpoint: async () => {
          let o = typeof t == "string" ? t : await t();
          return UE(o)
            ? !0
            : typeof r != "function"
              ? Promise.resolve(!!r)
              : r();
        },
      });
    };
  });
var Soe = s(() => {
  yoe();
  Eoe();
});
var Coe = s(() => {});
var boe = s(() => {});
var _oe = s(() => {});
var woe = s(() => {});
var Toe = s(() => {});
var Aoe = s(() => {});
var Roe = s(() => {
  _oe();
  woe();
  Toe();
  Aoe();
});
var Ioe = s(() => {
  Coe();
  boe();
  Roe();
});
var _l = s(() => {
  goe();
  Soe();
  Ioe();
});
function $et(e) {
  return (t) => async (r) => {
    let o = r.request;
    if (Bo.isInstance(o)) {
      let { body: n, headers: i } = o;
      if (
        n &&
        Object.keys(i)
          .map((a) => a.toLowerCase())
          .indexOf(Poe) === -1
      )
        try {
          let a = e(n);
          o.headers = { ...o.headers, [Poe]: String(a) };
        } catch {}
    }
    return t({ ...r, request: o });
  };
}
var Poe,
  Het,
  HE,
  zD = s(() => {
    pn();
    Poe = "content-length";
    (Het = {
      step: "build",
      tags: ["SET_CONTENT_LENGTH", "CONTENT_LENGTH"],
      name: "contentLengthMiddleware",
      override: !0,
    }),
      (HE = (e) => ({
        applyToStack: (t) => {
          t.add($et(e.bodyLengthChecker), Het);
        },
      }));
  });
var voe,
  zet,
  qet,
  jet,
  Get,
  Vet,
  Ooe = s(() => {
    (voe = async (e) => {
      let t = e?.Bucket || "";
      if (
        (typeof e.Bucket == "string" &&
          (e.Bucket = t
            .replace(/#/g, encodeURIComponent("#"))
            .replace(/\?/g, encodeURIComponent("?"))),
        Vet(t))
      ) {
        if (e.ForcePathStyle === !0)
          throw new Error(
            "Path-style addressing cannot be used with ARN buckets"
          );
      } else
        (!Get(t) ||
          (t.indexOf(".") !== -1 && !String(e.Endpoint).startsWith("http:")) ||
          t.toLowerCase() !== t ||
          t.length < 3) &&
          (e.ForcePathStyle = !0);
      return (
        e.DisableMultiRegionAccessPoints &&
          ((e.disableMultiRegionAccessPoints = !0), (e.DisableMRAP = !0)),
        e
      );
    }),
      (zet = /^[a-z0-9][a-z0-9\.\-]{1,61}[a-z0-9]$/),
      (qet = /(\d+\.){3}\d+/),
      (jet = /\.\./),
      (Get = (e) => zet.test(e) && !qet.test(e) && !jet.test(e)),
      (Vet = (e) => {
        let [t, r, o, , , n] = e.split(":"),
          i = t === "arn" && e.split(":").length >= 6,
          a = !!(i && r && o && n);
        if (i && !a) throw new Error(`Invalid ARN: ${e} was an invalid ARN.`);
        return a;
      });
  });
var koe = s(() => {
  Ooe();
});
var Doe,
  Noe = s(() => {
    Doe = (e, t, r) => {
      let o = async () => {
        let n = r[e] ?? r[t];
        return typeof n == "function" ? n() : n;
      };
      return e === "credentialScope" || t === "CredentialScope"
        ? async () => {
            let n =
              typeof r.credentials == "function"
                ? await r.credentials()
                : r.credentials;
            return n?.credentialScope ?? n?.CredentialScope;
          }
        : e === "accountId" || t === "AccountId"
          ? async () => {
              let n =
                typeof r.credentials == "function"
                  ? await r.credentials()
                  : r.credentials;
              return n?.accountId ?? n?.AccountId;
            }
          : e === "endpoint" || t === "endpoint"
            ? async () => {
                let n = await o();
                if (n && typeof n == "object") {
                  if ("url" in n) return n.url.href;
                  if ("hostname" in n) {
                    let { protocol: i, hostname: a, port: c, path: d } = n;
                    return `${i}//${a}${c ? ":" + c : ""}${d}`;
                  }
                }
                return n;
              }
            : o;
    };
  });
function zE(e) {
  try {
    let t = new Set(Array.from(e.match(/([A-Z_]){3,}/g) ?? []));
    return (
      t.delete("CONFIG"),
      t.delete("CONFIG_PREFIX_SEPARATOR"),
      t.delete("ENV"),
      [...t].join(", ")
    );
  } catch {
    return e;
  }
}
var qD = s(() => {});
var Boe,
  Moe = s(() => {
    re();
    qD();
    Boe = (e, t) => async () => {
      try {
        let r = e(process.env, t);
        if (r === void 0) throw new Error();
        return r;
      } catch (r) {
        throw new P(r.message || `Not found in ENV: ${zE(e.toString())}`, {
          logger: t?.logger,
        });
      }
    };
  });
import { homedir as Wet } from "os";
import { sep as Ket } from "path";
var jD,
  Yet,
  va,
  wl = s(() => {
    (jD = {}),
      (Yet = () =>
        process && process.geteuid ? `${process.geteuid()}` : "DEFAULT"),
      (va = () => {
        let {
          HOME: e,
          USERPROFILE: t,
          HOMEPATH: r,
          HOMEDRIVE: o = `C:${Ket}`,
        } = process.env;
        if (e) return e;
        if (t) return t;
        if (r) return `${o}${r}`;
        let n = Yet();
        return jD[n] || (jD[n] = Wet()), jD[n];
      });
  });
var GD,
  Qet,
  Kn,
  Loe = s(() => {
    (GD = "AWS_PROFILE"),
      (Qet = "default"),
      (Kn = (e) => e.profile || process.env[GD] || Qet);
  });
import { createHash as Xet } from "crypto";
import { join as Jet } from "path";
var qE,
  VD = s(() => {
    wl();
    qE = (e) => {
      let r = Xet("sha1").update(e).digest("hex");
      return Jet(va(), ".aws", "sso", "cache", `${r}.json`);
    };
  });
import { promises as Zet } from "fs";
var ett,
  jE,
  Foe = s(() => {
    VD();
    ({ readFile: ett } = Zet),
      (jE = async (e) => {
        let t = qE(e),
          r = await ett(t, "utf8");
        return JSON.parse(r);
      });
  });
var Uoe,
  $oe = s(() => {
    Xc();
    Tl();
    Uoe = (e) =>
      Object.entries(e)
        .filter(([t]) => {
          let r = t.indexOf(Yn);
          return r === -1 ? !1 : Object.values(zi).includes(t.substring(0, r));
        })
        .reduce(
          (t, [r, o]) => {
            let n = r.indexOf(Yn),
              i = r.substring(0, n) === zi.PROFILE ? r.substring(n + 1) : r;
            return (t[i] = o), t;
          },
          { ...(e.default && { default: e.default }) }
        );
  });
import { join as ttt } from "path";
var rtt,
  GE,
  WD = s(() => {
    wl();
    (rtt = "AWS_CONFIG_FILE"),
      (GE = () => process.env[rtt] || ttt(va(), ".aws", "config"));
  });
import { join as ott } from "path";
var ntt,
  Hoe,
  zoe = s(() => {
    wl();
    (ntt = "AWS_SHARED_CREDENTIALS_FILE"),
      (Hoe = () => process.env[ntt] || ott(va(), ".aws", "credentials"));
  });
var stt,
  itt,
  Jh,
  KD = s(() => {
    Xc();
    Tl();
    (stt = /^([\w-]+)\s(["'])?([\w-@\+\.%:/]+)\2$/),
      (itt = ["__proto__", "profile __proto__"]),
      (Jh = (e) => {
        let t = {},
          r,
          o;
        for (let n of e.split(/\r?\n/)) {
          let i = n.split(/(^|\s)[;#]/)[0].trim();
          if (i[0] === "[" && i[i.length - 1] === "]") {
            (r = void 0), (o = void 0);
            let c = i.substring(1, i.length - 1),
              d = stt.exec(c);
            if (d) {
              let [, m, , f] = d;
              Object.values(zi).includes(m) && (r = [m, f].join(Yn));
            } else r = c;
            if (itt.includes(c))
              throw new Error(`Found invalid profile name "${c}"`);
          } else if (r) {
            let c = i.indexOf("=");
            if (![0, -1].includes(c)) {
              let [d, m] = [
                i.substring(0, c).trim(),
                i.substring(c + 1).trim(),
              ];
              if (m === "") o = d;
              else {
                o && n.trimStart() === n && (o = void 0), (t[r] = t[r] || {});
                let f = o ? [o, d].join(Yn) : d;
                t[r][f] = m;
              }
            }
          }
        }
        return t;
      });
  });
import { promises as att } from "fs";
var ctt,
  YD,
  Zh,
  QD = s(() => {
    ({ readFile: ctt } = att),
      (YD = {}),
      (Zh = (e, t) => (
        (!YD[e] || t?.ignoreCache) && (YD[e] = ctt(e, "utf8")), YD[e]
      ));
  });
import { join as qoe } from "path";
var joe,
  Yn,
  VE,
  Tl = s(() => {
    $oe();
    WD();
    zoe();
    wl();
    KD();
    QD();
    (joe = () => ({})),
      (Yn = "."),
      (VE = async (e = {}) => {
        let { filepath: t = Hoe(), configFilepath: r = GE() } = e,
          o = va(),
          n = "~/",
          i = t;
        t.startsWith(n) && (i = qoe(o, t.slice(2)));
        let a = r;
        r.startsWith(n) && (a = qoe(o, r.slice(2)));
        let c = await Promise.all([
          Zh(a, { ignoreCache: e.ignoreCache }).then(Jh).then(Uoe).catch(joe),
          Zh(i, { ignoreCache: e.ignoreCache }).then(Jh).catch(joe),
        ]);
        return { configFile: c[0], credentialsFile: c[1] };
      });
  });
var Goe,
  Voe = s(() => {
    Xc();
    Tl();
    Goe = (e) =>
      Object.entries(e)
        .filter(([t]) => t.startsWith(zi.SSO_SESSION + Yn))
        .reduce(
          (t, [r, o]) => ({ ...t, [r.substring(r.indexOf(Yn) + 1)]: o }),
          {}
        );
  });
var dtt,
  WE,
  Woe = s(() => {
    WD();
    Voe();
    KD();
    QD();
    (dtt = () => ({})),
      (WE = async (e = {}) =>
        Zh(e.configFilepath ?? GE())
          .then(Jh)
          .then(Goe)
          .catch(dtt));
  });
var Koe,
  Yoe = s(() => {
    Koe = (...e) => {
      let t = {};
      for (let r of e)
        for (let [o, n] of Object.entries(r))
          t[o] !== void 0 ? Object.assign(t[o], n) : (t[o] = n);
      return t;
    };
  });
var Oa,
  Qoe = s(() => {
    Tl();
    Yoe();
    Oa = async (e) => {
      let t = await VE(e);
      return Koe(t.configFile, t.credentialsFile);
    };
  });
var Xoe = s(() => {});
var Ls = s(() => {
  wl();
  Loe();
  VD();
  Foe();
  Tl();
  Woe();
  Qoe();
  Xoe();
});
var Joe,
  Zoe = s(() => {
    re();
    Ls();
    qD();
    Joe =
      (e, { preferredFile: t = "config", ...r } = {}) =>
      async () => {
        let o = Kn(r),
          { configFile: n, credentialsFile: i } = await VE(r),
          a = i[o] || {},
          c = n[o] || {},
          d = t === "config" ? { ...a, ...c } : { ...c, ...a };
        try {
          let f = e(d, t === "config" ? n : i);
          if (f === void 0) throw new Error();
          return f;
        } catch (m) {
          throw new P(
            m.message ||
              `Not found in config files w/ profile [${o}]: ${zE(e.toString())}`,
            { logger: r.logger }
          );
        }
      };
  });
var mtt,
  ene,
  tne = s(() => {
    re();
    (mtt = (e) => typeof e == "function"),
      (ene = (e) => (mtt(e) ? async () => await e() : Ra(e)));
  });
var Wt,
  rne = s(() => {
    re();
    Moe();
    Zoe();
    tne();
    Wt = (
      { environmentVariableSelector: e, configFileSelector: t, default: r },
      o = {}
    ) => {
      let { signingName: n, logger: i } = o;
      return gr(Ht(Boe(e, { signingName: n, logger: i }), Joe(t, o), ene(r)));
    };
  });
var od = s(() => {
  rne();
});
var one,
  nne,
  sne,
  ine = s(() => {
    Ls();
    (one = "AWS_ENDPOINT_URL"),
      (nne = "endpoint_url"),
      (sne = (e) => ({
        environmentVariableSelector: (t) => {
          let r = e.split(" ").map((i) => i.toUpperCase()),
            o = t[[one, ...r].join("_")];
          if (o) return o;
          let n = t[one];
          if (n) return n;
        },
        configFileSelector: (t, r) => {
          if (r && t.services) {
            let n = r[["services", t.services].join(Yn)];
            if (n) {
              let i = e.split(" ").map((c) => c.toLowerCase()),
                a = n[[i.join("_"), nne].join(Yn)];
              if (a) return a;
            }
          }
          let o = t[nne];
          if (o) return o;
        },
        default: void 0,
      }));
  });
var KE,
  XD = s(() => {
    od();
    ine();
    KE = async (e) => Wt(sne(e ?? ""))();
  });
function ane(e) {
  let t = {};
  if (((e = e.replace(/^\?/, "")), e))
    for (let r of e.split("&")) {
      let [o, n = null] = r.split("=");
      (o = decodeURIComponent(o)),
        n && (n = decodeURIComponent(n)),
        o in t
          ? Array.isArray(t[o])
            ? t[o].push(n)
            : (t[o] = [t[o], n])
          : (t[o] = n);
    }
  return t;
}
var cne = s(() => {});
var ii,
  eg = s(() => {
    cne();
    ii = (e) => {
      if (typeof e == "string") return ii(new URL(e));
      let { hostname: t, pathname: r, port: o, protocol: n, search: i } = e,
        a;
      return (
        i && (a = ane(i)),
        {
          hostname: t,
          port: o ? parseInt(o) : void 0,
          protocol: n,
          path: r,
          query: a,
        }
      );
    };
  });
var YE,
  QE = s(() => {
    eg();
    YE = (e) => (typeof e == "object" ? ("url" in e ? ii(e.url) : e) : ii(e));
  });
var dne,
  ltt,
  JD = s(() => {
    koe();
    Noe();
    XD();
    QE();
    (dne = async (e, t, r, o) => {
      if (!r.endpoint) {
        let a;
        r.serviceConfiguredEndpoint
          ? (a = await r.serviceConfiguredEndpoint())
          : (a = await KE(r.serviceId)),
          a && (r.endpoint = () => Promise.resolve(YE(a)));
      }
      let n = await ltt(e, t, r);
      if (typeof r.endpointProvider != "function")
        throw new Error("config.endpointProvider is not set.");
      return r.endpointProvider(n, o);
    }),
      (ltt = async (e, t, r) => {
        let o = {},
          n = t?.getEndpointParameterInstructions?.() || {};
        for (let [i, a] of Object.entries(n))
          switch (a.type) {
            case "staticContextParams":
              o[i] = a.value;
              break;
            case "contextParams":
              o[i] = e[a.name];
              break;
            case "clientContextParams":
            case "builtInParams":
              o[i] = await Doe(a.name, i, r)();
              break;
            case "operationContextParams":
              o[i] = a.get(e);
              break;
            default:
              throw new Error(
                "Unrecognized endpoint parameter instruction: " +
                  JSON.stringify(a)
              );
          }
        return (
          Object.keys(n).length === 0 && Object.assign(o, r),
          String(r.serviceId).toLowerCase() === "s3" && (await voe(o)),
          o
        );
      });
  });
var mne = s(() => {
  JD();
  QE();
});
var lne,
  ZD = s(() => {
    Ue();
    ct();
    JD();
    lne =
      ({ config: e, instructions: t }) =>
      (r, o) =>
      async (n) => {
        e.endpoint && Ta(o, "ENDPOINT_OVERRIDE", "N");
        let i = await dne(
          n.input,
          {
            getEndpointParameterInstructions() {
              return t;
            },
          },
          { ...e },
          o
        );
        (o.endpointV2 = i), (o.authSchemes = i.properties?.authSchemes);
        let a = o.authSchemes?.[0];
        if (a) {
          (o.signing_region = a.signingRegion),
            (o.signing_service = a.signingName);
          let d = bt(o)?.selectedHttpAuthScheme?.httpAuthOption;
          d &&
            (d.signingProperties = Object.assign(
              d.signingProperties || {},
              {
                signing_region: a.signingRegion,
                signingRegion: a.signingRegion,
                signing_service: a.signingName,
                signingName: a.signingName,
                signingRegionSet: a.signingRegionSet,
              },
              a.properties
            ));
        }
        return r({ ...n });
      };
  });
var fne,
  eN,
  tN = s(() => {
    pn();
    (fne = (e, t) => (r, o) => async (n) => {
      let { response: i } = await r(n);
      try {
        let a = await t(i, e);
        return { response: i, output: a };
      } catch (a) {
        if (
          (Object.defineProperty(a, "$response", { value: i }),
          !("$metadata" in a))
        ) {
          let c =
            "Deserialization error: to see the raw response, inspect the hidden field {error}.$response on this object.";
          try {
            a.message +=
              `
  ` + c;
          } catch {
            !o.logger || o.logger?.constructor?.name === "NoOpLogger"
              ? console.warn(c)
              : o.logger?.warn?.(c);
          }
          typeof a.$responseBodyText < "u" &&
            a.$response &&
            (a.$response.body = a.$responseBodyText);
          try {
            if (ri.isInstance(i)) {
              let { headers: d = {} } = i,
                m = Object.entries(d);
              a.$metadata = {
                httpStatusCode: i.statusCode,
                requestId: eN(/^x-[\w-]+-request-?id$/, m),
                extendedRequestId: eN(/^x-[\w-]+-id-2$/, m),
                cfId: eN(/^x-[\w-]+-cf-id$/, m),
              };
            }
          } catch {}
        }
        throw a;
      }
    }),
      (eN = (e, t) => (t.find(([r]) => r.match(e)) || [void 0, void 0])[1]);
  });
var une,
  rN = s(() => {
    une = (e, t) => (r, o) => async (n) => {
      let i = e,
        a =
          o.endpointV2?.url && i.urlParser
            ? async () => i.urlParser(o.endpointV2.url)
            : i.endpoint;
      if (!a) throw new Error("No valid endpoint provider available.");
      let c = await t(n.input, { ...e, endpoint: a });
      return r({ ...n, request: c });
    };
  });
function z(e, t, r) {
  return {
    applyToStack: (o) => {
      o.add(fne(e, r), ftt), o.add(une(e, t), oN);
    },
  };
}
var ftt,
  oN,
  pne = s(() => {
    tN();
    rN();
    (ftt = {
      name: "deserializerMiddleware",
      step: "deserialize",
      tags: ["DESERIALIZER"],
      override: !0,
    }),
      (oN = {
        name: "serializerMiddleware",
        step: "serialize",
        tags: ["SERIALIZER"],
        override: !0,
      });
  });
var xe = s(() => {
  tN();
  pne();
  rN();
});
var utt,
  q,
  hne = s(() => {
    xe();
    ZD();
    (utt = {
      step: "serialize",
      tags: ["ENDPOINT_PARAMETERS", "ENDPOINT_V2", "ENDPOINT"],
      name: "endpointV2Middleware",
      override: !0,
      relation: "before",
      toMiddleware: oN.name,
    }),
      (q = (e, t) => ({
        applyToStack: (r) => {
          r.addRelativeTo(lne({ config: e, instructions: t }), utt);
        },
      }));
  });
var XE,
  gne = s(() => {
    ct();
    XD();
    QE();
    XE = (e) => {
      let t = e.tls ?? !0,
        { endpoint: r, useDualstackEndpoint: o, useFipsEndpoint: n } = e,
        i = r != null ? async () => YE(await pe(r)()) : void 0,
        c = Object.assign(e, {
          endpoint: i,
          tls: t,
          isCustomEndpoint: !!r,
          useDualstackEndpoint: pe(o ?? !1),
          useFipsEndpoint: pe(n ?? !1),
        }),
        d;
      return (
        (c.serviceConfiguredEndpoint = async () => (
          e.serviceId && !d && (d = KE(e.serviceId)), d
        )),
        c
      );
    };
  });
var yne = s(() => {});
var xne = s(() => {});
var ye = s(() => {
  mne();
  ZD();
  hne();
  gne();
  yne();
  xne();
});
var Fs,
  nd,
  Al,
  JE = s(() => {
    (function (e) {
      (e.STANDARD = "standard"), (e.ADAPTIVE = "adaptive");
    })(Fs || (Fs = {}));
    (nd = 3), (Al = Fs.STANDARD);
  });
var Ene,
  Sne,
  Cne,
  bne,
  _ne,
  wne = s(() => {
    (Ene = [
      "BandwidthLimitExceeded",
      "EC2ThrottledException",
      "LimitExceededException",
      "PriorRequestNotComplete",
      "ProvisionedThroughputExceededException",
      "RequestLimitExceeded",
      "RequestThrottled",
      "RequestThrottledException",
      "SlowDown",
      "ThrottledException",
      "Throttling",
      "ThrottlingException",
      "TooManyRequestsException",
      "TransactionInProgressException",
    ]),
      (Sne = ["TimeoutError", "RequestTimeout", "RequestTimeoutException"]),
      (Cne = [500, 502, 503, 504]),
      (bne = ["ECONNRESET", "ECONNREFUSED", "EPIPE", "ETIMEDOUT"]),
      (_ne = ["EHOSTUNREACH", "ENETUNREACH", "ENOTFOUND"]);
  });
var ptt,
  htt,
  Rl,
  tg,
  Tne,
  rg = s(() => {
    wne();
    (ptt = (e) => e.$metadata?.clockSkewCorrected),
      (htt = (e) => {
        let t = new Set([
          "Failed to fetch",
          "NetworkError when attempting to fetch resource",
          "The Internet connection appears to be offline",
          "Load failed",
          "Network request failed",
        ]);
        return e && e instanceof TypeError ? t.has(e.message) : !1;
      }),
      (Rl = (e) =>
        e.$metadata?.httpStatusCode === 429 ||
        Ene.includes(e.name) ||
        e.$retryable?.throttling == !0),
      (tg = (e, t = 0) =>
        ptt(e) ||
        Sne.includes(e.name) ||
        bne.includes(e?.code || "") ||
        _ne.includes(e?.code || "") ||
        Cne.includes(e.$metadata?.httpStatusCode || 0) ||
        htt(e) ||
        (e.cause !== void 0 && t <= 10 && tg(e.cause, t + 1))),
      (Tne = (e) => {
        if (e.$metadata?.httpStatusCode !== void 0) {
          let t = e.$metadata.httpStatusCode;
          return 500 <= t && t <= 599 && !tg(e);
        }
        return !1;
      });
  });
var Il,
  nN = s(() => {
    rg();
    Il = class e {
      constructor(t) {
        (this.currentCapacity = 0),
          (this.enabled = !1),
          (this.lastMaxRate = 0),
          (this.measuredTxRate = 0),
          (this.requestCount = 0),
          (this.lastTimestamp = 0),
          (this.timeWindow = 0),
          (this.beta = t?.beta ?? 0.7),
          (this.minCapacity = t?.minCapacity ?? 1),
          (this.minFillRate = t?.minFillRate ?? 0.5),
          (this.scaleConstant = t?.scaleConstant ?? 0.4),
          (this.smooth = t?.smooth ?? 0.8);
        let r = this.getCurrentTimeInSeconds();
        (this.lastThrottleTime = r),
          (this.lastTxRateBucket = Math.floor(this.getCurrentTimeInSeconds())),
          (this.fillRate = this.minFillRate),
          (this.maxCapacity = this.minCapacity);
      }
      getCurrentTimeInSeconds() {
        return Date.now() / 1e3;
      }
      async getSendToken() {
        return this.acquireTokenBucket(1);
      }
      async acquireTokenBucket(t) {
        if (this.enabled) {
          if ((this.refillTokenBucket(), t > this.currentCapacity)) {
            let r = ((t - this.currentCapacity) / this.fillRate) * 1e3;
            await new Promise((o) => e.setTimeoutFn(o, r));
          }
          this.currentCapacity = this.currentCapacity - t;
        }
      }
      refillTokenBucket() {
        let t = this.getCurrentTimeInSeconds();
        if (!this.lastTimestamp) {
          this.lastTimestamp = t;
          return;
        }
        let r = (t - this.lastTimestamp) * this.fillRate;
        (this.currentCapacity = Math.min(
          this.maxCapacity,
          this.currentCapacity + r
        )),
          (this.lastTimestamp = t);
      }
      updateClientSendingRate(t) {
        let r;
        if ((this.updateMeasuredRate(), Rl(t))) {
          let n = this.enabled
            ? Math.min(this.measuredTxRate, this.fillRate)
            : this.measuredTxRate;
          (this.lastMaxRate = n),
            this.calculateTimeWindow(),
            (this.lastThrottleTime = this.getCurrentTimeInSeconds()),
            (r = this.cubicThrottle(n)),
            this.enableTokenBucket();
        } else
          this.calculateTimeWindow(),
            (r = this.cubicSuccess(this.getCurrentTimeInSeconds()));
        let o = Math.min(r, 2 * this.measuredTxRate);
        this.updateTokenBucketRate(o);
      }
      calculateTimeWindow() {
        this.timeWindow = this.getPrecise(
          Math.pow(
            (this.lastMaxRate * (1 - this.beta)) / this.scaleConstant,
            1 / 3
          )
        );
      }
      cubicThrottle(t) {
        return this.getPrecise(t * this.beta);
      }
      cubicSuccess(t) {
        return this.getPrecise(
          this.scaleConstant *
            Math.pow(t - this.lastThrottleTime - this.timeWindow, 3) +
            this.lastMaxRate
        );
      }
      enableTokenBucket() {
        this.enabled = !0;
      }
      updateTokenBucketRate(t) {
        this.refillTokenBucket(),
          (this.fillRate = Math.max(t, this.minFillRate)),
          (this.maxCapacity = Math.max(t, this.minCapacity)),
          (this.currentCapacity = Math.min(
            this.currentCapacity,
            this.maxCapacity
          ));
      }
      updateMeasuredRate() {
        let t = this.getCurrentTimeInSeconds(),
          r = Math.floor(t * 2) / 2;
        if ((this.requestCount++, r > this.lastTxRateBucket)) {
          let o = this.requestCount / (r - this.lastTxRateBucket);
          (this.measuredTxRate = this.getPrecise(
            o * this.smooth + this.measuredTxRate * (1 - this.smooth)
          )),
            (this.requestCount = 0),
            (this.lastTxRateBucket = r);
        }
      }
      getPrecise(t) {
        return parseFloat(t.toFixed(8));
      }
    };
    Il.setTimeoutFn = setTimeout;
  });
var ZE,
  eS,
  Pl = s(() => {
    (ZE = "amz-sdk-invocation-id"), (eS = "amz-sdk-request");
  });
var Ane,
  Rne = s(() => {
    Pl();
    Ane = () => {
      let e = 100;
      return {
        computeNextBackoffDelay: (o) =>
          Math.floor(Math.min(2e4, Math.random() * 2 ** o * e)),
        setDelayBase: (o) => {
          e = o;
        },
      };
    };
  });
var sN,
  Ine = s(() => {
    Pl();
    sN = ({ retryDelay: e, retryCount: t, retryCost: r }) => ({
      getRetryCount: () => t,
      getRetryDelay: () => Math.min(2e4, e),
      getRetryCost: () => r,
    });
  });
var sd,
  rS = s(() => {
    JE();
    Pl();
    Rne();
    Ine();
    sd = class {
      constructor(t) {
        (this.maxAttempts = t),
          (this.mode = Fs.STANDARD),
          (this.capacity = 500),
          (this.retryBackoffStrategy = Ane()),
          (this.maxAttemptsProvider =
            typeof t == "function" ? t : async () => t);
      }
      async acquireInitialRetryToken(t) {
        return sN({ retryDelay: 100, retryCount: 0 });
      }
      async refreshRetryTokenForRetry(t, r) {
        let o = await this.getMaxAttempts();
        if (this.shouldRetry(t, r, o)) {
          let n = r.errorType;
          this.retryBackoffStrategy.setDelayBase(
            n === "THROTTLING" ? 500 : 100
          );
          let i = this.retryBackoffStrategy.computeNextBackoffDelay(
              t.getRetryCount()
            ),
            a = r.retryAfterHint
              ? Math.max(r.retryAfterHint.getTime() - Date.now() || 0, i)
              : i,
            c = this.getCapacityCost(n);
          return (
            (this.capacity -= c),
            sN({
              retryDelay: a,
              retryCount: t.getRetryCount() + 1,
              retryCost: c,
            })
          );
        }
        throw new Error("No retry token available");
      }
      recordSuccess(t) {
        this.capacity = Math.max(500, this.capacity + (t.getRetryCost() ?? 1));
      }
      getCapacity() {
        return this.capacity;
      }
      async getMaxAttempts() {
        try {
          return await this.maxAttemptsProvider();
        } catch {
          return (
            console.warn(
              `Max attempts provider could not resolve. Using default of ${nd}`
            ),
            nd
          );
        }
      }
      shouldRetry(t, r, o) {
        return (
          t.getRetryCount() + 1 < o &&
          this.capacity >= this.getCapacityCost(r.errorType) &&
          this.isRetryableError(r.errorType)
        );
      }
      getCapacityCost(t) {
        return t === "TRANSIENT" ? 10 : 5;
      }
      isRetryableError(t) {
        return t === "THROTTLING" || t === "TRANSIENT";
      }
    };
  });
var oS,
  Dne = s(() => {
    JE();
    nN();
    rS();
    oS = class {
      constructor(t, r) {
        (this.maxAttemptsProvider = t), (this.mode = Fs.ADAPTIVE);
        let { rateLimiter: o } = r ?? {};
        (this.rateLimiter = o ?? new Il()),
          (this.standardRetryStrategy = new sd(t));
      }
      async acquireInitialRetryToken(t) {
        return (
          await this.rateLimiter.getSendToken(),
          this.standardRetryStrategy.acquireInitialRetryToken(t)
        );
      }
      async refreshRetryTokenForRetry(t, r) {
        return (
          this.rateLimiter.updateClientSendingRate(r),
          this.standardRetryStrategy.refreshRetryTokenForRetry(t, r)
        );
      }
      recordSuccess(t) {
        this.rateLimiter.updateClientSendingRate({}),
          this.standardRetryStrategy.recordSuccess(t);
      }
    };
  });
var Nne = s(() => {
  Pl();
  rS();
});
var Bne = s(() => {});
var ai = s(() => {
  Dne();
  Nne();
  nN();
  rS();
  JE();
  Pl();
  Bne();
});
import gtt from "crypto";
function aN() {
  return (
    nS > sS.length - 16 && (gtt.randomFillSync(sS), (nS = 0)),
    sS.slice(nS, (nS += 16))
  );
}
var sS,
  nS,
  Mne = s(() => {
    (sS = new Uint8Array(256)), (nS = sS.length);
  });
function Lne(e, t = 0) {
  return (
    Ao[e[t + 0]] +
    Ao[e[t + 1]] +
    Ao[e[t + 2]] +
    Ao[e[t + 3]] +
    "-" +
    Ao[e[t + 4]] +
    Ao[e[t + 5]] +
    "-" +
    Ao[e[t + 6]] +
    Ao[e[t + 7]] +
    "-" +
    Ao[e[t + 8]] +
    Ao[e[t + 9]] +
    "-" +
    Ao[e[t + 10]] +
    Ao[e[t + 11]] +
    Ao[e[t + 12]] +
    Ao[e[t + 13]] +
    Ao[e[t + 14]] +
    Ao[e[t + 15]]
  );
}
var Ao,
  Fne = s(() => {
    Ao = [];
    for (let e = 0; e < 256; ++e) Ao.push((e + 256).toString(16).slice(1));
  });
import ytt from "crypto";
var cN,
  Une = s(() => {
    cN = { randomUUID: ytt.randomUUID };
  });
function xtt(e, t, r) {
  if (cN.randomUUID && !t && !e) return cN.randomUUID();
  e = e || {};
  let o = e.random || (e.rng || aN)();
  if (((o[6] = (o[6] & 15) | 64), (o[8] = (o[8] & 63) | 128), t)) {
    r = r || 0;
    for (let n = 0; n < 16; ++n) t[r + n] = o[n];
    return t;
  }
  return Lne(o);
}
var qo,
  $ne = s(() => {
    Une();
    Mne();
    Fne();
    qo = xtt;
  });
var id = s(() => {
  $ne();
});
var Hne = s(() => {
  ai();
});
var dN = s(() => {
  ai();
});
var mN = s(() => {
  rg();
});
var lN,
  fN = s(() => {
    lN = (e) =>
      e instanceof Error
        ? e
        : e instanceof Object
          ? Object.assign(new Error(), e)
          : typeof e == "string"
            ? new Error(e)
            : new Error(`AWS SDK error wrapper for ${e}`);
  });
var uN = s(() => {
  pn();
  rg();
  ai();
  Hne();
  dN();
  mN();
  fN();
});
var zne = s(() => {
  ai();
  uN();
});
var qne,
  jne,
  iS,
  aS,
  Ett,
  Stt,
  cS,
  Gne = s(() => {
    ct();
    ai();
    (qne = "AWS_MAX_ATTEMPTS"),
      (jne = "max_attempts"),
      (iS = {
        environmentVariableSelector: (e) => {
          let t = e[qne];
          if (!t) return;
          let r = parseInt(t);
          if (Number.isNaN(r))
            throw new Error(
              `Environment variable ${qne} mast be a number, got "${t}"`
            );
          return r;
        },
        configFileSelector: (e) => {
          let t = e[jne];
          if (!t) return;
          let r = parseInt(t);
          if (Number.isNaN(r))
            throw new Error(
              `Shared config file entry ${jne} mast be a number, got "${t}"`
            );
          return r;
        },
        default: nd,
      }),
      (aS = (e) => {
        let { retryStrategy: t, retryMode: r, maxAttempts: o } = e,
          n = pe(o ?? nd);
        return Object.assign(e, {
          maxAttempts: n,
          retryStrategy: async () =>
            t || ((await pe(r)()) === Fs.ADAPTIVE ? new oS(n) : new sd(n)),
        });
      }),
      (Ett = "AWS_RETRY_MODE"),
      (Stt = "retry_mode"),
      (cS = {
        environmentVariableSelector: (e) => e[Ett],
        configFileSelector: (e) => e[Stt],
        default: Al,
      });
  });
var Vne = s(() => {
  pn();
  ai();
});
var ad,
  ka,
  Ol,
  Wne,
  Kne,
  Yne = s(() => {
    (ad = (e, t) => {
      let r = [];
      if ((e && r.push(e), t)) for (let o of t) r.push(o);
      return r;
    }),
      (ka = (e, t) =>
        `${e || "anonymous"}${t && t.length > 0 ? ` (a.k.a. ${t.join(",")})` : ""}`),
      (Ol = () => {
        let e = [],
          t = [],
          r = !1,
          o = new Set(),
          n = (l) =>
            l.sort(
              (u, h) =>
                Wne[h.step] - Wne[u.step] ||
                Kne[h.priority || "normal"] - Kne[u.priority || "normal"]
            ),
          i = (l) => {
            let u = !1,
              h = (y) => {
                let S = ad(y.name, y.aliases);
                if (S.includes(l)) {
                  u = !0;
                  for (let E of S) o.delete(E);
                  return !1;
                }
                return !0;
              };
            return (e = e.filter(h)), (t = t.filter(h)), u;
          },
          a = (l) => {
            let u = !1,
              h = (y) => {
                if (y.middleware === l) {
                  u = !0;
                  for (let S of ad(y.name, y.aliases)) o.delete(S);
                  return !1;
                }
                return !0;
              };
            return (e = e.filter(h)), (t = t.filter(h)), u;
          },
          c = (l) => (
            e.forEach((u) => {
              l.add(u.middleware, { ...u });
            }),
            t.forEach((u) => {
              l.addRelativeTo(u.middleware, { ...u });
            }),
            l.identifyOnResolve?.(f.identifyOnResolve()),
            l
          ),
          d = (l) => {
            let u = [];
            return (
              l.before.forEach((h) => {
                h.before.length === 0 && h.after.length === 0
                  ? u.push(h)
                  : u.push(...d(h));
              }),
              u.push(l),
              l.after.reverse().forEach((h) => {
                h.before.length === 0 && h.after.length === 0
                  ? u.push(h)
                  : u.push(...d(h));
              }),
              u
            );
          },
          m = (l = !1) => {
            let u = [],
              h = [],
              y = {};
            return (
              e.forEach((E) => {
                let b = { ...E, before: [], after: [] };
                for (let v of ad(b.name, b.aliases)) y[v] = b;
                u.push(b);
              }),
              t.forEach((E) => {
                let b = { ...E, before: [], after: [] };
                for (let v of ad(b.name, b.aliases)) y[v] = b;
                h.push(b);
              }),
              h.forEach((E) => {
                if (E.toMiddleware) {
                  let b = y[E.toMiddleware];
                  if (b === void 0) {
                    if (l) return;
                    throw new Error(
                      `${E.toMiddleware} is not found when adding ${ka(E.name, E.aliases)} middleware ${E.relation} ${E.toMiddleware}`
                    );
                  }
                  E.relation === "after" && b.after.push(E),
                    E.relation === "before" && b.before.push(E);
                }
              }),
              n(u)
                .map(d)
                .reduce((E, b) => (E.push(...b), E), [])
            );
          },
          f = {
            add: (l, u = {}) => {
              let { name: h, override: y, aliases: S } = u,
                E = {
                  step: "initialize",
                  priority: "normal",
                  middleware: l,
                  ...u,
                },
                b = ad(h, S);
              if (b.length > 0) {
                if (b.some((v) => o.has(v))) {
                  if (!y)
                    throw new Error(`Duplicate middleware name '${ka(h, S)}'`);
                  for (let v of b) {
                    let I = e.findIndex(
                      (ge) =>
                        ge.name === v || ge.aliases?.some((Fe) => Fe === v)
                    );
                    if (I === -1) continue;
                    let O = e[I];
                    if (O.step !== E.step || E.priority !== O.priority)
                      throw new Error(
                        `"${ka(O.name, O.aliases)}" middleware with ${O.priority} priority in ${O.step} step cannot be overridden by "${ka(h, S)}" middleware with ${E.priority} priority in ${E.step} step.`
                      );
                    e.splice(I, 1);
                  }
                }
                for (let v of b) o.add(v);
              }
              e.push(E);
            },
            addRelativeTo: (l, u) => {
              let { name: h, override: y, aliases: S } = u,
                E = { middleware: l, ...u },
                b = ad(h, S);
              if (b.length > 0) {
                if (b.some((v) => o.has(v))) {
                  if (!y)
                    throw new Error(`Duplicate middleware name '${ka(h, S)}'`);
                  for (let v of b) {
                    let I = t.findIndex(
                      (ge) =>
                        ge.name === v || ge.aliases?.some((Fe) => Fe === v)
                    );
                    if (I === -1) continue;
                    let O = t[I];
                    if (
                      O.toMiddleware !== E.toMiddleware ||
                      O.relation !== E.relation
                    )
                      throw new Error(
                        `"${ka(O.name, O.aliases)}" middleware ${O.relation} "${O.toMiddleware}" middleware cannot be overridden by "${ka(h, S)}" middleware ${E.relation} "${E.toMiddleware}" middleware.`
                      );
                    t.splice(I, 1);
                  }
                }
                for (let v of b) o.add(v);
              }
              t.push(E);
            },
            clone: () => c(Ol()),
            use: (l) => {
              l.applyToStack(f);
            },
            remove: (l) => (typeof l == "string" ? i(l) : a(l)),
            removeByTag: (l) => {
              let u = !1,
                h = (y) => {
                  let { tags: S, name: E, aliases: b } = y;
                  if (S && S.includes(l)) {
                    let v = ad(E, b);
                    for (let I of v) o.delete(I);
                    return (u = !0), !1;
                  }
                  return !0;
                };
              return (e = e.filter(h)), (t = t.filter(h)), u;
            },
            concat: (l) => {
              let u = c(Ol());
              return (
                u.use(l),
                u.identifyOnResolve(
                  r || u.identifyOnResolve() || (l.identifyOnResolve?.() ?? !1)
                ),
                u
              );
            },
            applyToStack: c,
            identify: () =>
              m(!0).map((l) => {
                let u = l.step ?? l.relation + " " + l.toMiddleware;
                return ka(l.name, l.aliases) + " - " + u;
              }),
            identifyOnResolve(l) {
              return typeof l == "boolean" && (r = l), r;
            },
            resolve: (l, u) => {
              for (let h of m()
                .map((y) => y.middleware)
                .reverse())
                l = h(l, u);
              return r && console.log(f.identify()), l;
            },
          };
        return f;
      }),
      (Wne = {
        initialize: 5,
        serialize: 4,
        build: 3,
        finalizeRequest: 2,
        deserialize: 1,
      }),
      (Kne = { high: 3, normal: 2, low: 1 });
  });
var pN = s(() => {
  Yne();
});
var kl,
  Qne = s(() => {
    pN();
    kl = class {
      constructor(t) {
        (this.config = t), (this.middlewareStack = Ol());
      }
      send(t, r, o) {
        let n = typeof r != "function" ? r : void 0,
          i = typeof r == "function" ? r : o,
          a = n === void 0 && this.config.cacheMiddleware === !0,
          c;
        if (a) {
          this.handlers || (this.handlers = new WeakMap());
          let d = this.handlers;
          d.has(t.constructor)
            ? (c = d.get(t.constructor))
            : ((c = t.resolveMiddleware(this.middlewareStack, this.config, n)),
              d.set(t.constructor, c));
        } else
          delete this.handlers,
            (c = t.resolveMiddleware(this.middlewareStack, this.config, n));
        if (i)
          c(t)
            .then(
              (d) => i(null, d.output),
              (d) => i(d)
            )
            .catch(() => {});
        else return c(t).then((d) => d.output);
      }
      destroy() {
        this.config?.requestHandler?.destroy?.(), delete this.handlers;
      }
    };
  });
var Xne = s(() => {
  Dt();
});
var L,
  hN,
  Jne = s(() => {
    pN();
    Xc();
    (L = class {
      constructor() {
        this.middlewareStack = Ol();
      }
      static classBuilder() {
        return new hN();
      }
      resolveMiddlewareWithContext(
        t,
        r,
        o,
        {
          middlewareFn: n,
          clientName: i,
          commandName: a,
          inputFilterSensitiveLog: c,
          outputFilterSensitiveLog: d,
          smithyContext: m,
          additionalContext: f,
          CommandCtor: l,
        }
      ) {
        for (let E of n.bind(this)(l, t, r, o)) this.middlewareStack.use(E);
        let u = t.concat(this.middlewareStack),
          { logger: h } = r,
          y = {
            logger: h,
            clientName: i,
            commandName: a,
            inputFilterSensitiveLog: c,
            outputFilterSensitiveLog: d,
            [UK]: { commandInstance: this, ...m },
            ...f,
          },
          { requestHandler: S } = r;
        return u.resolve((E) => S.handle(E.request, o || {}), y);
      }
    }),
      (hN = class {
        constructor() {
          (this._init = () => {}),
            (this._ep = {}),
            (this._middlewareFn = () => []),
            (this._commandName = ""),
            (this._clientName = ""),
            (this._additionalContext = {}),
            (this._smithyContext = {}),
            (this._inputFilterSensitiveLog = (t) => t),
            (this._outputFilterSensitiveLog = (t) => t),
            (this._serializer = null),
            (this._deserializer = null);
        }
        init(t) {
          this._init = t;
        }
        ep(t) {
          return (this._ep = t), this;
        }
        m(t) {
          return (this._middlewareFn = t), this;
        }
        s(t, r, o = {}) {
          return (
            (this._smithyContext = { service: t, operation: r, ...o }), this
          );
        }
        c(t = {}) {
          return (this._additionalContext = t), this;
        }
        n(t, r) {
          return (this._clientName = t), (this._commandName = r), this;
        }
        f(t = (o) => o, r = (o) => o) {
          return (
            (this._inputFilterSensitiveLog = t),
            (this._outputFilterSensitiveLog = r),
            this
          );
        }
        ser(t) {
          return (this._serializer = t), this;
        }
        de(t) {
          return (this._deserializer = t), this;
        }
        sc(t) {
          return (
            (this._operationSchema = t),
            (this._smithyContext.operationSchema = t),
            this
          );
        }
        build() {
          let t = this,
            r;
          return (r = class extends L {
            static getEndpointParameterInstructions() {
              return t._ep;
            }
            constructor(...[o]) {
              super(),
                (this.serialize = t._serializer),
                (this.deserialize = t._deserializer),
                (this.input = o ?? {}),
                t._init(this),
                (this.schema = t._operationSchema);
            }
            resolveMiddleware(o, n, i) {
              return this.resolveMiddlewareWithContext(o, n, i, {
                CommandCtor: r,
                middlewareFn: t._middlewareFn,
                clientName: t._clientName,
                commandName: t._commandName,
                inputFilterSensitiveLog: t._inputFilterSensitiveLog,
                outputFilterSensitiveLog: t._outputFilterSensitiveLog,
                smithyContext: t._smithyContext,
                additionalContext: t._additionalContext,
              });
            }
          });
        }
      });
  });
var cd,
  Zne = s(() => {
    cd = "***SensitiveInformation***";
  });
var dS,
  ese = s(() => {
    dS = (e, t) => {
      for (let r of Object.keys(e)) {
        let o = e[r],
          n = async function (a, c, d) {
            let m = new o(a);
            if (typeof c == "function") this.send(m, c);
            else if (typeof d == "function") {
              if (typeof c != "object")
                throw new Error(`Expected http options but got ${typeof c}`);
              this.send(m, c || {}, d);
            } else return this.send(m, c);
          },
          i = (r[0].toLowerCase() + r.slice(1)).replace(/Command$/, "");
        t.prototype[i] = n;
      }
    };
  });
var Dl,
  Ye,
  gN = s(() => {
    (Dl = class e extends Error {
      constructor(t) {
        super(t.message),
          Object.setPrototypeOf(
            this,
            Object.getPrototypeOf(this).constructor.prototype
          ),
          (this.name = t.name),
          (this.$fault = t.$fault),
          (this.$metadata = t.$metadata);
      }
      static isInstance(t) {
        if (!t) return !1;
        let r = t;
        return (
          e.prototype.isPrototypeOf(r) ||
          (!!r.$fault &&
            !!r.$metadata &&
            (r.$fault === "client" || r.$fault === "server"))
        );
      }
      static [Symbol.hasInstance](t) {
        if (!t) return !1;
        let r = t;
        return this === e
          ? e.isInstance(t)
          : e.isInstance(t)
            ? r.name && this.name
              ? this.prototype.isPrototypeOf(t) || r.name === this.name
              : this.prototype.isPrototypeOf(t)
            : !1;
      }
    }),
      (Ye = (e, t = {}) => {
        Object.entries(t)
          .filter(([, o]) => o !== void 0)
          .forEach(([o, n]) => {
            (e[o] == null || e[o] === "") && (e[o] = n);
          });
        let r = e.message || e.Message || "UnknownError";
        return (e.message = r), delete e.Message, e;
      });
  });
var Ctt,
  mS,
  btt,
  tse = s(() => {
    gN();
    (Ctt = ({ output: e, parsedBody: t, exceptionCtor: r, errorCode: o }) => {
      let n = btt(e),
        i = n.httpStatusCode ? n.httpStatusCode + "" : void 0,
        a = new r({
          name: t?.code || t?.Code || o || i || "UnknownError",
          $fault: "client",
          $metadata: n,
        });
      throw Ye(a, t);
    }),
      (mS =
        (e) =>
        ({ output: t, parsedBody: r, errorCode: o }) => {
          Ctt({ output: t, parsedBody: r, exceptionCtor: e, errorCode: o });
        }),
      (btt = (e) => ({
        httpStatusCode: e.statusCode,
        requestId:
          e.headers["x-amzn-requestid"] ??
          e.headers["x-amzn-request-id"] ??
          e.headers["x-amz-request-id"],
        extendedRequestId: e.headers["x-amz-id-2"],
        cfId: e.headers["x-amz-cf-id"],
      }));
  });
var lS,
  rse = s(() => {
    lS = (e) => {
      switch (e) {
        case "standard":
          return { retryMode: "standard", connectionTimeout: 3100 };
        case "in-region":
          return { retryMode: "standard", connectionTimeout: 1100 };
        case "cross-region":
          return { retryMode: "standard", connectionTimeout: 3100 };
        case "mobile":
          return { retryMode: "standard", connectionTimeout: 3e4 };
        default:
          return {};
      }
    };
  });
var ose,
  fS,
  nse = s(() => {
    (ose = !1),
      (fS = (e) => {
        e &&
          !ose &&
          parseInt(e.substring(1, e.indexOf("."))) < 16 &&
          (ose = !0);
      });
  });
var sse = s(() => {
  Dt();
});
var ise,
  ase,
  cse = s(() => {
    Xc();
    (ise = (e) => {
      let t = [];
      for (let r in nl) {
        let o = nl[r];
        e[o] !== void 0 &&
          t.push({ algorithmId: () => o, checksumConstructor: () => e[o] });
      }
      return {
        addChecksumAlgorithm(r) {
          t.push(r);
        },
        checksumAlgorithms() {
          return t;
        },
      };
    }),
      (ase = (e) => {
        let t = {};
        return (
          e.checksumAlgorithms().forEach((r) => {
            t[r.algorithmId()] = r.checksumConstructor();
          }),
          t
        );
      });
  });
var dse,
  mse,
  lse = s(() => {
    (dse = (e) => ({
      setRetryStrategy(t) {
        e.retryStrategy = t;
      },
      retryStrategy() {
        return e.retryStrategy;
      },
    })),
      (mse = (e) => {
        let t = {};
        return (t.retryStrategy = e.retryStrategy()), t;
      });
  });
var uS,
  pS,
  fse = s(() => {
    cse();
    lse();
    (uS = (e) => Object.assign(ise(e), dse(e))),
      (pS = (e) => Object.assign(ase(e), mse(e)));
  });
var use = s(() => {
  fse();
});
var pse = s(() => {});
var hse = s(() => {});
var og,
  gse = s(() => {
    og = (e) => e != null;
  });
var Da,
  yse = s(() => {
    Da = class {
      trace() {}
      debug() {}
      info() {}
      warn() {}
      error() {}
    };
  });
function Ro(e, t, r) {
  let o, n, i;
  if (typeof t > "u" && typeof r > "u") (o = {}), (i = e);
  else {
    if (((o = e), typeof t == "function"))
      return (n = t), (i = r), _tt(o, n, i);
    i = t;
  }
  for (let a of Object.keys(i)) {
    if (!Array.isArray(i[a])) {
      o[a] = i[a];
      continue;
    }
    xse(o, null, i, a);
  }
  return o;
}
var M,
  _tt,
  xse,
  wtt,
  Ttt,
  Ese = s(() => {
    (M = (e, t) => {
      let r = {};
      for (let o in t) xse(r, e, t, o);
      return r;
    }),
      (_tt = (e, t, r) =>
        Ro(
          e,
          Object.entries(r).reduce(
            (o, [n, i]) => (
              Array.isArray(i)
                ? (o[n] = i)
                : typeof i == "function"
                  ? (o[n] = [t, i()])
                  : (o[n] = [t, i]),
              o
            ),
            {}
          )
        )),
      (xse = (e, t, r, o) => {
        if (t !== null) {
          let a = r[o];
          typeof a == "function" && (a = [, a]);
          let [c = wtt, d = Ttt, m = o] = a;
          ((typeof c == "function" && c(t[m])) ||
            (typeof c != "function" && c)) &&
            (e[o] = d(t[m]));
          return;
        }
        let [n, i] = r[o];
        if (typeof i == "function") {
          let a,
            c = n === void 0 && (a = i()) != null,
            d =
              (typeof n == "function" && !!n(void 0)) ||
              (typeof n != "function" && !!n);
          c ? (e[o] = a) : d && (e[o] = i());
        } else {
          let a = n === void 0 && i != null,
            c =
              (typeof n == "function" && !!n(i)) ||
              (typeof n != "function" && !!n);
          (a || c) && (e[o] = i);
        }
      }),
      (wtt = (e) => e != null),
      (Ttt = (e) => e);
  });
var Sse = s(() => {
  Dt();
});
var Cse,
  bse = s(() => {
    Cse = (e) => {
      if (e !== e) return "NaN";
      switch (e) {
        case 1 / 0:
          return "Infinity";
        case -1 / 0:
          return "-Infinity";
        default:
          return e;
      }
    };
  });
var D,
  _se = s(() => {
    D = (e) => {
      if (e == null) return {};
      if (Array.isArray(e)) return e.filter((t) => t != null).map(D);
      if (typeof e == "object") {
        let t = {};
        for (let r of Object.keys(e)) e[r] != null && (t[r] = D(e[r]));
        return t;
      }
      return e;
    };
  });
var ae = s(() => {
  Qne();
  Xne();
  Jne();
  Zne();
  ese();
  tse();
  rse();
  nse();
  gN();
  sse();
  use();
  pse();
  hse();
  gse();
  yse();
  Ese();
  Sse();
  bse();
  _se();
  Uo();
});
import { Readable as Att } from "stream";
var wse,
  Tse = s(() => {
    wse = (e) =>
      e?.body instanceof Att ||
      (typeof ReadableStream < "u" && e?.body instanceof ReadableStream);
  });
var Rtt,
  Itt,
  Ptt,
  vtt,
  Ott,
  hS,
  ktt,
  Ase = s(() => {
    pn();
    rg();
    ae();
    ai();
    id();
    Tse();
    fN();
    (Rtt = (e) => (t, r) => async (o) => {
      let n = await e.retryStrategy(),
        i = await e.maxAttempts();
      if (Itt(n)) {
        n = n;
        let a = await n.acquireInitialRetryToken(r.partition_id),
          c = new Error(),
          d = 0,
          m = 0,
          { request: f } = o,
          l = Bo.isInstance(f);
        for (l && (f.headers[ZE] = qo()); ; )
          try {
            l && (f.headers[eS] = `attempt=${d + 1}; max=${i}`);
            let { response: u, output: h } = await t(o);
            return (
              n.recordSuccess(a),
              (h.$metadata.attempts = d + 1),
              (h.$metadata.totalRetryDelay = m),
              { response: u, output: h }
            );
          } catch (u) {
            let h = Ptt(u);
            if (((c = lN(u)), l && wse(f)))
              throw (
                ((r.logger instanceof Da ? console : r.logger)?.warn(
                  "An error was encountered in a non-retryable streaming request."
                ),
                c)
              );
            try {
              a = await n.refreshRetryTokenForRetry(a, h);
            } catch {
              throw (
                (c.$metadata || (c.$metadata = {}),
                (c.$metadata.attempts = d + 1),
                (c.$metadata.totalRetryDelay = m),
                c)
              );
            }
            d = a.getRetryCount();
            let y = a.getRetryDelay();
            (m += y), await new Promise((S) => setTimeout(S, y));
          }
      } else
        return (
          (n = n),
          n?.mode &&
            (r.userAgent = [
              ...(r.userAgent || []),
              ["cfg/retry-mode", n.mode],
            ]),
          n.retry(t, o)
        );
    }),
      (Itt = (e) =>
        typeof e.acquireInitialRetryToken < "u" &&
        typeof e.refreshRetryTokenForRetry < "u" &&
        typeof e.recordSuccess < "u"),
      (Ptt = (e) => {
        let t = { error: e, errorType: vtt(e) },
          r = ktt(e.$response);
        return r && (t.retryAfterHint = r), t;
      }),
      (vtt = (e) =>
        Rl(e)
          ? "THROTTLING"
          : tg(e)
            ? "TRANSIENT"
            : Tne(e)
              ? "SERVER_ERROR"
              : "CLIENT_ERROR"),
      (Ott = {
        name: "retryMiddleware",
        tags: ["RETRY"],
        step: "finalizeRequest",
        priority: "high",
        override: !0,
      }),
      (hS = (e) => ({
        applyToStack: (t) => {
          t.add(Rtt(e), Ott);
        },
      })),
      (ktt = (e) => {
        if (!ri.isInstance(e)) return;
        let t = Object.keys(e.headers).find(
          (i) => i.toLowerCase() === "retry-after"
        );
        if (!t) return;
        let r = e.headers[t],
          o = Number(r);
        return Number.isNaN(o) ? new Date(r) : new Date(o * 1e3);
      });
  });
var ng = s(() => {
  zne();
  uN();
  Gne();
  dN();
  Vne();
  mN();
  Ase();
});
function Dtt(e) {
  return {
    schemeId: "aws.auth#sigv4",
    signingProperties: { name: "dynamodb", region: e.region },
    propertiesExtractor: (t, r) => ({
      signingProperties: { config: t, context: r },
    }),
  };
}
var Rse,
  Ise,
  Pse,
  yN = s(() => {
    rt();
    ct();
    Rse = async (e, t, r) => ({
      operation: bt(t).operation,
      region:
        (await pe(e.region)()) ||
        (() => {
          throw new Error(
            "expected `region` to be configured for `aws.auth#sigv4`"
          );
        })(),
    });
    (Ise = (e) => {
      let t = [];
      switch (e.operation) {
        default:
          t.push(Dtt(e));
      }
      return t;
    }),
      (Pse = (e) => {
        let t = zo(e);
        return Object.assign(t, {
          authSchemePreference: pe(e.authSchemePreference ?? []),
        });
      });
  });
var vse,
  V,
  Ce = s(() => {
    (vse = (e) =>
      Object.assign(e, {
        useDualstackEndpoint: e.useDualstackEndpoint ?? !1,
        useFipsEndpoint: e.useFipsEndpoint ?? !1,
        defaultSigningName: "dynamodb",
      })),
      (V = {
        UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
        AccountId: { type: "builtInParams", name: "accountId" },
        Endpoint: { type: "builtInParams", name: "endpoint" },
        Region: { type: "builtInParams", name: "region" },
        UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        AccountIdEndpointMode: {
          type: "builtInParams",
          name: "accountIdEndpointMode",
        },
      });
  });
var at,
  xN = s(() => {
    ae();
    at = class e extends Dl {
      constructor(t) {
        super(t), Object.setPrototypeOf(this, e.prototype);
      }
    };
  });
var gS,
  yS,
  xS,
  ES,
  SS,
  CS,
  bS,
  _S,
  wS,
  TS,
  AS,
  RS,
  IS,
  PS,
  vS,
  OS,
  kS,
  DS,
  NS,
  BS,
  MS,
  LS,
  FS,
  US,
  $S,
  HS,
  zS,
  qS,
  jS,
  GS,
  VS,
  WS,
  KS,
  YS,
  QS,
  EN = s(() => {
    xN();
    (gS = class e extends at {
      name = "BackupInUseException";
      $fault = "client";
      constructor(t) {
        super({ name: "BackupInUseException", $fault: "client", ...t }),
          Object.setPrototypeOf(this, e.prototype);
      }
    }),
      (yS = class e extends at {
        name = "BackupNotFoundException";
        $fault = "client";
        constructor(t) {
          super({ name: "BackupNotFoundException", $fault: "client", ...t }),
            Object.setPrototypeOf(this, e.prototype);
        }
      }),
      (xS = class e extends at {
        name = "InternalServerError";
        $fault = "server";
        constructor(t) {
          super({ name: "InternalServerError", $fault: "server", ...t }),
            Object.setPrototypeOf(this, e.prototype);
        }
      }),
      (ES = class e extends at {
        name = "RequestLimitExceeded";
        $fault = "client";
        constructor(t) {
          super({ name: "RequestLimitExceeded", $fault: "client", ...t }),
            Object.setPrototypeOf(this, e.prototype);
        }
      }),
      (SS = class e extends at {
        name = "InvalidEndpointException";
        $fault = "client";
        Message;
        constructor(t) {
          super({ name: "InvalidEndpointException", $fault: "client", ...t }),
            Object.setPrototypeOf(this, e.prototype),
            (this.Message = t.Message);
        }
      }),
      (CS = class e extends at {
        name = "ProvisionedThroughputExceededException";
        $fault = "client";
        constructor(t) {
          super({
            name: "ProvisionedThroughputExceededException",
            $fault: "client",
            ...t,
          }),
            Object.setPrototypeOf(this, e.prototype);
        }
      }),
      (bS = class e extends at {
        name = "ResourceNotFoundException";
        $fault = "client";
        constructor(t) {
          super({ name: "ResourceNotFoundException", $fault: "client", ...t }),
            Object.setPrototypeOf(this, e.prototype);
        }
      }),
      (_S = class e extends at {
        name = "ItemCollectionSizeLimitExceededException";
        $fault = "client";
        constructor(t) {
          super({
            name: "ItemCollectionSizeLimitExceededException",
            $fault: "client",
            ...t,
          }),
            Object.setPrototypeOf(this, e.prototype);
        }
      }),
      (wS = class e extends at {
        name = "ContinuousBackupsUnavailableException";
        $fault = "client";
        constructor(t) {
          super({
            name: "ContinuousBackupsUnavailableException",
            $fault: "client",
            ...t,
          }),
            Object.setPrototypeOf(this, e.prototype);
        }
      }),
      (TS = class e extends at {
        name = "LimitExceededException";
        $fault = "client";
        constructor(t) {
          super({ name: "LimitExceededException", $fault: "client", ...t }),
            Object.setPrototypeOf(this, e.prototype);
        }
      }),
      (AS = class e extends at {
        name = "TableInUseException";
        $fault = "client";
        constructor(t) {
          super({ name: "TableInUseException", $fault: "client", ...t }),
            Object.setPrototypeOf(this, e.prototype);
        }
      }),
      (RS = class e extends at {
        name = "TableNotFoundException";
        $fault = "client";
        constructor(t) {
          super({ name: "TableNotFoundException", $fault: "client", ...t }),
            Object.setPrototypeOf(this, e.prototype);
        }
      }),
      (IS = class e extends at {
        name = "GlobalTableAlreadyExistsException";
        $fault = "client";
        constructor(t) {
          super({
            name: "GlobalTableAlreadyExistsException",
            $fault: "client",
            ...t,
          }),
            Object.setPrototypeOf(this, e.prototype);
        }
      }),
      (PS = class e extends at {
        name = "ResourceInUseException";
        $fault = "client";
        constructor(t) {
          super({ name: "ResourceInUseException", $fault: "client", ...t }),
            Object.setPrototypeOf(this, e.prototype);
        }
      }),
      (vS = class e extends at {
        name = "ReplicatedWriteConflictException";
        $fault = "client";
        constructor(t) {
          super({
            name: "ReplicatedWriteConflictException",
            $fault: "client",
            ...t,
          }),
            Object.setPrototypeOf(this, e.prototype);
        }
      }),
      (OS = class e extends at {
        name = "TransactionConflictException";
        $fault = "client";
        constructor(t) {
          super({
            name: "TransactionConflictException",
            $fault: "client",
            ...t,
          }),
            Object.setPrototypeOf(this, e.prototype);
        }
      }),
      (kS = class e extends at {
        name = "PolicyNotFoundException";
        $fault = "client";
        constructor(t) {
          super({ name: "PolicyNotFoundException", $fault: "client", ...t }),
            Object.setPrototypeOf(this, e.prototype);
        }
      }),
      (DS = class e extends at {
        name = "ExportNotFoundException";
        $fault = "client";
        constructor(t) {
          super({ name: "ExportNotFoundException", $fault: "client", ...t }),
            Object.setPrototypeOf(this, e.prototype);
        }
      }),
      (NS = class e extends at {
        name = "GlobalTableNotFoundException";
        $fault = "client";
        constructor(t) {
          super({
            name: "GlobalTableNotFoundException",
            $fault: "client",
            ...t,
          }),
            Object.setPrototypeOf(this, e.prototype);
        }
      }),
      (BS = class e extends at {
        name = "ImportNotFoundException";
        $fault = "client";
        constructor(t) {
          super({ name: "ImportNotFoundException", $fault: "client", ...t }),
            Object.setPrototypeOf(this, e.prototype);
        }
      }),
      (MS = class e extends at {
        name = "DuplicateItemException";
        $fault = "client";
        constructor(t) {
          super({ name: "DuplicateItemException", $fault: "client", ...t }),
            Object.setPrototypeOf(this, e.prototype);
        }
      }),
      (LS = class e extends at {
        name = "IdempotentParameterMismatchException";
        $fault = "client";
        Message;
        constructor(t) {
          super({
            name: "IdempotentParameterMismatchException",
            $fault: "client",
            ...t,
          }),
            Object.setPrototypeOf(this, e.prototype),
            (this.Message = t.Message);
        }
      }),
      (FS = class e extends at {
        name = "TransactionInProgressException";
        $fault = "client";
        Message;
        constructor(t) {
          super({
            name: "TransactionInProgressException",
            $fault: "client",
            ...t,
          }),
            Object.setPrototypeOf(this, e.prototype),
            (this.Message = t.Message);
        }
      }),
      (US = class e extends at {
        name = "ExportConflictException";
        $fault = "client";
        constructor(t) {
          super({ name: "ExportConflictException", $fault: "client", ...t }),
            Object.setPrototypeOf(this, e.prototype);
        }
      }),
      ($S = class e extends at {
        name = "InvalidExportTimeException";
        $fault = "client";
        constructor(t) {
          super({ name: "InvalidExportTimeException", $fault: "client", ...t }),
            Object.setPrototypeOf(this, e.prototype);
        }
      }),
      (HS = class e extends at {
        name = "PointInTimeRecoveryUnavailableException";
        $fault = "client";
        constructor(t) {
          super({
            name: "PointInTimeRecoveryUnavailableException",
            $fault: "client",
            ...t,
          }),
            Object.setPrototypeOf(this, e.prototype);
        }
      }),
      (zS = class e extends at {
        name = "ImportConflictException";
        $fault = "client";
        constructor(t) {
          super({ name: "ImportConflictException", $fault: "client", ...t }),
            Object.setPrototypeOf(this, e.prototype);
        }
      }),
      (qS = class e extends at {
        name = "TableAlreadyExistsException";
        $fault = "client";
        constructor(t) {
          super({
            name: "TableAlreadyExistsException",
            $fault: "client",
            ...t,
          }),
            Object.setPrototypeOf(this, e.prototype);
        }
      }),
      (jS = class e extends at {
        name = "InvalidRestoreTimeException";
        $fault = "client";
        constructor(t) {
          super({
            name: "InvalidRestoreTimeException",
            $fault: "client",
            ...t,
          }),
            Object.setPrototypeOf(this, e.prototype);
        }
      }),
      (GS = class e extends at {
        name = "ReplicaAlreadyExistsException";
        $fault = "client";
        constructor(t) {
          super({
            name: "ReplicaAlreadyExistsException",
            $fault: "client",
            ...t,
          }),
            Object.setPrototypeOf(this, e.prototype);
        }
      }),
      (VS = class e extends at {
        name = "ReplicaNotFoundException";
        $fault = "client";
        constructor(t) {
          super({ name: "ReplicaNotFoundException", $fault: "client", ...t }),
            Object.setPrototypeOf(this, e.prototype);
        }
      }),
      (WS = class e extends at {
        name = "IndexNotFoundException";
        $fault = "client";
        constructor(t) {
          super({ name: "IndexNotFoundException", $fault: "client", ...t }),
            Object.setPrototypeOf(this, e.prototype);
        }
      });
    (function (e) {
      e.visit = (t, r) =>
        t.S !== void 0
          ? r.S(t.S)
          : t.N !== void 0
            ? r.N(t.N)
            : t.B !== void 0
              ? r.B(t.B)
              : t.SS !== void 0
                ? r.SS(t.SS)
                : t.NS !== void 0
                  ? r.NS(t.NS)
                  : t.BS !== void 0
                    ? r.BS(t.BS)
                    : t.M !== void 0
                      ? r.M(t.M)
                      : t.L !== void 0
                        ? r.L(t.L)
                        : t.NULL !== void 0
                          ? r.NULL(t.NULL)
                          : t.BOOL !== void 0
                            ? r.BOOL(t.BOOL)
                            : r._(t.$unknown[0], t.$unknown[1]);
    })(KS || (KS = {}));
    (YS = class e extends at {
      name = "ConditionalCheckFailedException";
      $fault = "client";
      Item;
      constructor(t) {
        super({
          name: "ConditionalCheckFailedException",
          $fault: "client",
          ...t,
        }),
          Object.setPrototypeOf(this, e.prototype),
          (this.Item = t.Item);
      }
    }),
      (QS = class e extends at {
        name = "TransactionCanceledException";
        $fault = "client";
        Message;
        CancellationReasons;
        constructor(t) {
          super({
            name: "TransactionCanceledException",
            $fault: "client",
            ...t,
          }),
            Object.setPrototypeOf(this, e.prototype),
            (this.Message = t.Message),
            (this.CancellationReasons = t.CancellationReasons);
        }
      });
  });
function Re(e) {
  return {
    "content-type": "application/x-amz-json-1.0",
    "x-amz-target": `DynamoDB_20120810.${e}`,
  };
}
var kse,
  Dse,
  Nse,
  Bse,
  Mse,
  Lse,
  Fse,
  Use,
  $se,
  Hse,
  zse,
  qse,
  jse,
  Gse,
  Vse,
  Wse,
  Kse,
  Yse,
  Qse,
  Xse,
  Jse,
  Zse,
  eie,
  tie,
  rie,
  oie,
  nie,
  sie,
  iie,
  aie,
  cie,
  die,
  mie,
  lie,
  fie,
  uie,
  pie,
  hie,
  gie,
  yie,
  xie,
  Eie,
  Sie,
  Cie,
  bie,
  _ie,
  wie,
  Tie,
  Aie,
  Rie,
  Iie,
  Pie,
  vie,
  Oie,
  kie,
  Die,
  Nie,
  Bie,
  Mie,
  Lie,
  Fie,
  Uie,
  $ie,
  Hie,
  zie,
  qie,
  jie,
  Gie,
  Vie,
  Wie,
  Kie,
  Yie,
  Qie,
  Xie,
  Jie,
  Zie,
  eae,
  tae,
  rae,
  oae,
  nae,
  sae,
  iae,
  aae,
  cae,
  dae,
  mae,
  lae,
  fae,
  uae,
  pae,
  hae,
  gae,
  yae,
  xae,
  Eae,
  Sae,
  Cae,
  bae,
  _ae,
  wae,
  Tae,
  Aae,
  Rae,
  Iae,
  Pae,
  vae,
  Oae,
  kae,
  Dae,
  Nae,
  Bae,
  Mae,
  Lae,
  Te,
  Ntt,
  Btt,
  Mtt,
  Ltt,
  Ftt,
  Utt,
  $tt,
  Htt,
  ztt,
  qtt,
  jtt,
  Gtt,
  Vtt,
  Wtt,
  Ktt,
  Ytt,
  Qtt,
  Xtt,
  Jtt,
  Ztt,
  ert,
  trt,
  rrt,
  ort,
  nrt,
  srt,
  irt,
  art,
  crt,
  drt,
  mrt,
  lrt,
  frt,
  urt,
  prt,
  Ki,
  Fae,
  hrt,
  grt,
  Ba,
  yrt,
  xrt,
  Ert,
  Srt,
  Crt,
  brt,
  _rt,
  wrt,
  Uae,
  Trt,
  Art,
  Rrt,
  Irt,
  Prt,
  vrt,
  SN,
  Ort,
  krt,
  Yi,
  $ae,
  Drt,
  Nrt,
  Brt,
  Mrt,
  Lrt,
  Frt,
  Urt,
  $rt,
  Us,
  Hrt,
  zrt,
  qrt,
  jrt,
  Grt,
  Vrt,
  Wrt,
  Krt,
  Yrt,
  CN,
  Qrt,
  Xrt,
  bN,
  Jrt,
  Zrt,
  eot,
  tot,
  rot,
  oot,
  not,
  sot,
  iot,
  aot,
  cot,
  dot,
  mot,
  lot,
  fot,
  uot,
  pot,
  hot,
  got,
  yot,
  xot,
  Eot,
  Sot,
  Cot,
  bot,
  ci,
  Nl,
  _ot,
  wot,
  Na,
  Tot,
  Hae,
  zae,
  Aot,
  Rot,
  Iot,
  Pot,
  vot,
  Oot,
  kot,
  Dot,
  Not,
  Bot,
  qae,
  Mot,
  Lot,
  Fot,
  jae,
  Uot,
  Ma,
  Bl,
  Gae,
  $ot,
  Hot,
  zot,
  qot,
  jot,
  Got,
  Vot,
  Wot,
  Kot,
  Yot,
  Qot,
  Xot,
  Jot,
  Zot,
  ent,
  tnt,
  rnt,
  ont,
  Vae,
  nnt,
  snt,
  int,
  ant,
  _N,
  cnt,
  dnt,
  Wae,
  mnt,
  lnt,
  fnt,
  XS,
  unt,
  Kae,
  pnt,
  JS,
  hnt,
  Yae,
  sg,
  gnt,
  ynt,
  xnt,
  Ent,
  Snt,
  Cnt,
  bnt,
  _nt,
  Qae,
  wnt,
  Tnt,
  Ant,
  Rnt,
  Int,
  Pnt,
  vnt,
  Xae,
  Ont,
  knt,
  Dnt,
  Nnt,
  Bnt,
  Jae,
  Mnt,
  Lnt,
  Fnt,
  Unt,
  Ose,
  $nt,
  Hnt,
  Zae,
  ece,
  wN,
  Ml,
  znt,
  qnt,
  jnt,
  Gnt,
  Vnt,
  Wnt,
  Knt,
  Ynt,
  Qnt,
  Xnt,
  Jnt,
  oe,
  Znt,
  Ae,
  be = s(() => {
    rt();
    pn();
    ae();
    id();
    xN();
    EN();
    (kse = async (e, t) => {
      let r = Re("BatchExecuteStatement"),
        o;
      return (o = JSON.stringify(xrt(e, t))), Ae(t, r, "/", void 0, o);
    }),
      (Dse = async (e, t) => {
        let r = Re("BatchGetItem"),
          o;
        return (o = JSON.stringify(Ert(e, t))), Ae(t, r, "/", void 0, o);
      }),
      (Nse = async (e, t) => {
        let r = Re("BatchWriteItem"),
          o;
        return (o = JSON.stringify(brt(e, t))), Ae(t, r, "/", void 0, o);
      }),
      (Bse = async (e, t) => {
        let r = Re("CreateBackup"),
          o;
        return (o = JSON.stringify(D(e))), Ae(t, r, "/", void 0, o);
      }),
      (Mse = async (e, t) => {
        let r = Re("CreateGlobalTable"),
          o;
        return (o = JSON.stringify(D(e))), Ae(t, r, "/", void 0, o);
      }),
      (Lse = async (e, t) => {
        let r = Re("CreateTable"),
          o;
        return (o = JSON.stringify(D(e))), Ae(t, r, "/", void 0, o);
      }),
      (Fse = async (e, t) => {
        let r = Re("DeleteBackup"),
          o;
        return (o = JSON.stringify(D(e))), Ae(t, r, "/", void 0, o);
      }),
      (Use = async (e, t) => {
        let r = Re("DeleteItem"),
          o;
        return (o = JSON.stringify(Rrt(e, t))), Ae(t, r, "/", void 0, o);
      }),
      ($se = async (e, t) => {
        let r = Re("DeleteResourcePolicy"),
          o;
        return (o = JSON.stringify(D(e))), Ae(t, r, "/", void 0, o);
      }),
      (Hse = async (e, t) => {
        let r = Re("DeleteTable"),
          o;
        return (o = JSON.stringify(D(e))), Ae(t, r, "/", void 0, o);
      }),
      (zse = async (e, t) => {
        let r = Re("DescribeBackup"),
          o;
        return (o = JSON.stringify(D(e))), Ae(t, r, "/", void 0, o);
      }),
      (qse = async (e, t) => {
        let r = Re("DescribeContinuousBackups"),
          o;
        return (o = JSON.stringify(D(e))), Ae(t, r, "/", void 0, o);
      }),
      (jse = async (e, t) => {
        let r = Re("DescribeContributorInsights"),
          o;
        return (o = JSON.stringify(D(e))), Ae(t, r, "/", void 0, o);
      }),
      (Gse = async (e, t) => {
        let r = Re("DescribeEndpoints"),
          o;
        return (o = JSON.stringify(D(e))), Ae(t, r, "/", void 0, o);
      }),
      (Vse = async (e, t) => {
        let r = Re("DescribeExport"),
          o;
        return (o = JSON.stringify(D(e))), Ae(t, r, "/", void 0, o);
      }),
      (Wse = async (e, t) => {
        let r = Re("DescribeGlobalTable"),
          o;
        return (o = JSON.stringify(D(e))), Ae(t, r, "/", void 0, o);
      }),
      (Kse = async (e, t) => {
        let r = Re("DescribeGlobalTableSettings"),
          o;
        return (o = JSON.stringify(D(e))), Ae(t, r, "/", void 0, o);
      }),
      (Yse = async (e, t) => {
        let r = Re("DescribeImport"),
          o;
        return (o = JSON.stringify(D(e))), Ae(t, r, "/", void 0, o);
      }),
      (Qse = async (e, t) => {
        let r = Re("DescribeKinesisStreamingDestination"),
          o;
        return (o = JSON.stringify(D(e))), Ae(t, r, "/", void 0, o);
      }),
      (Xse = async (e, t) => {
        let r = Re("DescribeLimits"),
          o;
        return (o = JSON.stringify(D(e))), Ae(t, r, "/", void 0, o);
      }),
      (Jse = async (e, t) => {
        let r = Re("DescribeTable"),
          o;
        return (o = JSON.stringify(D(e))), Ae(t, r, "/", void 0, o);
      }),
      (Zse = async (e, t) => {
        let r = Re("DescribeTableReplicaAutoScaling"),
          o;
        return (o = JSON.stringify(D(e))), Ae(t, r, "/", void 0, o);
      }),
      (eie = async (e, t) => {
        let r = Re("DescribeTimeToLive"),
          o;
        return (o = JSON.stringify(D(e))), Ae(t, r, "/", void 0, o);
      }),
      (tie = async (e, t) => {
        let r = Re("DisableKinesisStreamingDestination"),
          o;
        return (o = JSON.stringify(D(e))), Ae(t, r, "/", void 0, o);
      }),
      (rie = async (e, t) => {
        let r = Re("EnableKinesisStreamingDestination"),
          o;
        return (o = JSON.stringify(D(e))), Ae(t, r, "/", void 0, o);
      }),
      (oie = async (e, t) => {
        let r = Re("ExecuteStatement"),
          o;
        return (o = JSON.stringify(Prt(e, t))), Ae(t, r, "/", void 0, o);
      }),
      (nie = async (e, t) => {
        let r = Re("ExecuteTransaction"),
          o;
        return (o = JSON.stringify(vrt(e, t))), Ae(t, r, "/", void 0, o);
      }),
      (sie = async (e, t) => {
        let r = Re("ExportTableToPointInTime"),
          o;
        return (o = JSON.stringify(krt(e, t))), Ae(t, r, "/", void 0, o);
      }),
      (iie = async (e, t) => {
        let r = Re("GetItem"),
          o;
        return (o = JSON.stringify(Nrt(e, t))), Ae(t, r, "/", void 0, o);
      }),
      (aie = async (e, t) => {
        let r = Re("GetResourcePolicy"),
          o;
        return (o = JSON.stringify(D(e))), Ae(t, r, "/", void 0, o);
      }),
      (cie = async (e, t) => {
        let r = Re("ImportTable"),
          o;
        return (o = JSON.stringify(Urt(e, t))), Ae(t, r, "/", void 0, o);
      }),
      (die = async (e, t) => {
        let r = Re("ListBackups"),
          o;
        return (o = JSON.stringify(Grt(e, t))), Ae(t, r, "/", void 0, o);
      }),
      (mie = async (e, t) => {
        let r = Re("ListContributorInsights"),
          o;
        return (o = JSON.stringify(D(e))), Ae(t, r, "/", void 0, o);
      }),
      (lie = async (e, t) => {
        let r = Re("ListExports"),
          o;
        return (o = JSON.stringify(D(e))), Ae(t, r, "/", void 0, o);
      }),
      (fie = async (e, t) => {
        let r = Re("ListGlobalTables"),
          o;
        return (o = JSON.stringify(D(e))), Ae(t, r, "/", void 0, o);
      }),
      (uie = async (e, t) => {
        let r = Re("ListImports"),
          o;
        return (o = JSON.stringify(D(e))), Ae(t, r, "/", void 0, o);
      }),
      (pie = async (e, t) => {
        let r = Re("ListTables"),
          o;
        return (o = JSON.stringify(D(e))), Ae(t, r, "/", void 0, o);
      }),
      (hie = async (e, t) => {
        let r = Re("ListTagsOfResource"),
          o;
        return (o = JSON.stringify(D(e))), Ae(t, r, "/", void 0, o);
      }),
      (gie = async (e, t) => {
        let r = Re("PutItem"),
          o;
        return (o = JSON.stringify(Xrt(e, t))), Ae(t, r, "/", void 0, o);
      }),
      (yie = async (e, t) => {
        let r = Re("PutResourcePolicy"),
          o;
        return (o = JSON.stringify(D(e))), Ae(t, r, "/", void 0, o);
      }),
      (xie = async (e, t) => {
        let r = Re("Query"),
          o;
        return (o = JSON.stringify(Zrt(e, t))), Ae(t, r, "/", void 0, o);
      }),
      (Eie = async (e, t) => {
        let r = Re("RestoreTableFromBackup"),
          o;
        return (o = JSON.stringify(D(e))), Ae(t, r, "/", void 0, o);
      }),
      (Sie = async (e, t) => {
        let r = Re("RestoreTableToPointInTime"),
          o;
        return (o = JSON.stringify(cot(e, t))), Ae(t, r, "/", void 0, o);
      }),
      (Cie = async (e, t) => {
        let r = Re("Scan"),
          o;
        return (o = JSON.stringify(dot(e, t))), Ae(t, r, "/", void 0, o);
      }),
      (bie = async (e, t) => {
        let r = Re("TagResource"),
          o;
        return (o = JSON.stringify(D(e))), Ae(t, r, "/", void 0, o);
      }),
      (_ie = async (e, t) => {
        let r = Re("TransactGetItems"),
          o;
        return (o = JSON.stringify(fot(e, t))), Ae(t, r, "/", void 0, o);
      }),
      (wie = async (e, t) => {
        let r = Re("TransactWriteItems"),
          o;
        return (o = JSON.stringify(hot(e, t))), Ae(t, r, "/", void 0, o);
      }),
      (Tie = async (e, t) => {
        let r = Re("UntagResource"),
          o;
        return (o = JSON.stringify(D(e))), Ae(t, r, "/", void 0, o);
      }),
      (Aie = async (e, t) => {
        let r = Re("UpdateContinuousBackups"),
          o;
        return (o = JSON.stringify(D(e))), Ae(t, r, "/", void 0, o);
      }),
      (Rie = async (e, t) => {
        let r = Re("UpdateContributorInsights"),
          o;
        return (o = JSON.stringify(D(e))), Ae(t, r, "/", void 0, o);
      }),
      (Iie = async (e, t) => {
        let r = Re("UpdateGlobalTable"),
          o;
        return (o = JSON.stringify(D(e))), Ae(t, r, "/", void 0, o);
      }),
      (Pie = async (e, t) => {
        let r = Re("UpdateGlobalTableSettings"),
          o;
        return (o = JSON.stringify(yot(e, t))), Ae(t, r, "/", void 0, o);
      }),
      (vie = async (e, t) => {
        let r = Re("UpdateItem"),
          o;
        return (o = JSON.stringify(xot(e, t))), Ae(t, r, "/", void 0, o);
      }),
      (Oie = async (e, t) => {
        let r = Re("UpdateKinesisStreamingDestination"),
          o;
        return (o = JSON.stringify(D(e))), Ae(t, r, "/", void 0, o);
      }),
      (kie = async (e, t) => {
        let r = Re("UpdateTable"),
          o;
        return (o = JSON.stringify(D(e))), Ae(t, r, "/", void 0, o);
      }),
      (Die = async (e, t) => {
        let r = Re("UpdateTableReplicaAutoScaling"),
          o;
        return (o = JSON.stringify(Eot(e, t))), Ae(t, r, "/", void 0, o);
      }),
      (Nie = async (e, t) => {
        let r = Re("UpdateTimeToLive"),
          o;
        return (o = JSON.stringify(D(e))), Ae(t, r, "/", void 0, o);
      }),
      (Bie = async (e, t) => {
        if (e.statusCode >= 300) return Te(e, t);
        let r = await ie(e.body, t),
          o = {};
        return (o = Iot(r, t)), { $metadata: oe(e), ...o };
      }),
      (Mie = async (e, t) => {
        if (e.statusCode >= 300) return Te(e, t);
        let r = await ie(e.body, t),
          o = {};
        return (o = Pot(r, t)), { $metadata: oe(e), ...o };
      }),
      (Lie = async (e, t) => {
        if (e.statusCode >= 300) return Te(e, t);
        let r = await ie(e.body, t),
          o = {};
        return (o = Not(r, t)), { $metadata: oe(e), ...o };
      }),
      (Fie = async (e, t) => {
        if (e.statusCode >= 300) return Te(e, t);
        let r = await ie(e.body, t),
          o = {};
        return (o = $ot(r, t)), { $metadata: oe(e), ...o };
      }),
      (Uie = async (e, t) => {
        if (e.statusCode >= 300) return Te(e, t);
        let r = await ie(e.body, t),
          o = {};
        return (o = Hot(r, t)), { $metadata: oe(e), ...o };
      }),
      ($ie = async (e, t) => {
        if (e.statusCode >= 300) return Te(e, t);
        let r = await ie(e.body, t),
          o = {};
        return (o = zot(r, t)), { $metadata: oe(e), ...o };
      }),
      (Hie = async (e, t) => {
        if (e.statusCode >= 300) return Te(e, t);
        let r = await ie(e.body, t),
          o = {};
        return (o = qot(r, t)), { $metadata: oe(e), ...o };
      }),
      (zie = async (e, t) => {
        if (e.statusCode >= 300) return Te(e, t);
        let r = await ie(e.body, t),
          o = {};
        return (o = jot(r, t)), { $metadata: oe(e), ...o };
      }),
      (qie = async (e, t) => {
        if (e.statusCode >= 300) return Te(e, t);
        let r = await ie(e.body, t),
          o = {};
        return (o = D(r)), { $metadata: oe(e), ...o };
      }),
      (jie = async (e, t) => {
        if (e.statusCode >= 300) return Te(e, t);
        let r = await ie(e.body, t),
          o = {};
        return (o = Vot(r, t)), { $metadata: oe(e), ...o };
      }),
      (Gie = async (e, t) => {
        if (e.statusCode >= 300) return Te(e, t);
        let r = await ie(e.body, t),
          o = {};
        return (o = Wot(r, t)), { $metadata: oe(e), ...o };
      }),
      (Vie = async (e, t) => {
        if (e.statusCode >= 300) return Te(e, t);
        let r = await ie(e.body, t),
          o = {};
        return (o = Kot(r, t)), { $metadata: oe(e), ...o };
      }),
      (Wie = async (e, t) => {
        if (e.statusCode >= 300) return Te(e, t);
        let r = await ie(e.body, t),
          o = {};
        return (o = Yot(r, t)), { $metadata: oe(e), ...o };
      }),
      (Kie = async (e, t) => {
        if (e.statusCode >= 300) return Te(e, t);
        let r = await ie(e.body, t),
          o = {};
        return (o = D(r)), { $metadata: oe(e), ...o };
      }),
      (Yie = async (e, t) => {
        if (e.statusCode >= 300) return Te(e, t);
        let r = await ie(e.body, t),
          o = {};
        return (o = Qot(r, t)), { $metadata: oe(e), ...o };
      }),
      (Qie = async (e, t) => {
        if (e.statusCode >= 300) return Te(e, t);
        let r = await ie(e.body, t),
          o = {};
        return (o = Xot(r, t)), { $metadata: oe(e), ...o };
      }),
      (Xie = async (e, t) => {
        if (e.statusCode >= 300) return Te(e, t);
        let r = await ie(e.body, t),
          o = {};
        return (o = Jot(r, t)), { $metadata: oe(e), ...o };
      }),
      (Jie = async (e, t) => {
        if (e.statusCode >= 300) return Te(e, t);
        let r = await ie(e.body, t),
          o = {};
        return (o = Zot(r, t)), { $metadata: oe(e), ...o };
      }),
      (Zie = async (e, t) => {
        if (e.statusCode >= 300) return Te(e, t);
        let r = await ie(e.body, t),
          o = {};
        return (o = D(r)), { $metadata: oe(e), ...o };
      }),
      (eae = async (e, t) => {
        if (e.statusCode >= 300) return Te(e, t);
        let r = await ie(e.body, t),
          o = {};
        return (o = D(r)), { $metadata: oe(e), ...o };
      }),
      (tae = async (e, t) => {
        if (e.statusCode >= 300) return Te(e, t);
        let r = await ie(e.body, t),
          o = {};
        return (o = ent(r, t)), { $metadata: oe(e), ...o };
      }),
      (rae = async (e, t) => {
        if (e.statusCode >= 300) return Te(e, t);
        let r = await ie(e.body, t),
          o = {};
        return (o = tnt(r, t)), { $metadata: oe(e), ...o };
      }),
      (oae = async (e, t) => {
        if (e.statusCode >= 300) return Te(e, t);
        let r = await ie(e.body, t),
          o = {};
        return (o = D(r)), { $metadata: oe(e), ...o };
      }),
      (nae = async (e, t) => {
        if (e.statusCode >= 300) return Te(e, t);
        let r = await ie(e.body, t),
          o = {};
        return (o = D(r)), { $metadata: oe(e), ...o };
      }),
      (sae = async (e, t) => {
        if (e.statusCode >= 300) return Te(e, t);
        let r = await ie(e.body, t),
          o = {};
        return (o = D(r)), { $metadata: oe(e), ...o };
      }),
      (iae = async (e, t) => {
        if (e.statusCode >= 300) return Te(e, t);
        let r = await ie(e.body, t),
          o = {};
        return (o = rnt(r, t)), { $metadata: oe(e), ...o };
      }),
      (aae = async (e, t) => {
        if (e.statusCode >= 300) return Te(e, t);
        let r = await ie(e.body, t),
          o = {};
        return (o = ont(r, t)), { $metadata: oe(e), ...o };
      }),
      (cae = async (e, t) => {
        if (e.statusCode >= 300) return Te(e, t);
        let r = await ie(e.body, t),
          o = {};
        return (o = nnt(r, t)), { $metadata: oe(e), ...o };
      }),
      (dae = async (e, t) => {
        if (e.statusCode >= 300) return Te(e, t);
        let r = await ie(e.body, t),
          o = {};
        return (o = snt(r, t)), { $metadata: oe(e), ...o };
      }),
      (mae = async (e, t) => {
        if (e.statusCode >= 300) return Te(e, t);
        let r = await ie(e.body, t),
          o = {};
        return (o = D(r)), { $metadata: oe(e), ...o };
      }),
      (lae = async (e, t) => {
        if (e.statusCode >= 300) return Te(e, t);
        let r = await ie(e.body, t),
          o = {};
        return (o = mnt(r, t)), { $metadata: oe(e), ...o };
      }),
      (fae = async (e, t) => {
        if (e.statusCode >= 300) return Te(e, t);
        let r = await ie(e.body, t),
          o = {};
        return (o = Ent(r, t)), { $metadata: oe(e), ...o };
      }),
      (uae = async (e, t) => {
        if (e.statusCode >= 300) return Te(e, t);
        let r = await ie(e.body, t),
          o = {};
        return (o = D(r)), { $metadata: oe(e), ...o };
      }),
      (pae = async (e, t) => {
        if (e.statusCode >= 300) return Te(e, t);
        let r = await ie(e.body, t),
          o = {};
        return (o = D(r)), { $metadata: oe(e), ...o };
      }),
      (hae = async (e, t) => {
        if (e.statusCode >= 300) return Te(e, t);
        let r = await ie(e.body, t),
          o = {};
        return (o = D(r)), { $metadata: oe(e), ...o };
      }),
      (gae = async (e, t) => {
        if (e.statusCode >= 300) return Te(e, t);
        let r = await ie(e.body, t),
          o = {};
        return (o = Snt(r, t)), { $metadata: oe(e), ...o };
      }),
      (yae = async (e, t) => {
        if (e.statusCode >= 300) return Te(e, t);
        let r = await ie(e.body, t),
          o = {};
        return (o = D(r)), { $metadata: oe(e), ...o };
      }),
      (xae = async (e, t) => {
        if (e.statusCode >= 300) return Te(e, t);
        let r = await ie(e.body, t),
          o = {};
        return (o = D(r)), { $metadata: oe(e), ...o };
      }),
      (Eae = async (e, t) => {
        if (e.statusCode >= 300) return Te(e, t);
        let r = await ie(e.body, t),
          o = {};
        return (o = Tnt(r, t)), { $metadata: oe(e), ...o };
      }),
      (Sae = async (e, t) => {
        if (e.statusCode >= 300) return Te(e, t);
        let r = await ie(e.body, t),
          o = {};
        return (o = D(r)), { $metadata: oe(e), ...o };
      }),
      (Cae = async (e, t) => {
        if (e.statusCode >= 300) return Te(e, t);
        let r = await ie(e.body, t),
          o = {};
        return (o = Rnt(r, t)), { $metadata: oe(e), ...o };
      }),
      (bae = async (e, t) => {
        if (e.statusCode >= 300) return Te(e, t);
        let r = await ie(e.body, t),
          o = {};
        return (o = Lnt(r, t)), { $metadata: oe(e), ...o };
      }),
      (_ae = async (e, t) => {
        if (e.statusCode >= 300) return Te(e, t);
        let r = await ie(e.body, t),
          o = {};
        return (o = Fnt(r, t)), { $metadata: oe(e), ...o };
      }),
      (wae = async (e, t) => {
        if (e.statusCode >= 300) return Te(e, t);
        let r = await ie(e.body, t),
          o = {};
        return (o = Unt(r, t)), { $metadata: oe(e), ...o };
      }),
      (Tae = async (e, t) =>
        e.statusCode >= 300
          ? Te(e, t)
          : (await ne(e.body, t), { $metadata: oe(e) })),
      (Aae = async (e, t) => {
        if (e.statusCode >= 300) return Te(e, t);
        let r = await ie(e.body, t),
          o = {};
        return (o = znt(r, t)), { $metadata: oe(e), ...o };
      }),
      (Rae = async (e, t) => {
        if (e.statusCode >= 300) return Te(e, t);
        let r = await ie(e.body, t),
          o = {};
        return (o = jnt(r, t)), { $metadata: oe(e), ...o };
      }),
      (Iae = async (e, t) =>
        e.statusCode >= 300
          ? Te(e, t)
          : (await ne(e.body, t), { $metadata: oe(e) })),
      (Pae = async (e, t) => {
        if (e.statusCode >= 300) return Te(e, t);
        let r = await ie(e.body, t),
          o = {};
        return (o = Gnt(r, t)), { $metadata: oe(e), ...o };
      }),
      (vae = async (e, t) => {
        if (e.statusCode >= 300) return Te(e, t);
        let r = await ie(e.body, t),
          o = {};
        return (o = D(r)), { $metadata: oe(e), ...o };
      }),
      (Oae = async (e, t) => {
        if (e.statusCode >= 300) return Te(e, t);
        let r = await ie(e.body, t),
          o = {};
        return (o = Vnt(r, t)), { $metadata: oe(e), ...o };
      }),
      (kae = async (e, t) => {
        if (e.statusCode >= 300) return Te(e, t);
        let r = await ie(e.body, t),
          o = {};
        return (o = Wnt(r, t)), { $metadata: oe(e), ...o };
      }),
      (Dae = async (e, t) => {
        if (e.statusCode >= 300) return Te(e, t);
        let r = await ie(e.body, t),
          o = {};
        return (o = Knt(r, t)), { $metadata: oe(e), ...o };
      }),
      (Nae = async (e, t) => {
        if (e.statusCode >= 300) return Te(e, t);
        let r = await ie(e.body, t),
          o = {};
        return (o = D(r)), { $metadata: oe(e), ...o };
      }),
      (Bae = async (e, t) => {
        if (e.statusCode >= 300) return Te(e, t);
        let r = await ie(e.body, t),
          o = {};
        return (o = Ynt(r, t)), { $metadata: oe(e), ...o };
      }),
      (Mae = async (e, t) => {
        if (e.statusCode >= 300) return Te(e, t);
        let r = await ie(e.body, t),
          o = {};
        return (o = Qnt(r, t)), { $metadata: oe(e), ...o };
      }),
      (Lae = async (e, t) => {
        if (e.statusCode >= 300) return Te(e, t);
        let r = await ie(e.body, t),
          o = {};
        return (o = D(r)), { $metadata: oe(e), ...o };
      }),
      (Te = async (e, t) => {
        let r = { ...e, body: await Gn(e.body, t) },
          o = Vn(e, r.body);
        switch (o) {
          case "InternalServerError":
          case "com.amazonaws.dynamodb#InternalServerError":
            throw await Wtt(r, t);
          case "RequestLimitExceeded":
          case "com.amazonaws.dynamodb#RequestLimitExceeded":
            throw await srt(r, t);
          case "InvalidEndpointException":
          case "com.amazonaws.dynamodb#InvalidEndpointException":
            throw await Ktt(r, t);
          case "ProvisionedThroughputExceededException":
          case "com.amazonaws.dynamodb#ProvisionedThroughputExceededException":
            throw await trt(r, t);
          case "ResourceNotFoundException":
          case "com.amazonaws.dynamodb#ResourceNotFoundException":
            throw await art(r, t);
          case "ItemCollectionSizeLimitExceededException":
          case "com.amazonaws.dynamodb#ItemCollectionSizeLimitExceededException":
            throw await Xtt(r, t);
          case "BackupInUseException":
          case "com.amazonaws.dynamodb#BackupInUseException":
            throw await Ntt(r, t);
          case "ContinuousBackupsUnavailableException":
          case "com.amazonaws.dynamodb#ContinuousBackupsUnavailableException":
            throw await Ltt(r, t);
          case "LimitExceededException":
          case "com.amazonaws.dynamodb#LimitExceededException":
            throw await Jtt(r, t);
          case "TableInUseException":
          case "com.amazonaws.dynamodb#TableInUseException":
            throw await drt(r, t);
          case "TableNotFoundException":
          case "com.amazonaws.dynamodb#TableNotFoundException":
            throw await mrt(r, t);
          case "GlobalTableAlreadyExistsException":
          case "com.amazonaws.dynamodb#GlobalTableAlreadyExistsException":
            throw await Htt(r, t);
          case "ResourceInUseException":
          case "com.amazonaws.dynamodb#ResourceInUseException":
            throw await irt(r, t);
          case "BackupNotFoundException":
          case "com.amazonaws.dynamodb#BackupNotFoundException":
            throw await Btt(r, t);
          case "ConditionalCheckFailedException":
          case "com.amazonaws.dynamodb#ConditionalCheckFailedException":
            throw await Mtt(r, t);
          case "ReplicatedWriteConflictException":
          case "com.amazonaws.dynamodb#ReplicatedWriteConflictException":
            throw await nrt(r, t);
          case "TransactionConflictException":
          case "com.amazonaws.dynamodb#TransactionConflictException":
            throw await frt(r, t);
          case "PolicyNotFoundException":
          case "com.amazonaws.dynamodb#PolicyNotFoundException":
            throw await ert(r, t);
          case "ExportNotFoundException":
          case "com.amazonaws.dynamodb#ExportNotFoundException":
            throw await $tt(r, t);
          case "GlobalTableNotFoundException":
          case "com.amazonaws.dynamodb#GlobalTableNotFoundException":
            throw await ztt(r, t);
          case "ImportNotFoundException":
          case "com.amazonaws.dynamodb#ImportNotFoundException":
            throw await Gtt(r, t);
          case "DuplicateItemException":
          case "com.amazonaws.dynamodb#DuplicateItemException":
            throw await Ftt(r, t);
          case "IdempotentParameterMismatchException":
          case "com.amazonaws.dynamodb#IdempotentParameterMismatchException":
            throw await qtt(r, t);
          case "TransactionCanceledException":
          case "com.amazonaws.dynamodb#TransactionCanceledException":
            throw await lrt(r, t);
          case "TransactionInProgressException":
          case "com.amazonaws.dynamodb#TransactionInProgressException":
            throw await urt(r, t);
          case "ExportConflictException":
          case "com.amazonaws.dynamodb#ExportConflictException":
            throw await Utt(r, t);
          case "InvalidExportTimeException":
          case "com.amazonaws.dynamodb#InvalidExportTimeException":
            throw await Ytt(r, t);
          case "PointInTimeRecoveryUnavailableException":
          case "com.amazonaws.dynamodb#PointInTimeRecoveryUnavailableException":
            throw await Ztt(r, t);
          case "ImportConflictException":
          case "com.amazonaws.dynamodb#ImportConflictException":
            throw await jtt(r, t);
          case "TableAlreadyExistsException":
          case "com.amazonaws.dynamodb#TableAlreadyExistsException":
            throw await crt(r, t);
          case "InvalidRestoreTimeException":
          case "com.amazonaws.dynamodb#InvalidRestoreTimeException":
            throw await Qtt(r, t);
          case "ReplicaAlreadyExistsException":
          case "com.amazonaws.dynamodb#ReplicaAlreadyExistsException":
            throw await rrt(r, t);
          case "ReplicaNotFoundException":
          case "com.amazonaws.dynamodb#ReplicaNotFoundException":
            throw await ort(r, t);
          case "IndexNotFoundException":
          case "com.amazonaws.dynamodb#IndexNotFoundException":
            throw await Vtt(r, t);
          default:
            let n = r.body;
            return Znt({ output: e, parsedBody: n, errorCode: o });
        }
      }),
      (Ntt = async (e, t) => {
        let r = e.body,
          o = D(r),
          n = new gS({ $metadata: oe(e), ...o });
        return Ye(n, r);
      }),
      (Btt = async (e, t) => {
        let r = e.body,
          o = D(r),
          n = new yS({ $metadata: oe(e), ...o });
        return Ye(n, r);
      }),
      (Mtt = async (e, t) => {
        let r = e.body,
          o = Uot(r, t),
          n = new YS({ $metadata: oe(e), ...o });
        return Ye(n, r);
      }),
      (Ltt = async (e, t) => {
        let r = e.body,
          o = D(r),
          n = new wS({ $metadata: oe(e), ...o });
        return Ye(n, r);
      }),
      (Ftt = async (e, t) => {
        let r = e.body,
          o = D(r),
          n = new MS({ $metadata: oe(e), ...o });
        return Ye(n, r);
      }),
      (Utt = async (e, t) => {
        let r = e.body,
          o = D(r),
          n = new US({ $metadata: oe(e), ...o });
        return Ye(n, r);
      }),
      ($tt = async (e, t) => {
        let r = e.body,
          o = D(r),
          n = new DS({ $metadata: oe(e), ...o });
        return Ye(n, r);
      }),
      (Htt = async (e, t) => {
        let r = e.body,
          o = D(r),
          n = new IS({ $metadata: oe(e), ...o });
        return Ye(n, r);
      }),
      (ztt = async (e, t) => {
        let r = e.body,
          o = D(r),
          n = new NS({ $metadata: oe(e), ...o });
        return Ye(n, r);
      }),
      (qtt = async (e, t) => {
        let r = e.body,
          o = D(r),
          n = new LS({ $metadata: oe(e), ...o });
        return Ye(n, r);
      }),
      (jtt = async (e, t) => {
        let r = e.body,
          o = D(r),
          n = new zS({ $metadata: oe(e), ...o });
        return Ye(n, r);
      }),
      (Gtt = async (e, t) => {
        let r = e.body,
          o = D(r),
          n = new BS({ $metadata: oe(e), ...o });
        return Ye(n, r);
      }),
      (Vtt = async (e, t) => {
        let r = e.body,
          o = D(r),
          n = new WS({ $metadata: oe(e), ...o });
        return Ye(n, r);
      }),
      (Wtt = async (e, t) => {
        let r = e.body,
          o = D(r),
          n = new xS({ $metadata: oe(e), ...o });
        return Ye(n, r);
      }),
      (Ktt = async (e, t) => {
        let r = e.body,
          o = D(r),
          n = new SS({ $metadata: oe(e), ...o });
        return Ye(n, r);
      }),
      (Ytt = async (e, t) => {
        let r = e.body,
          o = D(r),
          n = new $S({ $metadata: oe(e), ...o });
        return Ye(n, r);
      }),
      (Qtt = async (e, t) => {
        let r = e.body,
          o = D(r),
          n = new jS({ $metadata: oe(e), ...o });
        return Ye(n, r);
      }),
      (Xtt = async (e, t) => {
        let r = e.body,
          o = D(r),
          n = new _S({ $metadata: oe(e), ...o });
        return Ye(n, r);
      }),
      (Jtt = async (e, t) => {
        let r = e.body,
          o = D(r),
          n = new TS({ $metadata: oe(e), ...o });
        return Ye(n, r);
      }),
      (Ztt = async (e, t) => {
        let r = e.body,
          o = D(r),
          n = new HS({ $metadata: oe(e), ...o });
        return Ye(n, r);
      }),
      (ert = async (e, t) => {
        let r = e.body,
          o = D(r),
          n = new kS({ $metadata: oe(e), ...o });
        return Ye(n, r);
      }),
      (trt = async (e, t) => {
        let r = e.body,
          o = D(r),
          n = new CS({ $metadata: oe(e), ...o });
        return Ye(n, r);
      }),
      (rrt = async (e, t) => {
        let r = e.body,
          o = D(r),
          n = new GS({ $metadata: oe(e), ...o });
        return Ye(n, r);
      }),
      (ort = async (e, t) => {
        let r = e.body,
          o = D(r),
          n = new VS({ $metadata: oe(e), ...o });
        return Ye(n, r);
      }),
      (nrt = async (e, t) => {
        let r = e.body,
          o = D(r),
          n = new vS({ $metadata: oe(e), ...o });
        return Ye(n, r);
      }),
      (srt = async (e, t) => {
        let r = e.body,
          o = D(r),
          n = new ES({ $metadata: oe(e), ...o });
        return Ye(n, r);
      }),
      (irt = async (e, t) => {
        let r = e.body,
          o = D(r),
          n = new PS({ $metadata: oe(e), ...o });
        return Ye(n, r);
      }),
      (art = async (e, t) => {
        let r = e.body,
          o = D(r),
          n = new bS({ $metadata: oe(e), ...o });
        return Ye(n, r);
      }),
      (crt = async (e, t) => {
        let r = e.body,
          o = D(r),
          n = new qS({ $metadata: oe(e), ...o });
        return Ye(n, r);
      }),
      (drt = async (e, t) => {
        let r = e.body,
          o = D(r),
          n = new AS({ $metadata: oe(e), ...o });
        return Ye(n, r);
      }),
      (mrt = async (e, t) => {
        let r = e.body,
          o = D(r),
          n = new RS({ $metadata: oe(e), ...o });
        return Ye(n, r);
      }),
      (lrt = async (e, t) => {
        let r = e.body,
          o = qnt(r, t),
          n = new QS({ $metadata: oe(e), ...o });
        return Ye(n, r);
      }),
      (frt = async (e, t) => {
        let r = e.body,
          o = D(r),
          n = new OS({ $metadata: oe(e), ...o });
        return Ye(n, r);
      }),
      (urt = async (e, t) => {
        let r = e.body,
          o = D(r),
          n = new FS({ $metadata: oe(e), ...o });
        return Ye(n, r);
      }),
      (prt = (e, t) =>
        Object.entries(e).reduce(
          (r, [o, n]) => (n === null || (r[o] = hrt(n, t)), r),
          {}
        )),
      (Ki = (e, t) =>
        KS.visit(e, {
          B: (r) => ({ B: t.base64Encoder(r) }),
          BOOL: (r) => ({ BOOL: r }),
          BS: (r) => ({ BS: wrt(r, t) }),
          L: (r) => ({ L: jrt(r, t) }),
          M: (r) => ({ M: Vrt(r, t) }),
          N: (r) => ({ N: r }),
          NS: (r) => ({ NS: D(r) }),
          NULL: (r) => ({ NULL: r }),
          S: (r) => ({ S: r }),
          SS: (r) => ({ SS: D(r) }),
          _: (r, o) => ({ [r]: o }),
        })),
      (Fae = (e, t) => e.filter((r) => r != null).map((r) => Ki(r, t))),
      (hrt = (e, t) => M(e, { Action: [], Value: (r) => Ki(r, t) })),
      (grt = (e, t) =>
        M(e, {
          PolicyName: [],
          TargetTrackingScalingPolicyConfiguration: (r) => yrt(r, t),
        })),
      (Ba = (e, t) =>
        M(e, {
          AutoScalingDisabled: [],
          AutoScalingRoleArn: [],
          MaximumUnits: [],
          MinimumUnits: [],
          ScalingPolicyUpdate: (r) => grt(r, t),
        })),
      (yrt = (e, t) =>
        M(e, {
          DisableScaleIn: [],
          ScaleInCooldown: [],
          ScaleOutCooldown: [],
          TargetValue: Cse,
        })),
      (xrt = (e, t) =>
        M(e, { ReturnConsumedCapacity: [], Statements: (r) => Yrt(r, t) })),
      (Ert = (e, t) =>
        M(e, { RequestItems: (r) => Srt(r, t), ReturnConsumedCapacity: [] })),
      (Srt = (e, t) =>
        Object.entries(e).reduce(
          (r, [o, n]) => (n === null || (r[o] = qrt(n, t)), r),
          {}
        )),
      (Crt = (e, t) =>
        M(e, {
          ConsistentRead: [],
          Parameters: (r) => CN(r, t),
          ReturnValuesOnConditionCheckFailure: [],
          Statement: [],
        })),
      (brt = (e, t) =>
        M(e, {
          RequestItems: (r) => _rt(r, t),
          ReturnConsumedCapacity: [],
          ReturnItemCollectionMetrics: [],
        })),
      (_rt = (e, t) =>
        Object.entries(e).reduce(
          (r, [o, n]) => (n === null || (r[o] = Cot(n, t)), r),
          {}
        )),
      (wrt = (e, t) =>
        e.filter((r) => r != null).map((r) => t.base64Encoder(r))),
      (Uae = (e, t) =>
        M(e, { AttributeValueList: (r) => Fae(r, t), ComparisonOperator: [] })),
      (Trt = (e, t) =>
        M(e, {
          ConditionExpression: [],
          ExpressionAttributeNames: D,
          ExpressionAttributeValues: (r) => Yi(r, t),
          Key: (r) => Us(r, t),
          ReturnValuesOnConditionCheckFailure: [],
          TableName: [],
        })),
      (Art = (e, t) =>
        M(e, {
          ConditionExpression: [],
          ExpressionAttributeNames: D,
          ExpressionAttributeValues: (r) => Yi(r, t),
          Key: (r) => Us(r, t),
          ReturnValuesOnConditionCheckFailure: [],
          TableName: [],
        })),
      (Rrt = (e, t) =>
        M(e, {
          ConditionExpression: [],
          ConditionalOperator: [],
          Expected: (r) => SN(r, t),
          ExpressionAttributeNames: D,
          ExpressionAttributeValues: (r) => Yi(r, t),
          Key: (r) => Us(r, t),
          ReturnConsumedCapacity: [],
          ReturnItemCollectionMetrics: [],
          ReturnValues: [],
          ReturnValuesOnConditionCheckFailure: [],
          TableName: [],
        })),
      (Irt = (e, t) => M(e, { Key: (r) => Us(r, t) })),
      (Prt = (e, t) =>
        M(e, {
          ConsistentRead: [],
          Limit: [],
          NextToken: [],
          Parameters: (r) => CN(r, t),
          ReturnConsumedCapacity: [],
          ReturnValuesOnConditionCheckFailure: [],
          Statement: [],
        })),
      (vrt = (e, t) =>
        M(e, {
          ClientRequestToken: [!0, (r) => r ?? qo()],
          ReturnConsumedCapacity: [],
          TransactStatements: (r) => Krt(r, t),
        })),
      (SN = (e, t) =>
        Object.entries(e).reduce(
          (r, [o, n]) => (n === null || (r[o] = Ort(n, t)), r),
          {}
        )),
      (Ort = (e, t) =>
        M(e, {
          AttributeValueList: (r) => Fae(r, t),
          ComparisonOperator: [],
          Exists: [],
          Value: (r) => Ki(r, t),
        })),
      (krt = (e, t) =>
        M(e, {
          ClientToken: [!0, (r) => r ?? qo()],
          ExportFormat: [],
          ExportTime: (r) => r.getTime() / 1e3,
          ExportType: [],
          IncrementalExportSpecification: (r) => $rt(r, t),
          S3Bucket: [],
          S3BucketOwner: [],
          S3Prefix: [],
          S3SseAlgorithm: [],
          S3SseKmsKeyId: [],
          TableArn: [],
        })),
      (Yi = (e, t) =>
        Object.entries(e).reduce(
          (r, [o, n]) => (n === null || (r[o] = Ki(n, t)), r),
          {}
        )),
      ($ae = (e, t) =>
        Object.entries(e).reduce(
          (r, [o, n]) => (n === null || (r[o] = Uae(n, t)), r),
          {}
        )),
      (Drt = (e, t) =>
        M(e, {
          ExpressionAttributeNames: D,
          Key: (r) => Us(r, t),
          ProjectionExpression: [],
          TableName: [],
        })),
      (Nrt = (e, t) =>
        M(e, {
          AttributesToGet: D,
          ConsistentRead: [],
          ExpressionAttributeNames: D,
          Key: (r) => Us(r, t),
          ProjectionExpression: [],
          ReturnConsumedCapacity: [],
          TableName: [],
        })),
      (Brt = (e, t) =>
        M(e, {
          IndexName: [],
          ProvisionedWriteCapacityAutoScalingUpdate: (r) => Ba(r, t),
        })),
      (Mrt = (e, t) => e.filter((r) => r != null).map((r) => Brt(r, t))),
      (Lrt = (e, t) =>
        M(e, {
          IndexName: [],
          ProvisionedWriteCapacityAutoScalingSettingsUpdate: (r) => Ba(r, t),
          ProvisionedWriteCapacityUnits: [],
        })),
      (Frt = (e, t) => e.filter((r) => r != null).map((r) => Lrt(r, t))),
      (Urt = (e, t) =>
        M(e, {
          ClientToken: [!0, (r) => r ?? qo()],
          InputCompressionType: [],
          InputFormat: [],
          InputFormatOptions: D,
          S3BucketSource: D,
          TableCreationParameters: D,
        })),
      ($rt = (e, t) =>
        M(e, {
          ExportFromTime: (r) => r.getTime() / 1e3,
          ExportToTime: (r) => r.getTime() / 1e3,
          ExportViewType: [],
        })),
      (Us = (e, t) =>
        Object.entries(e).reduce(
          (r, [o, n]) => (n === null || (r[o] = Ki(n, t)), r),
          {}
        )),
      (Hrt = (e, t) =>
        Object.entries(e).reduce(
          (r, [o, n]) => (n === null || (r[o] = Uae(n, t)), r),
          {}
        )),
      (zrt = (e, t) => e.filter((r) => r != null).map((r) => Us(r, t))),
      (qrt = (e, t) =>
        M(e, {
          AttributesToGet: D,
          ConsistentRead: [],
          ExpressionAttributeNames: D,
          Keys: (r) => zrt(r, t),
          ProjectionExpression: [],
        })),
      (jrt = (e, t) => e.filter((r) => r != null).map((r) => Ki(r, t))),
      (Grt = (e, t) =>
        M(e, {
          BackupType: [],
          ExclusiveStartBackupArn: [],
          Limit: [],
          TableName: [],
          TimeRangeLowerBound: (r) => r.getTime() / 1e3,
          TimeRangeUpperBound: (r) => r.getTime() / 1e3,
        })),
      (Vrt = (e, t) =>
        Object.entries(e).reduce(
          (r, [o, n]) => (n === null || (r[o] = Ki(n, t)), r),
          {}
        )),
      (Wrt = (e, t) =>
        M(e, {
          Parameters: (r) => CN(r, t),
          ReturnValuesOnConditionCheckFailure: [],
          Statement: [],
        })),
      (Krt = (e, t) => e.filter((r) => r != null).map((r) => Wrt(r, t))),
      (Yrt = (e, t) => e.filter((r) => r != null).map((r) => Crt(r, t))),
      (CN = (e, t) => e.filter((r) => r != null).map((r) => Ki(r, t))),
      (Qrt = (e, t) =>
        M(e, {
          ConditionExpression: [],
          ExpressionAttributeNames: D,
          ExpressionAttributeValues: (r) => Yi(r, t),
          Item: (r) => bN(r, t),
          ReturnValuesOnConditionCheckFailure: [],
          TableName: [],
        })),
      (Xrt = (e, t) =>
        M(e, {
          ConditionExpression: [],
          ConditionalOperator: [],
          Expected: (r) => SN(r, t),
          ExpressionAttributeNames: D,
          ExpressionAttributeValues: (r) => Yi(r, t),
          Item: (r) => bN(r, t),
          ReturnConsumedCapacity: [],
          ReturnItemCollectionMetrics: [],
          ReturnValues: [],
          ReturnValuesOnConditionCheckFailure: [],
          TableName: [],
        })),
      (bN = (e, t) =>
        Object.entries(e).reduce(
          (r, [o, n]) => (n === null || (r[o] = Ki(n, t)), r),
          {}
        )),
      (Jrt = (e, t) => M(e, { Item: (r) => bN(r, t) })),
      (Zrt = (e, t) =>
        M(e, {
          AttributesToGet: D,
          ConditionalOperator: [],
          ConsistentRead: [],
          ExclusiveStartKey: (r) => Us(r, t),
          ExpressionAttributeNames: D,
          ExpressionAttributeValues: (r) => Yi(r, t),
          FilterExpression: [],
          IndexName: [],
          KeyConditionExpression: [],
          KeyConditions: (r) => Hrt(r, t),
          Limit: [],
          ProjectionExpression: [],
          QueryFilter: (r) => $ae(r, t),
          ReturnConsumedCapacity: [],
          ScanIndexForward: [],
          Select: [],
          TableName: [],
        })),
      (eot = (e, t) =>
        M(e, {
          RegionName: [],
          ReplicaGlobalSecondaryIndexUpdates: (r) => oot(r, t),
          ReplicaProvisionedReadCapacityAutoScalingUpdate: (r) => Ba(r, t),
        })),
      (tot = (e, t) => e.filter((r) => r != null).map((r) => eot(r, t))),
      (rot = (e, t) =>
        M(e, {
          IndexName: [],
          ProvisionedReadCapacityAutoScalingUpdate: (r) => Ba(r, t),
        })),
      (oot = (e, t) => e.filter((r) => r != null).map((r) => rot(r, t))),
      (not = (e, t) =>
        M(e, {
          IndexName: [],
          ProvisionedReadCapacityAutoScalingSettingsUpdate: (r) => Ba(r, t),
          ProvisionedReadCapacityUnits: [],
        })),
      (sot = (e, t) => e.filter((r) => r != null).map((r) => not(r, t))),
      (iot = (e, t) =>
        M(e, {
          RegionName: [],
          ReplicaGlobalSecondaryIndexSettingsUpdate: (r) => sot(r, t),
          ReplicaProvisionedReadCapacityAutoScalingSettingsUpdate: (r) =>
            Ba(r, t),
          ReplicaProvisionedReadCapacityUnits: [],
          ReplicaTableClass: [],
        })),
      (aot = (e, t) => e.filter((r) => r != null).map((r) => iot(r, t))),
      (cot = (e, t) =>
        M(e, {
          BillingModeOverride: [],
          GlobalSecondaryIndexOverride: D,
          LocalSecondaryIndexOverride: D,
          OnDemandThroughputOverride: D,
          ProvisionedThroughputOverride: D,
          RestoreDateTime: (r) => r.getTime() / 1e3,
          SSESpecificationOverride: D,
          SourceTableArn: [],
          SourceTableName: [],
          TargetTableName: [],
          UseLatestRestorableTime: [],
        })),
      (dot = (e, t) =>
        M(e, {
          AttributesToGet: D,
          ConditionalOperator: [],
          ConsistentRead: [],
          ExclusiveStartKey: (r) => Us(r, t),
          ExpressionAttributeNames: D,
          ExpressionAttributeValues: (r) => Yi(r, t),
          FilterExpression: [],
          IndexName: [],
          Limit: [],
          ProjectionExpression: [],
          ReturnConsumedCapacity: [],
          ScanFilter: (r) => $ae(r, t),
          Segment: [],
          Select: [],
          TableName: [],
          TotalSegments: [],
        })),
      (mot = (e, t) => M(e, { Get: (r) => Drt(r, t) })),
      (lot = (e, t) => e.filter((r) => r != null).map((r) => mot(r, t))),
      (fot = (e, t) =>
        M(e, { ReturnConsumedCapacity: [], TransactItems: (r) => lot(r, t) })),
      (uot = (e, t) =>
        M(e, {
          ConditionCheck: (r) => Trt(r, t),
          Delete: (r) => Art(r, t),
          Put: (r) => Qrt(r, t),
          Update: (r) => got(r, t),
        })),
      (pot = (e, t) => e.filter((r) => r != null).map((r) => uot(r, t))),
      (hot = (e, t) =>
        M(e, {
          ClientRequestToken: [!0, (r) => r ?? qo()],
          ReturnConsumedCapacity: [],
          ReturnItemCollectionMetrics: [],
          TransactItems: (r) => pot(r, t),
        })),
      (got = (e, t) =>
        M(e, {
          ConditionExpression: [],
          ExpressionAttributeNames: D,
          ExpressionAttributeValues: (r) => Yi(r, t),
          Key: (r) => Us(r, t),
          ReturnValuesOnConditionCheckFailure: [],
          TableName: [],
          UpdateExpression: [],
        })),
      (yot = (e, t) =>
        M(e, {
          GlobalTableBillingMode: [],
          GlobalTableGlobalSecondaryIndexSettingsUpdate: (r) => Frt(r, t),
          GlobalTableName: [],
          GlobalTableProvisionedWriteCapacityAutoScalingSettingsUpdate: (r) =>
            Ba(r, t),
          GlobalTableProvisionedWriteCapacityUnits: [],
          ReplicaSettingsUpdate: (r) => aot(r, t),
        })),
      (xot = (e, t) =>
        M(e, {
          AttributeUpdates: (r) => prt(r, t),
          ConditionExpression: [],
          ConditionalOperator: [],
          Expected: (r) => SN(r, t),
          ExpressionAttributeNames: D,
          ExpressionAttributeValues: (r) => Yi(r, t),
          Key: (r) => Us(r, t),
          ReturnConsumedCapacity: [],
          ReturnItemCollectionMetrics: [],
          ReturnValues: [],
          ReturnValuesOnConditionCheckFailure: [],
          TableName: [],
          UpdateExpression: [],
        })),
      (Eot = (e, t) =>
        M(e, {
          GlobalSecondaryIndexUpdates: (r) => Mrt(r, t),
          ProvisionedWriteCapacityAutoScalingUpdate: (r) => Ba(r, t),
          ReplicaUpdates: (r) => tot(r, t),
          TableName: [],
        })),
      (Sot = (e, t) =>
        M(e, {
          DeleteRequest: (r) => Irt(r, t),
          PutRequest: (r) => Jrt(r, t),
        })),
      (Cot = (e, t) => e.filter((r) => r != null).map((r) => Sot(r, t))),
      (bot = (e, t) =>
        M(e, {
          ArchivalBackupArn: p,
          ArchivalDateTime: (r) => F(Mt(Pt(r))),
          ArchivalReason: p,
        })),
      (ci = (e, t) =>
        Object.entries(e).reduce(
          (r, [o, n]) => (n === null || (r[o] = Nl(td(n), t)), r),
          {}
        )),
      (Nl = (e, t) =>
        e.B != null
          ? { B: t.base64Decoder(e.B) }
          : Bs(e.BOOL) !== void 0
            ? { BOOL: Bs(e.BOOL) }
            : e.BS != null
              ? { BS: Mot(e.BS, t) }
              : e.L != null
                ? { L: xnt(e.L, t) }
                : e.M != null
                  ? { M: Cnt(e.M, t) }
                  : p(e.N) !== void 0
                    ? { N: p(e.N) }
                    : e.NS != null
                      ? { NS: D(e.NS) }
                      : Bs(e.NULL) !== void 0
                        ? { NULL: Bs(e.NULL) }
                        : p(e.S) !== void 0
                          ? { S: p(e.S) }
                          : e.SS != null
                            ? { SS: D(e.SS) }
                            : { $unknown: Object.entries(e)[0] }),
      (_ot = (e, t) =>
        M(e, {
          PolicyName: p,
          TargetTrackingScalingPolicyConfiguration: (r) => Tot(r, t),
        })),
      (wot = (e, t) =>
        (e || []).filter((o) => o != null).map((o) => _ot(o, t))),
      (Na = (e, t) =>
        M(e, {
          AutoScalingDisabled: Bs,
          AutoScalingRoleArn: p,
          MaximumUnits: Xt,
          MinimumUnits: Xt,
          ScalingPolicies: (r) => wot(r, t),
        })),
      (Tot = (e, t) =>
        M(e, {
          DisableScaleIn: Bs,
          ScaleInCooldown: $n,
          ScaleOutCooldown: $n,
          TargetValue: ji,
        })),
      (Hae = (e, t) =>
        M(e, {
          BackupDetails: (r) => zae(r, t),
          SourceTableDetails: (r) => $nt(r, t),
          SourceTableFeatureDetails: (r) => Hnt(r, t),
        })),
      (zae = (e, t) =>
        M(e, {
          BackupArn: p,
          BackupCreationDateTime: (r) => F(Mt(Pt(r))),
          BackupExpiryDateTime: (r) => F(Mt(Pt(r))),
          BackupName: p,
          BackupSizeBytes: Xt,
          BackupStatus: p,
          BackupType: p,
        })),
      (Aot = (e, t) =>
        (e || []).filter((o) => o != null).map((o) => Rot(o, t))),
      (Rot = (e, t) =>
        M(e, {
          BackupArn: p,
          BackupCreationDateTime: (r) => F(Mt(Pt(r))),
          BackupExpiryDateTime: (r) => F(Mt(Pt(r))),
          BackupName: p,
          BackupSizeBytes: Xt,
          BackupStatus: p,
          BackupType: p,
          TableArn: p,
          TableId: p,
          TableName: p,
        })),
      (Iot = (e, t) =>
        M(e, {
          ConsumedCapacity: (r) => Bl(r, t),
          Responses: (r) => bnt(r, t),
        })),
      (Pot = (e, t) =>
        M(e, {
          ConsumedCapacity: (r) => Bl(r, t),
          Responses: (r) => Oot(r, t),
          UnprocessedKeys: (r) => vot(r, t),
        })),
      (vot = (e, t) =>
        Object.entries(e).reduce(
          (r, [o, n]) => (n === null || (r[o] = ynt(n, t)), r),
          {}
        )),
      (Oot = (e, t) =>
        Object.entries(e).reduce(
          (r, [o, n]) => (n === null || (r[o] = JS(n, t)), r),
          {}
        )),
      (kot = (e, t) => M(e, { Code: p, Item: (r) => ci(r, t), Message: p })),
      (Dot = (e, t) =>
        M(e, { Error: (r) => kot(r, t), Item: (r) => ci(r, t), TableName: p })),
      (Not = (e, t) =>
        M(e, {
          ConsumedCapacity: (r) => Bl(r, t),
          ItemCollectionMetrics: (r) => Kae(r, t),
          UnprocessedItems: (r) => Bot(r, t),
        })),
      (Bot = (e, t) =>
        Object.entries(e).reduce(
          (r, [o, n]) => (n === null || (r[o] = Jnt(n, t)), r),
          {}
        )),
      (qae = (e, t) =>
        M(e, {
          BillingMode: p,
          LastUpdateToPayPerRequestDateTime: (r) => F(Mt(Pt(r))),
        })),
      (Mot = (e, t) =>
        (e || []).filter((o) => o != null).map((o) => t.base64Decoder(o))),
      (Lot = (e, t) => M(e, { Code: p, Item: (r) => ci(r, t), Message: p })),
      (Fot = (e, t) =>
        (e || []).filter((o) => o != null).map((o) => Lot(o, t))),
      (jae = (e, t) =>
        M(e, {
          CapacityUnits: ji,
          ReadCapacityUnits: ji,
          WriteCapacityUnits: ji,
        })),
      (Uot = (e, t) => M(e, { Item: (r) => ci(r, t), message: p })),
      (Ma = (e, t) =>
        M(e, {
          CapacityUnits: ji,
          GlobalSecondaryIndexes: (r) => Ose(r, t),
          LocalSecondaryIndexes: (r) => Ose(r, t),
          ReadCapacityUnits: ji,
          Table: (r) => jae(r, t),
          TableName: p,
          WriteCapacityUnits: ji,
        })),
      (Bl = (e, t) => (e || []).filter((o) => o != null).map((o) => Ma(o, t))),
      (Gae = (e, t) =>
        M(e, {
          ContinuousBackupsStatus: p,
          PointInTimeRecoveryDescription: (r) => _nt(r, t),
        })),
      ($ot = (e, t) => M(e, { BackupDetails: (r) => zae(r, t) })),
      (Hot = (e, t) => M(e, { GlobalTableDescription: (r) => _N(r, t) })),
      (zot = (e, t) => M(e, { TableDescription: (r) => Ml(r, t) })),
      (qot = (e, t) => M(e, { BackupDescription: (r) => Hae(r, t) })),
      (jot = (e, t) =>
        M(e, {
          Attributes: (r) => ci(r, t),
          ConsumedCapacity: (r) => Ma(r, t),
          ItemCollectionMetrics: (r) => XS(r, t),
        })),
      (Got = (e, t) => M(e, { Key: (r) => sg(r, t) })),
      (Vot = (e, t) => M(e, { TableDescription: (r) => Ml(r, t) })),
      (Wot = (e, t) => M(e, { BackupDescription: (r) => Hae(r, t) })),
      (Kot = (e, t) =>
        M(e, { ContinuousBackupsDescription: (r) => Gae(r, t) })),
      (Yot = (e, t) =>
        M(e, {
          ContributorInsightsRuleList: D,
          ContributorInsightsStatus: p,
          FailureException: D,
          IndexName: p,
          LastUpdateDateTime: (r) => F(Mt(Pt(r))),
          TableName: p,
        })),
      (Qot = (e, t) => M(e, { ExportDescription: (r) => Vae(r, t) })),
      (Xot = (e, t) => M(e, { GlobalTableDescription: (r) => _N(r, t) })),
      (Jot = (e, t) =>
        M(e, { GlobalTableName: p, ReplicaSettings: (r) => Jae(r, t) })),
      (Zot = (e, t) => M(e, { ImportTableDescription: (r) => Wae(r, t) })),
      (ent = (e, t) => M(e, { Table: (r) => Ml(r, t) })),
      (tnt = (e, t) => M(e, { TableAutoScalingDescription: (r) => ece(r, t) })),
      (rnt = (e, t) =>
        M(e, {
          ConsumedCapacity: (r) => Ma(r, t),
          Items: (r) => JS(r, t),
          LastEvaluatedKey: (r) => sg(r, t),
          NextToken: p,
        })),
      (ont = (e, t) =>
        M(e, {
          ConsumedCapacity: (r) => Bl(r, t),
          Responses: (r) => Yae(r, t),
        })),
      (Vae = (e, t) =>
        M(e, {
          BilledSizeBytes: Xt,
          ClientToken: p,
          EndTime: (r) => F(Mt(Pt(r))),
          ExportArn: p,
          ExportFormat: p,
          ExportManifest: p,
          ExportStatus: p,
          ExportTime: (r) => F(Mt(Pt(r))),
          ExportType: p,
          FailureCode: p,
          FailureMessage: p,
          IncrementalExportSpecification: (r) => lnt(r, t),
          ItemCount: Xt,
          S3Bucket: p,
          S3BucketOwner: p,
          S3Prefix: p,
          S3SseAlgorithm: p,
          S3SseKmsKeyId: p,
          StartTime: (r) => F(Mt(Pt(r))),
          TableArn: p,
          TableId: p,
        })),
      (nnt = (e, t) => M(e, { ExportDescription: (r) => Vae(r, t) })),
      (snt = (e, t) =>
        M(e, { ConsumedCapacity: (r) => Ma(r, t), Item: (r) => ci(r, t) })),
      (int = (e, t) =>
        M(e, {
          Backfilling: Bs,
          IndexArn: p,
          IndexName: p,
          IndexSizeBytes: Xt,
          IndexStatus: p,
          ItemCount: Xt,
          KeySchema: D,
          OnDemandThroughput: D,
          Projection: D,
          ProvisionedThroughput: (r) => Qae(r, t),
          WarmThroughput: D,
        })),
      (ant = (e, t) =>
        (e || []).filter((o) => o != null).map((o) => int(o, t))),
      (_N = (e, t) =>
        M(e, {
          CreationDateTime: (r) => F(Mt(Pt(r))),
          GlobalTableArn: p,
          GlobalTableName: p,
          GlobalTableStatus: p,
          ReplicationGroup: (r) => Xae(r, t),
        })),
      (cnt = (e, t) =>
        M(e, {
          CloudWatchLogGroupArn: p,
          EndTime: (r) => F(Mt(Pt(r))),
          ImportArn: p,
          ImportStatus: p,
          InputFormat: p,
          S3BucketSource: D,
          StartTime: (r) => F(Mt(Pt(r))),
          TableArn: p,
        })),
      (dnt = (e, t) =>
        (e || []).filter((o) => o != null).map((o) => cnt(o, t))),
      (Wae = (e, t) =>
        M(e, {
          ClientToken: p,
          CloudWatchLogGroupArn: p,
          EndTime: (r) => F(Mt(Pt(r))),
          ErrorCount: Xt,
          FailureCode: p,
          FailureMessage: p,
          ImportArn: p,
          ImportStatus: p,
          ImportedItemCount: Xt,
          InputCompressionType: p,
          InputFormat: p,
          InputFormatOptions: D,
          ProcessedItemCount: Xt,
          ProcessedSizeBytes: Xt,
          S3BucketSource: D,
          StartTime: (r) => F(Mt(Pt(r))),
          TableArn: p,
          TableCreationParameters: D,
          TableId: p,
        })),
      (mnt = (e, t) => M(e, { ImportTableDescription: (r) => Wae(r, t) })),
      (lnt = (e, t) =>
        M(e, {
          ExportFromTime: (r) => F(Mt(Pt(r))),
          ExportToTime: (r) => F(Mt(Pt(r))),
          ExportViewType: p,
        })),
      (fnt = (e, t) =>
        Object.entries(e).reduce(
          (r, [o, n]) => (n === null || (r[o] = Nl(td(n), t)), r),
          {}
        )),
      (XS = (e, t) =>
        M(e, {
          ItemCollectionKey: (r) => fnt(r, t),
          SizeEstimateRangeGB: (r) => pnt(r, t),
        })),
      (unt = (e, t) => (e || []).filter((o) => o != null).map((o) => XS(o, t))),
      (Kae = (e, t) =>
        Object.entries(e).reduce(
          (r, [o, n]) => (n === null || (r[o] = unt(n, t)), r),
          {}
        )),
      (pnt = (e, t) => (e || []).filter((o) => o != null).map((o) => ji(o))),
      (JS = (e, t) => (e || []).filter((o) => o != null).map((o) => ci(o, t))),
      (hnt = (e, t) => M(e, { Item: (r) => ci(r, t) })),
      (Yae = (e, t) =>
        (e || []).filter((o) => o != null).map((o) => hnt(o, t))),
      (sg = (e, t) =>
        Object.entries(e).reduce(
          (r, [o, n]) => (n === null || (r[o] = Nl(td(n), t)), r),
          {}
        )),
      (gnt = (e, t) => (e || []).filter((o) => o != null).map((o) => sg(o, t))),
      (ynt = (e, t) =>
        M(e, {
          AttributesToGet: D,
          ConsistentRead: Bs,
          ExpressionAttributeNames: D,
          Keys: (r) => gnt(r, t),
          ProjectionExpression: p,
        })),
      (xnt = (e, t) =>
        (e || []).filter((o) => o != null).map((o) => Nl(td(o), t))),
      (Ent = (e, t) =>
        M(e, { BackupSummaries: (r) => Aot(r, t), LastEvaluatedBackupArn: p })),
      (Snt = (e, t) =>
        M(e, { ImportSummaryList: (r) => dnt(r, t), NextToken: p })),
      (Cnt = (e, t) =>
        Object.entries(e).reduce(
          (r, [o, n]) => (n === null || (r[o] = Nl(td(n), t)), r),
          {}
        )),
      (bnt = (e, t) =>
        (e || []).filter((o) => o != null).map((o) => Dot(o, t))),
      (_nt = (e, t) =>
        M(e, {
          EarliestRestorableDateTime: (r) => F(Mt(Pt(r))),
          LatestRestorableDateTime: (r) => F(Mt(Pt(r))),
          PointInTimeRecoveryStatus: p,
          RecoveryPeriodInDays: $n,
        })),
      (Qae = (e, t) =>
        M(e, {
          LastDecreaseDateTime: (r) => F(Mt(Pt(r))),
          LastIncreaseDateTime: (r) => F(Mt(Pt(r))),
          NumberOfDecreasesToday: Xt,
          ReadCapacityUnits: Xt,
          WriteCapacityUnits: Xt,
        })),
      (wnt = (e, t) =>
        Object.entries(e).reduce(
          (r, [o, n]) => (n === null || (r[o] = Nl(td(n), t)), r),
          {}
        )),
      (Tnt = (e, t) =>
        M(e, {
          Attributes: (r) => ci(r, t),
          ConsumedCapacity: (r) => Ma(r, t),
          ItemCollectionMetrics: (r) => XS(r, t),
        })),
      (Ant = (e, t) => M(e, { Item: (r) => wnt(r, t) })),
      (Rnt = (e, t) =>
        M(e, {
          ConsumedCapacity: (r) => Ma(r, t),
          Count: $n,
          Items: (r) => JS(r, t),
          LastEvaluatedKey: (r) => sg(r, t),
          ScannedCount: $n,
        })),
      (Int = (e, t) =>
        M(e, {
          GlobalSecondaryIndexes: (r) => knt(r, t),
          RegionName: p,
          ReplicaProvisionedReadCapacityAutoScalingSettings: (r) => Na(r, t),
          ReplicaProvisionedWriteCapacityAutoScalingSettings: (r) => Na(r, t),
          ReplicaStatus: p,
        })),
      (Pnt = (e, t) =>
        (e || []).filter((o) => o != null).map((o) => Int(o, t))),
      (vnt = (e, t) =>
        M(e, {
          GlobalSecondaryIndexes: D,
          KMSMasterKeyId: p,
          OnDemandThroughputOverride: D,
          ProvisionedThroughputOverride: D,
          RegionName: p,
          ReplicaInaccessibleDateTime: (r) => F(Mt(Pt(r))),
          ReplicaStatus: p,
          ReplicaStatusDescription: p,
          ReplicaStatusPercentProgress: p,
          ReplicaTableClassSummary: (r) => wN(r, t),
          WarmThroughput: D,
        })),
      (Xae = (e, t) =>
        (e || []).filter((o) => o != null).map((o) => vnt(o, t))),
      (Ont = (e, t) =>
        M(e, {
          IndexName: p,
          IndexStatus: p,
          ProvisionedReadCapacityAutoScalingSettings: (r) => Na(r, t),
          ProvisionedWriteCapacityAutoScalingSettings: (r) => Na(r, t),
        })),
      (knt = (e, t) =>
        (e || []).filter((o) => o != null).map((o) => Ont(o, t))),
      (Dnt = (e, t) =>
        M(e, {
          IndexName: p,
          IndexStatus: p,
          ProvisionedReadCapacityAutoScalingSettings: (r) => Na(r, t),
          ProvisionedReadCapacityUnits: Xt,
          ProvisionedWriteCapacityAutoScalingSettings: (r) => Na(r, t),
          ProvisionedWriteCapacityUnits: Xt,
        })),
      (Nnt = (e, t) =>
        (e || []).filter((o) => o != null).map((o) => Dnt(o, t))),
      (Bnt = (e, t) =>
        M(e, {
          RegionName: p,
          ReplicaBillingModeSummary: (r) => qae(r, t),
          ReplicaGlobalSecondaryIndexSettings: (r) => Nnt(r, t),
          ReplicaProvisionedReadCapacityAutoScalingSettings: (r) => Na(r, t),
          ReplicaProvisionedReadCapacityUnits: Xt,
          ReplicaProvisionedWriteCapacityAutoScalingSettings: (r) => Na(r, t),
          ReplicaProvisionedWriteCapacityUnits: Xt,
          ReplicaStatus: p,
          ReplicaTableClassSummary: (r) => wN(r, t),
        })),
      (Jae = (e, t) =>
        (e || []).filter((o) => o != null).map((o) => Bnt(o, t))),
      (Mnt = (e, t) =>
        M(e, {
          RestoreDateTime: (r) => F(Mt(Pt(r))),
          RestoreInProgress: Bs,
          SourceBackupArn: p,
          SourceTableArn: p,
        })),
      (Lnt = (e, t) => M(e, { TableDescription: (r) => Ml(r, t) })),
      (Fnt = (e, t) => M(e, { TableDescription: (r) => Ml(r, t) })),
      (Unt = (e, t) =>
        M(e, {
          ConsumedCapacity: (r) => Ma(r, t),
          Count: $n,
          Items: (r) => JS(r, t),
          LastEvaluatedKey: (r) => sg(r, t),
          ScannedCount: $n,
        })),
      (Ose = (e, t) =>
        Object.entries(e).reduce(
          (r, [o, n]) => (n === null || (r[o] = jae(n, t)), r),
          {}
        )),
      ($nt = (e, t) =>
        M(e, {
          BillingMode: p,
          ItemCount: Xt,
          KeySchema: D,
          OnDemandThroughput: D,
          ProvisionedThroughput: D,
          TableArn: p,
          TableCreationDateTime: (r) => F(Mt(Pt(r))),
          TableId: p,
          TableName: p,
          TableSizeBytes: Xt,
        })),
      (Hnt = (e, t) =>
        M(e, {
          GlobalSecondaryIndexes: D,
          LocalSecondaryIndexes: D,
          SSEDescription: (r) => Zae(r, t),
          StreamDescription: D,
          TimeToLiveDescription: D,
        })),
      (Zae = (e, t) =>
        M(e, {
          InaccessibleEncryptionDateTime: (r) => F(Mt(Pt(r))),
          KMSMasterKeyArn: p,
          SSEType: p,
          Status: p,
        })),
      (ece = (e, t) =>
        M(e, { Replicas: (r) => Pnt(r, t), TableName: p, TableStatus: p })),
      (wN = (e, t) =>
        M(e, { LastUpdateDateTime: (r) => F(Mt(Pt(r))), TableClass: p })),
      (Ml = (e, t) =>
        M(e, {
          ArchivalSummary: (r) => bot(r, t),
          AttributeDefinitions: D,
          BillingModeSummary: (r) => qae(r, t),
          CreationDateTime: (r) => F(Mt(Pt(r))),
          DeletionProtectionEnabled: Bs,
          GlobalSecondaryIndexes: (r) => ant(r, t),
          GlobalTableVersion: p,
          ItemCount: Xt,
          KeySchema: D,
          LatestStreamArn: p,
          LatestStreamLabel: p,
          LocalSecondaryIndexes: D,
          MultiRegionConsistency: p,
          OnDemandThroughput: D,
          ProvisionedThroughput: (r) => Qae(r, t),
          Replicas: (r) => Xae(r, t),
          RestoreSummary: (r) => Mnt(r, t),
          SSEDescription: (r) => Zae(r, t),
          StreamSpecification: D,
          TableArn: p,
          TableClassSummary: (r) => wN(r, t),
          TableId: p,
          TableName: p,
          TableSizeBytes: Xt,
          TableStatus: p,
          WarmThroughput: D,
        })),
      (znt = (e, t) =>
        M(e, {
          ConsumedCapacity: (r) => Bl(r, t),
          Responses: (r) => Yae(r, t),
        })),
      (qnt = (e, t) =>
        M(e, { CancellationReasons: (r) => Fot(r, t), Message: p })),
      (jnt = (e, t) =>
        M(e, {
          ConsumedCapacity: (r) => Bl(r, t),
          ItemCollectionMetrics: (r) => Kae(r, t),
        })),
      (Gnt = (e, t) =>
        M(e, { ContinuousBackupsDescription: (r) => Gae(r, t) })),
      (Vnt = (e, t) => M(e, { GlobalTableDescription: (r) => _N(r, t) })),
      (Wnt = (e, t) =>
        M(e, { GlobalTableName: p, ReplicaSettings: (r) => Jae(r, t) })),
      (Knt = (e, t) =>
        M(e, {
          Attributes: (r) => ci(r, t),
          ConsumedCapacity: (r) => Ma(r, t),
          ItemCollectionMetrics: (r) => XS(r, t),
        })),
      (Ynt = (e, t) => M(e, { TableDescription: (r) => Ml(r, t) })),
      (Qnt = (e, t) => M(e, { TableAutoScalingDescription: (r) => ece(r, t) })),
      (Xnt = (e, t) =>
        M(e, {
          DeleteRequest: (r) => Got(r, t),
          PutRequest: (r) => Ant(r, t),
        })),
      (Jnt = (e, t) =>
        (e || []).filter((o) => o != null).map((o) => Xnt(o, t))),
      (oe = (e) => ({
        httpStatusCode: e.statusCode,
        requestId:
          e.headers["x-amzn-requestid"] ??
          e.headers["x-amzn-request-id"] ??
          e.headers["x-amz-request-id"],
        extendedRequestId: e.headers["x-amz-id-2"],
        cfId: e.headers["x-amz-cf-id"],
      })),
      (Znt = mS(at)),
      (Ae = async (e, t, r, o, n) => {
        let {
            hostname: i,
            protocol: a = "https",
            port: c,
            path: d,
          } = await e.endpoint(),
          m = {
            protocol: a,
            hostname: i,
            port: c,
            method: "POST",
            path: d.endsWith("/") ? d.slice(0, -1) + r : d + r,
            headers: t,
          };
        return (
          o !== void 0 && (m.hostname = o),
          n !== void 0 && (m.body = n),
          new Bo(m)
        );
      });
  });
var Ll,
  ZS = s(() => {
    ye();
    xe();
    ae();
    Ce();
    be();
    Ll = class extends (
      L.classBuilder()
        .ep(V)
        .m(function (t, r, o, n) {
          return [
            z(o, this.serialize, this.deserialize),
            q(o, t.getEndpointParameterInstructions()),
          ];
        })
        .s("DynamoDB_20120810", "DescribeEndpoints", {})
        .n("DynamoDBClient", "DescribeEndpointsCommand")
        .f(void 0, void 0)
        .ser(Gse)
        .de(Kie)
        .build()
    ) {};
  });
var rce,
  tce = s(() => {
    rce = {
      name: "@aws-sdk/client-dynamodb",
      description:
        "AWS SDK for JavaScript Dynamodb Client for Node.js, Browser and React Native",
      version: "3.839.0",
      scripts: {
        build:
          "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
        "build:cjs": "node ../../scripts/compilation/inline client-dynamodb",
        "build:es": "tsc -p tsconfig.es.json",
        "build:include:deps":
          "lerna run --scope $npm_package_name --include-dependencies build",
        "build:types": "tsc -p tsconfig.types.json",
        "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
        clean: "rimraf ./dist-* && rimraf *.tsbuildinfo",
        "extract:docs": "api-extractor run --local",
        "generate:client":
          "node ../../scripts/generate-clients/single-service --solo dynamodb",
      },
      main: "./dist-cjs/index.js",
      types: "./dist-types/index.d.ts",
      module: "./dist-es/index.js",
      sideEffects: !1,
      dependencies: {
        "@aws-crypto/sha256-browser": "5.2.0",
        "@aws-crypto/sha256-js": "5.2.0",
        "@aws-sdk/core": "3.839.0",
        "@aws-sdk/credential-provider-node": "3.839.0",
        "@aws-sdk/middleware-endpoint-discovery": "3.821.0",
        "@aws-sdk/middleware-host-header": "3.821.0",
        "@aws-sdk/middleware-logger": "3.821.0",
        "@aws-sdk/middleware-recursion-detection": "3.821.0",
        "@aws-sdk/middleware-user-agent": "3.839.0",
        "@aws-sdk/region-config-resolver": "3.821.0",
        "@aws-sdk/types": "3.821.0",
        "@aws-sdk/util-endpoints": "3.828.0",
        "@aws-sdk/util-user-agent-browser": "3.821.0",
        "@aws-sdk/util-user-agent-node": "3.839.0",
        "@smithy/config-resolver": "^4.1.4",
        "@smithy/core": "^3.6.0",
        "@smithy/fetch-http-handler": "^5.0.4",
        "@smithy/hash-node": "^4.0.4",
        "@smithy/invalid-dependency": "^4.0.4",
        "@smithy/middleware-content-length": "^4.0.4",
        "@smithy/middleware-endpoint": "^4.1.13",
        "@smithy/middleware-retry": "^4.1.14",
        "@smithy/middleware-serde": "^4.0.8",
        "@smithy/middleware-stack": "^4.0.4",
        "@smithy/node-config-provider": "^4.1.3",
        "@smithy/node-http-handler": "^4.0.6",
        "@smithy/protocol-http": "^5.1.2",
        "@smithy/smithy-client": "^4.4.5",
        "@smithy/types": "^4.3.1",
        "@smithy/url-parser": "^4.0.4",
        "@smithy/util-base64": "^4.0.0",
        "@smithy/util-body-length-browser": "^4.0.0",
        "@smithy/util-body-length-node": "^4.0.0",
        "@smithy/util-defaults-mode-browser": "^4.0.21",
        "@smithy/util-defaults-mode-node": "^4.0.21",
        "@smithy/util-endpoints": "^3.0.6",
        "@smithy/util-middleware": "^4.0.4",
        "@smithy/util-retry": "^4.0.6",
        "@smithy/util-utf8": "^4.0.0",
        "@smithy/util-waiter": "^4.0.6",
        "@types/uuid": "^9.0.1",
        tslib: "^2.6.2",
        uuid: "^9.0.1",
      },
      devDependencies: {
        "@tsconfig/node18": "18.2.4",
        "@types/node": "^18.19.69",
        concurrently: "7.0.0",
        "downlevel-dts": "0.10.1",
        rimraf: "3.0.2",
        typescript: "~5.8.3",
      },
      engines: { node: ">=18.0.0" },
      typesVersions: { "<4.0": { "dist-types/*": ["dist-types/ts3.4/*"] } },
      files: ["dist-*/**"],
      author: {
        name: "AWS SDK for JavaScript Team",
        url: "https://aws.amazon.com/javascript/",
      },
      license: "Apache-2.0",
      browser: { "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.browser" },
      "react-native": {
        "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.native",
      },
      homepage:
        "https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-dynamodb",
      repository: {
        type: "git",
        url: "https://github.com/aws/aws-sdk-js-v3.git",
        directory: "clients/client-dynamodb",
      },
    };
  });
var eC,
  tC,
  oce,
  nce,
  sce,
  ice,
  TN,
  ace = s(() => {
    xt();
    re();
    (eC = "AWS_ACCESS_KEY_ID"),
      (tC = "AWS_SECRET_ACCESS_KEY"),
      (oce = "AWS_SESSION_TOKEN"),
      (nce = "AWS_CREDENTIAL_EXPIRATION"),
      (sce = "AWS_CREDENTIAL_SCOPE"),
      (ice = "AWS_ACCOUNT_ID"),
      (TN = (e) => async () => {
        e?.logger?.debug("@aws-sdk/credential-provider-env - fromEnv");
        let t = process.env[eC],
          r = process.env[tC],
          o = process.env[oce],
          n = process.env[nce],
          i = process.env[sce],
          a = process.env[ice];
        if (t && r) {
          let c = {
            accessKeyId: t,
            secretAccessKey: r,
            ...(o && { sessionToken: o }),
            ...(n && { expiration: new Date(n) }),
            ...(i && { credentialScope: i }),
            ...(a && { accountId: a }),
          };
          return ce(c, "CREDENTIALS_ENV_VARS", "g"), c;
        }
        throw new P("Unable to find environment variable credentials.", {
          logger: e?.logger,
        });
      });
  });
var cce = {};
It(cce, {
  ENV_ACCOUNT_ID: () => ice,
  ENV_CREDENTIAL_SCOPE: () => sce,
  ENV_EXPIRATION: () => nce,
  ENV_KEY: () => eC,
  ENV_SECRET: () => tC,
  ENV_SESSION: () => oce,
  fromEnv: () => TN,
});
var AN = s(() => {
  ace();
});
import { Buffer as tst } from "buffer";
import { request as rst } from "http";
function La(e) {
  return new Promise((t, r) => {
    let o = rst({
      method: "GET",
      ...e,
      hostname: e.hostname?.replace(/^\[(.+)\]$/, "$1"),
    });
    o.on("error", (n) => {
      r(
        Object.assign(
          new Zt("Unable to connect to instance metadata service"),
          n
        )
      ),
        o.destroy();
    }),
      o.on("timeout", () => {
        r(new Zt("TimeoutError from instance metadata service")), o.destroy();
      }),
      o.on("response", (n) => {
        let { statusCode: i = 400 } = n;
        (i < 200 || 300 <= i) &&
          (r(
            Object.assign(
              new Zt("Error response received from instance metadata service"),
              { statusCode: i }
            )
          ),
          o.destroy());
        let a = [];
        n.on("data", (c) => {
          a.push(c);
        }),
          n.on("end", () => {
            t(tst.concat(a)), o.destroy();
          });
      }),
      o.end();
  });
}
var rC = s(() => {
  re();
});
var oC,
  nC,
  RN = s(() => {
    (oC = (e) =>
      !!e &&
      typeof e == "object" &&
      typeof e.AccessKeyId == "string" &&
      typeof e.SecretAccessKey == "string" &&
      typeof e.Token == "string" &&
      typeof e.Expiration == "string"),
      (nC = (e) => ({
        accessKeyId: e.AccessKeyId,
        secretAccessKey: e.SecretAccessKey,
        sessionToken: e.Token,
        expiration: new Date(e.Expiration),
        ...(e.AccountId && { accountId: e.AccountId }),
      }));
  });
var Btr,
  Mtr,
  ig,
  sC = s(() => {
    (Btr = 1e3),
      (Mtr = 0),
      (ig = ({ maxRetries: e = 0, timeout: t = 1e3 }) => ({
        maxRetries: e,
        timeout: t,
      }));
  });
var ag,
  IN = s(() => {
    ag = (e, t) => {
      let r = e();
      for (let o = 0; o < t; o++) r = r.catch(e);
      return r;
    };
  });
import { parse as ost } from "url";
var iC,
  aC,
  PN,
  nst,
  sst,
  ist,
  ast,
  cst,
  dst,
  dce = s(() => {
    re();
    rC();
    RN();
    sC();
    IN();
    (iC = "AWS_CONTAINER_CREDENTIALS_FULL_URI"),
      (aC = "AWS_CONTAINER_CREDENTIALS_RELATIVE_URI"),
      (PN = "AWS_CONTAINER_AUTHORIZATION_TOKEN"),
      (nst = (e = {}) => {
        let { timeout: t, maxRetries: r } = ig(e);
        return () =>
          ag(async () => {
            let o = await dst({ logger: e.logger }),
              n = JSON.parse(await sst(t, o));
            if (!oC(n))
              throw new P(
                "Invalid response received from instance metadata service.",
                { logger: e.logger }
              );
            return nC(n);
          }, r);
      }),
      (sst = async (e, t) => (
        process.env[PN] &&
          (t.headers = { ...t.headers, Authorization: process.env[PN] }),
        (await La({ ...t, timeout: e })).toString()
      )),
      (ist = "169.254.170.2"),
      (ast = { localhost: !0, "127.0.0.1": !0 }),
      (cst = { "http:": !0, "https:": !0 }),
      (dst = async ({ logger: e }) => {
        if (process.env[aC]) return { hostname: ist, path: process.env[aC] };
        if (process.env[iC]) {
          let t = ost(process.env[iC]);
          if (!t.hostname || !(t.hostname in ast))
            throw new P(
              `${t.hostname} is not a valid container metadata service hostname`,
              { tryNextLink: !1, logger: e }
            );
          if (!t.protocol || !(t.protocol in cst))
            throw new P(
              `${t.protocol} is not a valid container metadata service protocol`,
              { tryNextLink: !1, logger: e }
            );
          return { ...t, port: t.port ? parseInt(t.port, 10) : void 0 };
        }
        throw new P(
          `The container metadata credential provider cannot be used unless the ${aC} or ${iC} environment variable is set`,
          { tryNextLink: !1, logger: e }
        );
      });
  });
var cC,
  mce = s(() => {
    re();
    cC = class e extends P {
      constructor(t, r = !0) {
        super(t, r),
          (this.tryNextLink = r),
          (this.name = "InstanceMetadataV1FallbackError"),
          Object.setPrototypeOf(this, e.prototype);
      }
    };
  });
var dd,
  vN = s(() => {
    (function (e) {
      (e.IPv4 = "http://169.254.169.254"), (e.IPv6 = "http://[fd00:ec2::254]");
    })(dd || (dd = {}));
  });
var mst,
  lst,
  lce,
  fce = s(() => {
    (mst = "AWS_EC2_METADATA_SERVICE_ENDPOINT"),
      (lst = "ec2_metadata_service_endpoint"),
      (lce = {
        environmentVariableSelector: (e) => e[mst],
        configFileSelector: (e) => e[lst],
        default: void 0,
      });
  });
var Fa,
  ON = s(() => {
    (function (e) {
      (e.IPv4 = "IPv4"), (e.IPv6 = "IPv6");
    })(Fa || (Fa = {}));
  });
var fst,
  ust,
  uce,
  pce = s(() => {
    ON();
    (fst = "AWS_EC2_METADATA_SERVICE_ENDPOINT_MODE"),
      (ust = "ec2_metadata_service_endpoint_mode"),
      (uce = {
        environmentVariableSelector: (e) => e[fst],
        configFileSelector: (e) => e[ust],
        default: Fa.IPv4,
      });
  });
var dC,
  pst,
  hst,
  kN = s(() => {
    od();
    eg();
    vN();
    fce();
    ON();
    pce();
    (dC = async () => ii((await pst()) || (await hst()))),
      (pst = async () => Wt(lce)()),
      (hst = async () => {
        let e = await Wt(uce)();
        switch (e) {
          case Fa.IPv4:
            return dd.IPv4;
          case Fa.IPv6:
            return dd.IPv6;
          default:
            throw new Error(
              `Unsupported endpoint mode: ${e}. Select from ${Object.values(Fa)}`
            );
        }
      });
  });
var gst,
  DN,
  hce = s(() => {
    (gst =
      "https://docs.aws.amazon.com/sdkref/latest/guide/feature-static-credentials.html"),
      (DN = (e, t) => {
        let r = 300 + Math.floor(Math.random() * 300),
          o = new Date(Date.now() + r * 1e3);
        t.warn(
          `Attempting credential expiration extension due to a credential service availability issue. A refresh of these credentials will be attempted after ${new Date(o)}.
For more information, please visit: ` + gst
        );
        let n = e.originalExpiration ?? e.expiration;
        return { ...e, ...(n ? { originalExpiration: n } : {}), expiration: o };
      });
  });
var gce,
  yce = s(() => {
    hce();
    gce = (e, t = {}) => {
      let r = t?.logger || console,
        o;
      return async () => {
        let n;
        try {
          (n = await e()),
            n.expiration &&
              n.expiration.getTime() < Date.now() &&
              (n = DN(n, r));
        } catch (i) {
          if (o) r.warn("Credential renew failed: ", i), (n = DN(o, r));
          else throw i;
        }
        return (o = n), n;
      };
    };
  });
var Sce,
  yst,
  NN,
  xce,
  Ece,
  xst,
  Est,
  Sst,
  Cst,
  bst,
  Cce = s(() => {
    od();
    re();
    mce();
    rC();
    RN();
    sC();
    IN();
    kN();
    yce();
    (Sce = "/latest/meta-data/iam/security-credentials/"),
      (yst = "/latest/api/token"),
      (NN = "AWS_EC2_METADATA_V1_DISABLED"),
      (xce = "ec2_metadata_v1_disabled"),
      (Ece = "x-aws-ec2-metadata-token"),
      (xst = (e = {}) => gce(Est(e), { logger: e.logger })),
      (Est = (e = {}) => {
        let t = !1,
          { logger: r, profile: o } = e,
          { timeout: n, maxRetries: i } = ig(e),
          a = async (c, d) => {
            if (t || d.headers?.[Ece] == null) {
              let l = !1,
                u = !1,
                h = await Wt(
                  {
                    environmentVariableSelector: (y) => {
                      let S = y[NN];
                      if (((u = !!S && S !== "false"), S === void 0))
                        throw new P(
                          `${NN} not set in env, checking config file next.`,
                          { logger: e.logger }
                        );
                      return u;
                    },
                    configFileSelector: (y) => {
                      let S = y[xce];
                      return (l = !!S && S !== "false"), l;
                    },
                    default: !1,
                  },
                  { profile: o }
                )();
              if (e.ec2MetadataV1Disabled || h) {
                let y = [];
                throw (
                  (e.ec2MetadataV1Disabled &&
                    y.push(
                      "credential provider initialization (runtime option ec2MetadataV1Disabled)"
                    ),
                  l && y.push(`config file profile (${xce})`),
                  u && y.push(`process environment variable (${NN})`),
                  new cC(
                    `AWS EC2 Metadata v1 fallback has been blocked by AWS SDK configuration in the following: [${y.join(", ")}].`
                  ))
                );
              }
            }
            let f = (
              await ag(async () => {
                let l;
                try {
                  l = await Cst(d);
                } catch (u) {
                  throw (u.statusCode === 401 && (t = !1), u);
                }
                return l;
              }, c)
            ).trim();
            return ag(async () => {
              let l;
              try {
                l = await bst(f, d, e);
              } catch (u) {
                throw (u.statusCode === 401 && (t = !1), u);
              }
              return l;
            }, c);
          };
        return async () => {
          let c = await dC();
          if (t)
            return (
              r?.debug(
                "AWS SDK Instance Metadata",
                "using v1 fallback (no token fetch)"
              ),
              a(i, { ...c, timeout: n })
            );
          {
            let d;
            try {
              d = (await Sst({ ...c, timeout: n })).toString();
            } catch (m) {
              if (m?.statusCode === 400)
                throw Object.assign(m, {
                  message: "EC2 Metadata token request returned error",
                });
              return (
                (m.message === "TimeoutError" ||
                  [403, 404, 405].includes(m.statusCode)) &&
                  (t = !0),
                r?.debug(
                  "AWS SDK Instance Metadata",
                  "using v1 fallback (initial)"
                ),
                a(i, { ...c, timeout: n })
              );
            }
            return a(i, { ...c, headers: { [Ece]: d }, timeout: n });
          }
        };
      }),
      (Sst = async (e) =>
        La({
          ...e,
          path: yst,
          method: "PUT",
          headers: { "x-aws-ec2-metadata-token-ttl-seconds": "21600" },
        })),
      (Cst = async (e) => (await La({ ...e, path: Sce })).toString()),
      (bst = async (e, t, r) => {
        let o = JSON.parse((await La({ ...t, path: Sce + e })).toString());
        if (!oC(o))
          throw new P(
            "Invalid response received from instance metadata service.",
            { logger: r.logger }
          );
        return nC(o);
      });
  });
var bce = s(() => {});
var cg = {};
It(cg, {
  DEFAULT_MAX_RETRIES: () => Mtr,
  DEFAULT_TIMEOUT: () => Btr,
  ENV_CMDS_AUTH_TOKEN: () => PN,
  ENV_CMDS_FULL_URI: () => iC,
  ENV_CMDS_RELATIVE_URI: () => aC,
  Endpoint: () => dd,
  fromContainerMetadata: () => nst,
  fromInstanceMetadata: () => xst,
  getInstanceMetadataEndpoint: () => dC,
  httpRequest: () => La,
  providerConfigFromInit: () => ig,
});
var dg = s(() => {
  dce();
  Cce();
  sC();
  bce();
  rC();
  kN();
  vN();
});
var _ce = s(() => {});
var wce = s(() => {
  _ce();
});
var Tce = s(() => {});
var Ace,
  Rce = s(() => {
    (function (e) {
      (e.HEADER = "header"), (e.QUERY = "query");
    })(Ace || (Ace = {}));
  });
var Ice,
  Pce = s(() => {
    (function (e) {
      (e.HEADER = "header"), (e.QUERY = "query");
    })(Ice || (Ice = {}));
  });
var vce = s(() => {});
var Oce = s(() => {});
var kce = s(() => {});
var Dce = s(() => {});
var Nce = s(() => {
  Rce();
  Pce();
  vce();
  Oce();
  kce();
  Dce();
});
var Bce = s(() => {});
var Mce = s(() => {});
var Lce = s(() => {});
var Fce = s(() => {});
var Uce = s(() => {});
var $ce = s(() => {});
var Hce = s(() => {});
var zce = s(() => {
  Uce();
  $ce();
  Hce();
});
var qce = s(() => {});
var jce = s(() => {});
var Gce,
  Vce = s(() => {
    (function (e) {
      (e.HTTP = "http"), (e.HTTPS = "https");
    })(Gce || (Gce = {}));
  });
var Wce = s(() => {});
var Kce = s(() => {});
var Yce = s(() => {});
var Qce = s(() => {});
var Xce = s(() => {});
var Jce = s(() => {
  Wce();
  Kce();
  Yce();
  Qce();
  Xce();
});
var Zce = s(() => {});
var mC,
  BN = s(() => {
    (function (e) {
      (e.MD5 = "md5"),
        (e.CRC32 = "crc32"),
        (e.CRC32C = "crc32c"),
        (e.SHA1 = "sha1"),
        (e.SHA256 = "sha256");
    })(mC || (mC = {}));
  });
var ede = s(() => {
  BN();
});
var tde = s(() => {});
var rde = s(() => {
  ede();
  tde();
  BN();
});
var ode = s(() => {});
var MN,
  nde = s(() => {
    (function (e) {
      (e[(e.HEADER = 0)] = "HEADER"), (e[(e.TRAILER = 1)] = "TRAILER");
    })(MN || (MN = {}));
  });
var sde = s(() => {});
var ide = s(() => {});
var ade = s(() => {});
var cde = s(() => {});
var dde = s(() => {});
var mde = s(() => {
  ide();
  ade();
  cde();
  dde();
});
var lde = s(() => {});
var fde = s(() => {});
var ude = s(() => {});
var pde,
  hde = s(() => {
    (function (e) {
      (e.PROFILE = "profile"),
        (e.SSO_SESSION = "sso-session"),
        (e.SERVICES = "services");
    })(pde || (pde = {}));
  });
var gde = s(() => {});
var yde = s(() => {});
var xde = s(() => {});
var Ede = s(() => {});
var Sde = s(() => {});
var Cde = s(() => {});
var bde = s(() => {});
var _de = s(() => {});
var wde = s(() => {});
var Tde = s(() => {});
var Ade = s(() => {});
var Rde,
  Ide = s(() => {
    (function (e) {
      (e.HTTP_0_9 = "http/0.9"),
        (e.HTTP_1_0 = "http/1.0"),
        (e.TDS_8_0 = "tds/8.0");
    })(Rde || (Rde = {}));
  });
var Pde = s(() => {});
var vde = s(() => {});
var Ode = s(() => {});
var kde = s(() => {});
var Dde = s(() => {});
var Nde = s(() => {});
var Bde = s(() => {});
var lC = s(() => {
  Tce();
  Nce();
  Bce();
  Mce();
  Lce();
  Fce();
  zce();
  qce();
  jce();
  Vce();
  Jce();
  Zce();
  rde();
  ode();
  nde();
  sde();
  mde();
  lde();
  fde();
  ude();
  hde();
  gde();
  yde();
  xde();
  Ede();
  Sde();
  Cde();
  bde();
  _de();
  wde();
  Tde();
  Ade();
  Ide();
  Pde();
  vde();
  Ode();
  kde();
  Dde();
  Nde();
  Bde();
});
var Mde = s(() => {
  lC();
});
var Lde = s(() => {});
var Fde = s(() => {});
function _st(e) {
  return Object.keys(e).reduce((t, r) => {
    let o = e[r];
    return { ...t, [r]: Array.isArray(o) ? [...o] : o };
  }, {});
}
var fC,
  Ude = s(() => {
    fC = class e {
      constructor(t) {
        (this.method = t.method || "GET"),
          (this.hostname = t.hostname || "localhost"),
          (this.port = t.port),
          (this.query = t.query || {}),
          (this.headers = t.headers || {}),
          (this.body = t.body),
          (this.protocol = t.protocol
            ? t.protocol.slice(-1) !== ":"
              ? `${t.protocol}:`
              : t.protocol
            : "https:"),
          (this.path = t.path
            ? t.path.charAt(0) !== "/"
              ? `/${t.path}`
              : t.path
            : "/"),
          (this.username = t.username),
          (this.password = t.password),
          (this.fragment = t.fragment);
      }
      static clone(t) {
        let r = new e({ ...t, headers: { ...t.headers } });
        return r.query && (r.query = _st(r.query)), r;
      }
      static isInstance(t) {
        if (!t) return !1;
        let r = t;
        return (
          "method" in r &&
          "protocol" in r &&
          "hostname" in r &&
          "path" in r &&
          typeof r.query == "object" &&
          typeof r.headers == "object"
        );
      }
      clone() {
        return e.clone(this);
      }
    };
  });
var Fl,
  $de = s(() => {
    Fl = class {
      constructor(t) {
        (this.statusCode = t.statusCode),
          (this.reason = t.reason),
          (this.headers = t.headers || {}),
          (this.body = t.body);
      }
      static isInstance(t) {
        if (!t) return !1;
        let r = t;
        return typeof r.statusCode == "number" && typeof r.headers == "object";
      }
    };
  });
var Hde = s(() => {});
var zde = s(() => {});
var mg = s(() => {
  wce();
  Mde();
  Lde();
  Fde();
  Ude();
  $de();
  Hde();
  zde();
});
var lg,
  wst,
  LN = s(() => {
    (lg = (e) => encodeURIComponent(e).replace(/[!'()*]/g, wst)),
      (wst = (e) => `%${e.charCodeAt(0).toString(16).toUpperCase()}`);
  });
var qde = s(() => {
  LN();
});
var jde = s(() => {
  LN();
  qde();
});
function uC(e) {
  let t = [];
  for (let r of Object.keys(e).sort()) {
    let o = e[r];
    if (((r = lg(r)), Array.isArray(o)))
      for (let n = 0, i = o.length; n < i; n++) t.push(`${r}=${lg(o[n])}`);
    else {
      let n = r;
      (o || typeof o == "string") && (n += `=${lg(o)}`), t.push(n);
    }
  }
  return t.join("&");
}
var pC = s(() => {
  jde();
});
var Gde,
  Vde = s(() => {
    Gde = ["ECONNRESET", "EPIPE", "ETIMEDOUT"];
  });
var FN,
  UN = s(() => {
    FN = (e) => {
      let t = {};
      for (let r of Object.keys(e)) {
        let o = e[r];
        t[r] = Array.isArray(o) ? o.join(",") : o;
      }
      return t;
    };
  });
var Zr,
  Ul = s(() => {
    Zr = {
      setTimeout: (e, t) => setTimeout(e, t),
      clearTimeout: (e) => clearTimeout(e),
    };
  });
var Wde,
  Kde,
  Yde = s(() => {
    Ul();
    (Wde = 1e3),
      (Kde = (e, t, r = 0) => {
        if (!r) return -1;
        let o = (n) => {
          let i = Zr.setTimeout(() => {
              e.destroy(),
                t(
                  Object.assign(
                    new Error(
                      `Socket timed out without establishing a connection within ${r} ms`
                    ),
                    { name: "TimeoutError" }
                  )
                );
            }, r - n),
            a = (c) => {
              c?.connecting
                ? c.on("connect", () => {
                    Zr.clearTimeout(i);
                  })
                : Zr.clearTimeout(i);
            };
          e.socket ? a(e.socket) : e.on("socket", a);
        };
        return r < 2e3 ? (o(0), 0) : Zr.setTimeout(o.bind(null, Wde), Wde);
      });
  });
var Tst,
  Qde,
  Xde = s(() => {
    Ul();
    (Tst = 3e3),
      (Qde = (e, { keepAlive: t, keepAliveMsecs: r }, o = Tst) => {
        if (t !== !0) return -1;
        let n = () => {
          e.socket
            ? e.socket.setKeepAlive(t, r || 0)
            : e.on("socket", (i) => {
                i.setKeepAlive(t, r || 0);
              });
        };
        return o === 0 ? (n(), 0) : Zr.setTimeout(n, o);
      });
  });
var Jde,
  Zde,
  eme = s(() => {
    $N();
    Ul();
    (Jde = 3e3),
      (Zde = (e, t, r = tme) => {
        let o = (n) => {
          let i = r - n,
            a = () => {
              e.destroy(),
                t(
                  Object.assign(
                    new Error(`Connection timed out after ${r} ms`),
                    { name: "TimeoutError" }
                  )
                );
            };
          e.socket
            ? (e.socket.setTimeout(i, a),
              e.on("close", () => e.socket?.removeListener("timeout", a)))
            : e.setTimeout(i, a);
        };
        return 0 < r && r < 6e3
          ? (o(0), 0)
          : Zr.setTimeout(o.bind(null, r === 0 ? 0 : Jde), Jde);
      });
  });
import { Readable as Ast } from "stream";
async function HN(e, t, r = rme) {
  let o = t.headers ?? {},
    n = o.Expect || o.expect,
    i = -1,
    a = !0;
  n === "100-continue" &&
    (a = await Promise.race([
      new Promise((c) => {
        i = Number(Zr.setTimeout(() => c(!0), Math.max(rme, r)));
      }),
      new Promise((c) => {
        e.on("continue", () => {
          Zr.clearTimeout(i), c(!0);
        }),
          e.on("response", () => {
            Zr.clearTimeout(i), c(!1);
          }),
          e.on("error", () => {
            Zr.clearTimeout(i), c(!1);
          });
      }),
    ])),
    a && Rst(e, t.body);
}
function Rst(e, t) {
  if (t instanceof Ast) {
    t.pipe(e);
    return;
  }
  if (t) {
    if (Buffer.isBuffer(t) || typeof t == "string") {
      e.end(t);
      return;
    }
    let r = t;
    if (
      typeof r == "object" &&
      r.buffer &&
      typeof r.byteOffset == "number" &&
      typeof r.byteLength == "number"
    ) {
      e.end(Buffer.from(r.buffer, r.byteOffset, r.byteLength));
      return;
    }
    e.end(Buffer.from(t));
    return;
  }
  e.end();
}
var rme,
  zN = s(() => {
    Ul();
    rme = 6e3;
  });
import { Agent as ome, request as Ist } from "http";
import { Agent as nme, request as Pst } from "https";
var tme,
  hC,
  $N = s(() => {
    mg();
    pC();
    Vde();
    UN();
    Yde();
    Xde();
    eme();
    Ul();
    zN();
    (tme = 0),
      (hC = class e {
        static create(t) {
          return typeof t?.handle == "function" ? t : new e(t);
        }
        static checkSocketUsage(t, r, o = console) {
          let { sockets: n, requests: i, maxSockets: a } = t;
          if (typeof a != "number" || a === 1 / 0 || Date.now() - 15e3 < r)
            return r;
          if (n && i)
            for (let d in n) {
              let m = n[d]?.length ?? 0,
                f = i[d]?.length ?? 0;
              if (m >= a && f >= 2 * a)
                return (
                  o?.warn?.(`@smithy/node-http-handler:WARN - socket usage at capacity=${m} and ${f} additional requests are enqueued.
See https://docs.aws.amazon.com/sdk-for-javascript/v3/developer-guide/node-configuring-maxsockets.html
or increase socketAcquisitionWarningTimeout=(millis) in the NodeHttpHandler config.`),
                  Date.now()
                );
            }
          return r;
        }
        constructor(t) {
          (this.socketWarningTimestamp = 0),
            (this.metadata = { handlerProtocol: "http/1.1" }),
            (this.configProvider = new Promise((r, o) => {
              typeof t == "function"
                ? t()
                    .then((n) => {
                      r(this.resolveDefaultConfig(n));
                    })
                    .catch(o)
                : r(this.resolveDefaultConfig(t));
            }));
        }
        resolveDefaultConfig(t) {
          let {
              requestTimeout: r,
              connectionTimeout: o,
              socketTimeout: n,
              socketAcquisitionWarningTimeout: i,
              httpAgent: a,
              httpsAgent: c,
            } = t || {},
            d = !0,
            m = 50;
          return {
            connectionTimeout: o,
            requestTimeout: r ?? n,
            socketAcquisitionWarningTimeout: i,
            httpAgent:
              a instanceof ome || typeof a?.destroy == "function"
                ? a
                : new ome({ keepAlive: d, maxSockets: m, ...a }),
            httpsAgent:
              c instanceof nme || typeof c?.destroy == "function"
                ? c
                : new nme({ keepAlive: d, maxSockets: m, ...c }),
            logger: console,
          };
        }
        destroy() {
          this.config?.httpAgent?.destroy(), this.config?.httpsAgent?.destroy();
        }
        async handle(t, { abortSignal: r } = {}) {
          return (
            this.config || (this.config = await this.configProvider),
            new Promise((o, n) => {
              let i,
                a = [],
                c = async (I) => {
                  await i, a.forEach(Zr.clearTimeout), o(I);
                },
                d = async (I) => {
                  await i, a.forEach(Zr.clearTimeout), n(I);
                };
              if (!this.config)
                throw new Error(
                  "Node HTTP request handler config is not resolved"
                );
              if (r?.aborted) {
                let I = new Error("Request aborted");
                (I.name = "AbortError"), d(I);
                return;
              }
              let m = t.protocol === "https:",
                f = m ? this.config.httpsAgent : this.config.httpAgent;
              a.push(
                Zr.setTimeout(
                  () => {
                    this.socketWarningTimestamp = e.checkSocketUsage(
                      f,
                      this.socketWarningTimestamp,
                      this.config.logger
                    );
                  },
                  this.config.socketAcquisitionWarningTimeout ??
                    (this.config.requestTimeout ?? 2e3) +
                      (this.config.connectionTimeout ?? 1e3)
                )
              );
              let l = uC(t.query || {}),
                u;
              if (t.username != null || t.password != null) {
                let I = t.username ?? "",
                  O = t.password ?? "";
                u = `${I}:${O}`;
              }
              let h = t.path;
              l && (h += `?${l}`), t.fragment && (h += `#${t.fragment}`);
              let y = t.hostname ?? "";
              y[0] === "[" && y.endsWith("]")
                ? (y = t.hostname.slice(1, -1))
                : (y = t.hostname);
              let S = {
                  headers: t.headers,
                  host: y,
                  method: t.method,
                  path: h,
                  port: t.port,
                  agent: f,
                  auth: u,
                },
                b = (m ? Pst : Ist)(S, (I) => {
                  let O = new Fl({
                    statusCode: I.statusCode || -1,
                    reason: I.statusMessage,
                    headers: FN(I.headers),
                    body: I,
                  });
                  c({ response: O });
                });
              if (
                (b.on("error", (I) => {
                  Gde.includes(I.code)
                    ? d(Object.assign(I, { name: "TimeoutError" }))
                    : d(I);
                }),
                r)
              ) {
                let I = () => {
                  b.destroy();
                  let O = new Error("Request aborted");
                  (O.name = "AbortError"), d(O);
                };
                if (typeof r.addEventListener == "function") {
                  let O = r;
                  O.addEventListener("abort", I, { once: !0 }),
                    b.once("close", () => O.removeEventListener("abort", I));
                } else r.onabort = I;
              }
              a.push(Kde(b, d, this.config.connectionTimeout)),
                a.push(Zde(b, d, this.config.requestTimeout));
              let v = S.agent;
              typeof v == "object" &&
                "keepAlive" in v &&
                a.push(
                  Qde(b, {
                    keepAlive: v.keepAlive,
                    keepAliveMsecs: v.keepAliveMsecs,
                  })
                ),
                (i = HN(b, t, this.config.requestTimeout).catch(
                  (I) => (a.forEach(Zr.clearTimeout), n(I))
                ));
            })
          );
        }
        updateHttpClientConfig(t, r) {
          (this.config = void 0),
            (this.configProvider = this.configProvider.then((o) => ({
              ...o,
              [t]: r,
            })));
        }
        httpHandlerConfigs() {
          return this.config ?? {};
        }
      });
  });
var sme = s(() => {});
var ime = s(() => {
  sme();
});
var ame = s(() => {
  mg();
  pC();
  UN();
  ime();
  zN();
});
import { Writable as vst } from "stream";
var gC,
  cme = s(() => {
    gC = class extends vst {
      constructor() {
        super(...arguments), (this.bufferedBytes = []);
      }
      _write(t, r, o) {
        this.bufferedBytes.push(t), o();
      }
    };
  });
async function kst(e) {
  let t = [],
    r = e.getReader(),
    o = !1,
    n = 0;
  for (; !o; ) {
    let { done: c, value: d } = await r.read();
    d && (t.push(d), (n += d.length)), (o = c);
  }
  let i = new Uint8Array(n),
    a = 0;
  for (let c of t) i.set(c, a), (a += c.length);
  return i;
}
var dme,
  Ost,
  mme = s(() => {
    cme();
    (dme = (e) =>
      Ost(e)
        ? kst(e)
        : new Promise((t, r) => {
            let o = new gC();
            e.pipe(o),
              e.on("error", (n) => {
                o.end(), r(n);
              }),
              o.on("error", r),
              o.on("finish", function () {
                let n = new Uint8Array(Buffer.concat(this.bufferedBytes));
                t(n);
              });
          })),
      (Ost = (e) =>
        typeof ReadableStream == "function" && e instanceof ReadableStream);
  });
var qN = s(() => {
  $N();
  ame();
  mme();
});
var Dst,
  Nst,
  Bst,
  lme,
  fme = s(() => {
    re();
    (Dst = "169.254.170.2"),
      (Nst = "169.254.170.23"),
      (Bst = "[fd00:ec2::23]"),
      (lme = (e, t) => {
        if (
          e.protocol !== "https:" &&
          !(e.hostname === Dst || e.hostname === Nst || e.hostname === Bst)
        ) {
          if (e.hostname.includes("[")) {
            if (
              e.hostname === "[::1]" ||
              e.hostname === "[0000:0000:0000:0000:0000:0000:0000:0001]"
            )
              return;
          } else {
            if (e.hostname === "localhost") return;
            let r = e.hostname.split("."),
              o = (n) => {
                let i = parseInt(n, 10);
                return 0 <= i && i <= 255;
              };
            if (
              r[0] === "127" &&
              o(r[1]) &&
              o(r[2]) &&
              o(r[3]) &&
              r.length === 4
            )
              return;
          }
          throw new P(
            `URL not accepted. It must either be HTTPS or match one of the following:
  - loopback CIDR 127.0.0.0/8 or [::1/128]
  - ECS container host 169.254.170.2
  - EKS container host 169.254.170.23 or [fd00:ec2::23]`,
            { logger: t }
          );
        }
      });
  });
var ume = s(() => {});
var jN = s(() => {
  ume();
});
var pme = s(() => {
  jN();
});
var hme = s(() => {
  Dt();
});
var gme = s(() => {
  jN();
  lC();
});
var yme = s(() => {});
var xme = s(() => {});
var GN = s(() => {});
var Eme = s(() => {
  GN();
});
var Sme = s(() => {});
var Cme = s(() => {});
var bme = s(() => {
  Dt();
});
var _me = s(() => {
  lC();
});
var wme = s(() => {});
var Tme = s(() => {
  _me();
  wme();
});
var Ame = s(() => {
  Tme();
});
var Rme = s(() => {});
var Ime = s(() => {});
var Pme = s(() => {});
var vme = s(() => {});
var Ome = s(() => {});
var kme = s(() => {
  Dt();
});
var Dme = s(() => {});
var Nme = s(() => {});
var Bme = s(() => {
  pme();
  hme();
  gme();
  yme();
  xme();
  Eme();
  Sme();
  Cme();
  GN();
  bme();
  Ame();
  Rme();
  Ime();
  Pme();
  vme();
  Ome();
  kme();
  Dme();
  Nme();
  Uo();
});
import { Buffer as VN } from "buffer";
var $l,
  yC,
  Hl = s(() => {
    cr();
    ($l = (e, t = 0, r = e.byteLength - t) => {
      if (!Ke(e))
        throw new TypeError(
          `The "input" argument must be ArrayBuffer. Received type ${typeof e} (${e})`
        );
      return VN.from(e, t, r);
    }),
      (yC = (e, t) => {
        if (typeof e != "string")
          throw new TypeError(
            `The "input" argument must be of type string. Received type ${typeof e} (${e})`
          );
        return t ? VN.from(e, t) : VN.from(e);
      });
  });
var Lst,
  WN,
  Mme = s(() => {
    Hl();
    (Lst = /^[A-Za-z0-9+/]*={0,2}$/),
      (WN = (e) => {
        if ((e.length * 3) % 4 !== 0)
          throw new TypeError("Incorrect padding on base64 string.");
        if (!Lst.exec(e)) throw new TypeError("Invalid base64 string.");
        let t = yC(e, "base64");
        return new Uint8Array(t.buffer, t.byteOffset, t.byteLength);
      });
  });
var xC,
  KN = s(() => {
    Hl();
    xC = (e) => {
      let t = yC(e, "utf8");
      return new Uint8Array(
        t.buffer,
        t.byteOffset,
        t.byteLength / Uint8Array.BYTES_PER_ELEMENT
      );
    };
  });
var Lme = s(() => {
  KN();
});
var YN,
  Fme = s(() => {
    Hl();
    YN = (e) => {
      if (typeof e == "string") return e;
      if (
        typeof e != "object" ||
        typeof e.byteOffset != "number" ||
        typeof e.byteLength != "number"
      )
        throw new Error(
          "@smithy/util-utf8: toUtf8 encoder function only accepts string | Uint8Array."
        );
      return $l(e.buffer, e.byteOffset, e.byteLength).toString("utf8");
    };
  });
var EC = s(() => {
  KN();
  Lme();
  Fme();
});
var fg,
  Ume = s(() => {
    Hl();
    EC();
    fg = (e) => {
      let t;
      if (
        (typeof e == "string" ? (t = xC(e)) : (t = e),
        typeof t != "object" ||
          typeof t.byteOffset != "number" ||
          typeof t.byteLength != "number")
      )
        throw new Error(
          "@smithy/util-base64: toBase64 encoder function only accepts string | Uint8Array."
        );
      return $l(t.buffer, t.byteOffset, t.byteLength).toString("base64");
    };
  });
var zl = s(() => {
  Mme();
  Ume();
});
var $me = s(() => {
  zl();
  EC();
  QN();
});
var QN = s(() => {
  $me();
});
var XN = s(() => {
  zl();
});
var Ua,
  $a = s(() => {
    Ua = (e) =>
      typeof ReadableStream == "function" &&
      (e?.constructor?.name === ReadableStream.name ||
        e instanceof ReadableStream);
  });
var Hme = s(() => {});
var zme = s(() => {
  zl();
  $a();
  Hme();
});
var qme = s(() => {
  $a();
  XN();
  zme();
});
var JN = s(() => {});
var jme = s(() => {
  JN();
});
var Gme = s(() => {
  JN();
  jme();
  $a();
});
var Vme = s(() => {});
var Wme = s(() => {});
var Kme = s(() => {
  Wme();
  $a();
});
var Yme = s(() => {});
var Qme = s(() => {});
var Xme = s(() => {
  mg();
  pC();
  Yme();
  Qme();
});
async function Ust(e) {
  let t = await Hst(e),
    r = WN(t);
  return new Uint8Array(r);
}
async function $st(e) {
  let t = [],
    r = e.getReader(),
    o = !1,
    n = 0;
  for (; !o; ) {
    let { done: c, value: d } = await r.read();
    d && (t.push(d), (n += d.length)), (o = c);
  }
  let i = new Uint8Array(n),
    a = 0;
  for (let c of t) i.set(c, a), (a += c.length);
  return i;
}
function Hst(e) {
  return new Promise((t, r) => {
    let o = new FileReader();
    (o.onloadend = () => {
      if (o.readyState !== 2) return r(new Error("Reader aborted too early"));
      let n = o.result ?? "",
        i = n.indexOf(","),
        a = i > -1 ? i + 1 : n.length;
      t(n.substring(a));
    }),
      (o.onabort = () => r(new Error("Read aborted"))),
      (o.onerror = () => r(o.error)),
      o.readAsDataURL(e);
  });
}
var Jme,
  Zme = s(() => {
    zl();
    Jme = async (e) =>
      (typeof Blob == "function" && e instanceof Blob) ||
      e.constructor?.name === "Blob"
        ? Blob.prototype.arrayBuffer !== void 0
          ? new Uint8Array(await e.arrayBuffer())
          : Ust(e)
        : $st(e);
  });
var ele = s(() => {
  Xme();
  Zme();
});
var tle,
  ole,
  rle,
  nle = s(() => {
    ele();
    zl();
    Fo();
    EC();
    $a();
    (tle = "The stream has already been transformed."),
      (ole = (e) => {
        if (!rle(e) && !Ua(e)) {
          let n = e?.__proto__?.constructor?.name || e;
          throw new Error(
            `Unexpected stream implementation, expect Blob or ReadableStream, got ${n}`
          );
        }
        let t = !1,
          r = async () => {
            if (t) throw new Error(tle);
            return (t = !0), await Jme(e);
          },
          o = (n) => {
            if (typeof n.stream != "function")
              throw new Error(`Cannot transform payload Blob to web stream. Please make sure the Blob.stream() is polyfilled.
If you are using React Native, this API is not yet supported, see: https://react-native.canny.io/feature-requests/p/fetch-streaming-body`);
            return n.stream();
          };
        return Object.assign(e, {
          transformToByteArray: r,
          transformToString: async (n) => {
            let i = await r();
            if (n === "base64") return fg(i);
            if (n === "hex") return _t(i);
            if (n === void 0 || n === "utf8" || n === "utf-8") return YN(i);
            if (typeof TextDecoder == "function")
              return new TextDecoder(n).decode(i);
            throw new Error(
              "TextDecoder is not available, please make sure polyfill is provided."
            );
          },
          transformToWebStream: () => {
            if (t) throw new Error(tle);
            if (((t = !0), rle(e))) return o(e);
            if (Ua(e)) return e;
            throw new Error(`Cannot transform payload to web stream, got ${e}`);
          },
        });
      }),
      (rle = (e) => typeof Blob == "function" && e instanceof Blob);
  });
import { Readable as ZN } from "stream";
var sle,
  ile,
  ale = s(() => {
    qN();
    Hl();
    nle();
    (sle = "The stream has already been transformed."),
      (ile = (e) => {
        if (!(e instanceof ZN))
          try {
            return ole(e);
          } catch {
            let n = e?.__proto__?.constructor?.name || e;
            throw new Error(
              `Unexpected stream implementation, expect Stream.Readable instance, got ${n}`
            );
          }
        let t = !1,
          r = async () => {
            if (t) throw new Error(sle);
            return (t = !0), await dme(e);
          };
        return Object.assign(e, {
          transformToByteArray: r,
          transformToString: async (o) => {
            let n = await r();
            return o === void 0 || Buffer.isEncoding(o)
              ? $l(n.buffer, n.byteOffset, n.byteLength).toString(o)
              : new TextDecoder(o).decode(n);
          },
          transformToWebStream: () => {
            if (t) throw new Error(sle);
            if (e.readableFlowing !== null)
              throw new Error(
                "The stream has been consumed by other callbacks."
              );
            if (typeof ZN.toWeb != "function")
              throw new Error(
                "Readable.toWeb() is not supported. Please ensure a polyfill is available."
              );
            return (t = !0), ZN.toWeb(e);
          },
        });
      });
  });
var cle = s(() => {});
var dle = s(() => {
  cle();
  $a();
});
var mle = s(() => {
  QN();
  XN();
  qme();
  Gme();
  Vme();
  Kme();
  ale();
  dle();
  $a();
});
function lle(e) {
  return new fC({
    protocol: e.protocol,
    hostname: e.hostname,
    port: Number(e.port),
    path: e.pathname,
    query: Array.from(e.searchParams.entries()).reduce(
      (t, [r, o]) => ((t[r] = o), t),
      {}
    ),
    fragment: e.hash,
  });
}
async function fle(e, t) {
  let o = await ile(e.body).transformToString();
  if (e.statusCode === 200) {
    let n = JSON.parse(o);
    if (
      typeof n.AccessKeyId != "string" ||
      typeof n.SecretAccessKey != "string" ||
      typeof n.Token != "string" ||
      typeof n.Expiration != "string"
    )
      throw new P(
        "HTTP credential provider response not of the required format, an object matching: { AccessKeyId: string, SecretAccessKey: string, Token: string, Expiration: string(rfc3339) }",
        { logger: t }
      );
    return {
      accessKeyId: n.AccessKeyId,
      secretAccessKey: n.SecretAccessKey,
      sessionToken: n.Token,
      expiration: KY(n.Expiration),
    };
  }
  if (e.statusCode >= 400 && e.statusCode < 500) {
    let n = {};
    try {
      n = JSON.parse(o);
    } catch {}
    throw Object.assign(
      new P(`Server responded with status: ${e.statusCode}`, { logger: t }),
      { Code: n.Code, Message: n.Message }
    );
  }
  throw new P(`Server responded with status: ${e.statusCode}`, { logger: t });
}
var ule = s(() => {
  re();
  mg();
  Bme();
  mle();
});
var ple,
  hle = s(() => {
    ple = (e, t, r) => async () => {
      for (let o = 0; o < t; ++o)
        try {
          return await e();
        } catch {
          await new Promise((i) => setTimeout(i, r));
        }
      return await e();
    };
  });
import zst from "fs/promises";
var qst,
  jst,
  Gst,
  Vst,
  Wst,
  gle,
  yle = s(() => {
    xt();
    qN();
    re();
    fme();
    ule();
    hle();
    (qst = "AWS_CONTAINER_CREDENTIALS_RELATIVE_URI"),
      (jst = "http://169.254.170.2"),
      (Gst = "AWS_CONTAINER_CREDENTIALS_FULL_URI"),
      (Vst = "AWS_CONTAINER_AUTHORIZATION_TOKEN_FILE"),
      (Wst = "AWS_CONTAINER_AUTHORIZATION_TOKEN"),
      (gle = (e = {}) => {
        e.logger?.debug("@aws-sdk/credential-provider-http - fromHttp");
        let t,
          r = e.awsContainerCredentialsRelativeUri ?? process.env[qst],
          o = e.awsContainerCredentialsFullUri ?? process.env[Gst],
          n = e.awsContainerAuthorizationToken ?? process.env[Wst],
          i = e.awsContainerAuthorizationTokenFile ?? process.env[Vst],
          a =
            e.logger?.constructor?.name === "NoOpLogger" || !e.logger
              ? console.warn
              : e.logger.warn;
        if (
          (r &&
            o &&
            (a(
              "@aws-sdk/credential-provider-http: you have set both awsContainerCredentialsRelativeUri and awsContainerCredentialsFullUri."
            ),
            a("awsContainerCredentialsFullUri will take precedence.")),
          n &&
            i &&
            (a(
              "@aws-sdk/credential-provider-http: you have set both awsContainerAuthorizationToken and awsContainerAuthorizationTokenFile."
            ),
            a("awsContainerAuthorizationToken will take precedence.")),
          o)
        )
          t = o;
        else if (r) t = `${jst}${r}`;
        else
          throw new P(
            `No HTTP credential provider host provided.
Set AWS_CONTAINER_CREDENTIALS_FULL_URI or AWS_CONTAINER_CREDENTIALS_RELATIVE_URI.`,
            { logger: e.logger }
          );
        let c = new URL(t);
        lme(c, e.logger);
        let d = new hC({
          requestTimeout: e.timeout ?? 1e3,
          connectionTimeout: e.timeout ?? 1e3,
        });
        return ple(
          async () => {
            let m = lle(c);
            n
              ? (m.headers.Authorization = n)
              : i &&
                (m.headers.Authorization = (await zst.readFile(i)).toString());
            try {
              let f = await d.handle(m);
              return fle(f.response).then((l) =>
                ce(l, "CREDENTIALS_HTTP", "z")
              );
            } catch (f) {
              throw new P(String(f), { logger: e.logger });
            }
          },
          e.maxRetries ?? 3,
          e.timeout ?? 1e3
        );
      });
  });
var md = {};
It(md, { fromHttp: () => gle });
var ld = s(() => {
  yle();
});
var xle,
  Ele,
  Sle = s(() => {
    re();
    (xle = "AWS_EC2_METADATA_DISABLED"),
      (Ele = async (e) => {
        let {
          ENV_CMDS_FULL_URI: t,
          ENV_CMDS_RELATIVE_URI: r,
          fromContainerMetadata: o,
          fromInstanceMetadata: n,
        } = await Promise.resolve().then(() => (dg(), cg));
        if (process.env[r] || process.env[t]) {
          e.logger?.debug(
            "@aws-sdk/credential-provider-node - remoteProvider::fromHttp/fromContainerMetadata"
          );
          let { fromHttp: i } = await Promise.resolve().then(() => (ld(), md));
          return Ht(i(e), o(e));
        }
        return process.env[xle] && process.env[xle] !== "false"
          ? async () => {
              throw new P("EC2 Instance Metadata Service access disabled", {
                logger: e.logger,
              });
            }
          : (e.logger?.debug(
              "@aws-sdk/credential-provider-node - remoteProvider::fromInstanceMetadata"
            ),
            n(e));
      });
  });
var eB,
  tB = s(() => {
    eB = (e) =>
      e &&
      (typeof e.sso_start_url == "string" ||
        typeof e.sso_account_id == "string" ||
        typeof e.sso_session == "string" ||
        typeof e.sso_region == "string" ||
        typeof e.sso_role_name == "string");
  });
var Cle = s(() => {
  re();
});
var ql,
  SC = s(() => {
    ql =
      "To refresh this SSO session run 'aws sso login' with the corresponding profile.";
  });
var CC,
  bC,
  ble = s(() => {
    (CC = (e) => ({
      setHttpHandler(t) {
        e.httpHandler = t;
      },
      httpHandler() {
        return e.httpHandler;
      },
      updateHttpClientConfig(t, r) {
        e.httpHandler?.updateHttpClientConfig(t, r);
      },
      httpHandlerConfigs() {
        return e.httpHandler.httpHandlerConfigs();
      },
    })),
      (bC = (e) => ({ httpHandler: e.httpHandler() }));
  });
var _le = s(() => {
  ble();
});
var wle = s(() => {});
var Tle,
  Ale = s(() => {
    (function (e) {
      (e.HEADER = "header"), (e.QUERY = "query");
    })(Tle || (Tle = {}));
  });
var Rle,
  Ile = s(() => {
    (function (e) {
      (e.HEADER = "header"), (e.QUERY = "query");
    })(Rle || (Rle = {}));
  });
var Ple = s(() => {});
var vle = s(() => {});
var Ole = s(() => {});
var kle = s(() => {});
var Dle = s(() => {
  Ale();
  Ile();
  Ple();
  vle();
  Ole();
  kle();
});
var Nle = s(() => {});
var Ble = s(() => {});
var Mle = s(() => {});
var Lle = s(() => {});
var Fle = s(() => {});
var Ule = s(() => {});
var $le = s(() => {});
var Hle = s(() => {
  Fle();
  Ule();
  $le();
});
var zle = s(() => {});
var qle = s(() => {});
var jle,
  Gle = s(() => {
    (function (e) {
      (e.HTTP = "http"), (e.HTTPS = "https");
    })(jle || (jle = {}));
  });
var Vle = s(() => {});
var Wle = s(() => {});
var Kle = s(() => {});
var Yle = s(() => {});
var Qle = s(() => {});
var Xle = s(() => {
  Vle();
  Wle();
  Kle();
  Yle();
  Qle();
});
var Jle = s(() => {});
var jl,
  rB = s(() => {
    (function (e) {
      (e.MD5 = "md5"),
        (e.CRC32 = "crc32"),
        (e.CRC32C = "crc32c"),
        (e.SHA1 = "sha1"),
        (e.SHA256 = "sha256");
    })(jl || (jl = {}));
  });
var Zle = s(() => {
  rB();
});
var efe = s(() => {});
var tfe = s(() => {
  Zle();
  efe();
  rB();
});
var rfe = s(() => {});
var oB,
  ofe = s(() => {
    (function (e) {
      (e[(e.HEADER = 0)] = "HEADER"), (e[(e.TRAILER = 1)] = "TRAILER");
    })(oB || (oB = {}));
  });
var nfe = s(() => {});
var sfe = s(() => {});
var ife = s(() => {});
var afe = s(() => {});
var cfe = s(() => {});
var dfe = s(() => {
  sfe();
  ife();
  afe();
  cfe();
});
var mfe = s(() => {});
var lfe,
  ffe = s(() => {
    lfe = "__smithy_context";
  });
var ufe = s(() => {});
var Ha,
  pfe = s(() => {
    (function (e) {
      (e.PROFILE = "profile"),
        (e.SSO_SESSION = "sso-session"),
        (e.SERVICES = "services");
    })(Ha || (Ha = {}));
  });
var hfe = s(() => {});
var gfe = s(() => {});
var yfe = s(() => {});
var xfe = s(() => {});
var Efe = s(() => {});
var Sfe = s(() => {});
var Cfe = s(() => {});
var bfe = s(() => {});
var _fe = s(() => {});
var wfe = s(() => {});
var Tfe = s(() => {});
var Afe,
  Rfe = s(() => {
    (function (e) {
      (e.HTTP_0_9 = "http/0.9"),
        (e.HTTP_1_0 = "http/1.0"),
        (e.TDS_8_0 = "tds/8.0");
    })(Afe || (Afe = {}));
  });
var Ife = s(() => {});
var Pfe = s(() => {});
var vfe = s(() => {});
var Ofe = s(() => {});
var kfe = s(() => {});
var Dfe = s(() => {});
var Nfe = s(() => {});
var fd = s(() => {
  wle();
  Dle();
  Nle();
  Ble();
  Mle();
  Lle();
  Hle();
  zle();
  qle();
  Gle();
  Xle();
  Jle();
  tfe();
  rfe();
  ofe();
  nfe();
  dfe();
  mfe();
  ffe();
  ufe();
  pfe();
  hfe();
  gfe();
  yfe();
  xfe();
  Efe();
  Sfe();
  Cfe();
  bfe();
  _fe();
  wfe();
  Tfe();
  Rfe();
  Ife();
  Pfe();
  vfe();
  Ofe();
  kfe();
  Dfe();
  Nfe();
});
var Bfe = s(() => {
  fd();
});
var Mfe = s(() => {});
var Lfe = s(() => {});
function Kst(e) {
  return Object.keys(e).reduce((t, r) => {
    let o = e[r];
    return { ...t, [r]: Array.isArray(o) ? [...o] : o };
  }, {});
}
var jo,
  Ffe = s(() => {
    jo = class e {
      constructor(t) {
        (this.method = t.method || "GET"),
          (this.hostname = t.hostname || "localhost"),
          (this.port = t.port),
          (this.query = t.query || {}),
          (this.headers = t.headers || {}),
          (this.body = t.body),
          (this.protocol = t.protocol
            ? t.protocol.slice(-1) !== ":"
              ? `${t.protocol}:`
              : t.protocol
            : "https:"),
          (this.path = t.path
            ? t.path.charAt(0) !== "/"
              ? `/${t.path}`
              : t.path
            : "/"),
          (this.username = t.username),
          (this.password = t.password),
          (this.fragment = t.fragment);
      }
      static clone(t) {
        let r = new e({ ...t, headers: { ...t.headers } });
        return r.query && (r.query = Kst(r.query)), r;
      }
      static isInstance(t) {
        if (!t) return !1;
        let r = t;
        return (
          "method" in r &&
          "protocol" in r &&
          "hostname" in r &&
          "path" in r &&
          typeof r.query == "object" &&
          typeof r.headers == "object"
        );
      }
      clone() {
        return e.clone(this);
      }
    };
  });
var di,
  Ufe = s(() => {
    di = class {
      constructor(t) {
        (this.statusCode = t.statusCode),
          (this.reason = t.reason),
          (this.headers = t.headers || {}),
          (this.body = t.body);
      }
      static isInstance(t) {
        if (!t) return !1;
        let r = t;
        return typeof r.statusCode == "number" && typeof r.headers == "object";
      }
    };
  });
var $fe = s(() => {});
var Hfe = s(() => {});
var yn = s(() => {
  _le();
  Bfe();
  Mfe();
  Lfe();
  Ffe();
  Ufe();
  $fe();
  Hfe();
});
var Yst,
  Qst,
  _C,
  nB = s(() => {
    yn();
    (Yst = (e) => (t) => async (r) => {
      if (!jo.isInstance(r.request)) return t(r);
      let { request: o } = r,
        { handlerProtocol: n = "" } = e.requestHandler.metadata || {};
      if (n.indexOf("h2") >= 0 && !o.headers[":authority"])
        delete o.headers.host,
          (o.headers[":authority"] = o.hostname + (o.port ? ":" + o.port : ""));
      else if (!o.headers.host) {
        let i = o.hostname;
        o.port != null && (i += `:${o.port}`), (o.headers.host = i);
      }
      return t(r);
    }),
      (Qst = {
        name: "hostHeaderMiddleware",
        step: "build",
        priority: "low",
        tags: ["HOST"],
        override: !0,
      }),
      (_C = (e) => ({
        applyToStack: (t) => {
          t.add(Yst(e), Qst);
        },
      }));
  });
var Xst,
  Jst,
  wC,
  zfe = s(() => {
    (Xst = () => (e, t) => async (r) => {
      try {
        let o = await e(r),
          {
            clientName: n,
            commandName: i,
            logger: a,
            dynamoDbDocumentClientOptions: c = {},
          } = t,
          {
            overrideInputFilterSensitiveLog: d,
            overrideOutputFilterSensitiveLog: m,
          } = c,
          f = d ?? t.inputFilterSensitiveLog,
          l = m ?? t.outputFilterSensitiveLog,
          { $metadata: u, ...h } = o.output;
        return (
          a?.info?.({
            clientName: n,
            commandName: i,
            input: f(r.input),
            output: l(h),
            metadata: u,
          }),
          o
        );
      } catch (o) {
        let {
            clientName: n,
            commandName: i,
            logger: a,
            dynamoDbDocumentClientOptions: c = {},
          } = t,
          { overrideInputFilterSensitiveLog: d } = c,
          m = d ?? t.inputFilterSensitiveLog;
        throw (
          (a?.error?.({
            clientName: n,
            commandName: i,
            input: m(r.input),
            error: o,
            metadata: o.$metadata,
          }),
          o)
        );
      }
    }),
      (Jst = {
        name: "loggerMiddleware",
        tags: ["LOGGER"],
        step: "initialize",
        override: !0,
      }),
      (wC = (e) => ({
        applyToStack: (t) => {
          t.add(Xst(), Jst);
        },
      }));
  });
var sB = s(() => {
  zfe();
});
var iB,
  Zst,
  eit,
  tit,
  rit,
  TC,
  aB = s(() => {
    yn();
    (iB = "X-Amzn-Trace-Id"),
      (Zst = "AWS_LAMBDA_FUNCTION_NAME"),
      (eit = "_X_AMZN_TRACE_ID"),
      (tit = (e) => (t) => async (r) => {
        let { request: o } = r;
        if (!jo.isInstance(o) || e.runtime !== "node") return t(r);
        let n =
          Object.keys(o.headers ?? {}).find(
            (d) => d.toLowerCase() === iB.toLowerCase()
          ) ?? iB;
        if (o.headers.hasOwnProperty(n)) return t(r);
        let i = process.env[Zst],
          a = process.env[eit],
          c = (d) => typeof d == "string" && d.length > 0;
        return c(i) && c(a) && (o.headers[iB] = a), t({ ...r, request: o });
      }),
      (rit = {
        step: "build",
        tags: ["RECURSION_DETECTION"],
        name: "recursionDetectionMiddleware",
        override: !0,
        priority: "low",
      }),
      (TC = (e) => ({
        applyToStack: (t) => {
          t.add(tit(e), rit);
        },
      }));
  });
function oit(e) {
  return e === void 0 ? !0 : typeof e == "string" && e.length <= 50;
}
function AC(e) {
  let t = rn(e.userAgentAppId ?? cB),
    { customUserAgent: r } = e;
  return Object.assign(e, {
    customUserAgent: typeof r == "string" ? [[r]] : r,
    userAgentAppId: async () => {
      let o = await t();
      if (!oit(o)) {
        let n =
          e.logger?.constructor?.name === "NoOpLogger" || !e.logger
            ? console
            : e.logger;
        typeof o != "string"
          ? n?.warn("userAgentAppId must be a string or undefined.")
          : o.length > 50 &&
            n?.warn(
              "The provided userAgentAppId exceeds the maximum length of 50 characters."
            );
      }
      return o;
    },
  });
}
var cB,
  qfe = s(() => {
    Ue();
    cB = void 0;
  });
var dB = s(() => {
  $t();
});
var mB,
  jfe = s(() => {
    $t();
    dB();
    mB = (e, t = !1) => {
      if (t) {
        for (let r of e.split(".")) if (!mB(r)) return !1;
        return !0;
      }
      return !(
        !Ms(e) ||
        e.length < 3 ||
        e.length > 63 ||
        e !== e.toLowerCase() ||
        gn(e)
      );
    };
  });
var Gfe,
  nit,
  Vfe,
  Wfe = s(() => {
    (Gfe = ":"),
      (nit = "/"),
      (Vfe = (e) => {
        let t = e.split(Gfe);
        if (t.length < 6) return null;
        let [r, o, n, i, a, ...c] = t;
        if (r !== "arn" || o === "" || n === "" || c.join(Gfe) === "")
          return null;
        let d = c.map((m) => m.split(nit)).flat();
        return {
          partition: o,
          service: n,
          region: i,
          accountId: a,
          resourceId: d,
        };
      });
  });
var Yfe,
  Kfe = s(() => {
    Yfe = {
      partitions: [
        {
          id: "aws",
          outputs: {
            dnsSuffix: "amazonaws.com",
            dualStackDnsSuffix: "api.aws",
            implicitGlobalRegion: "us-east-1",
            name: "aws",
            supportsDualStack: !0,
            supportsFIPS: !0,
          },
          regionRegex: "^(us|eu|ap|sa|ca|me|af|il|mx)\\-\\w+\\-\\d+$",
          regions: {
            "af-south-1": { description: "Africa (Cape Town)" },
            "ap-east-1": { description: "Asia Pacific (Hong Kong)" },
            "ap-east-2": { description: "Asia Pacific (Taipei)" },
            "ap-northeast-1": { description: "Asia Pacific (Tokyo)" },
            "ap-northeast-2": { description: "Asia Pacific (Seoul)" },
            "ap-northeast-3": { description: "Asia Pacific (Osaka)" },
            "ap-south-1": { description: "Asia Pacific (Mumbai)" },
            "ap-south-2": { description: "Asia Pacific (Hyderabad)" },
            "ap-southeast-1": { description: "Asia Pacific (Singapore)" },
            "ap-southeast-2": { description: "Asia Pacific (Sydney)" },
            "ap-southeast-3": { description: "Asia Pacific (Jakarta)" },
            "ap-southeast-4": { description: "Asia Pacific (Melbourne)" },
            "ap-southeast-5": { description: "Asia Pacific (Malaysia)" },
            "ap-southeast-7": { description: "Asia Pacific (Thailand)" },
            "aws-global": { description: "AWS Standard global region" },
            "ca-central-1": { description: "Canada (Central)" },
            "ca-west-1": { description: "Canada West (Calgary)" },
            "eu-central-1": { description: "Europe (Frankfurt)" },
            "eu-central-2": { description: "Europe (Zurich)" },
            "eu-north-1": { description: "Europe (Stockholm)" },
            "eu-south-1": { description: "Europe (Milan)" },
            "eu-south-2": { description: "Europe (Spain)" },
            "eu-west-1": { description: "Europe (Ireland)" },
            "eu-west-2": { description: "Europe (London)" },
            "eu-west-3": { description: "Europe (Paris)" },
            "il-central-1": { description: "Israel (Tel Aviv)" },
            "me-central-1": { description: "Middle East (UAE)" },
            "me-south-1": { description: "Middle East (Bahrain)" },
            "mx-central-1": { description: "Mexico (Central)" },
            "sa-east-1": { description: "South America (Sao Paulo)" },
            "us-east-1": { description: "US East (N. Virginia)" },
            "us-east-2": { description: "US East (Ohio)" },
            "us-west-1": { description: "US West (N. California)" },
            "us-west-2": { description: "US West (Oregon)" },
          },
        },
        {
          id: "aws-cn",
          outputs: {
            dnsSuffix: "amazonaws.com.cn",
            dualStackDnsSuffix: "api.amazonwebservices.com.cn",
            implicitGlobalRegion: "cn-northwest-1",
            name: "aws-cn",
            supportsDualStack: !0,
            supportsFIPS: !0,
          },
          regionRegex: "^cn\\-\\w+\\-\\d+$",
          regions: {
            "aws-cn-global": { description: "AWS China global region" },
            "cn-north-1": { description: "China (Beijing)" },
            "cn-northwest-1": { description: "China (Ningxia)" },
          },
        },
        {
          id: "aws-us-gov",
          outputs: {
            dnsSuffix: "amazonaws.com",
            dualStackDnsSuffix: "api.aws",
            implicitGlobalRegion: "us-gov-west-1",
            name: "aws-us-gov",
            supportsDualStack: !0,
            supportsFIPS: !0,
          },
          regionRegex: "^us\\-gov\\-\\w+\\-\\d+$",
          regions: {
            "aws-us-gov-global": {
              description: "AWS GovCloud (US) global region",
            },
            "us-gov-east-1": { description: "AWS GovCloud (US-East)" },
            "us-gov-west-1": { description: "AWS GovCloud (US-West)" },
          },
        },
        {
          id: "aws-iso",
          outputs: {
            dnsSuffix: "c2s.ic.gov",
            dualStackDnsSuffix: "c2s.ic.gov",
            implicitGlobalRegion: "us-iso-east-1",
            name: "aws-iso",
            supportsDualStack: !1,
            supportsFIPS: !0,
          },
          regionRegex: "^us\\-iso\\-\\w+\\-\\d+$",
          regions: {
            "aws-iso-global": { description: "AWS ISO (US) global region" },
            "us-iso-east-1": { description: "US ISO East" },
            "us-iso-west-1": { description: "US ISO WEST" },
          },
        },
        {
          id: "aws-iso-b",
          outputs: {
            dnsSuffix: "sc2s.sgov.gov",
            dualStackDnsSuffix: "sc2s.sgov.gov",
            implicitGlobalRegion: "us-isob-east-1",
            name: "aws-iso-b",
            supportsDualStack: !1,
            supportsFIPS: !0,
          },
          regionRegex: "^us\\-isob\\-\\w+\\-\\d+$",
          regions: {
            "aws-iso-b-global": { description: "AWS ISOB (US) global region" },
            "us-isob-east-1": { description: "US ISOB East (Ohio)" },
          },
        },
        {
          id: "aws-iso-e",
          outputs: {
            dnsSuffix: "cloud.adc-e.uk",
            dualStackDnsSuffix: "cloud.adc-e.uk",
            implicitGlobalRegion: "eu-isoe-west-1",
            name: "aws-iso-e",
            supportsDualStack: !1,
            supportsFIPS: !0,
          },
          regionRegex: "^eu\\-isoe\\-\\w+\\-\\d+$",
          regions: {
            "aws-iso-e-global": {
              description: "AWS ISOE (Europe) global region",
            },
            "eu-isoe-west-1": { description: "EU ISOE West" },
          },
        },
        {
          id: "aws-iso-f",
          outputs: {
            dnsSuffix: "csp.hci.ic.gov",
            dualStackDnsSuffix: "csp.hci.ic.gov",
            implicitGlobalRegion: "us-isof-south-1",
            name: "aws-iso-f",
            supportsDualStack: !1,
            supportsFIPS: !0,
          },
          regionRegex: "^us\\-isof\\-\\w+\\-\\d+$",
          regions: {
            "aws-iso-f-global": { description: "AWS ISOF global region" },
            "us-isof-east-1": { description: "US ISOF EAST" },
            "us-isof-south-1": { description: "US ISOF SOUTH" },
          },
        },
        {
          id: "aws-eusc",
          outputs: {
            dnsSuffix: "amazonaws.eu",
            dualStackDnsSuffix: "amazonaws.eu",
            implicitGlobalRegion: "eusc-de-east-1",
            name: "aws-eusc",
            supportsDualStack: !1,
            supportsFIPS: !0,
          },
          regionRegex: "^eusc\\-(de)\\-\\w+\\-\\d+$",
          regions: { "eusc-de-east-1": { description: "EU (Germany)" } },
        },
      ],
      version: "1.1",
    };
  });
var iit,
  ait,
  Qfe,
  Xfe,
  lB = s(() => {
    Kfe();
    (iit = Yfe),
      (ait = ""),
      (Qfe = (e) => {
        let { partitions: t } = iit;
        for (let o of t) {
          let { regions: n, outputs: i } = o;
          for (let [a, c] of Object.entries(n))
            if (a === e) return { ...i, ...c };
        }
        for (let o of t) {
          let { regionRegex: n, outputs: i } = o;
          if (new RegExp(n).test(e)) return { ...i };
        }
        let r = t.find((o) => o.id === "aws");
        if (!r)
          throw new Error(
            "Provided region was not found in the partition array or regex, and default partition with id 'aws' doesn't exist."
          );
        return { ...r.outputs };
      }),
      (Xfe = () => ait);
  });
var ug,
  Jfe = s(() => {
    $t();
    jfe();
    Wfe();
    lB();
    ug = { isVirtualHostableS3Bucket: mB, parseArn: Vfe, partition: Qfe };
    Jt.aws = ug;
  });
var Zfe = s(() => {
  $t();
});
var eue = s(() => {
  $t();
});
var tue = s(() => {});
var rue = s(() => {});
var oue = s(() => {});
var nue = s(() => {});
var sue = s(() => {});
var iue = s(() => {
  eue();
  tue();
  rue();
  oue();
  nue();
  sue();
});
var RC = s(() => {
  Jfe();
  lB();
  dB();
  Zfe();
  iue();
});
async function aue(e, t, r) {
  if (
    (r.request?.headers?.["smithy-protocol"] === "rpc-v2-cbor" &&
      _e(e, "PROTOCOL_RPC_V2_CBOR", "M"),
    typeof t.retryStrategy == "function")
  ) {
    let i = await t.retryStrategy();
    typeof i.acquireInitialRetryToken == "function"
      ? i.constructor?.name?.includes("Adaptive")
        ? _e(e, "RETRY_MODE_ADAPTIVE", "F")
        : _e(e, "RETRY_MODE_STANDARD", "E")
      : _e(e, "RETRY_MODE_LEGACY", "D");
  }
  if (typeof t.accountIdEndpointMode == "function") {
    let i = e.endpointV2;
    switch (
      (String(i?.url?.hostname).match(cit) && _e(e, "ACCOUNT_ID_ENDPOINT", "O"),
      await t.accountIdEndpointMode?.())
    ) {
      case "disabled":
        _e(e, "ACCOUNT_ID_MODE_DISABLED", "Q");
        break;
      case "preferred":
        _e(e, "ACCOUNT_ID_MODE_PREFERRED", "P");
        break;
      case "required":
        _e(e, "ACCOUNT_ID_MODE_REQUIRED", "R");
        break;
    }
  }
  let n = e.__smithy_context?.selectedHttpAuthScheme?.identity;
  if (n?.$source) {
    let i = n;
    i.accountId && _e(e, "RESOLVED_ACCOUNT_ID", "T");
    for (let [a, c] of Object.entries(i.$source ?? {})) _e(e, a, c);
  }
}
var cit,
  cue = s(() => {
    rt();
    cit = /\d{12}\.ddb/;
  });
var fB,
  IC,
  uB,
  PC,
  due,
  mue,
  pB,
  lue = s(() => {
    (fB = "user-agent"),
      (IC = "x-amz-user-agent"),
      (uB = " "),
      (PC = "/"),
      (due = /[^\!\$\%\&\'\*\+\-\.\^\_\`\|\~\d\w]/g),
      (mue = /[^\!\$\%\&\'\*\+\-\.\^\_\`\|\~\d\w\#]/g),
      (pB = "-");
  });
function fue(e) {
  let t = "";
  for (let r in e) {
    let o = e[r];
    if (t.length + o.length + 1 <= 1024) {
      t.length ? (t += "," + o) : (t += o);
      continue;
    }
    break;
  }
  return t;
}
var uue = s(() => {});
var dit,
  vC,
  mit,
  OC,
  pue = s(() => {
    RC();
    yn();
    cue();
    lue();
    uue();
    (dit = (e) => (t, r) => async (o) => {
      let { request: n } = o;
      if (!jo.isInstance(n)) return t(o);
      let { headers: i } = n,
        a = r?.userAgent?.map(vC) || [],
        c = (await e.defaultUserAgentProvider()).map(vC);
      await aue(r, e, o);
      let d = r;
      c.push(
        `m/${fue(Object.assign({}, r.__smithy_context?.features, d.__aws_sdk_context?.features))}`
      );
      let m = e?.customUserAgent?.map(vC) || [],
        f = await e.userAgentAppId();
      f && c.push(vC([`app/${f}`]));
      let l = Xfe(),
        u = (l ? [l] : []).concat([...c, ...a, ...m]).join(uB),
        h = [...c.filter((y) => y.startsWith("aws-sdk-")), ...m].join(uB);
      return (
        e.runtime !== "browser"
          ? (h && (i[IC] = i[IC] ? `${i[fB]} ${h}` : h), (i[fB] = u))
          : (i[IC] = u),
        t({ ...o, request: n })
      );
    }),
      (vC = (e) => {
        let t = e[0]
            .split(PC)
            .map((a) => a.replace(due, pB))
            .join(PC),
          r = e[1]?.replace(mue, pB),
          o = t.indexOf(PC),
          n = t.substring(0, o),
          i = t.substring(o + 1);
        return (
          n === "api" && (i = i.toLowerCase()),
          [n, i, r]
            .filter((a) => a && a.length > 0)
            .reduce((a, c, d) => {
              switch (d) {
                case 0:
                  return c;
                case 1:
                  return `${a}/${c}`;
                default:
                  return `${a}#${c}`;
              }
            }, "")
        );
      }),
      (mit = {
        name: "getUserAgentMiddleware",
        step: "build",
        priority: "low",
        tags: ["SET_USER_AGENT", "USER_AGENT"],
        override: !0,
      }),
      (OC = (e) => ({
        applyToStack: (t) => {
          t.add(dit(e), mit);
        },
      }));
  });
var kC = s(() => {
  qfe();
  pue();
});
var lit,
  fit,
  DC,
  hue = s(() => {
    Wn();
    (lit = "AWS_USE_DUALSTACK_ENDPOINT"),
      (fit = "use_dualstack_endpoint"),
      (DC = {
        environmentVariableSelector: (e) => Nt(e, lit, Tt.ENV),
        configFileSelector: (e) => Nt(e, fit, Tt.CONFIG),
        default: !1,
      });
  });
var uit,
  pit,
  NC,
  gue = s(() => {
    Wn();
    (uit = "AWS_USE_FIPS_ENDPOINT"),
      (pit = "use_fips_endpoint"),
      (NC = {
        environmentVariableSelector: (e) => Nt(e, uit, Tt.ENV),
        configFileSelector: (e) => Nt(e, pit, Tt.CONFIG),
        default: !1,
      });
  });
var yue = s(() => {
  ct();
});
var xue = s(() => {});
var Eue = s(() => {
  ct();
  xue();
});
var Sue = s(() => {
  hue();
  gue();
  yue();
  Eue();
});
var hit,
  git,
  Gl,
  BC,
  Cue = s(() => {
    (hit = "AWS_REGION"),
      (git = "region"),
      (Gl = {
        environmentVariableSelector: (e) => e[hit],
        configFileSelector: (e) => e[git],
        default: () => {
          throw new Error("Region is missing");
        },
      }),
      (BC = { preferredFile: "credentials" });
  });
var MC,
  hB = s(() => {
    MC = (e) =>
      typeof e == "string" && (e.startsWith("fips-") || e.endsWith("-fips"));
  });
var gB,
  bue = s(() => {
    hB();
    gB = (e) =>
      MC(e)
        ? ["fips-aws-global", "aws-fips"].includes(e)
          ? "us-east-1"
          : e.replace(/fips-(dkr-|prod-)?|-fips/, "")
        : e;
  });
var LC,
  _ue = s(() => {
    bue();
    hB();
    LC = (e) => {
      let { region: t, useFipsEndpoint: r } = e;
      if (!t) throw new Error("Region is missing");
      return Object.assign(e, {
        region: async () => {
          if (typeof t == "string") return gB(t);
          let o = await t();
          return gB(o);
        },
        useFipsEndpoint: async () => {
          let o = typeof t == "string" ? t : await t();
          return MC(o)
            ? !0
            : typeof r != "function"
              ? Promise.resolve(!!r)
              : r();
        },
      });
    };
  });
var wue = s(() => {
  Cue();
  _ue();
});
var Tue = s(() => {});
var Aue = s(() => {});
var Rue = s(() => {});
var Iue = s(() => {});
var Pue = s(() => {});
var vue = s(() => {});
var Oue = s(() => {
  Rue();
  Iue();
  Pue();
  vue();
});
var kue = s(() => {
  Tue();
  Aue();
  Oue();
});
var Vl = s(() => {
  Sue();
  wue();
  kue();
});
function yit(e) {
  return (t) => async (r) => {
    let o = r.request;
    if (jo.isInstance(o)) {
      let { body: n, headers: i } = o;
      if (
        n &&
        Object.keys(i)
          .map((a) => a.toLowerCase())
          .indexOf(Due) === -1
      )
        try {
          let a = e(n);
          o.headers = { ...o.headers, [Due]: String(a) };
        } catch {}
    }
    return t({ ...r, request: o });
  };
}
var Due,
  xit,
  FC,
  yB = s(() => {
    yn();
    Due = "content-length";
    (xit = {
      step: "build",
      tags: ["SET_CONTENT_LENGTH", "CONTENT_LENGTH"],
      name: "contentLengthMiddleware",
      override: !0,
    }),
      (FC = (e) => ({
        applyToStack: (t) => {
          t.add(yit(e.bodyLengthChecker), xit);
        },
      }));
  });
var Nue,
  Eit,
  Sit,
  Cit,
  bit,
  _it,
  Bue = s(() => {
    (Nue = async (e) => {
      let t = e?.Bucket || "";
      if (
        (typeof e.Bucket == "string" &&
          (e.Bucket = t
            .replace(/#/g, encodeURIComponent("#"))
            .replace(/\?/g, encodeURIComponent("?"))),
        _it(t))
      ) {
        if (e.ForcePathStyle === !0)
          throw new Error(
            "Path-style addressing cannot be used with ARN buckets"
          );
      } else
        (!bit(t) ||
          (t.indexOf(".") !== -1 && !String(e.Endpoint).startsWith("http:")) ||
          t.toLowerCase() !== t ||
          t.length < 3) &&
          (e.ForcePathStyle = !0);
      return (
        e.DisableMultiRegionAccessPoints &&
          ((e.disableMultiRegionAccessPoints = !0), (e.DisableMRAP = !0)),
        e
      );
    }),
      (Eit = /^[a-z0-9][a-z0-9\.\-]{1,61}[a-z0-9]$/),
      (Sit = /(\d+\.){3}\d+/),
      (Cit = /\.\./),
      (bit = (e) => Eit.test(e) && !Sit.test(e) && !Cit.test(e)),
      (_it = (e) => {
        let [t, r, o, , , n] = e.split(":"),
          i = t === "arn" && e.split(":").length >= 6,
          a = !!(i && r && o && n);
        if (i && !a) throw new Error(`Invalid ARN: ${e} was an invalid ARN.`);
        return a;
      });
  });
var Mue = s(() => {
  Bue();
});
var Lue,
  Fue = s(() => {
    Lue = (e, t, r) => {
      let o = async () => {
        let n = r[e] ?? r[t];
        return typeof n == "function" ? n() : n;
      };
      return e === "credentialScope" || t === "CredentialScope"
        ? async () => {
            let n =
              typeof r.credentials == "function"
                ? await r.credentials()
                : r.credentials;
            return n?.credentialScope ?? n?.CredentialScope;
          }
        : e === "accountId" || t === "AccountId"
          ? async () => {
              let n =
                typeof r.credentials == "function"
                  ? await r.credentials()
                  : r.credentials;
              return n?.accountId ?? n?.AccountId;
            }
          : e === "endpoint" || t === "endpoint"
            ? async () => {
                let n = await o();
                if (n && typeof n == "object") {
                  if ("url" in n) return n.url.href;
                  if ("hostname" in n) {
                    let { protocol: i, hostname: a, port: c, path: d } = n;
                    return `${i}//${a}${c ? ":" + c : ""}${d}`;
                  }
                }
                return n;
              }
            : o;
    };
  });
function UC(e) {
  try {
    let t = new Set(Array.from(e.match(/([A-Z_]){3,}/g) ?? []));
    return (
      t.delete("CONFIG"),
      t.delete("CONFIG_PREFIX_SEPARATOR"),
      t.delete("ENV"),
      [...t].join(", ")
    );
  } catch {
    return e;
  }
}
var xB = s(() => {});
var Uue,
  $ue = s(() => {
    re();
    xB();
    Uue = (e, t) => async () => {
      try {
        let r = e(process.env, t);
        if (r === void 0) throw new Error();
        return r;
      } catch (r) {
        throw new P(r.message || `Not found in ENV: ${UC(e.toString())}`, {
          logger: t?.logger,
        });
      }
    };
  });
import { homedir as wit } from "os";
import { sep as Tit } from "path";
var EB,
  Ait,
  ud,
  Wl = s(() => {
    (EB = {}),
      (Ait = () =>
        process && process.geteuid ? `${process.geteuid()}` : "DEFAULT"),
      (ud = () => {
        let {
          HOME: e,
          USERPROFILE: t,
          HOMEPATH: r,
          HOMEDRIVE: o = `C:${Tit}`,
        } = process.env;
        if (e) return e;
        if (t) return t;
        if (r) return `${o}${r}`;
        let n = Ait();
        return EB[n] || (EB[n] = wit()), EB[n];
      });
  });
var Rit,
  Iit,
  Hue,
  zue = s(() => {
    (Rit = "AWS_PROFILE"),
      (Iit = "default"),
      (Hue = (e) => e.profile || process.env[Rit] || Iit);
  });
var SB = s(() => {
  Wl();
});
import { promises as Pit } from "fs";
var Lfr,
  que = s(() => {
    SB();
    ({ readFile: Lfr } = Pit);
  });
var jue,
  Gue = s(() => {
    fd();
    Kl();
    jue = (e) =>
      Object.entries(e)
        .filter(([t]) => {
          let r = t.indexOf(mi);
          return r === -1 ? !1 : Object.values(Ha).includes(t.substring(0, r));
        })
        .reduce(
          (t, [r, o]) => {
            let n = r.indexOf(mi),
              i = r.substring(0, n) === Ha.PROFILE ? r.substring(n + 1) : r;
            return (t[i] = o), t;
          },
          { ...(e.default && { default: e.default }) }
        );
  });
import { join as vit } from "path";
var Oit,
  CB,
  bB = s(() => {
    Wl();
    (Oit = "AWS_CONFIG_FILE"),
      (CB = () => process.env[Oit] || vit(ud(), ".aws", "config"));
  });
import { join as kit } from "path";
var Dit,
  Vue,
  Wue = s(() => {
    Wl();
    (Dit = "AWS_SHARED_CREDENTIALS_FILE"),
      (Vue = () => process.env[Dit] || kit(ud(), ".aws", "credentials"));
  });
var Nit,
  Bit,
  $C,
  _B = s(() => {
    fd();
    Kl();
    (Nit = /^([\w-]+)\s(["'])?([\w-@\+\.%:/]+)\2$/),
      (Bit = ["__proto__", "profile __proto__"]),
      ($C = (e) => {
        let t = {},
          r,
          o;
        for (let n of e.split(/\r?\n/)) {
          let i = n.split(/(^|\s)[;#]/)[0].trim();
          if (i[0] === "[" && i[i.length - 1] === "]") {
            (r = void 0), (o = void 0);
            let c = i.substring(1, i.length - 1),
              d = Nit.exec(c);
            if (d) {
              let [, m, , f] = d;
              Object.values(Ha).includes(m) && (r = [m, f].join(mi));
            } else r = c;
            if (Bit.includes(c))
              throw new Error(`Found invalid profile name "${c}"`);
          } else if (r) {
            let c = i.indexOf("=");
            if (![0, -1].includes(c)) {
              let [d, m] = [
                i.substring(0, c).trim(),
                i.substring(c + 1).trim(),
              ];
              if (m === "") o = d;
              else {
                o && n.trimStart() === n && (o = void 0), (t[r] = t[r] || {});
                let f = o ? [o, d].join(mi) : d;
                t[r][f] = m;
              }
            }
          }
        }
        return t;
      });
  });
import { promises as Mit } from "fs";
var Lit,
  wB,
  HC,
  TB = s(() => {
    ({ readFile: Lit } = Mit),
      (wB = {}),
      (HC = (e, t) => (
        (!wB[e] || t?.ignoreCache) && (wB[e] = Lit(e, "utf8")), wB[e]
      ));
  });
import { join as Kue } from "path";
var Yue,
  mi,
  AB,
  Kl = s(() => {
    Gue();
    bB();
    Wue();
    Wl();
    _B();
    TB();
    (Yue = () => ({})),
      (mi = "."),
      (AB = async (e = {}) => {
        let { filepath: t = Vue(), configFilepath: r = CB() } = e,
          o = ud(),
          n = "~/",
          i = t;
        t.startsWith(n) && (i = Kue(o, t.slice(2)));
        let a = r;
        r.startsWith(n) && (a = Kue(o, r.slice(2)));
        let c = await Promise.all([
          HC(a, { ignoreCache: e.ignoreCache }).then($C).then(jue).catch(Yue),
          HC(i, { ignoreCache: e.ignoreCache }).then($C).catch(Yue),
        ]);
        return { configFile: c[0], credentialsFile: c[1] };
      });
  });
var Que = s(() => {
  fd();
  Kl();
});
var Xue = s(() => {
  bB();
  Que();
  _B();
  TB();
});
var Jue = s(() => {});
var Zue = s(() => {
  Kl();
  Jue();
});
var epe = s(() => {});
var RB = s(() => {
  Wl();
  zue();
  SB();
  que();
  Kl();
  Xue();
  Zue();
  epe();
});
var tpe,
  rpe = s(() => {
    re();
    RB();
    xB();
    tpe =
      (e, { preferredFile: t = "config", ...r } = {}) =>
      async () => {
        let o = Hue(r),
          { configFile: n, credentialsFile: i } = await AB(r),
          a = i[o] || {},
          c = n[o] || {},
          d = t === "config" ? { ...a, ...c } : { ...c, ...a };
        try {
          let f = e(d, t === "config" ? n : i);
          if (f === void 0) throw new Error();
          return f;
        } catch (m) {
          throw new P(
            m.message ||
              `Not found in config files w/ profile [${o}]: ${UC(e.toString())}`,
            { logger: r.logger }
          );
        }
      };
  });
var Fit,
  ope,
  npe = s(() => {
    re();
    (Fit = (e) => typeof e == "function"),
      (ope = (e) => (Fit(e) ? async () => await e() : Ra(e)));
  });
var mr,
  spe = s(() => {
    re();
    $ue();
    rpe();
    npe();
    mr = (
      { environmentVariableSelector: e, configFileSelector: t, default: r },
      o = {}
    ) => {
      let { signingName: n, logger: i } = o;
      return gr(Ht(Uue(e, { signingName: n, logger: i }), tpe(t, o), ope(r)));
    };
  });
var pd = s(() => {
  spe();
});
var ipe,
  ape,
  cpe,
  dpe = s(() => {
    RB();
    (ipe = "AWS_ENDPOINT_URL"),
      (ape = "endpoint_url"),
      (cpe = (e) => ({
        environmentVariableSelector: (t) => {
          let r = e.split(" ").map((i) => i.toUpperCase()),
            o = t[[ipe, ...r].join("_")];
          if (o) return o;
          let n = t[ipe];
          if (n) return n;
        },
        configFileSelector: (t, r) => {
          if (r && t.services) {
            let n = r[["services", t.services].join(mi)];
            if (n) {
              let i = e.split(" ").map((c) => c.toLowerCase()),
                a = n[[i.join("_"), ape].join(mi)];
              if (a) return a;
            }
          }
          let o = t[ape];
          if (o) return o;
        },
        default: void 0,
      }));
  });
var zC,
  IB = s(() => {
    pd();
    dpe();
    zC = async (e) => mr(cpe(e ?? ""))();
  });
function mpe(e) {
  let t = {};
  if (((e = e.replace(/^\?/, "")), e))
    for (let r of e.split("&")) {
      let [o, n = null] = r.split("=");
      (o = decodeURIComponent(o)),
        n && (n = decodeURIComponent(n)),
        o in t
          ? Array.isArray(t[o])
            ? t[o].push(n)
            : (t[o] = [t[o], n])
          : (t[o] = n);
    }
  return t;
}
var lpe = s(() => {});
var li,
  pg = s(() => {
    lpe();
    li = (e) => {
      if (typeof e == "string") return li(new URL(e));
      let { hostname: t, pathname: r, port: o, protocol: n, search: i } = e,
        a;
      return (
        i && (a = mpe(i)),
        {
          hostname: t,
          port: o ? parseInt(o) : void 0,
          protocol: n,
          path: r,
          query: a,
        }
      );
    };
  });
var qC,
  jC = s(() => {
    pg();
    qC = (e) => (typeof e == "object" ? ("url" in e ? li(e.url) : e) : li(e));
  });
var fpe,
  Uit,
  PB = s(() => {
    Mue();
    Fue();
    IB();
    jC();
    (fpe = async (e, t, r, o) => {
      if (!r.endpoint) {
        let a;
        r.serviceConfiguredEndpoint
          ? (a = await r.serviceConfiguredEndpoint())
          : (a = await zC(r.serviceId)),
          a && (r.endpoint = () => Promise.resolve(qC(a)));
      }
      let n = await Uit(e, t, r);
      if (typeof r.endpointProvider != "function")
        throw new Error("config.endpointProvider is not set.");
      return r.endpointProvider(n, o);
    }),
      (Uit = async (e, t, r) => {
        let o = {},
          n = t?.getEndpointParameterInstructions?.() || {};
        for (let [i, a] of Object.entries(n))
          switch (a.type) {
            case "staticContextParams":
              o[i] = a.value;
              break;
            case "contextParams":
              o[i] = e[a.name];
              break;
            case "clientContextParams":
            case "builtInParams":
              o[i] = await Lue(a.name, i, r)();
              break;
            case "operationContextParams":
              o[i] = a.get(e);
              break;
            default:
              throw new Error(
                "Unrecognized endpoint parameter instruction: " +
                  JSON.stringify(a)
              );
          }
        return (
          Object.keys(n).length === 0 && Object.assign(o, r),
          String(r.serviceId).toLowerCase() === "s3" && (await Nue(o)),
          o
        );
      });
  });
var upe = s(() => {
  PB();
  jC();
});
var ppe,
  vB = s(() => {
    Ue();
    ct();
    PB();
    ppe =
      ({ config: e, instructions: t }) =>
      (r, o) =>
      async (n) => {
        e.endpoint && Ta(o, "ENDPOINT_OVERRIDE", "N");
        let i = await fpe(
          n.input,
          {
            getEndpointParameterInstructions() {
              return t;
            },
          },
          { ...e },
          o
        );
        (o.endpointV2 = i), (o.authSchemes = i.properties?.authSchemes);
        let a = o.authSchemes?.[0];
        if (a) {
          (o.signing_region = a.signingRegion),
            (o.signing_service = a.signingName);
          let d = bt(o)?.selectedHttpAuthScheme?.httpAuthOption;
          d &&
            (d.signingProperties = Object.assign(
              d.signingProperties || {},
              {
                signing_region: a.signingRegion,
                signingRegion: a.signingRegion,
                signing_service: a.signingName,
                signingName: a.signingName,
                signingRegionSet: a.signingRegionSet,
              },
              a.properties
            ));
        }
        return r({ ...n });
      };
  });
var hpe,
  OB,
  kB = s(() => {
    yn();
    (hpe = (e, t) => (r, o) => async (n) => {
      let { response: i } = await r(n);
      try {
        let a = await t(i, e);
        return { response: i, output: a };
      } catch (a) {
        if (
          (Object.defineProperty(a, "$response", { value: i }),
          !("$metadata" in a))
        ) {
          let c =
            "Deserialization error: to see the raw response, inspect the hidden field {error}.$response on this object.";
          try {
            a.message +=
              `
  ` + c;
          } catch {
            !o.logger || o.logger?.constructor?.name === "NoOpLogger"
              ? console.warn(c)
              : o.logger?.warn?.(c);
          }
          typeof a.$responseBodyText < "u" &&
            a.$response &&
            (a.$response.body = a.$responseBodyText);
          try {
            if (di.isInstance(i)) {
              let { headers: d = {} } = i,
                m = Object.entries(d);
              a.$metadata = {
                httpStatusCode: i.statusCode,
                requestId: OB(/^x-[\w-]+-request-?id$/, m),
                extendedRequestId: OB(/^x-[\w-]+-id-2$/, m),
                cfId: OB(/^x-[\w-]+-cf-id$/, m),
              };
            }
          } catch {}
        }
        throw a;
      }
    }),
      (OB = (e, t) => (t.find(([r]) => r.match(e)) || [void 0, void 0])[1]);
  });
var gpe,
  DB = s(() => {
    gpe = (e, t) => (r, o) => async (n) => {
      let i = e,
        a =
          o.endpointV2?.url && i.urlParser
            ? async () => i.urlParser(o.endpointV2.url)
            : i.endpoint;
      if (!a) throw new Error("No valid endpoint provider available.");
      let c = await t(n.input, { ...e, endpoint: a });
      return r({ ...n, request: c });
    };
  });
function Yl(e, t, r) {
  return {
    applyToStack: (o) => {
      o.add(hpe(e, r), $it), o.add(gpe(e, t), NB);
    },
  };
}
var $it,
  NB,
  ype = s(() => {
    kB();
    DB();
    ($it = {
      name: "deserializerMiddleware",
      step: "deserialize",
      tags: ["DESERIALIZER"],
      override: !0,
    }),
      (NB = {
        name: "serializerMiddleware",
        step: "serialize",
        tags: ["SERIALIZER"],
        override: !0,
      });
  });
var hg = s(() => {
  kB();
  ype();
  DB();
});
var Hit,
  Ql,
  xpe = s(() => {
    hg();
    vB();
    (Hit = {
      step: "serialize",
      tags: ["ENDPOINT_PARAMETERS", "ENDPOINT_V2", "ENDPOINT"],
      name: "endpointV2Middleware",
      override: !0,
      relation: "before",
      toMiddleware: NB.name,
    }),
      (Ql = (e, t) => ({
        applyToStack: (r) => {
          r.addRelativeTo(ppe({ config: e, instructions: t }), Hit);
        },
      }));
  });
var GC,
  Epe = s(() => {
    ct();
    IB();
    jC();
    GC = (e) => {
      let t = e.tls ?? !0,
        { endpoint: r, useDualstackEndpoint: o, useFipsEndpoint: n } = e,
        i = r != null ? async () => qC(await pe(r)()) : void 0,
        c = Object.assign(e, {
          endpoint: i,
          tls: t,
          isCustomEndpoint: !!r,
          useDualstackEndpoint: pe(o ?? !1),
          useFipsEndpoint: pe(n ?? !1),
        }),
        d;
      return (
        (c.serviceConfiguredEndpoint = async () => (
          e.serviceId && !d && (d = zC(e.serviceId)), d
        )),
        c
      );
    };
  });
var Spe = s(() => {});
var Cpe = s(() => {});
var Xl = s(() => {
  upe();
  vB();
  xpe();
  Epe();
  Spe();
  Cpe();
});
var $s,
  hd,
  Jl,
  VC = s(() => {
    (function (e) {
      (e.STANDARD = "standard"), (e.ADAPTIVE = "adaptive");
    })($s || ($s = {}));
    (hd = 3), (Jl = $s.STANDARD);
  });
var bpe,
  _pe,
  wpe,
  Tpe,
  Ape,
  Rpe = s(() => {
    (bpe = [
      "BandwidthLimitExceeded",
      "EC2ThrottledException",
      "LimitExceededException",
      "PriorRequestNotComplete",
      "ProvisionedThroughputExceededException",
      "RequestLimitExceeded",
      "RequestThrottled",
      "RequestThrottledException",
      "SlowDown",
      "ThrottledException",
      "Throttling",
      "ThrottlingException",
      "TooManyRequestsException",
      "TransactionInProgressException",
    ]),
      (_pe = ["TimeoutError", "RequestTimeout", "RequestTimeoutException"]),
      (wpe = [500, 502, 503, 504]),
      (Tpe = ["ECONNRESET", "ECONNREFUSED", "EPIPE", "ETIMEDOUT"]),
      (Ape = ["EHOSTUNREACH", "ENETUNREACH", "ENOTFOUND"]);
  });
var zit,
  qit,
  Zl,
  gg,
  Ipe,
  yg = s(() => {
    Rpe();
    (zit = (e) => e.$metadata?.clockSkewCorrected),
      (qit = (e) => {
        let t = new Set([
          "Failed to fetch",
          "NetworkError when attempting to fetch resource",
          "The Internet connection appears to be offline",
          "Load failed",
          "Network request failed",
        ]);
        return e && e instanceof TypeError ? t.has(e.message) : !1;
      }),
      (Zl = (e) =>
        e.$metadata?.httpStatusCode === 429 ||
        bpe.includes(e.name) ||
        e.$retryable?.throttling == !0),
      (gg = (e, t = 0) =>
        zit(e) ||
        _pe.includes(e.name) ||
        Tpe.includes(e?.code || "") ||
        Ape.includes(e?.code || "") ||
        wpe.includes(e.$metadata?.httpStatusCode || 0) ||
        qit(e) ||
        (e.cause !== void 0 && t <= 10 && gg(e.cause, t + 1))),
      (Ipe = (e) => {
        if (e.$metadata?.httpStatusCode !== void 0) {
          let t = e.$metadata.httpStatusCode;
          return 500 <= t && t <= 599 && !gg(e);
        }
        return !1;
      });
  });
var ef,
  BB = s(() => {
    yg();
    ef = class e {
      constructor(t) {
        (this.currentCapacity = 0),
          (this.enabled = !1),
          (this.lastMaxRate = 0),
          (this.measuredTxRate = 0),
          (this.requestCount = 0),
          (this.lastTimestamp = 0),
          (this.timeWindow = 0),
          (this.beta = t?.beta ?? 0.7),
          (this.minCapacity = t?.minCapacity ?? 1),
          (this.minFillRate = t?.minFillRate ?? 0.5),
          (this.scaleConstant = t?.scaleConstant ?? 0.4),
          (this.smooth = t?.smooth ?? 0.8);
        let r = this.getCurrentTimeInSeconds();
        (this.lastThrottleTime = r),
          (this.lastTxRateBucket = Math.floor(this.getCurrentTimeInSeconds())),
          (this.fillRate = this.minFillRate),
          (this.maxCapacity = this.minCapacity);
      }
      getCurrentTimeInSeconds() {
        return Date.now() / 1e3;
      }
      async getSendToken() {
        return this.acquireTokenBucket(1);
      }
      async acquireTokenBucket(t) {
        if (this.enabled) {
          if ((this.refillTokenBucket(), t > this.currentCapacity)) {
            let r = ((t - this.currentCapacity) / this.fillRate) * 1e3;
            await new Promise((o) => e.setTimeoutFn(o, r));
          }
          this.currentCapacity = this.currentCapacity - t;
        }
      }
      refillTokenBucket() {
        let t = this.getCurrentTimeInSeconds();
        if (!this.lastTimestamp) {
          this.lastTimestamp = t;
          return;
        }
        let r = (t - this.lastTimestamp) * this.fillRate;
        (this.currentCapacity = Math.min(
          this.maxCapacity,
          this.currentCapacity + r
        )),
          (this.lastTimestamp = t);
      }
      updateClientSendingRate(t) {
        let r;
        if ((this.updateMeasuredRate(), Zl(t))) {
          let n = this.enabled
            ? Math.min(this.measuredTxRate, this.fillRate)
            : this.measuredTxRate;
          (this.lastMaxRate = n),
            this.calculateTimeWindow(),
            (this.lastThrottleTime = this.getCurrentTimeInSeconds()),
            (r = this.cubicThrottle(n)),
            this.enableTokenBucket();
        } else
          this.calculateTimeWindow(),
            (r = this.cubicSuccess(this.getCurrentTimeInSeconds()));
        let o = Math.min(r, 2 * this.measuredTxRate);
        this.updateTokenBucketRate(o);
      }
      calculateTimeWindow() {
        this.timeWindow = this.getPrecise(
          Math.pow(
            (this.lastMaxRate * (1 - this.beta)) / this.scaleConstant,
            1 / 3
          )
        );
      }
      cubicThrottle(t) {
        return this.getPrecise(t * this.beta);
      }
      cubicSuccess(t) {
        return this.getPrecise(
          this.scaleConstant *
            Math.pow(t - this.lastThrottleTime - this.timeWindow, 3) +
            this.lastMaxRate
        );
      }
      enableTokenBucket() {
        this.enabled = !0;
      }
      updateTokenBucketRate(t) {
        this.refillTokenBucket(),
          (this.fillRate = Math.max(t, this.minFillRate)),
          (this.maxCapacity = Math.max(t, this.minCapacity)),
          (this.currentCapacity = Math.min(
            this.currentCapacity,
            this.maxCapacity
          ));
      }
      updateMeasuredRate() {
        let t = this.getCurrentTimeInSeconds(),
          r = Math.floor(t * 2) / 2;
        if ((this.requestCount++, r > this.lastTxRateBucket)) {
          let o = this.requestCount / (r - this.lastTxRateBucket);
          (this.measuredTxRate = this.getPrecise(
            o * this.smooth + this.measuredTxRate * (1 - this.smooth)
          )),
            (this.requestCount = 0),
            (this.lastTxRateBucket = r);
        }
      }
      getPrecise(t) {
        return parseFloat(t.toFixed(8));
      }
    };
    ef.setTimeoutFn = setTimeout;
  });
var WC,
  KC,
  tf = s(() => {
    (WC = "amz-sdk-invocation-id"), (KC = "amz-sdk-request");
  });
var Ppe,
  vpe = s(() => {
    tf();
    Ppe = () => {
      let e = 100;
      return {
        computeNextBackoffDelay: (o) =>
          Math.floor(Math.min(2e4, Math.random() * 2 ** o * e)),
        setDelayBase: (o) => {
          e = o;
        },
      };
    };
  });
var MB,
  Ope = s(() => {
    tf();
    MB = ({ retryDelay: e, retryCount: t, retryCost: r }) => ({
      getRetryCount: () => t,
      getRetryDelay: () => Math.min(2e4, e),
      getRetryCost: () => r,
    });
  });
var gd,
  QC = s(() => {
    VC();
    tf();
    vpe();
    Ope();
    gd = class {
      constructor(t) {
        (this.maxAttempts = t),
          (this.mode = $s.STANDARD),
          (this.capacity = 500),
          (this.retryBackoffStrategy = Ppe()),
          (this.maxAttemptsProvider =
            typeof t == "function" ? t : async () => t);
      }
      async acquireInitialRetryToken(t) {
        return MB({ retryDelay: 100, retryCount: 0 });
      }
      async refreshRetryTokenForRetry(t, r) {
        let o = await this.getMaxAttempts();
        if (this.shouldRetry(t, r, o)) {
          let n = r.errorType;
          this.retryBackoffStrategy.setDelayBase(
            n === "THROTTLING" ? 500 : 100
          );
          let i = this.retryBackoffStrategy.computeNextBackoffDelay(
              t.getRetryCount()
            ),
            a = r.retryAfterHint
              ? Math.max(r.retryAfterHint.getTime() - Date.now() || 0, i)
              : i,
            c = this.getCapacityCost(n);
          return (
            (this.capacity -= c),
            MB({
              retryDelay: a,
              retryCount: t.getRetryCount() + 1,
              retryCost: c,
            })
          );
        }
        throw new Error("No retry token available");
      }
      recordSuccess(t) {
        this.capacity = Math.max(500, this.capacity + (t.getRetryCost() ?? 1));
      }
      getCapacity() {
        return this.capacity;
      }
      async getMaxAttempts() {
        try {
          return await this.maxAttemptsProvider();
        } catch {
          return (
            console.warn(
              `Max attempts provider could not resolve. Using default of ${hd}`
            ),
            hd
          );
        }
      }
      shouldRetry(t, r, o) {
        return (
          t.getRetryCount() + 1 < o &&
          this.capacity >= this.getCapacityCost(r.errorType) &&
          this.isRetryableError(r.errorType)
        );
      }
      getCapacityCost(t) {
        return t === "TRANSIENT" ? 10 : 5;
      }
      isRetryableError(t) {
        return t === "THROTTLING" || t === "TRANSIENT";
      }
    };
  });
var XC,
  Mpe = s(() => {
    VC();
    BB();
    QC();
    XC = class {
      constructor(t, r) {
        (this.maxAttemptsProvider = t), (this.mode = $s.ADAPTIVE);
        let { rateLimiter: o } = r ?? {};
        (this.rateLimiter = o ?? new ef()),
          (this.standardRetryStrategy = new gd(t));
      }
      async acquireInitialRetryToken(t) {
        return (
          await this.rateLimiter.getSendToken(),
          this.standardRetryStrategy.acquireInitialRetryToken(t)
        );
      }
      async refreshRetryTokenForRetry(t, r) {
        return (
          this.rateLimiter.updateClientSendingRate(r),
          this.standardRetryStrategy.refreshRetryTokenForRetry(t, r)
        );
      }
      recordSuccess(t) {
        this.rateLimiter.updateClientSendingRate({}),
          this.standardRetryStrategy.recordSuccess(t);
      }
    };
  });
var Lpe = s(() => {
  tf();
  QC();
});
var Fpe = s(() => {});
var fi = s(() => {
  Mpe();
  Lpe();
  BB();
  QC();
  VC();
  tf();
  Fpe();
});
var Upe = s(() => {
  fi();
});
var FB = s(() => {
  fi();
});
var UB = s(() => {
  yg();
});
var $B,
  HB = s(() => {
    $B = (e) =>
      e instanceof Error
        ? e
        : e instanceof Object
          ? Object.assign(new Error(), e)
          : typeof e == "string"
            ? new Error(e)
            : new Error(`AWS SDK error wrapper for ${e}`);
  });
var zB = s(() => {
  yn();
  yg();
  fi();
  Upe();
  FB();
  UB();
  HB();
});
var $pe = s(() => {
  fi();
  zB();
});
var Hpe,
  zpe,
  JC,
  ZC,
  jit,
  Git,
  eb,
  qpe = s(() => {
    ct();
    fi();
    (Hpe = "AWS_MAX_ATTEMPTS"),
      (zpe = "max_attempts"),
      (JC = {
        environmentVariableSelector: (e) => {
          let t = e[Hpe];
          if (!t) return;
          let r = parseInt(t);
          if (Number.isNaN(r))
            throw new Error(
              `Environment variable ${Hpe} mast be a number, got "${t}"`
            );
          return r;
        },
        configFileSelector: (e) => {
          let t = e[zpe];
          if (!t) return;
          let r = parseInt(t);
          if (Number.isNaN(r))
            throw new Error(
              `Shared config file entry ${zpe} mast be a number, got "${t}"`
            );
          return r;
        },
        default: hd,
      }),
      (ZC = (e) => {
        let { retryStrategy: t, retryMode: r, maxAttempts: o } = e,
          n = pe(o ?? hd);
        return Object.assign(e, {
          maxAttempts: n,
          retryStrategy: async () =>
            t || ((await pe(r)()) === $s.ADAPTIVE ? new XC(n) : new gd(n)),
        });
      }),
      (jit = "AWS_RETRY_MODE"),
      (Git = "retry_mode"),
      (eb = {
        environmentVariableSelector: (e) => e[jit],
        configFileSelector: (e) => e[Git],
        default: Jl,
      });
  });
var jpe = s(() => {
  yn();
  fi();
});
var yd,
  za,
  of,
  Gpe,
  Vpe,
  Wpe = s(() => {
    (yd = (e, t) => {
      let r = [];
      if ((e && r.push(e), t)) for (let o of t) r.push(o);
      return r;
    }),
      (za = (e, t) =>
        `${e || "anonymous"}${t && t.length > 0 ? ` (a.k.a. ${t.join(",")})` : ""}`),
      (of = () => {
        let e = [],
          t = [],
          r = !1,
          o = new Set(),
          n = (l) =>
            l.sort(
              (u, h) =>
                Gpe[h.step] - Gpe[u.step] ||
                Vpe[h.priority || "normal"] - Vpe[u.priority || "normal"]
            ),
          i = (l) => {
            let u = !1,
              h = (y) => {
                let S = yd(y.name, y.aliases);
                if (S.includes(l)) {
                  u = !0;
                  for (let E of S) o.delete(E);
                  return !1;
                }
                return !0;
              };
            return (e = e.filter(h)), (t = t.filter(h)), u;
          },
          a = (l) => {
            let u = !1,
              h = (y) => {
                if (y.middleware === l) {
                  u = !0;
                  for (let S of yd(y.name, y.aliases)) o.delete(S);
                  return !1;
                }
                return !0;
              };
            return (e = e.filter(h)), (t = t.filter(h)), u;
          },
          c = (l) => (
            e.forEach((u) => {
              l.add(u.middleware, { ...u });
            }),
            t.forEach((u) => {
              l.addRelativeTo(u.middleware, { ...u });
            }),
            l.identifyOnResolve?.(f.identifyOnResolve()),
            l
          ),
          d = (l) => {
            let u = [];
            return (
              l.before.forEach((h) => {
                h.before.length === 0 && h.after.length === 0
                  ? u.push(h)
                  : u.push(...d(h));
              }),
              u.push(l),
              l.after.reverse().forEach((h) => {
                h.before.length === 0 && h.after.length === 0
                  ? u.push(h)
                  : u.push(...d(h));
              }),
              u
            );
          },
          m = (l = !1) => {
            let u = [],
              h = [],
              y = {};
            return (
              e.forEach((E) => {
                let b = { ...E, before: [], after: [] };
                for (let v of yd(b.name, b.aliases)) y[v] = b;
                u.push(b);
              }),
              t.forEach((E) => {
                let b = { ...E, before: [], after: [] };
                for (let v of yd(b.name, b.aliases)) y[v] = b;
                h.push(b);
              }),
              h.forEach((E) => {
                if (E.toMiddleware) {
                  let b = y[E.toMiddleware];
                  if (b === void 0) {
                    if (l) return;
                    throw new Error(
                      `${E.toMiddleware} is not found when adding ${za(E.name, E.aliases)} middleware ${E.relation} ${E.toMiddleware}`
                    );
                  }
                  E.relation === "after" && b.after.push(E),
                    E.relation === "before" && b.before.push(E);
                }
              }),
              n(u)
                .map(d)
                .reduce((E, b) => (E.push(...b), E), [])
            );
          },
          f = {
            add: (l, u = {}) => {
              let { name: h, override: y, aliases: S } = u,
                E = {
                  step: "initialize",
                  priority: "normal",
                  middleware: l,
                  ...u,
                },
                b = yd(h, S);
              if (b.length > 0) {
                if (b.some((v) => o.has(v))) {
                  if (!y)
                    throw new Error(`Duplicate middleware name '${za(h, S)}'`);
                  for (let v of b) {
                    let I = e.findIndex(
                      (ge) =>
                        ge.name === v || ge.aliases?.some((Fe) => Fe === v)
                    );
                    if (I === -1) continue;
                    let O = e[I];
                    if (O.step !== E.step || E.priority !== O.priority)
                      throw new Error(
                        `"${za(O.name, O.aliases)}" middleware with ${O.priority} priority in ${O.step} step cannot be overridden by "${za(h, S)}" middleware with ${E.priority} priority in ${E.step} step.`
                      );
                    e.splice(I, 1);
                  }
                }
                for (let v of b) o.add(v);
              }
              e.push(E);
            },
            addRelativeTo: (l, u) => {
              let { name: h, override: y, aliases: S } = u,
                E = { middleware: l, ...u },
                b = yd(h, S);
              if (b.length > 0) {
                if (b.some((v) => o.has(v))) {
                  if (!y)
                    throw new Error(`Duplicate middleware name '${za(h, S)}'`);
                  for (let v of b) {
                    let I = t.findIndex(
                      (ge) =>
                        ge.name === v || ge.aliases?.some((Fe) => Fe === v)
                    );
                    if (I === -1) continue;
                    let O = t[I];
                    if (
                      O.toMiddleware !== E.toMiddleware ||
                      O.relation !== E.relation
                    )
                      throw new Error(
                        `"${za(O.name, O.aliases)}" middleware ${O.relation} "${O.toMiddleware}" middleware cannot be overridden by "${za(h, S)}" middleware ${E.relation} "${E.toMiddleware}" middleware.`
                      );
                    t.splice(I, 1);
                  }
                }
                for (let v of b) o.add(v);
              }
              t.push(E);
            },
            clone: () => c(of()),
            use: (l) => {
              l.applyToStack(f);
            },
            remove: (l) => (typeof l == "string" ? i(l) : a(l)),
            removeByTag: (l) => {
              let u = !1,
                h = (y) => {
                  let { tags: S, name: E, aliases: b } = y;
                  if (S && S.includes(l)) {
                    let v = yd(E, b);
                    for (let I of v) o.delete(I);
                    return (u = !0), !1;
                  }
                  return !0;
                };
              return (e = e.filter(h)), (t = t.filter(h)), u;
            },
            concat: (l) => {
              let u = c(of());
              return (
                u.use(l),
                u.identifyOnResolve(
                  r || u.identifyOnResolve() || (l.identifyOnResolve?.() ?? !1)
                ),
                u
              );
            },
            applyToStack: c,
            identify: () =>
              m(!0).map((l) => {
                let u = l.step ?? l.relation + " " + l.toMiddleware;
                return za(l.name, l.aliases) + " - " + u;
              }),
            identifyOnResolve(l) {
              return typeof l == "boolean" && (r = l), r;
            },
            resolve: (l, u) => {
              for (let h of m()
                .map((y) => y.middleware)
                .reverse())
                l = h(l, u);
              return r && console.log(f.identify()), l;
            },
          };
        return f;
      }),
      (Gpe = {
        initialize: 5,
        serialize: 4,
        build: 3,
        finalizeRequest: 2,
        deserialize: 1,
      }),
      (Vpe = { high: 3, normal: 2, low: 1 });
  });
var qB = s(() => {
  Wpe();
});
var qa,
  Kpe = s(() => {
    qB();
    qa = class {
      constructor(t) {
        (this.config = t), (this.middlewareStack = of());
      }
      send(t, r, o) {
        let n = typeof r != "function" ? r : void 0,
          i = typeof r == "function" ? r : o,
          a = n === void 0 && this.config.cacheMiddleware === !0,
          c;
        if (a) {
          this.handlers || (this.handlers = new WeakMap());
          let d = this.handlers;
          d.has(t.constructor)
            ? (c = d.get(t.constructor))
            : ((c = t.resolveMiddleware(this.middlewareStack, this.config, n)),
              d.set(t.constructor, c));
        } else
          delete this.handlers,
            (c = t.resolveMiddleware(this.middlewareStack, this.config, n));
        if (i)
          c(t)
            .then(
              (d) => i(null, d.output),
              (d) => i(d)
            )
            .catch(() => {});
        else return c(t).then((d) => d.output);
      }
      destroy() {
        this.config?.requestHandler?.destroy?.(), delete this.handlers;
      }
    };
  });
var Ype = s(() => {
  Dt();
});
var Hs,
  jB,
  Qpe = s(() => {
    qB();
    fd();
    (Hs = class {
      constructor() {
        this.middlewareStack = of();
      }
      static classBuilder() {
        return new jB();
      }
      resolveMiddlewareWithContext(
        t,
        r,
        o,
        {
          middlewareFn: n,
          clientName: i,
          commandName: a,
          inputFilterSensitiveLog: c,
          outputFilterSensitiveLog: d,
          smithyContext: m,
          additionalContext: f,
          CommandCtor: l,
        }
      ) {
        for (let E of n.bind(this)(l, t, r, o)) this.middlewareStack.use(E);
        let u = t.concat(this.middlewareStack),
          { logger: h } = r,
          y = {
            logger: h,
            clientName: i,
            commandName: a,
            inputFilterSensitiveLog: c,
            outputFilterSensitiveLog: d,
            [lfe]: { commandInstance: this, ...m },
            ...f,
          },
          { requestHandler: S } = r;
        return u.resolve((E) => S.handle(E.request, o || {}), y);
      }
    }),
      (jB = class {
        constructor() {
          (this._init = () => {}),
            (this._ep = {}),
            (this._middlewareFn = () => []),
            (this._commandName = ""),
            (this._clientName = ""),
            (this._additionalContext = {}),
            (this._smithyContext = {}),
            (this._inputFilterSensitiveLog = (t) => t),
            (this._outputFilterSensitiveLog = (t) => t),
            (this._serializer = null),
            (this._deserializer = null);
        }
        init(t) {
          this._init = t;
        }
        ep(t) {
          return (this._ep = t), this;
        }
        m(t) {
          return (this._middlewareFn = t), this;
        }
        s(t, r, o = {}) {
          return (
            (this._smithyContext = { service: t, operation: r, ...o }), this
          );
        }
        c(t = {}) {
          return (this._additionalContext = t), this;
        }
        n(t, r) {
          return (this._clientName = t), (this._commandName = r), this;
        }
        f(t = (o) => o, r = (o) => o) {
          return (
            (this._inputFilterSensitiveLog = t),
            (this._outputFilterSensitiveLog = r),
            this
          );
        }
        ser(t) {
          return (this._serializer = t), this;
        }
        de(t) {
          return (this._deserializer = t), this;
        }
        sc(t) {
          return (
            (this._operationSchema = t),
            (this._smithyContext.operationSchema = t),
            this
          );
        }
        build() {
          let t = this,
            r;
          return (r = class extends Hs {
            static getEndpointParameterInstructions() {
              return t._ep;
            }
            constructor(...[o]) {
              super(),
                (this.serialize = t._serializer),
                (this.deserialize = t._deserializer),
                (this.input = o ?? {}),
                t._init(this),
                (this.schema = t._operationSchema);
            }
            resolveMiddleware(o, n, i) {
              return this.resolveMiddlewareWithContext(o, n, i, {
                CommandCtor: r,
                middlewareFn: t._middlewareFn,
                clientName: t._clientName,
                commandName: t._commandName,
                inputFilterSensitiveLog: t._inputFilterSensitiveLog,
                outputFilterSensitiveLog: t._outputFilterSensitiveLog,
                smithyContext: t._smithyContext,
                additionalContext: t._additionalContext,
              });
            }
          });
        }
      });
  });
var ui,
  Xpe = s(() => {
    ui = "***SensitiveInformation***";
  });
var tb,
  Jpe = s(() => {
    tb = (e, t) => {
      for (let r of Object.keys(e)) {
        let o = e[r],
          n = async function (a, c, d) {
            let m = new o(a);
            if (typeof c == "function") this.send(m, c);
            else if (typeof d == "function") {
              if (typeof c != "object")
                throw new Error(`Expected http options but got ${typeof c}`);
              this.send(m, c || {}, d);
            } else return this.send(m, c);
          },
          i = (r[0].toLowerCase() + r.slice(1)).replace(/Command$/, "");
        t.prototype[i] = n;
      }
    };
  });
var nf,
  Dr,
  GB = s(() => {
    (nf = class e extends Error {
      constructor(t) {
        super(t.message),
          Object.setPrototypeOf(
            this,
            Object.getPrototypeOf(this).constructor.prototype
          ),
          (this.name = t.name),
          (this.$fault = t.$fault),
          (this.$metadata = t.$metadata);
      }
      static isInstance(t) {
        if (!t) return !1;
        let r = t;
        return (
          e.prototype.isPrototypeOf(r) ||
          (!!r.$fault &&
            !!r.$metadata &&
            (r.$fault === "client" || r.$fault === "server"))
        );
      }
      static [Symbol.hasInstance](t) {
        if (!t) return !1;
        let r = t;
        return this === e
          ? e.isInstance(t)
          : e.isInstance(t)
            ? r.name && this.name
              ? this.prototype.isPrototypeOf(t) || r.name === this.name
              : this.prototype.isPrototypeOf(t)
            : !1;
      }
    }),
      (Dr = (e, t = {}) => {
        Object.entries(t)
          .filter(([, o]) => o !== void 0)
          .forEach(([o, n]) => {
            (e[o] == null || e[o] === "") && (e[o] = n);
          });
        let r = e.message || e.Message || "UnknownError";
        return (e.message = r), delete e.Message, e;
      });
  });
var Vit,
  rb,
  Wit,
  Zpe = s(() => {
    GB();
    (Vit = ({ output: e, parsedBody: t, exceptionCtor: r, errorCode: o }) => {
      let n = Wit(e),
        i = n.httpStatusCode ? n.httpStatusCode + "" : void 0,
        a = new r({
          name: t?.code || t?.Code || o || i || "UnknownError",
          $fault: "client",
          $metadata: n,
        });
      throw Dr(a, t);
    }),
      (rb =
        (e) =>
        ({ output: t, parsedBody: r, errorCode: o }) => {
          Vit({ output: t, parsedBody: r, exceptionCtor: e, errorCode: o });
        }),
      (Wit = (e) => ({
        httpStatusCode: e.statusCode,
        requestId:
          e.headers["x-amzn-requestid"] ??
          e.headers["x-amzn-request-id"] ??
          e.headers["x-amz-request-id"],
        extendedRequestId: e.headers["x-amz-id-2"],
        cfId: e.headers["x-amz-cf-id"],
      }));
  });
var ob,
  ehe = s(() => {
    ob = (e) => {
      switch (e) {
        case "standard":
          return { retryMode: "standard", connectionTimeout: 3100 };
        case "in-region":
          return { retryMode: "standard", connectionTimeout: 1100 };
        case "cross-region":
          return { retryMode: "standard", connectionTimeout: 3100 };
        case "mobile":
          return { retryMode: "standard", connectionTimeout: 3e4 };
        default:
          return {};
      }
    };
  });
var the,
  nb,
  rhe = s(() => {
    (the = !1),
      (nb = (e) => {
        e &&
          !the &&
          parseInt(e.substring(1, e.indexOf("."))) < 16 &&
          (the = !0);
      });
  });
var ohe = s(() => {
  Dt();
});
var nhe,
  she,
  ihe = s(() => {
    fd();
    (nhe = (e) => {
      let t = [];
      for (let r in jl) {
        let o = jl[r];
        e[o] !== void 0 &&
          t.push({ algorithmId: () => o, checksumConstructor: () => e[o] });
      }
      return {
        addChecksumAlgorithm(r) {
          t.push(r);
        },
        checksumAlgorithms() {
          return t;
        },
      };
    }),
      (she = (e) => {
        let t = {};
        return (
          e.checksumAlgorithms().forEach((r) => {
            t[r.algorithmId()] = r.checksumConstructor();
          }),
          t
        );
      });
  });
var ahe,
  che,
  dhe = s(() => {
    (ahe = (e) => ({
      setRetryStrategy(t) {
        e.retryStrategy = t;
      },
      retryStrategy() {
        return e.retryStrategy;
      },
    })),
      (che = (e) => {
        let t = {};
        return (t.retryStrategy = e.retryStrategy()), t;
      });
  });
var sb,
  ib,
  mhe = s(() => {
    ihe();
    dhe();
    (sb = (e) => Object.assign(nhe(e), ahe(e))),
      (ib = (e) => Object.assign(she(e), che(e)));
  });
var lhe = s(() => {
  mhe();
});
var fhe = s(() => {});
var uhe = s(() => {});
var phe = s(() => {});
var ja,
  hhe = s(() => {
    ja = class {
      trace() {}
      debug() {}
      info() {}
      warn() {}
      error() {}
    };
  });
function xn(e, t, r) {
  let o, n, i;
  if (typeof t > "u" && typeof r > "u") (o = {}), (i = e);
  else {
    if (((o = e), typeof t == "function"))
      return (n = t), (i = r), Kit(o, n, i);
    i = t;
  }
  for (let a of Object.keys(i)) {
    if (!Array.isArray(i[a])) {
      o[a] = i[a];
      continue;
    }
    ghe(o, null, i, a);
  }
  return o;
}
var En,
  Kit,
  ghe,
  Yit,
  Qit,
  yhe = s(() => {
    (En = (e, t) => {
      let r = {};
      for (let o in t) ghe(r, e, t, o);
      return r;
    }),
      (Kit = (e, t, r) =>
        xn(
          e,
          Object.entries(r).reduce(
            (o, [n, i]) => (
              Array.isArray(i)
                ? (o[n] = i)
                : typeof i == "function"
                  ? (o[n] = [t, i()])
                  : (o[n] = [t, i]),
              o
            ),
            {}
          )
        )),
      (ghe = (e, t, r, o) => {
        if (t !== null) {
          let a = r[o];
          typeof a == "function" && (a = [, a]);
          let [c = Yit, d = Qit, m = o] = a;
          ((typeof c == "function" && c(t[m])) ||
            (typeof c != "function" && c)) &&
            (e[o] = d(t[m]));
          return;
        }
        let [n, i] = r[o];
        if (typeof i == "function") {
          let a,
            c = n === void 0 && (a = i()) != null,
            d =
              (typeof n == "function" && !!n(void 0)) ||
              (typeof n != "function" && !!n);
          c ? (e[o] = a) : d && (e[o] = i());
        } else {
          let a = n === void 0 && i != null,
            c =
              (typeof n == "function" && !!n(i)) ||
              (typeof n != "function" && !!n);
          (a || c) && (e[o] = i);
        }
      }),
      (Yit = (e) => e != null),
      (Qit = (e) => e);
  });
var xhe = s(() => {
  Dt();
});
var Ehe = s(() => {});
var ab,
  She = s(() => {
    ab = (e) => {
      if (e == null) return {};
      if (Array.isArray(e)) return e.filter((t) => t != null).map(ab);
      if (typeof e == "object") {
        let t = {};
        for (let r of Object.keys(e)) e[r] != null && (t[r] = ab(e[r]));
        return t;
      }
      return e;
    };
  });
var Tr = s(() => {
  Kpe();
  Ype();
  Qpe();
  Xpe();
  Jpe();
  Zpe();
  ehe();
  rhe();
  GB();
  ohe();
  lhe();
  fhe();
  uhe();
  phe();
  hhe();
  yhe();
  xhe();
  Ehe();
  She();
  Uo();
});
import { Readable as Xit } from "stream";
var Che,
  bhe = s(() => {
    Che = (e) =>
      e?.body instanceof Xit ||
      (typeof ReadableStream < "u" && e?.body instanceof ReadableStream);
  });
var Jit,
  Zit,
  eat,
  tat,
  rat,
  cb,
  oat,
  _he = s(() => {
    yn();
    yg();
    Tr();
    fi();
    id();
    bhe();
    HB();
    (Jit = (e) => (t, r) => async (o) => {
      let n = await e.retryStrategy(),
        i = await e.maxAttempts();
      if (Zit(n)) {
        n = n;
        let a = await n.acquireInitialRetryToken(r.partition_id),
          c = new Error(),
          d = 0,
          m = 0,
          { request: f } = o,
          l = jo.isInstance(f);
        for (l && (f.headers[WC] = qo()); ; )
          try {
            l && (f.headers[KC] = `attempt=${d + 1}; max=${i}`);
            let { response: u, output: h } = await t(o);
            return (
              n.recordSuccess(a),
              (h.$metadata.attempts = d + 1),
              (h.$metadata.totalRetryDelay = m),
              { response: u, output: h }
            );
          } catch (u) {
            let h = eat(u);
            if (((c = $B(u)), l && Che(f)))
              throw (
                ((r.logger instanceof ja ? console : r.logger)?.warn(
                  "An error was encountered in a non-retryable streaming request."
                ),
                c)
              );
            try {
              a = await n.refreshRetryTokenForRetry(a, h);
            } catch {
              throw (
                (c.$metadata || (c.$metadata = {}),
                (c.$metadata.attempts = d + 1),
                (c.$metadata.totalRetryDelay = m),
                c)
              );
            }
            d = a.getRetryCount();
            let y = a.getRetryDelay();
            (m += y), await new Promise((S) => setTimeout(S, y));
          }
      } else
        return (
          (n = n),
          n?.mode &&
            (r.userAgent = [
              ...(r.userAgent || []),
              ["cfg/retry-mode", n.mode],
            ]),
          n.retry(t, o)
        );
    }),
      (Zit = (e) =>
        typeof e.acquireInitialRetryToken < "u" &&
        typeof e.refreshRetryTokenForRetry < "u" &&
        typeof e.recordSuccess < "u"),
      (eat = (e) => {
        let t = { error: e, errorType: tat(e) },
          r = oat(e.$response);
        return r && (t.retryAfterHint = r), t;
      }),
      (tat = (e) =>
        Zl(e)
          ? "THROTTLING"
          : gg(e)
            ? "TRANSIENT"
            : Ipe(e)
              ? "SERVER_ERROR"
              : "CLIENT_ERROR"),
      (rat = {
        name: "retryMiddleware",
        tags: ["RETRY"],
        step: "finalizeRequest",
        priority: "high",
        override: !0,
      }),
      (cb = (e) => ({
        applyToStack: (t) => {
          t.add(Jit(e), rat);
        },
      })),
      (oat = (e) => {
        if (!di.isInstance(e)) return;
        let t = Object.keys(e.headers).find(
          (i) => i.toLowerCase() === "retry-after"
        );
        if (!t) return;
        let r = e.headers[t],
          o = Number(r);
        return Number.isNaN(o) ? new Date(r) : new Date(o * 1e3);
      });
  });
var xg = s(() => {
  $pe();
  zB();
  qpe();
  FB();
  jpe();
  UB();
  _he();
});
function nat(e) {
  return {
    schemeId: "aws.auth#sigv4",
    signingProperties: { name: "sso-oauth", region: e.region },
    propertiesExtractor: (t, r) => ({
      signingProperties: { config: t, context: r },
    }),
  };
}
function sat(e) {
  return { schemeId: "smithy.api#noAuth" };
}
var whe,
  The,
  Ahe,
  VB = s(() => {
    rt();
    ct();
    whe = async (e, t, r) => ({
      operation: bt(t).operation,
      region:
        (await pe(e.region)()) ||
        (() => {
          throw new Error(
            "expected `region` to be configured for `aws.auth#sigv4`"
          );
        })(),
    });
    (The = (e) => {
      let t = [];
      switch (e.operation) {
        case "CreateToken": {
          t.push(sat(e));
          break;
        }
        default:
          t.push(nat(e));
      }
      return t;
    }),
      (Ahe = (e) => {
        let t = zo(e);
        return Object.assign(t, {
          authSchemePreference: pe(e.authSchemePreference ?? []),
        });
      });
  });
var Rhe,
  Ihe,
  WB = s(() => {
    (Rhe = (e) =>
      Object.assign(e, {
        useDualstackEndpoint: e.useDualstackEndpoint ?? !1,
        useFipsEndpoint: e.useFipsEndpoint ?? !1,
        defaultSigningName: "sso-oauth",
      })),
      (Ihe = {
        UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
        Endpoint: { type: "builtInParams", name: "endpoint" },
        Region: { type: "builtInParams", name: "region" },
        UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
      });
  });
var db,
  KB = s(() => {
    db = {
      name: "@aws-sdk/nested-clients",
      version: "3.839.0",
      description: "Nested clients for AWS SDK packages.",
      main: "./dist-cjs/index.js",
      module: "./dist-es/index.js",
      types: "./dist-types/index.d.ts",
      scripts: {
        build:
          "yarn lint && concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
        "build:cjs": "node ../../scripts/compilation/inline nested-clients",
        "build:es": "tsc -p tsconfig.es.json",
        "build:include:deps":
          "lerna run --scope $npm_package_name --include-dependencies build",
        "build:types": "tsc -p tsconfig.types.json",
        "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
        clean: "rimraf ./dist-* && rimraf *.tsbuildinfo",
        lint: "node ../../scripts/validation/submodules-linter.js --pkg nested-clients",
        test: "yarn g:vitest run",
        "test:watch": "yarn g:vitest watch",
      },
      engines: { node: ">=18.0.0" },
      author: {
        name: "AWS SDK for JavaScript Team",
        url: "https://aws.amazon.com/javascript/",
      },
      license: "Apache-2.0",
      dependencies: {
        "@aws-crypto/sha256-browser": "5.2.0",
        "@aws-crypto/sha256-js": "5.2.0",
        "@aws-sdk/core": "3.839.0",
        "@aws-sdk/middleware-host-header": "3.821.0",
        "@aws-sdk/middleware-logger": "3.821.0",
        "@aws-sdk/middleware-recursion-detection": "3.821.0",
        "@aws-sdk/middleware-user-agent": "3.839.0",
        "@aws-sdk/region-config-resolver": "3.821.0",
        "@aws-sdk/types": "3.821.0",
        "@aws-sdk/util-endpoints": "3.828.0",
        "@aws-sdk/util-user-agent-browser": "3.821.0",
        "@aws-sdk/util-user-agent-node": "3.839.0",
        "@smithy/config-resolver": "^4.1.4",
        "@smithy/core": "^3.6.0",
        "@smithy/fetch-http-handler": "^5.0.4",
        "@smithy/hash-node": "^4.0.4",
        "@smithy/invalid-dependency": "^4.0.4",
        "@smithy/middleware-content-length": "^4.0.4",
        "@smithy/middleware-endpoint": "^4.1.13",
        "@smithy/middleware-retry": "^4.1.14",
        "@smithy/middleware-serde": "^4.0.8",
        "@smithy/middleware-stack": "^4.0.4",
        "@smithy/node-config-provider": "^4.1.3",
        "@smithy/node-http-handler": "^4.0.6",
        "@smithy/protocol-http": "^5.1.2",
        "@smithy/smithy-client": "^4.4.5",
        "@smithy/types": "^4.3.1",
        "@smithy/url-parser": "^4.0.4",
        "@smithy/util-base64": "^4.0.0",
        "@smithy/util-body-length-browser": "^4.0.0",
        "@smithy/util-body-length-node": "^4.0.0",
        "@smithy/util-defaults-mode-browser": "^4.0.21",
        "@smithy/util-defaults-mode-node": "^4.0.21",
        "@smithy/util-endpoints": "^3.0.6",
        "@smithy/util-middleware": "^4.0.4",
        "@smithy/util-retry": "^4.0.6",
        "@smithy/util-utf8": "^4.0.0",
        tslib: "^2.6.2",
      },
      devDependencies: {
        concurrently: "7.0.0",
        "downlevel-dts": "0.10.1",
        rimraf: "3.0.2",
        typescript: "~5.8.3",
      },
      typesVersions: { "<4.0": { "dist-types/*": ["dist-types/ts3.4/*"] } },
      files: [
        "./sso-oidc.d.ts",
        "./sso-oidc.js",
        "./sts.d.ts",
        "./sts.js",
        "dist-*/**",
      ],
      browser: {
        "./dist-es/submodules/sso-oidc/runtimeConfig":
          "./dist-es/submodules/sso-oidc/runtimeConfig.browser",
        "./dist-es/submodules/sts/runtimeConfig":
          "./dist-es/submodules/sts/runtimeConfig.browser",
      },
      "react-native": {},
      homepage:
        "https://github.com/aws/aws-sdk-js-v3/tree/main/packages/nested-clients",
      repository: {
        type: "git",
        url: "https://github.com/aws/aws-sdk-js-v3.git",
        directory: "packages/nested-clients",
      },
      exports: {
        "./sso-oidc": {
          types: "./dist-types/submodules/sso-oidc/index.d.ts",
          module: "./dist-es/submodules/sso-oidc/index.js",
          node: "./dist-cjs/submodules/sso-oidc/index.js",
          import: "./dist-es/submodules/sso-oidc/index.js",
          require: "./dist-cjs/submodules/sso-oidc/index.js",
        },
        "./sts": {
          types: "./dist-types/submodules/sts/index.d.ts",
          module: "./dist-es/submodules/sts/index.js",
          node: "./dist-cjs/submodules/sts/index.js",
          import: "./dist-es/submodules/sts/index.js",
          require: "./dist-cjs/submodules/sts/index.js",
        },
      },
    };
  });
var YB,
  QB = s(() => {
    YB = { isCrtAvailable: !1 };
  });
var Phe,
  vhe = s(() => {
    QB();
    Phe = () => (YB.isCrtAvailable ? ["md/crt-avail"] : null);
  });
import { platform as aat, release as cat } from "os";
import { env as Ohe, versions as dat } from "process";
var mb,
  khe = s(() => {
    vhe();
    QB();
    mb =
      ({ serviceId: e, clientVersion: t }) =>
      async (r) => {
        let o = [
            ["aws-sdk-js", t],
            ["ua", "2.1"],
            [`os/${aat()}`, cat()],
            ["lang/js"],
            ["md/nodejs", `${dat.node}`],
          ],
          n = Phe();
        n && o.push(n),
          e && o.push([`api/${e}`, t]),
          Ohe.AWS_EXECUTION_ENV &&
            o.push([`exec-env/${Ohe.AWS_EXECUTION_ENV}`]);
        let i = await r?.userAgentAppId?.();
        return i ? [...o, [`app/${i}`]] : [...o];
      };
  });
var mat,
  lat,
  fat,
  lb,
  Dhe = s(() => {
    kC();
    (mat = "AWS_SDK_UA_APP_ID"),
      (lat = "sdk_ua_app_id"),
      (fat = "sdk-ua-app-id"),
      (lb = {
        environmentVariableSelector: (e) => e[mat],
        configFileSelector: (e) => e[lat] ?? e[fat],
        default: cB,
      });
  });
var XB = s(() => {
  khe();
  Dhe();
});
import { Buffer as JB } from "buffer";
var ZB,
  Nhe,
  Bhe = s(() => {
    cr();
    (ZB = (e, t = 0, r = e.byteLength - t) => {
      if (!Ke(e))
        throw new TypeError(
          `The "input" argument must be ArrayBuffer. Received type ${typeof e} (${e})`
        );
      return JB.from(e, t, r);
    }),
      (Nhe = (e, t) => {
        if (typeof e != "string")
          throw new TypeError(
            `The "input" argument must be of type string. Received type ${typeof e} (${e})`
          );
        return t ? JB.from(e, t) : JB.from(e);
      });
  });
import { Buffer as eM } from "buffer";
var Mhe,
  Lhe,
  tM = s(() => {
    cr();
    (Mhe = (e, t = 0, r = e.byteLength - t) => {
      if (!Ke(e))
        throw new TypeError(
          `The "input" argument must be ArrayBuffer. Received type ${typeof e} (${e})`
        );
      return eM.from(e, t, r);
    }),
      (Lhe = (e, t) => {
        if (typeof e != "string")
          throw new TypeError(
            `The "input" argument must be of type string. Received type ${typeof e} (${e})`
          );
        return t ? eM.from(e, t) : eM.from(e);
      });
  });
var Ga,
  rM = s(() => {
    tM();
    Ga = (e) => {
      let t = Lhe(e, "utf8");
      return new Uint8Array(
        t.buffer,
        t.byteOffset,
        t.byteLength / Uint8Array.BYTES_PER_ELEMENT
      );
    };
  });
var Fhe,
  Uhe = s(() => {
    rM();
    Fhe = (e) =>
      typeof e == "string"
        ? Ga(e)
        : ArrayBuffer.isView(e)
          ? new Uint8Array(
              e.buffer,
              e.byteOffset,
              e.byteLength / Uint8Array.BYTES_PER_ELEMENT
            )
          : new Uint8Array(e);
  });
var fb,
  $he = s(() => {
    tM();
    fb = (e) => {
      if (typeof e == "string") return e;
      if (
        typeof e != "object" ||
        typeof e.byteOffset != "number" ||
        typeof e.byteLength != "number"
      )
        throw new Error(
          "@smithy/util-utf8: toUtf8 encoder function only accepts string | Uint8Array."
        );
      return Mhe(e.buffer, e.byteOffset, e.byteLength).toString("utf8");
    };
  });
var Eg = s(() => {
  rM();
  Uhe();
  $he();
});
import { Buffer as uat } from "buffer";
import { createHash as pat, createHmac as hat } from "crypto";
function Hhe(e, t) {
  return uat.isBuffer(e)
    ? e
    : typeof e == "string"
      ? Nhe(e, t)
      : ArrayBuffer.isView(e)
        ? ZB(e.buffer, e.byteOffset, e.byteLength)
        : ZB(e);
}
var sf,
  oM = s(() => {
    Bhe();
    Eg();
    sf = class {
      constructor(t, r) {
        (this.algorithmIdentifier = t), (this.secret = r), this.reset();
      }
      update(t, r) {
        this.hash.update(Fhe(Hhe(t, r)));
      }
      digest() {
        return Promise.resolve(this.hash.digest());
      }
      reset() {
        this.hash = this.secret
          ? hat(this.algorithmIdentifier, Hhe(this.secret))
          : pat(this.algorithmIdentifier);
      }
    };
  });
var Sg,
  gat,
  nM = s(() => {
    (Sg = (e) => encodeURIComponent(e).replace(/[!'()*]/g, gat)),
      (gat = (e) => `%${e.charCodeAt(0).toString(16).toUpperCase()}`);
  });
var zhe = s(() => {
  nM();
});
var qhe = s(() => {
  nM();
  zhe();
});
function sM(e) {
  let t = [];
  for (let r of Object.keys(e).sort()) {
    let o = e[r];
    if (((r = Sg(r)), Array.isArray(o)))
      for (let n = 0, i = o.length; n < i; n++) t.push(`${r}=${Sg(o[n])}`);
    else {
      let n = r;
      (o || typeof o == "string") && (n += `=${Sg(o)}`), t.push(n);
    }
  }
  return t.join("&");
}
var iM = s(() => {
  qhe();
});
var jhe,
  Ghe = s(() => {
    jhe = ["ECONNRESET", "EPIPE", "ETIMEDOUT"];
  });
var aM,
  cM = s(() => {
    aM = (e) => {
      let t = {};
      for (let r of Object.keys(e)) {
        let o = e[r];
        t[r] = Array.isArray(o) ? o.join(",") : o;
      }
      return t;
    };
  });
var eo,
  af = s(() => {
    eo = {
      setTimeout: (e, t) => setTimeout(e, t),
      clearTimeout: (e) => clearTimeout(e),
    };
  });
var Vhe,
  Whe,
  Khe = s(() => {
    af();
    (Vhe = 1e3),
      (Whe = (e, t, r = 0) => {
        if (!r) return -1;
        let o = (n) => {
          let i = eo.setTimeout(() => {
              e.destroy(),
                t(
                  Object.assign(
                    new Error(
                      `Socket timed out without establishing a connection within ${r} ms`
                    ),
                    { name: "TimeoutError" }
                  )
                );
            }, r - n),
            a = (c) => {
              c?.connecting
                ? c.on("connect", () => {
                    eo.clearTimeout(i);
                  })
                : eo.clearTimeout(i);
            };
          e.socket ? a(e.socket) : e.on("socket", a);
        };
        return r < 2e3 ? (o(0), 0) : eo.setTimeout(o.bind(null, Vhe), Vhe);
      });
  });
var yat,
  Yhe,
  Qhe = s(() => {
    af();
    (yat = 3e3),
      (Yhe = (e, { keepAlive: t, keepAliveMsecs: r }, o = yat) => {
        if (t !== !0) return -1;
        let n = () => {
          e.socket
            ? e.socket.setKeepAlive(t, r || 0)
            : e.on("socket", (i) => {
                i.setKeepAlive(t, r || 0);
              });
        };
        return o === 0 ? (n(), 0) : eo.setTimeout(n, o);
      });
  });
var Xhe,
  Jhe,
  Zhe = s(() => {
    dM();
    af();
    (Xhe = 3e3),
      (Jhe = (e, t, r = ege) => {
        let o = (n) => {
          let i = r - n,
            a = () => {
              e.destroy(),
                t(
                  Object.assign(
                    new Error(`Connection timed out after ${r} ms`),
                    { name: "TimeoutError" }
                  )
                );
            };
          e.socket
            ? (e.socket.setTimeout(i, a),
              e.on("close", () => e.socket?.removeListener("timeout", a)))
            : e.setTimeout(i, a);
        };
        return 0 < r && r < 6e3
          ? (o(0), 0)
          : eo.setTimeout(o.bind(null, r === 0 ? 0 : Xhe), Xhe);
      });
  });
import { Readable as xat } from "stream";
async function mM(e, t, r = tge) {
  let o = t.headers ?? {},
    n = o.Expect || o.expect,
    i = -1,
    a = !0;
  n === "100-continue" &&
    (a = await Promise.race([
      new Promise((c) => {
        i = Number(eo.setTimeout(() => c(!0), Math.max(tge, r)));
      }),
      new Promise((c) => {
        e.on("continue", () => {
          eo.clearTimeout(i), c(!0);
        }),
          e.on("response", () => {
            eo.clearTimeout(i), c(!1);
          }),
          e.on("error", () => {
            eo.clearTimeout(i), c(!1);
          });
      }),
    ])),
    a && Eat(e, t.body);
}
function Eat(e, t) {
  if (t instanceof xat) {
    t.pipe(e);
    return;
  }
  if (t) {
    if (Buffer.isBuffer(t) || typeof t == "string") {
      e.end(t);
      return;
    }
    let r = t;
    if (
      typeof r == "object" &&
      r.buffer &&
      typeof r.byteOffset == "number" &&
      typeof r.byteLength == "number"
    ) {
      e.end(Buffer.from(r.buffer, r.byteOffset, r.byteLength));
      return;
    }
    e.end(Buffer.from(t));
    return;
  }
  e.end();
}
var tge,
  lM = s(() => {
    af();
    tge = 6e3;
  });
import { Agent as rge, request as Sat } from "http";
import { Agent as oge, request as Cat } from "https";
var ege,
  cf,
  dM = s(() => {
    yn();
    iM();
    Ghe();
    cM();
    Khe();
    Qhe();
    Zhe();
    af();
    lM();
    (ege = 0),
      (cf = class e {
        static create(t) {
          return typeof t?.handle == "function" ? t : new e(t);
        }
        static checkSocketUsage(t, r, o = console) {
          let { sockets: n, requests: i, maxSockets: a } = t;
          if (typeof a != "number" || a === 1 / 0 || Date.now() - 15e3 < r)
            return r;
          if (n && i)
            for (let d in n) {
              let m = n[d]?.length ?? 0,
                f = i[d]?.length ?? 0;
              if (m >= a && f >= 2 * a)
                return (
                  o?.warn?.(`@smithy/node-http-handler:WARN - socket usage at capacity=${m} and ${f} additional requests are enqueued.
See https://docs.aws.amazon.com/sdk-for-javascript/v3/developer-guide/node-configuring-maxsockets.html
or increase socketAcquisitionWarningTimeout=(millis) in the NodeHttpHandler config.`),
                  Date.now()
                );
            }
          return r;
        }
        constructor(t) {
          (this.socketWarningTimestamp = 0),
            (this.metadata = { handlerProtocol: "http/1.1" }),
            (this.configProvider = new Promise((r, o) => {
              typeof t == "function"
                ? t()
                    .then((n) => {
                      r(this.resolveDefaultConfig(n));
                    })
                    .catch(o)
                : r(this.resolveDefaultConfig(t));
            }));
        }
        resolveDefaultConfig(t) {
          let {
              requestTimeout: r,
              connectionTimeout: o,
              socketTimeout: n,
              socketAcquisitionWarningTimeout: i,
              httpAgent: a,
              httpsAgent: c,
            } = t || {},
            d = !0,
            m = 50;
          return {
            connectionTimeout: o,
            requestTimeout: r ?? n,
            socketAcquisitionWarningTimeout: i,
            httpAgent:
              a instanceof rge || typeof a?.destroy == "function"
                ? a
                : new rge({ keepAlive: d, maxSockets: m, ...a }),
            httpsAgent:
              c instanceof oge || typeof c?.destroy == "function"
                ? c
                : new oge({ keepAlive: d, maxSockets: m, ...c }),
            logger: console,
          };
        }
        destroy() {
          this.config?.httpAgent?.destroy(), this.config?.httpsAgent?.destroy();
        }
        async handle(t, { abortSignal: r } = {}) {
          return (
            this.config || (this.config = await this.configProvider),
            new Promise((o, n) => {
              let i,
                a = [],
                c = async (I) => {
                  await i, a.forEach(eo.clearTimeout), o(I);
                },
                d = async (I) => {
                  await i, a.forEach(eo.clearTimeout), n(I);
                };
              if (!this.config)
                throw new Error(
                  "Node HTTP request handler config is not resolved"
                );
              if (r?.aborted) {
                let I = new Error("Request aborted");
                (I.name = "AbortError"), d(I);
                return;
              }
              let m = t.protocol === "https:",
                f = m ? this.config.httpsAgent : this.config.httpAgent;
              a.push(
                eo.setTimeout(
                  () => {
                    this.socketWarningTimestamp = e.checkSocketUsage(
                      f,
                      this.socketWarningTimestamp,
                      this.config.logger
                    );
                  },
                  this.config.socketAcquisitionWarningTimeout ??
                    (this.config.requestTimeout ?? 2e3) +
                      (this.config.connectionTimeout ?? 1e3)
                )
              );
              let l = sM(t.query || {}),
                u;
              if (t.username != null || t.password != null) {
                let I = t.username ?? "",
                  O = t.password ?? "";
                u = `${I}:${O}`;
              }
              let h = t.path;
              l && (h += `?${l}`), t.fragment && (h += `#${t.fragment}`);
              let y = t.hostname ?? "";
              y[0] === "[" && y.endsWith("]")
                ? (y = t.hostname.slice(1, -1))
                : (y = t.hostname);
              let S = {
                  headers: t.headers,
                  host: y,
                  method: t.method,
                  path: h,
                  port: t.port,
                  agent: f,
                  auth: u,
                },
                b = (m ? Cat : Sat)(S, (I) => {
                  let O = new di({
                    statusCode: I.statusCode || -1,
                    reason: I.statusMessage,
                    headers: aM(I.headers),
                    body: I,
                  });
                  c({ response: O });
                });
              if (
                (b.on("error", (I) => {
                  jhe.includes(I.code)
                    ? d(Object.assign(I, { name: "TimeoutError" }))
                    : d(I);
                }),
                r)
              ) {
                let I = () => {
                  b.destroy();
                  let O = new Error("Request aborted");
                  (O.name = "AbortError"), d(O);
                };
                if (typeof r.addEventListener == "function") {
                  let O = r;
                  O.addEventListener("abort", I, { once: !0 }),
                    b.once("close", () => O.removeEventListener("abort", I));
                } else r.onabort = I;
              }
              a.push(Whe(b, d, this.config.connectionTimeout)),
                a.push(Jhe(b, d, this.config.requestTimeout));
              let v = S.agent;
              typeof v == "object" &&
                "keepAlive" in v &&
                a.push(
                  Yhe(b, {
                    keepAlive: v.keepAlive,
                    keepAliveMsecs: v.keepAliveMsecs,
                  })
                ),
                (i = mM(b, t, this.config.requestTimeout).catch(
                  (I) => (a.forEach(eo.clearTimeout), n(I))
                ));
            })
          );
        }
        updateHttpClientConfig(t, r) {
          (this.config = void 0),
            (this.configProvider = this.configProvider.then((o) => ({
              ...o,
              [t]: r,
            })));
        }
        httpHandlerConfigs() {
          return this.config ?? {};
        }
      });
  });
var nge = s(() => {});
var sge = s(() => {
  nge();
});
var ige = s(() => {
  yn();
  iM();
  cM();
  sge();
  lM();
});
import { Writable as bat } from "stream";
var ub,
  age = s(() => {
    ub = class extends bat {
      constructor() {
        super(...arguments), (this.bufferedBytes = []);
      }
      _write(t, r, o) {
        this.bufferedBytes.push(t), o();
      }
    };
  });
async function wat(e) {
  let t = [],
    r = e.getReader(),
    o = !1,
    n = 0;
  for (; !o; ) {
    let { done: c, value: d } = await r.read();
    d && (t.push(d), (n += d.length)), (o = c);
  }
  let i = new Uint8Array(n),
    a = 0;
  for (let c of t) i.set(c, a), (a += c.length);
  return i;
}
var pb,
  _at,
  cge = s(() => {
    age();
    (pb = (e) =>
      _at(e)
        ? wat(e)
        : new Promise((t, r) => {
            let o = new ub();
            e.pipe(o),
              e.on("error", (n) => {
                o.end(), r(n);
              }),
              o.on("error", r),
              o.on("finish", function () {
                let n = new Uint8Array(Buffer.concat(this.bufferedBytes));
                t(n);
              });
          })),
      (_at = (e) =>
        typeof ReadableStream == "function" && e instanceof ReadableStream);
  });
var fM = s(() => {
  dM();
  ige();
  cge();
});
import { fstatSync as Tat, lstatSync as Aat } from "fs";
var hb,
  dge = s(() => {
    hb = (e) => {
      if (!e) return 0;
      if (typeof e == "string") return Buffer.byteLength(e);
      if (typeof e.byteLength == "number") return e.byteLength;
      if (typeof e.size == "number") return e.size;
      if (typeof e.start == "number" && typeof e.end == "number")
        return e.end + 1 - e.start;
      if (typeof e.path == "string" || Buffer.isBuffer(e.path))
        return Aat(e.path).size;
      if (typeof e.fd == "number") return Tat(e.fd).size;
      throw new Error(`Body Length computation failed for ${e}`);
    };
  });
var uM = s(() => {
  dge();
});
import { Buffer as pM } from "buffer";
var mge,
  lge,
  hM = s(() => {
    cr();
    (mge = (e, t = 0, r = e.byteLength - t) => {
      if (!Ke(e))
        throw new TypeError(
          `The "input" argument must be ArrayBuffer. Received type ${typeof e} (${e})`
        );
      return pM.from(e, t, r);
    }),
      (lge = (e, t) => {
        if (typeof e != "string")
          throw new TypeError(
            `The "input" argument must be of type string. Received type ${typeof e} (${e})`
          );
        return t ? pM.from(e, t) : pM.from(e);
      });
  });
var Rat,
  gb,
  fge = s(() => {
    hM();
    (Rat = /^[A-Za-z0-9+/]*={0,2}$/),
      (gb = (e) => {
        if ((e.length * 3) % 4 !== 0)
          throw new TypeError("Incorrect padding on base64 string.");
        if (!Rat.exec(e)) throw new TypeError("Invalid base64 string.");
        let t = lge(e, "base64");
        return new Uint8Array(t.buffer, t.byteOffset, t.byteLength);
      });
  });
var yb,
  uge = s(() => {
    hM();
    Eg();
    yb = (e) => {
      let t;
      if (
        (typeof e == "string" ? (t = Ga(e)) : (t = e),
        typeof t != "object" ||
          typeof t.byteOffset != "number" ||
          typeof t.byteLength != "number")
      )
        throw new Error(
          "@smithy/util-base64: toBase64 encoder function only accepts string | Uint8Array."
        );
      return mge(t.buffer, t.byteOffset, t.byteLength).toString("base64");
    };
  });
var gM = s(() => {
  fge();
  uge();
});
var _ge,
  Xn,
  Jn,
  lf,
  pge,
  Cg,
  df,
  mf,
  Qi,
  yM,
  xM,
  hge,
  gge,
  yge,
  wge,
  Tge,
  Qn,
  xge,
  Age,
  Ege,
  Sge,
  Cge,
  bge,
  Iat,
  Rge,
  Ige = s(() => {
    (_ge = "required"),
      (Xn = "fn"),
      (Jn = "argv"),
      (lf = "ref"),
      (pge = "isSet"),
      (Cg = "booleanEquals"),
      (df = "error"),
      (mf = "endpoint"),
      (Qi = "tree"),
      (yM = "PartitionResult"),
      (xM = "getAttr"),
      (hge = { [_ge]: !1, type: "String" }),
      (gge = { [_ge]: !0, default: !1, type: "Boolean" }),
      (yge = { [lf]: "Endpoint" }),
      (wge = { [Xn]: Cg, [Jn]: [{ [lf]: "UseFIPS" }, !0] }),
      (Tge = { [Xn]: Cg, [Jn]: [{ [lf]: "UseDualStack" }, !0] }),
      (Qn = {}),
      (xge = { [Xn]: xM, [Jn]: [{ [lf]: yM }, "supportsFIPS"] }),
      (Age = { [lf]: yM }),
      (Ege = {
        [Xn]: Cg,
        [Jn]: [!0, { [Xn]: xM, [Jn]: [Age, "supportsDualStack"] }],
      }),
      (Sge = [wge]),
      (Cge = [Tge]),
      (bge = [{ [lf]: "Region" }]),
      (Iat = {
        version: "1.0",
        parameters: {
          Region: hge,
          UseDualStack: gge,
          UseFIPS: gge,
          Endpoint: hge,
        },
        rules: [
          {
            conditions: [{ [Xn]: pge, [Jn]: [yge] }],
            rules: [
              {
                conditions: Sge,
                error:
                  "Invalid Configuration: FIPS and custom endpoint are not supported",
                type: df,
              },
              {
                conditions: Cge,
                error:
                  "Invalid Configuration: Dualstack and custom endpoint are not supported",
                type: df,
              },
              { endpoint: { url: yge, properties: Qn, headers: Qn }, type: mf },
            ],
            type: Qi,
          },
          {
            conditions: [{ [Xn]: pge, [Jn]: bge }],
            rules: [
              {
                conditions: [{ [Xn]: "aws.partition", [Jn]: bge, assign: yM }],
                rules: [
                  {
                    conditions: [wge, Tge],
                    rules: [
                      {
                        conditions: [{ [Xn]: Cg, [Jn]: [!0, xge] }, Ege],
                        rules: [
                          {
                            endpoint: {
                              url: "https://oidc-fips.{Region}.{PartitionResult#dualStackDnsSuffix}",
                              properties: Qn,
                              headers: Qn,
                            },
                            type: mf,
                          },
                        ],
                        type: Qi,
                      },
                      {
                        error:
                          "FIPS and DualStack are enabled, but this partition does not support one or both",
                        type: df,
                      },
                    ],
                    type: Qi,
                  },
                  {
                    conditions: Sge,
                    rules: [
                      {
                        conditions: [{ [Xn]: Cg, [Jn]: [xge, !0] }],
                        rules: [
                          {
                            conditions: [
                              {
                                [Xn]: "stringEquals",
                                [Jn]: [
                                  { [Xn]: xM, [Jn]: [Age, "name"] },
                                  "aws-us-gov",
                                ],
                              },
                            ],
                            endpoint: {
                              url: "https://oidc.{Region}.amazonaws.com",
                              properties: Qn,
                              headers: Qn,
                            },
                            type: mf,
                          },
                          {
                            endpoint: {
                              url: "https://oidc-fips.{Region}.{PartitionResult#dnsSuffix}",
                              properties: Qn,
                              headers: Qn,
                            },
                            type: mf,
                          },
                        ],
                        type: Qi,
                      },
                      {
                        error:
                          "FIPS is enabled but this partition does not support FIPS",
                        type: df,
                      },
                    ],
                    type: Qi,
                  },
                  {
                    conditions: Cge,
                    rules: [
                      {
                        conditions: [Ege],
                        rules: [
                          {
                            endpoint: {
                              url: "https://oidc.{Region}.{PartitionResult#dualStackDnsSuffix}",
                              properties: Qn,
                              headers: Qn,
                            },
                            type: mf,
                          },
                        ],
                        type: Qi,
                      },
                      {
                        error:
                          "DualStack is enabled but this partition does not support DualStack",
                        type: df,
                      },
                    ],
                    type: Qi,
                  },
                  {
                    endpoint: {
                      url: "https://oidc.{Region}.{PartitionResult#dnsSuffix}",
                      properties: Qn,
                      headers: Qn,
                    },
                    type: mf,
                  },
                ],
                type: Qi,
              },
            ],
            type: Qi,
          },
          { error: "Invalid Configuration: Missing Region", type: df },
        ],
      }),
      (Rge = Iat);
  });
var Pat,
  Pge,
  vge = s(() => {
    RC();
    $t();
    Ige();
    (Pat = new uo({
      size: 50,
      params: ["Endpoint", "Region", "UseDualStack", "UseFIPS"],
    })),
      (Pge = (e, t = {}) =>
        Pat.get(e, () => jr(Rge, { endpointParams: e, logger: t.logger })));
    Jt.aws = ug;
  });
var Oge,
  kge = s(() => {
    rt();
    Ue();
    Tr();
    pg();
    gM();
    Eg();
    VB();
    vge();
    Oge = (e) => ({
      apiVersion: "2019-06-10",
      base64Decoder: e?.base64Decoder ?? gb,
      base64Encoder: e?.base64Encoder ?? yb,
      disableHostPrefix: e?.disableHostPrefix ?? !1,
      endpointProvider: e?.endpointProvider ?? Pge,
      extensions: e?.extensions ?? [],
      httpAuthSchemeProvider: e?.httpAuthSchemeProvider ?? The,
      httpAuthSchemes: e?.httpAuthSchemes ?? [
        {
          schemeId: "aws.auth#sigv4",
          identityProvider: (t) => t.getIdentityProvider("aws.auth#sigv4"),
          signer: new wr(),
        },
        {
          schemeId: "smithy.api#noAuth",
          identityProvider: (t) =>
            t.getIdentityProvider("smithy.api#noAuth") || (async () => ({})),
          signer: new hn(),
        },
      ],
      logger: e?.logger ?? new ja(),
      serviceId: e?.serviceId ?? "SSO OIDC",
      urlParser: e?.urlParser ?? li,
      utf8Decoder: e?.utf8Decoder ?? Ga,
      utf8Encoder: e?.utf8Encoder ?? fb,
    });
  });
var Dge,
  EM,
  SM,
  Nge,
  Bge,
  Mge,
  Lge = s(() => {
    (Dge = "AWS_EXECUTION_ENV"),
      (EM = "AWS_REGION"),
      (SM = "AWS_DEFAULT_REGION"),
      (Nge = "AWS_EC2_METADATA_DISABLED"),
      (Bge = ["in-region", "cross-region", "mobile", "standard", "legacy"]),
      (Mge = "/latest/meta-data/placement/region");
  });
var vat,
  Oat,
  Fge,
  Uge = s(() => {
    (vat = "AWS_DEFAULTS_MODE"),
      (Oat = "defaults_mode"),
      (Fge = {
        environmentVariableSelector: (e) => e[vat],
        configFileSelector: (e) => e[Oat],
        default: "legacy",
      });
  });
import { Buffer as kat } from "buffer";
import { request as Dat } from "http";
function Va(e) {
  return new Promise((t, r) => {
    let o = Dat({
      method: "GET",
      ...e,
      hostname: e.hostname?.replace(/^\[(.+)\]$/, "$1"),
    });
    o.on("error", (n) => {
      r(
        Object.assign(
          new Zt("Unable to connect to instance metadata service"),
          n
        )
      ),
        o.destroy();
    }),
      o.on("timeout", () => {
        r(new Zt("TimeoutError from instance metadata service")), o.destroy();
      }),
      o.on("response", (n) => {
        let { statusCode: i = 400 } = n;
        (i < 200 || 300 <= i) &&
          (r(
            Object.assign(
              new Zt("Error response received from instance metadata service"),
              { statusCode: i }
            )
          ),
          o.destroy());
        let a = [];
        n.on("data", (c) => {
          a.push(c);
        }),
          n.on("end", () => {
            t(kat.concat(a)), o.destroy();
          });
      }),
      o.end();
  });
}
var xb = s(() => {
  re();
});
var Eb,
  Sb,
  CM = s(() => {
    (Eb = (e) =>
      !!e &&
      typeof e == "object" &&
      typeof e.AccessKeyId == "string" &&
      typeof e.SecretAccessKey == "string" &&
      typeof e.Token == "string" &&
      typeof e.Expiration == "string"),
      (Sb = (e) => ({
        accessKeyId: e.AccessKeyId,
        secretAccessKey: e.SecretAccessKey,
        sessionToken: e.Token,
        expiration: new Date(e.Expiration),
        ...(e.AccountId && { accountId: e.AccountId }),
      }));
  });
var OEr,
  kEr,
  bg,
  Cb = s(() => {
    (OEr = 1e3),
      (kEr = 0),
      (bg = ({ maxRetries: e = 0, timeout: t = 1e3 }) => ({
        maxRetries: e,
        timeout: t,
      }));
  });
var _g,
  bM = s(() => {
    _g = (e, t) => {
      let r = e();
      for (let o = 0; o < t; o++) r = r.catch(e);
      return r;
    };
  });
import { parse as Nat } from "url";
var bb,
  _b,
  _M,
  Bat,
  Mat,
  Lat,
  Fat,
  Uat,
  $at,
  $ge = s(() => {
    re();
    xb();
    CM();
    Cb();
    bM();
    (bb = "AWS_CONTAINER_CREDENTIALS_FULL_URI"),
      (_b = "AWS_CONTAINER_CREDENTIALS_RELATIVE_URI"),
      (_M = "AWS_CONTAINER_AUTHORIZATION_TOKEN"),
      (Bat = (e = {}) => {
        let { timeout: t, maxRetries: r } = bg(e);
        return () =>
          _g(async () => {
            let o = await $at({ logger: e.logger }),
              n = JSON.parse(await Mat(t, o));
            if (!Eb(n))
              throw new P(
                "Invalid response received from instance metadata service.",
                { logger: e.logger }
              );
            return Sb(n);
          }, r);
      }),
      (Mat = async (e, t) => (
        process.env[_M] &&
          (t.headers = { ...t.headers, Authorization: process.env[_M] }),
        (await Va({ ...t, timeout: e })).toString()
      )),
      (Lat = "169.254.170.2"),
      (Fat = { localhost: !0, "127.0.0.1": !0 }),
      (Uat = { "http:": !0, "https:": !0 }),
      ($at = async ({ logger: e }) => {
        if (process.env[_b]) return { hostname: Lat, path: process.env[_b] };
        if (process.env[bb]) {
          let t = Nat(process.env[bb]);
          if (!t.hostname || !(t.hostname in Fat))
            throw new P(
              `${t.hostname} is not a valid container metadata service hostname`,
              { tryNextLink: !1, logger: e }
            );
          if (!t.protocol || !(t.protocol in Uat))
            throw new P(
              `${t.protocol} is not a valid container metadata service protocol`,
              { tryNextLink: !1, logger: e }
            );
          return { ...t, port: t.port ? parseInt(t.port, 10) : void 0 };
        }
        throw new P(
          `The container metadata credential provider cannot be used unless the ${_b} or ${bb} environment variable is set`,
          { tryNextLink: !1, logger: e }
        );
      });
  });
var wb,
  Hge = s(() => {
    re();
    wb = class e extends P {
      constructor(t, r = !0) {
        super(t, r),
          (this.tryNextLink = r),
          (this.name = "InstanceMetadataV1FallbackError"),
          Object.setPrototypeOf(this, e.prototype);
      }
    };
  });
var xd,
  wM = s(() => {
    (function (e) {
      (e.IPv4 = "http://169.254.169.254"), (e.IPv6 = "http://[fd00:ec2::254]");
    })(xd || (xd = {}));
  });
var Hat,
  zat,
  zge,
  qge = s(() => {
    (Hat = "AWS_EC2_METADATA_SERVICE_ENDPOINT"),
      (zat = "ec2_metadata_service_endpoint"),
      (zge = {
        environmentVariableSelector: (e) => e[Hat],
        configFileSelector: (e) => e[zat],
        default: void 0,
      });
  });
var Wa,
  TM = s(() => {
    (function (e) {
      (e.IPv4 = "IPv4"), (e.IPv6 = "IPv6");
    })(Wa || (Wa = {}));
  });
var qat,
  jat,
  jge,
  Gge = s(() => {
    TM();
    (qat = "AWS_EC2_METADATA_SERVICE_ENDPOINT_MODE"),
      (jat = "ec2_metadata_service_endpoint_mode"),
      (jge = {
        environmentVariableSelector: (e) => e[qat],
        configFileSelector: (e) => e[jat],
        default: Wa.IPv4,
      });
  });
var Tb,
  Gat,
  Vat,
  AM = s(() => {
    pd();
    pg();
    wM();
    qge();
    TM();
    Gge();
    (Tb = async () => li((await Gat()) || (await Vat()))),
      (Gat = async () => mr(zge)()),
      (Vat = async () => {
        let e = await mr(jge)();
        switch (e) {
          case Wa.IPv4:
            return xd.IPv4;
          case Wa.IPv6:
            return xd.IPv6;
          default:
            throw new Error(
              `Unsupported endpoint mode: ${e}. Select from ${Object.values(Wa)}`
            );
        }
      });
  });
var Wat,
  RM,
  Vge = s(() => {
    (Wat =
      "https://docs.aws.amazon.com/sdkref/latest/guide/feature-static-credentials.html"),
      (RM = (e, t) => {
        let r = 300 + Math.floor(Math.random() * 300),
          o = new Date(Date.now() + r * 1e3);
        t.warn(
          `Attempting credential expiration extension due to a credential service availability issue. A refresh of these credentials will be attempted after ${new Date(o)}.
For more information, please visit: ` + Wat
        );
        let n = e.originalExpiration ?? e.expiration;
        return { ...e, ...(n ? { originalExpiration: n } : {}), expiration: o };
      });
  });
var Wge,
  Kge = s(() => {
    Vge();
    Wge = (e, t = {}) => {
      let r = t?.logger || console,
        o;
      return async () => {
        let n;
        try {
          (n = await e()),
            n.expiration &&
              n.expiration.getTime() < Date.now() &&
              (n = RM(n, r));
        } catch (i) {
          if (o) r.warn("Credential renew failed: ", i), (n = RM(o, r));
          else throw i;
        }
        return (o = n), n;
      };
    };
  });
var Xge,
  Kat,
  IM,
  Yge,
  Qge,
  Yat,
  Qat,
  Xat,
  Jat,
  Zat,
  Jge = s(() => {
    pd();
    re();
    Hge();
    xb();
    CM();
    Cb();
    bM();
    AM();
    Kge();
    (Xge = "/latest/meta-data/iam/security-credentials/"),
      (Kat = "/latest/api/token"),
      (IM = "AWS_EC2_METADATA_V1_DISABLED"),
      (Yge = "ec2_metadata_v1_disabled"),
      (Qge = "x-aws-ec2-metadata-token"),
      (Yat = (e = {}) => Wge(Qat(e), { logger: e.logger })),
      (Qat = (e = {}) => {
        let t = !1,
          { logger: r, profile: o } = e,
          { timeout: n, maxRetries: i } = bg(e),
          a = async (c, d) => {
            if (t || d.headers?.[Qge] == null) {
              let l = !1,
                u = !1,
                h = await mr(
                  {
                    environmentVariableSelector: (y) => {
                      let S = y[IM];
                      if (((u = !!S && S !== "false"), S === void 0))
                        throw new P(
                          `${IM} not set in env, checking config file next.`,
                          { logger: e.logger }
                        );
                      return u;
                    },
                    configFileSelector: (y) => {
                      let S = y[Yge];
                      return (l = !!S && S !== "false"), l;
                    },
                    default: !1,
                  },
                  { profile: o }
                )();
              if (e.ec2MetadataV1Disabled || h) {
                let y = [];
                throw (
                  (e.ec2MetadataV1Disabled &&
                    y.push(
                      "credential provider initialization (runtime option ec2MetadataV1Disabled)"
                    ),
                  l && y.push(`config file profile (${Yge})`),
                  u && y.push(`process environment variable (${IM})`),
                  new wb(
                    `AWS EC2 Metadata v1 fallback has been blocked by AWS SDK configuration in the following: [${y.join(", ")}].`
                  ))
                );
              }
            }
            let f = (
              await _g(async () => {
                let l;
                try {
                  l = await Jat(d);
                } catch (u) {
                  throw (u.statusCode === 401 && (t = !1), u);
                }
                return l;
              }, c)
            ).trim();
            return _g(async () => {
              let l;
              try {
                l = await Zat(f, d, e);
              } catch (u) {
                throw (u.statusCode === 401 && (t = !1), u);
              }
              return l;
            }, c);
          };
        return async () => {
          let c = await Tb();
          if (t)
            return (
              r?.debug(
                "AWS SDK Instance Metadata",
                "using v1 fallback (no token fetch)"
              ),
              a(i, { ...c, timeout: n })
            );
          {
            let d;
            try {
              d = (await Xat({ ...c, timeout: n })).toString();
            } catch (m) {
              if (m?.statusCode === 400)
                throw Object.assign(m, {
                  message: "EC2 Metadata token request returned error",
                });
              return (
                (m.message === "TimeoutError" ||
                  [403, 404, 405].includes(m.statusCode)) &&
                  (t = !0),
                r?.debug(
                  "AWS SDK Instance Metadata",
                  "using v1 fallback (initial)"
                ),
                a(i, { ...c, timeout: n })
              );
            }
            return a(i, { ...c, headers: { [Qge]: d }, timeout: n });
          }
        };
      }),
      (Xat = async (e) =>
        Va({
          ...e,
          path: Kat,
          method: "PUT",
          headers: { "x-aws-ec2-metadata-token-ttl-seconds": "21600" },
        })),
      (Jat = async (e) => (await Va({ ...e, path: Xge })).toString()),
      (Zat = async (e, t, r) => {
        let o = JSON.parse((await Va({ ...t, path: Xge + e })).toString());
        if (!Eb(o))
          throw new P(
            "Invalid response received from instance metadata service.",
            { logger: r.logger }
          );
        return Sb(o);
      });
  });
var Zge = s(() => {});
var eye = {};
It(eye, {
  DEFAULT_MAX_RETRIES: () => kEr,
  DEFAULT_TIMEOUT: () => OEr,
  ENV_CMDS_AUTH_TOKEN: () => _M,
  ENV_CMDS_FULL_URI: () => bb,
  ENV_CMDS_RELATIVE_URI: () => _b,
  Endpoint: () => xd,
  fromContainerMetadata: () => Bat,
  fromInstanceMetadata: () => Yat,
  getInstanceMetadataEndpoint: () => Tb,
  httpRequest: () => Va,
  providerConfigFromInit: () => bg,
});
var tye = s(() => {
  $ge();
  Jge();
  Cb();
  Zge();
  xb();
  AM();
  wM();
});
var Ab,
  ect,
  tct,
  rye = s(() => {
    Vl();
    pd();
    re();
    Lge();
    Uge();
    (Ab = ({ region: e = mr(Gl), defaultsMode: t = mr(Fge) } = {}) =>
      gr(async () => {
        let r = typeof t == "function" ? await t() : t;
        switch (r?.toLowerCase()) {
          case "auto":
            return ect(e);
          case "in-region":
          case "cross-region":
          case "mobile":
          case "standard":
          case "legacy":
            return Promise.resolve(r?.toLocaleLowerCase());
          case void 0:
            return Promise.resolve("legacy");
          default:
            throw new Error(
              `Invalid parameter for "defaultsMode", expect ${Bge.join(", ")}, got ${r}`
            );
        }
      })),
      (ect = async (e) => {
        if (e) {
          let t = typeof e == "function" ? await e() : e,
            r = await tct();
          return r ? (t === r ? "in-region" : "cross-region") : "standard";
        }
        return "standard";
      }),
      (tct = async () => {
        if (process.env[Dge] && (process.env[EM] || process.env[SM]))
          return process.env[EM] ?? process.env[SM];
        if (!process.env[Nge])
          try {
            let { getInstanceMetadataEndpoint: e, httpRequest: t } =
                await Promise.resolve().then(() => (tye(), eye)),
              r = await e();
            return (await t({ ...r, path: Mge })).toString();
          } catch {}
      });
  });
var PM = s(() => {
  rye();
});
var oye,
  nye = s(() => {
    KB();
    rt();
    XB();
    Vl();
    oM();
    xg();
    pd();
    fM();
    uM();
    fi();
    kge();
    Tr();
    PM();
    Tr();
    oye = (e) => {
      nb(process.version);
      let t = Ab(e),
        r = () => t().then(ob),
        o = Oge(e);
      $o(process.version);
      let n = { profile: e?.profile, logger: o.logger };
      return {
        ...o,
        ...e,
        runtime: "node",
        defaultsMode: t,
        authSchemePreference: e?.authSchemePreference ?? mr(Ho, n),
        bodyLengthChecker: e?.bodyLengthChecker ?? hb,
        defaultUserAgentProvider:
          e?.defaultUserAgentProvider ??
          mb({ serviceId: o.serviceId, clientVersion: db.version }),
        maxAttempts: e?.maxAttempts ?? mr(JC, e),
        region: e?.region ?? mr(Gl, { ...BC, ...n }),
        requestHandler: cf.create(e?.requestHandler ?? r),
        retryMode:
          e?.retryMode ??
          mr({ ...eb, default: async () => (await r()).retryMode || Jl }, e),
        sha256: e?.sha256 ?? sf.bind(null, "sha256"),
        streamCollector: e?.streamCollector ?? pb,
        useDualstackEndpoint: e?.useDualstackEndpoint ?? mr(DC, n),
        useFipsEndpoint: e?.useFipsEndpoint ?? mr(NC, n),
        userAgentAppId: e?.userAgentAppId ?? mr(lb, n),
      };
    };
  });
var Go,
  Vo,
  sye = s(() => {
    (Go = (e) => ({
      setRegion(t) {
        e.region = t;
      },
      region() {
        return e.region;
      },
    })),
      (Vo = (e) => ({ region: e.region() }));
  });
var iye = s(() => {});
var vM = s(() => {});
var aye = s(() => {
  vM();
});
var cye = s(() => {
  aye();
  vM();
});
var dye = s(() => {
  iye();
  cye();
});
var Xi = s(() => {
  sye();
  dye();
});
var mye,
  lye,
  fye = s(() => {
    (mye = (e) => {
      let t = e.httpAuthSchemes,
        r = e.httpAuthSchemeProvider,
        o = e.credentials;
      return {
        setHttpAuthScheme(n) {
          let i = t.findIndex((a) => a.schemeId === n.schemeId);
          i === -1 ? t.push(n) : t.splice(i, 1, n);
        },
        httpAuthSchemes() {
          return t;
        },
        setHttpAuthSchemeProvider(n) {
          r = n;
        },
        httpAuthSchemeProvider() {
          return r;
        },
        setCredentials(n) {
          o = n;
        },
        credentials() {
          return o;
        },
      };
    }),
      (lye = (e) => ({
        httpAuthSchemes: e.httpAuthSchemes(),
        httpAuthSchemeProvider: e.httpAuthSchemeProvider(),
        credentials: e.credentials(),
      }));
  });
var uye,
  pye = s(() => {
    Xi();
    yn();
    Tr();
    fye();
    uye = (e, t) => {
      let r = Object.assign(Go(e), sb(e), CC(e), mye(e));
      return (
        t.forEach((o) => o.configure(r)),
        Object.assign(e, Vo(r), ib(r), bC(r), lye(r))
      );
    };
  });
var wg,
  OM = s(() => {
    nB();
    sB();
    aB();
    kC();
    Vl();
    Ue();
    yB();
    Xl();
    xg();
    Tr();
    VB();
    WB();
    nye();
    pye();
    wg = class extends qa {
      config;
      constructor(...[t]) {
        let r = oye(t || {});
        super(r), (this.initConfig = r);
        let o = Rhe(r),
          n = AC(o),
          i = ZC(n),
          a = LC(i),
          c = a,
          d = GC(c),
          m = Ahe(d),
          f = uye(m, t?.extensions || []);
        (this.config = f),
          this.middlewareStack.use(OC(this.config)),
          this.middlewareStack.use(cb(this.config)),
          this.middlewareStack.use(FC(this.config)),
          this.middlewareStack.use(_C(this.config)),
          this.middlewareStack.use(wC(this.config)),
          this.middlewareStack.use(TC(this.config)),
          this.middlewareStack.use(
            Mo(this.config, {
              httpAuthSchemeParametersProvider: whe,
              identityProviderConfigProvider: async (l) =>
                new fo({ "aws.auth#sigv4": l.credentials }),
            })
          ),
          this.middlewareStack.use(Lo(this.config));
      }
      destroy() {
        super.destroy();
      }
    };
  });
var po,
  Rb = s(() => {
    Tr();
    po = class e extends nf {
      constructor(t) {
        super(t), Object.setPrototypeOf(this, e.prototype);
      }
    };
  });
var Tg,
  Ag,
  kM,
  DM,
  Rg,
  Ig,
  Pg,
  vg,
  Og,
  kg,
  Dg,
  Ng,
  Bg,
  Ib = s(() => {
    Tr();
    Rb();
    (Tg = class e extends po {
      name = "AccessDeniedException";
      $fault = "client";
      error;
      error_description;
      constructor(t) {
        super({ name: "AccessDeniedException", $fault: "client", ...t }),
          Object.setPrototypeOf(this, e.prototype),
          (this.error = t.error),
          (this.error_description = t.error_description);
      }
    }),
      (Ag = class e extends po {
        name = "AuthorizationPendingException";
        $fault = "client";
        error;
        error_description;
        constructor(t) {
          super({
            name: "AuthorizationPendingException",
            $fault: "client",
            ...t,
          }),
            Object.setPrototypeOf(this, e.prototype),
            (this.error = t.error),
            (this.error_description = t.error_description);
        }
      }),
      (kM = (e) => ({
        ...e,
        ...(e.clientSecret && { clientSecret: ui }),
        ...(e.refreshToken && { refreshToken: ui }),
        ...(e.codeVerifier && { codeVerifier: ui }),
      })),
      (DM = (e) => ({
        ...e,
        ...(e.accessToken && { accessToken: ui }),
        ...(e.refreshToken && { refreshToken: ui }),
        ...(e.idToken && { idToken: ui }),
      })),
      (Rg = class e extends po {
        name = "ExpiredTokenException";
        $fault = "client";
        error;
        error_description;
        constructor(t) {
          super({ name: "ExpiredTokenException", $fault: "client", ...t }),
            Object.setPrototypeOf(this, e.prototype),
            (this.error = t.error),
            (this.error_description = t.error_description);
        }
      }),
      (Ig = class e extends po {
        name = "InternalServerException";
        $fault = "server";
        error;
        error_description;
        constructor(t) {
          super({ name: "InternalServerException", $fault: "server", ...t }),
            Object.setPrototypeOf(this, e.prototype),
            (this.error = t.error),
            (this.error_description = t.error_description);
        }
      }),
      (Pg = class e extends po {
        name = "InvalidClientException";
        $fault = "client";
        error;
        error_description;
        constructor(t) {
          super({ name: "InvalidClientException", $fault: "client", ...t }),
            Object.setPrototypeOf(this, e.prototype),
            (this.error = t.error),
            (this.error_description = t.error_description);
        }
      }),
      (vg = class e extends po {
        name = "InvalidGrantException";
        $fault = "client";
        error;
        error_description;
        constructor(t) {
          super({ name: "InvalidGrantException", $fault: "client", ...t }),
            Object.setPrototypeOf(this, e.prototype),
            (this.error = t.error),
            (this.error_description = t.error_description);
        }
      }),
      (Og = class e extends po {
        name = "InvalidRequestException";
        $fault = "client";
        error;
        error_description;
        constructor(t) {
          super({ name: "InvalidRequestException", $fault: "client", ...t }),
            Object.setPrototypeOf(this, e.prototype),
            (this.error = t.error),
            (this.error_description = t.error_description);
        }
      }),
      (kg = class e extends po {
        name = "InvalidScopeException";
        $fault = "client";
        error;
        error_description;
        constructor(t) {
          super({ name: "InvalidScopeException", $fault: "client", ...t }),
            Object.setPrototypeOf(this, e.prototype),
            (this.error = t.error),
            (this.error_description = t.error_description);
        }
      }),
      (Dg = class e extends po {
        name = "SlowDownException";
        $fault = "client";
        error;
        error_description;
        constructor(t) {
          super({ name: "SlowDownException", $fault: "client", ...t }),
            Object.setPrototypeOf(this, e.prototype),
            (this.error = t.error),
            (this.error_description = t.error_description);
        }
      }),
      (Ng = class e extends po {
        name = "UnauthorizedClientException";
        $fault = "client";
        error;
        error_description;
        constructor(t) {
          super({
            name: "UnauthorizedClientException",
            $fault: "client",
            ...t,
          }),
            Object.setPrototypeOf(this, e.prototype),
            (this.error = t.error),
            (this.error_description = t.error_description);
        }
      }),
      (Bg = class e extends po {
        name = "UnsupportedGrantTypeException";
        $fault = "client";
        error;
        error_description;
        constructor(t) {
          super({
            name: "UnsupportedGrantTypeException",
            $fault: "client",
            ...t,
          }),
            Object.setPrototypeOf(this, e.prototype),
            (this.error = t.error),
            (this.error_description = t.error_description);
        }
      });
  });
var hye,
  gye,
  nct,
  sct,
  ict,
  act,
  cct,
  dct,
  mct,
  lct,
  fct,
  uct,
  pct,
  hct,
  gct,
  Zn,
  yye = s(() => {
    rt();
    Ue();
    Tr();
    Ib();
    Rb();
    (hye = async (e, t) => {
      let r = G(e, t),
        o = { "content-type": "application/json" };
      r.bp("/token");
      let n;
      return (
        (n = JSON.stringify(
          En(e, {
            clientId: [],
            clientSecret: [],
            code: [],
            codeVerifier: [],
            deviceCode: [],
            grantType: [],
            redirectUri: [],
            refreshToken: [],
            scope: (i) => ab(i),
          })
        )),
        r.m("POST").h(o).b(n),
        r.build()
      );
    }),
      (gye = async (e, t) => {
        if (e.statusCode !== 200 && e.statusCode >= 300) return nct(e, t);
        let r = xn({ $metadata: Zn(e) }),
          o = F(Se(await ie(e.body, t)), "body"),
          n = En(o, {
            accessToken: p,
            expiresIn: $n,
            idToken: p,
            refreshToken: p,
            tokenType: p,
          });
        return Object.assign(r, n), r;
      }),
      (nct = async (e, t) => {
        let r = { ...e, body: await Gn(e.body, t) },
          o = Vn(e, r.body);
        switch (o) {
          case "AccessDeniedException":
          case "com.amazonaws.ssooidc#AccessDeniedException":
            throw await ict(r, t);
          case "AuthorizationPendingException":
          case "com.amazonaws.ssooidc#AuthorizationPendingException":
            throw await act(r, t);
          case "ExpiredTokenException":
          case "com.amazonaws.ssooidc#ExpiredTokenException":
            throw await cct(r, t);
          case "InternalServerException":
          case "com.amazonaws.ssooidc#InternalServerException":
            throw await dct(r, t);
          case "InvalidClientException":
          case "com.amazonaws.ssooidc#InvalidClientException":
            throw await mct(r, t);
          case "InvalidGrantException":
          case "com.amazonaws.ssooidc#InvalidGrantException":
            throw await lct(r, t);
          case "InvalidRequestException":
          case "com.amazonaws.ssooidc#InvalidRequestException":
            throw await fct(r, t);
          case "InvalidScopeException":
          case "com.amazonaws.ssooidc#InvalidScopeException":
            throw await uct(r, t);
          case "SlowDownException":
          case "com.amazonaws.ssooidc#SlowDownException":
            throw await pct(r, t);
          case "UnauthorizedClientException":
          case "com.amazonaws.ssooidc#UnauthorizedClientException":
            throw await hct(r, t);
          case "UnsupportedGrantTypeException":
          case "com.amazonaws.ssooidc#UnsupportedGrantTypeException":
            throw await gct(r, t);
          default:
            let n = r.body;
            return sct({ output: e, parsedBody: n, errorCode: o });
        }
      }),
      (sct = rb(po)),
      (ict = async (e, t) => {
        let r = xn({}),
          o = e.body,
          n = En(o, { error: p, error_description: p });
        Object.assign(r, n);
        let i = new Tg({ $metadata: Zn(e), ...r });
        return Dr(i, e.body);
      }),
      (act = async (e, t) => {
        let r = xn({}),
          o = e.body,
          n = En(o, { error: p, error_description: p });
        Object.assign(r, n);
        let i = new Ag({ $metadata: Zn(e), ...r });
        return Dr(i, e.body);
      }),
      (cct = async (e, t) => {
        let r = xn({}),
          o = e.body,
          n = En(o, { error: p, error_description: p });
        Object.assign(r, n);
        let i = new Rg({ $metadata: Zn(e), ...r });
        return Dr(i, e.body);
      }),
      (dct = async (e, t) => {
        let r = xn({}),
          o = e.body,
          n = En(o, { error: p, error_description: p });
        Object.assign(r, n);
        let i = new Ig({ $metadata: Zn(e), ...r });
        return Dr(i, e.body);
      }),
      (mct = async (e, t) => {
        let r = xn({}),
          o = e.body,
          n = En(o, { error: p, error_description: p });
        Object.assign(r, n);
        let i = new Pg({ $metadata: Zn(e), ...r });
        return Dr(i, e.body);
      }),
      (lct = async (e, t) => {
        let r = xn({}),
          o = e.body,
          n = En(o, { error: p, error_description: p });
        Object.assign(r, n);
        let i = new vg({ $metadata: Zn(e), ...r });
        return Dr(i, e.body);
      }),
      (fct = async (e, t) => {
        let r = xn({}),
          o = e.body,
          n = En(o, { error: p, error_description: p });
        Object.assign(r, n);
        let i = new Og({ $metadata: Zn(e), ...r });
        return Dr(i, e.body);
      }),
      (uct = async (e, t) => {
        let r = xn({}),
          o = e.body,
          n = En(o, { error: p, error_description: p });
        Object.assign(r, n);
        let i = new kg({ $metadata: Zn(e), ...r });
        return Dr(i, e.body);
      }),
      (pct = async (e, t) => {
        let r = xn({}),
          o = e.body,
          n = En(o, { error: p, error_description: p });
        Object.assign(r, n);
        let i = new Dg({ $metadata: Zn(e), ...r });
        return Dr(i, e.body);
      }),
      (hct = async (e, t) => {
        let r = xn({}),
          o = e.body,
          n = En(o, { error: p, error_description: p });
        Object.assign(r, n);
        let i = new Ng({ $metadata: Zn(e), ...r });
        return Dr(i, e.body);
      }),
      (gct = async (e, t) => {
        let r = xn({}),
          o = e.body,
          n = En(o, { error: p, error_description: p });
        Object.assign(r, n);
        let i = new Bg({ $metadata: Zn(e), ...r });
        return Dr(i, e.body);
      }),
      (Zn = (e) => ({
        httpStatusCode: e.statusCode,
        requestId:
          e.headers["x-amzn-requestid"] ??
          e.headers["x-amzn-request-id"] ??
          e.headers["x-amz-request-id"],
        extendedRequestId: e.headers["x-amz-id-2"],
        cfId: e.headers["x-amz-cf-id"],
      }));
  });
var Mg,
  NM = s(() => {
    Xl();
    hg();
    Tr();
    WB();
    Ib();
    yye();
    Mg = class extends (
      Hs.classBuilder()
        .ep(Ihe)
        .m(function (t, r, o, n) {
          return [
            Yl(o, this.serialize, this.deserialize),
            Ql(o, t.getEndpointParameterInstructions()),
          ];
        })
        .s("AWSSSOOIDCService", "CreateToken", {})
        .n("SSOOIDCClient", "CreateTokenCommand")
        .f(kM, DM)
        .ser(hye)
        .de(gye)
        .build()
    ) {};
  });
var yct,
  Pb,
  xye = s(() => {
    Tr();
    NM();
    OM();
    (yct = { CreateTokenCommand: Mg }), (Pb = class extends wg {});
    tb(yct, Pb);
  });
var Eye = s(() => {
  NM();
});
var Sye = s(() => {
  Ib();
});
var Ed = {};
It(Ed, {
  $Command: () => Hs,
  AccessDeniedException: () => Tg,
  AuthorizationPendingException: () => Ag,
  CreateTokenCommand: () => Mg,
  CreateTokenRequestFilterSensitiveLog: () => kM,
  CreateTokenResponseFilterSensitiveLog: () => DM,
  ExpiredTokenException: () => Rg,
  InternalServerException: () => Ig,
  InvalidClientException: () => Pg,
  InvalidGrantException: () => vg,
  InvalidRequestException: () => Og,
  InvalidScopeException: () => kg,
  SSOOIDC: () => Pb,
  SSOOIDCClient: () => wg,
  SSOOIDCServiceException: () => po,
  SlowDownException: () => Dg,
  UnauthorizedClientException: () => Ng,
  UnsupportedGrantTypeException: () => Bg,
  __Client: () => qa,
});
var Sd = s(() => {
  OM();
  xye();
  Eye();
  Sye();
  Rb();
});
var Cye,
  bye = s(() => {
    Cye = async (e, t = {}) => {
      let { SSOOIDCClient: r } = await Promise.resolve().then(() => (Sd(), Ed));
      return new r(
        Object.assign({}, t.clientConfig ?? {}, {
          region: e ?? t.clientConfig?.region,
          logger: t.clientConfig?.logger ?? t.parentClientConfig?.logger,
        })
      );
    };
  });
var _ye,
  wye = s(() => {
    bye();
    _ye = async (e, t, r = {}) => {
      let { CreateTokenCommand: o } = await Promise.resolve().then(
        () => (Sd(), Ed)
      );
      return (await Cye(t, r)).send(
        new o({
          clientId: e.clientId,
          clientSecret: e.clientSecret,
          refreshToken: e.refreshToken,
          grantType: "refresh_token",
        })
      );
    };
  });
var BM,
  Tye = s(() => {
    re();
    SC();
    BM = (e) => {
      if (e.expiration && e.expiration.getTime() < Date.now())
        throw new Je(`Token is expired. ${ql}`, !1);
    };
  });
var Ka,
  Aye = s(() => {
    re();
    SC();
    Ka = (e, t, r = !1) => {
      if (typeof t > "u")
        throw new Je(
          `Value not present for '${e}' in SSO Token${r ? ". Cannot refresh" : ""}. ${ql}`,
          !1
        );
    };
  });
import { promises as xct } from "fs";
var Ect,
  Rye,
  Iye = s(() => {
    Ls();
    ({ writeFile: Ect } = xct),
      (Rye = (e, t) => {
        let r = qE(e),
          o = JSON.stringify(t, null, 2);
        return Ect(r, o);
      });
  });
var Pye,
  vye,
  Oye = s(() => {
    re();
    Ls();
    SC();
    wye();
    Tye();
    Aye();
    Iye();
    (Pye = new Date(0)),
      (vye =
        (e = {}) =>
        async ({ callerClientConfig: t } = {}) => {
          let r = {
            ...e,
            parentClientConfig: { ...t, ...e.parentClientConfig },
          };
          r.logger?.debug("@aws-sdk/token-providers - fromSso");
          let o = await Oa(r),
            n = Kn({ profile: r.profile ?? t?.profile }),
            i = o[n];
          if (i) {
            if (!i.sso_session)
              throw new Je(
                `Profile '${n}' is missing required property 'sso_session'.`
              );
          } else
            throw new Je(
              `Profile '${n}' could not be found in shared credentials file.`,
              !1
            );
          let a = i.sso_session,
            d = (await WE(r))[a];
          if (!d)
            throw new Je(
              `Sso session '${a}' could not be found in shared credentials file.`,
              !1
            );
          for (let S of ["sso_start_url", "sso_region"])
            if (!d[S])
              throw new Je(
                `Sso session '${a}' is missing required property '${S}'.`,
                !1
              );
          let m = d.sso_start_url,
            f = d.sso_region,
            l;
          try {
            l = await jE(a);
          } catch {
            throw new Je(
              `The SSO session token associated with profile=${n} was not found or is invalid. ${ql}`,
              !1
            );
          }
          Ka("accessToken", l.accessToken), Ka("expiresAt", l.expiresAt);
          let { accessToken: u, expiresAt: h } = l,
            y = { token: u, expiration: new Date(h) };
          if (y.expiration.getTime() - Date.now() > 3e5) return y;
          if (Date.now() - Pye.getTime() < 30 * 1e3) return BM(y), y;
          Ka("clientId", l.clientId, !0),
            Ka("clientSecret", l.clientSecret, !0),
            Ka("refreshToken", l.refreshToken, !0);
          try {
            Pye.setTime(Date.now());
            let S = await _ye(l, f, r);
            Ka("accessToken", S.accessToken), Ka("expiresIn", S.expiresIn);
            let E = new Date(Date.now() + S.expiresIn * 1e3);
            try {
              await Rye(a, {
                ...l,
                accessToken: S.accessToken,
                expiresAt: E.toISOString(),
                refreshToken: S.refreshToken,
              });
            } catch {}
            return { token: S.accessToken, expiration: E };
          } catch {
            return BM(y), y;
          }
        });
  });
var kye = s(() => {
  re();
});
var Dye = s(() => {
  re();
});
var Nye = s(() => {
  Cle();
  Oye();
  kye();
  Dye();
});
function Cct(e) {
  return {
    schemeId: "aws.auth#sigv4",
    signingProperties: { name: "awsssoportal", region: e.region },
    propertiesExtractor: (t, r) => ({
      signingProperties: { config: t, context: r },
    }),
  };
}
function vb(e) {
  return { schemeId: "smithy.api#noAuth" };
}
var Bye,
  Mye,
  Lye,
  MM = s(() => {
    rt();
    ct();
    Bye = async (e, t, r) => ({
      operation: bt(t).operation,
      region:
        (await pe(e.region)()) ||
        (() => {
          throw new Error(
            "expected `region` to be configured for `aws.auth#sigv4`"
          );
        })(),
    });
    (Mye = (e) => {
      let t = [];
      switch (e.operation) {
        case "GetRoleCredentials": {
          t.push(vb(e));
          break;
        }
        case "ListAccountRoles": {
          t.push(vb(e));
          break;
        }
        case "ListAccounts": {
          t.push(vb(e));
          break;
        }
        case "Logout": {
          t.push(vb(e));
          break;
        }
        default:
          t.push(Cct(e));
      }
      return t;
    }),
      (Lye = (e) => {
        let t = zo(e);
        return Object.assign(t, {
          authSchemePreference: pe(e.authSchemePreference ?? []),
        });
      });
  });
var Fye,
  Ya,
  ff = s(() => {
    (Fye = (e) =>
      Object.assign(e, {
        useDualstackEndpoint: e.useDualstackEndpoint ?? !1,
        useFipsEndpoint: e.useFipsEndpoint ?? !1,
        defaultSigningName: "awsssoportal",
      })),
      (Ya = {
        UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
        Endpoint: { type: "builtInParams", name: "endpoint" },
        Region: { type: "builtInParams", name: "region" },
        UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
      });
  });
var $ye,
  Uye = s(() => {
    $ye = {
      name: "@aws-sdk/client-sso",
      description:
        "AWS SDK for JavaScript Sso Client for Node.js, Browser and React Native",
      version: "3.839.0",
      scripts: {
        build:
          "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
        "build:cjs": "node ../../scripts/compilation/inline client-sso",
        "build:es": "tsc -p tsconfig.es.json",
        "build:include:deps":
          "lerna run --scope $npm_package_name --include-dependencies build",
        "build:types": "tsc -p tsconfig.types.json",
        "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
        clean: "rimraf ./dist-* && rimraf *.tsbuildinfo",
        "extract:docs": "api-extractor run --local",
        "generate:client":
          "node ../../scripts/generate-clients/single-service --solo sso",
      },
      main: "./dist-cjs/index.js",
      types: "./dist-types/index.d.ts",
      module: "./dist-es/index.js",
      sideEffects: !1,
      dependencies: {
        "@aws-crypto/sha256-browser": "5.2.0",
        "@aws-crypto/sha256-js": "5.2.0",
        "@aws-sdk/core": "3.839.0",
        "@aws-sdk/middleware-host-header": "3.821.0",
        "@aws-sdk/middleware-logger": "3.821.0",
        "@aws-sdk/middleware-recursion-detection": "3.821.0",
        "@aws-sdk/middleware-user-agent": "3.839.0",
        "@aws-sdk/region-config-resolver": "3.821.0",
        "@aws-sdk/types": "3.821.0",
        "@aws-sdk/util-endpoints": "3.828.0",
        "@aws-sdk/util-user-agent-browser": "3.821.0",
        "@aws-sdk/util-user-agent-node": "3.839.0",
        "@smithy/config-resolver": "^4.1.4",
        "@smithy/core": "^3.6.0",
        "@smithy/fetch-http-handler": "^5.0.4",
        "@smithy/hash-node": "^4.0.4",
        "@smithy/invalid-dependency": "^4.0.4",
        "@smithy/middleware-content-length": "^4.0.4",
        "@smithy/middleware-endpoint": "^4.1.13",
        "@smithy/middleware-retry": "^4.1.14",
        "@smithy/middleware-serde": "^4.0.8",
        "@smithy/middleware-stack": "^4.0.4",
        "@smithy/node-config-provider": "^4.1.3",
        "@smithy/node-http-handler": "^4.0.6",
        "@smithy/protocol-http": "^5.1.2",
        "@smithy/smithy-client": "^4.4.5",
        "@smithy/types": "^4.3.1",
        "@smithy/url-parser": "^4.0.4",
        "@smithy/util-base64": "^4.0.0",
        "@smithy/util-body-length-browser": "^4.0.0",
        "@smithy/util-body-length-node": "^4.0.0",
        "@smithy/util-defaults-mode-browser": "^4.0.21",
        "@smithy/util-defaults-mode-node": "^4.0.21",
        "@smithy/util-endpoints": "^3.0.6",
        "@smithy/util-middleware": "^4.0.4",
        "@smithy/util-retry": "^4.0.6",
        "@smithy/util-utf8": "^4.0.0",
        tslib: "^2.6.2",
      },
      devDependencies: {
        "@tsconfig/node18": "18.2.4",
        "@types/node": "^18.19.69",
        concurrently: "7.0.0",
        "downlevel-dts": "0.10.1",
        rimraf: "3.0.2",
        typescript: "~5.8.3",
      },
      engines: { node: ">=18.0.0" },
      typesVersions: { "<4.0": { "dist-types/*": ["dist-types/ts3.4/*"] } },
      files: ["dist-*/**"],
      author: {
        name: "AWS SDK for JavaScript Team",
        url: "https://aws.amazon.com/javascript/",
      },
      license: "Apache-2.0",
      browser: { "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.browser" },
      "react-native": {
        "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.native",
      },
      homepage:
        "https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-sso",
      repository: {
        type: "git",
        url: "https://github.com/aws/aws-sdk-js-v3.git",
        directory: "clients/client-sso",
      },
    };
  });
var LM,
  FM = s(() => {
    LM = { isCrtAvailable: !1 };
  });
var Hye,
  zye = s(() => {
    FM();
    Hye = () => (LM.isCrtAvailable ? ["md/crt-avail"] : null);
  });
import { platform as _ct, release as wct } from "os";
import { env as qye, versions as Tct } from "process";
var Ob,
  jye = s(() => {
    zye();
    FM();
    Ob =
      ({ serviceId: e, clientVersion: t }) =>
      async (r) => {
        let o = [
            ["aws-sdk-js", t],
            ["ua", "2.1"],
            [`os/${_ct()}`, wct()],
            ["lang/js"],
            ["md/nodejs", `${Tct.node}`],
          ],
          n = Hye();
        n && o.push(n),
          e && o.push([`api/${e}`, t]),
          qye.AWS_EXECUTION_ENV &&
            o.push([`exec-env/${qye.AWS_EXECUTION_ENV}`]);
        let i = await r?.userAgentAppId?.();
        return i ? [...o, [`app/${i}`]] : [...o];
      };
  });
var Act,
  Rct,
  Ict,
  kb,
  Gye = s(() => {
    BE();
    (Act = "AWS_SDK_UA_APP_ID"),
      (Rct = "sdk_ua_app_id"),
      (Ict = "sdk-ua-app-id"),
      (kb = {
        environmentVariableSelector: (e) => e[Act],
        configFileSelector: (e) => e[Rct] ?? e[Ict],
        default: bk,
      });
  });
var UM = s(() => {
  jye();
  Gye();
});
import { Buffer as $M } from "buffer";
var HM,
  Vye,
  Wye = s(() => {
    cr();
    (HM = (e, t = 0, r = e.byteLength - t) => {
      if (!Ke(e))
        throw new TypeError(
          `The "input" argument must be ArrayBuffer. Received type ${typeof e} (${e})`
        );
      return $M.from(e, t, r);
    }),
      (Vye = (e, t) => {
        if (typeof e != "string")
          throw new TypeError(
            `The "input" argument must be of type string. Received type ${typeof e} (${e})`
          );
        return t ? $M.from(e, t) : $M.from(e);
      });
  });
import { Buffer as zM } from "buffer";
var Kye,
  Yye,
  qM = s(() => {
    cr();
    (Kye = (e, t = 0, r = e.byteLength - t) => {
      if (!Ke(e))
        throw new TypeError(
          `The "input" argument must be ArrayBuffer. Received type ${typeof e} (${e})`
        );
      return zM.from(e, t, r);
    }),
      (Yye = (e, t) => {
        if (typeof e != "string")
          throw new TypeError(
            `The "input" argument must be of type string. Received type ${typeof e} (${e})`
          );
        return t ? zM.from(e, t) : zM.from(e);
      });
  });
var Qa,
  jM = s(() => {
    qM();
    Qa = (e) => {
      let t = Yye(e, "utf8");
      return new Uint8Array(
        t.buffer,
        t.byteOffset,
        t.byteLength / Uint8Array.BYTES_PER_ELEMENT
      );
    };
  });
var Qye,
  Xye = s(() => {
    jM();
    Qye = (e) =>
      typeof e == "string"
        ? Qa(e)
        : ArrayBuffer.isView(e)
          ? new Uint8Array(
              e.buffer,
              e.byteOffset,
              e.byteLength / Uint8Array.BYTES_PER_ELEMENT
            )
          : new Uint8Array(e);
  });
var Db,
  Jye = s(() => {
    qM();
    Db = (e) => {
      if (typeof e == "string") return e;
      if (
        typeof e != "object" ||
        typeof e.byteOffset != "number" ||
        typeof e.byteLength != "number"
      )
        throw new Error(
          "@smithy/util-utf8: toUtf8 encoder function only accepts string | Uint8Array."
        );
      return Kye(e.buffer, e.byteOffset, e.byteLength).toString("utf8");
    };
  });
var Lg = s(() => {
  jM();
  Xye();
  Jye();
});
import { Buffer as Pct } from "buffer";
import { createHash as vct, createHmac as Oct } from "crypto";
function Zye(e, t) {
  return Pct.isBuffer(e)
    ? e
    : typeof e == "string"
      ? Vye(e, t)
      : ArrayBuffer.isView(e)
        ? HM(e.buffer, e.byteOffset, e.byteLength)
        : HM(e);
}
var uf,
  GM = s(() => {
    Wye();
    Lg();
    uf = class {
      constructor(t, r) {
        (this.algorithmIdentifier = t), (this.secret = r), this.reset();
      }
      update(t, r) {
        this.hash.update(Qye(Zye(t, r)));
      }
      digest() {
        return Promise.resolve(this.hash.digest());
      }
      reset() {
        this.hash = this.secret
          ? Oct(this.algorithmIdentifier, Zye(this.secret))
          : vct(this.algorithmIdentifier);
      }
    };
  });
var Fg,
  kct,
  VM = s(() => {
    (Fg = (e) => encodeURIComponent(e).replace(/[!'()*]/g, kct)),
      (kct = (e) => `%${e.charCodeAt(0).toString(16).toUpperCase()}`);
  });
var exe = s(() => {
  VM();
});
var txe = s(() => {
  VM();
  exe();
});
function WM(e) {
  let t = [];
  for (let r of Object.keys(e).sort()) {
    let o = e[r];
    if (((r = Fg(r)), Array.isArray(o)))
      for (let n = 0, i = o.length; n < i; n++) t.push(`${r}=${Fg(o[n])}`);
    else {
      let n = r;
      (o || typeof o == "string") && (n += `=${Fg(o)}`), t.push(n);
    }
  }
  return t.join("&");
}
var KM = s(() => {
  txe();
});
var rxe,
  oxe = s(() => {
    rxe = ["ECONNRESET", "EPIPE", "ETIMEDOUT"];
  });
var YM,
  QM = s(() => {
    YM = (e) => {
      let t = {};
      for (let r of Object.keys(e)) {
        let o = e[r];
        t[r] = Array.isArray(o) ? o.join(",") : o;
      }
      return t;
    };
  });
var to,
  pf = s(() => {
    to = {
      setTimeout: (e, t) => setTimeout(e, t),
      clearTimeout: (e) => clearTimeout(e),
    };
  });
var nxe,
  sxe,
  ixe = s(() => {
    pf();
    (nxe = 1e3),
      (sxe = (e, t, r = 0) => {
        if (!r) return -1;
        let o = (n) => {
          let i = to.setTimeout(() => {
              e.destroy(),
                t(
                  Object.assign(
                    new Error(
                      `Socket timed out without establishing a connection within ${r} ms`
                    ),
                    { name: "TimeoutError" }
                  )
                );
            }, r - n),
            a = (c) => {
              c?.connecting
                ? c.on("connect", () => {
                    to.clearTimeout(i);
                  })
                : to.clearTimeout(i);
            };
          e.socket ? a(e.socket) : e.on("socket", a);
        };
        return r < 2e3 ? (o(0), 0) : to.setTimeout(o.bind(null, nxe), nxe);
      });
  });
var Dct,
  axe,
  cxe = s(() => {
    pf();
    (Dct = 3e3),
      (axe = (e, { keepAlive: t, keepAliveMsecs: r }, o = Dct) => {
        if (t !== !0) return -1;
        let n = () => {
          e.socket
            ? e.socket.setKeepAlive(t, r || 0)
            : e.on("socket", (i) => {
                i.setKeepAlive(t, r || 0);
              });
        };
        return o === 0 ? (n(), 0) : to.setTimeout(n, o);
      });
  });
var dxe,
  mxe,
  lxe = s(() => {
    XM();
    pf();
    (dxe = 3e3),
      (mxe = (e, t, r = fxe) => {
        let o = (n) => {
          let i = r - n,
            a = () => {
              e.destroy(),
                t(
                  Object.assign(
                    new Error(`Connection timed out after ${r} ms`),
                    { name: "TimeoutError" }
                  )
                );
            };
          e.socket
            ? (e.socket.setTimeout(i, a),
              e.on("close", () => e.socket?.removeListener("timeout", a)))
            : e.setTimeout(i, a);
        };
        return 0 < r && r < 6e3
          ? (o(0), 0)
          : to.setTimeout(o.bind(null, r === 0 ? 0 : dxe), dxe);
      });
  });
import { Readable as Nct } from "stream";
async function JM(e, t, r = uxe) {
  let o = t.headers ?? {},
    n = o.Expect || o.expect,
    i = -1,
    a = !0;
  n === "100-continue" &&
    (a = await Promise.race([
      new Promise((c) => {
        i = Number(to.setTimeout(() => c(!0), Math.max(uxe, r)));
      }),
      new Promise((c) => {
        e.on("continue", () => {
          to.clearTimeout(i), c(!0);
        }),
          e.on("response", () => {
            to.clearTimeout(i), c(!1);
          }),
          e.on("error", () => {
            to.clearTimeout(i), c(!1);
          });
      }),
    ])),
    a && Bct(e, t.body);
}
function Bct(e, t) {
  if (t instanceof Nct) {
    t.pipe(e);
    return;
  }
  if (t) {
    if (Buffer.isBuffer(t) || typeof t == "string") {
      e.end(t);
      return;
    }
    let r = t;
    if (
      typeof r == "object" &&
      r.buffer &&
      typeof r.byteOffset == "number" &&
      typeof r.byteLength == "number"
    ) {
      e.end(Buffer.from(r.buffer, r.byteOffset, r.byteLength));
      return;
    }
    e.end(Buffer.from(t));
    return;
  }
  e.end();
}
var uxe,
  ZM = s(() => {
    pf();
    uxe = 6e3;
  });
import { Agent as pxe, request as Mct } from "http";
import { Agent as hxe, request as Lct } from "https";
var fxe,
  hf,
  XM = s(() => {
    pn();
    KM();
    oxe();
    QM();
    ixe();
    cxe();
    lxe();
    pf();
    ZM();
    (fxe = 0),
      (hf = class e {
        static create(t) {
          return typeof t?.handle == "function" ? t : new e(t);
        }
        static checkSocketUsage(t, r, o = console) {
          let { sockets: n, requests: i, maxSockets: a } = t;
          if (typeof a != "number" || a === 1 / 0 || Date.now() - 15e3 < r)
            return r;
          if (n && i)
            for (let d in n) {
              let m = n[d]?.length ?? 0,
                f = i[d]?.length ?? 0;
              if (m >= a && f >= 2 * a)
                return (
                  o?.warn?.(`@smithy/node-http-handler:WARN - socket usage at capacity=${m} and ${f} additional requests are enqueued.
See https://docs.aws.amazon.com/sdk-for-javascript/v3/developer-guide/node-configuring-maxsockets.html
or increase socketAcquisitionWarningTimeout=(millis) in the NodeHttpHandler config.`),
                  Date.now()
                );
            }
          return r;
        }
        constructor(t) {
          (this.socketWarningTimestamp = 0),
            (this.metadata = { handlerProtocol: "http/1.1" }),
            (this.configProvider = new Promise((r, o) => {
              typeof t == "function"
                ? t()
                    .then((n) => {
                      r(this.resolveDefaultConfig(n));
                    })
                    .catch(o)
                : r(this.resolveDefaultConfig(t));
            }));
        }
        resolveDefaultConfig(t) {
          let {
              requestTimeout: r,
              connectionTimeout: o,
              socketTimeout: n,
              socketAcquisitionWarningTimeout: i,
              httpAgent: a,
              httpsAgent: c,
            } = t || {},
            d = !0,
            m = 50;
          return {
            connectionTimeout: o,
            requestTimeout: r ?? n,
            socketAcquisitionWarningTimeout: i,
            httpAgent:
              a instanceof pxe || typeof a?.destroy == "function"
                ? a
                : new pxe({ keepAlive: d, maxSockets: m, ...a }),
            httpsAgent:
              c instanceof hxe || typeof c?.destroy == "function"
                ? c
                : new hxe({ keepAlive: d, maxSockets: m, ...c }),
            logger: console,
          };
        }
        destroy() {
          this.config?.httpAgent?.destroy(), this.config?.httpsAgent?.destroy();
        }
        async handle(t, { abortSignal: r } = {}) {
          return (
            this.config || (this.config = await this.configProvider),
            new Promise((o, n) => {
              let i,
                a = [],
                c = async (I) => {
                  await i, a.forEach(to.clearTimeout), o(I);
                },
                d = async (I) => {
                  await i, a.forEach(to.clearTimeout), n(I);
                };
              if (!this.config)
                throw new Error(
                  "Node HTTP request handler config is not resolved"
                );
              if (r?.aborted) {
                let I = new Error("Request aborted");
                (I.name = "AbortError"), d(I);
                return;
              }
              let m = t.protocol === "https:",
                f = m ? this.config.httpsAgent : this.config.httpAgent;
              a.push(
                to.setTimeout(
                  () => {
                    this.socketWarningTimestamp = e.checkSocketUsage(
                      f,
                      this.socketWarningTimestamp,
                      this.config.logger
                    );
                  },
                  this.config.socketAcquisitionWarningTimeout ??
                    (this.config.requestTimeout ?? 2e3) +
                      (this.config.connectionTimeout ?? 1e3)
                )
              );
              let l = WM(t.query || {}),
                u;
              if (t.username != null || t.password != null) {
                let I = t.username ?? "",
                  O = t.password ?? "";
                u = `${I}:${O}`;
              }
              let h = t.path;
              l && (h += `?${l}`), t.fragment && (h += `#${t.fragment}`);
              let y = t.hostname ?? "";
              y[0] === "[" && y.endsWith("]")
                ? (y = t.hostname.slice(1, -1))
                : (y = t.hostname);
              let S = {
                  headers: t.headers,
                  host: y,
                  method: t.method,
                  path: h,
                  port: t.port,
                  agent: f,
                  auth: u,
                },
                b = (m ? Lct : Mct)(S, (I) => {
                  let O = new ri({
                    statusCode: I.statusCode || -1,
                    reason: I.statusMessage,
                    headers: YM(I.headers),
                    body: I,
                  });
                  c({ response: O });
                });
              if (
                (b.on("error", (I) => {
                  rxe.includes(I.code)
                    ? d(Object.assign(I, { name: "TimeoutError" }))
                    : d(I);
                }),
                r)
              ) {
                let I = () => {
                  b.destroy();
                  let O = new Error("Request aborted");
                  (O.name = "AbortError"), d(O);
                };
                if (typeof r.addEventListener == "function") {
                  let O = r;
                  O.addEventListener("abort", I, { once: !0 }),
                    b.once("close", () => O.removeEventListener("abort", I));
                } else r.onabort = I;
              }
              a.push(sxe(b, d, this.config.connectionTimeout)),
                a.push(mxe(b, d, this.config.requestTimeout));
              let v = S.agent;
              typeof v == "object" &&
                "keepAlive" in v &&
                a.push(
                  axe(b, {
                    keepAlive: v.keepAlive,
                    keepAliveMsecs: v.keepAliveMsecs,
                  })
                ),
                (i = JM(b, t, this.config.requestTimeout).catch(
                  (I) => (a.forEach(to.clearTimeout), n(I))
                ));
            })
          );
        }
        updateHttpClientConfig(t, r) {
          (this.config = void 0),
            (this.configProvider = this.configProvider.then((o) => ({
              ...o,
              [t]: r,
            })));
        }
        httpHandlerConfigs() {
          return this.config ?? {};
        }
      });
  });
var gxe = s(() => {});
var yxe = s(() => {
  gxe();
});
var xxe = s(() => {
  pn();
  KM();
  QM();
  yxe();
  ZM();
});
import { Writable as Fct } from "stream";
var Nb,
  Exe = s(() => {
    Nb = class extends Fct {
      constructor() {
        super(...arguments), (this.bufferedBytes = []);
      }
      _write(t, r, o) {
        this.bufferedBytes.push(t), o();
      }
    };
  });
async function $ct(e) {
  let t = [],
    r = e.getReader(),
    o = !1,
    n = 0;
  for (; !o; ) {
    let { done: c, value: d } = await r.read();
    d && (t.push(d), (n += d.length)), (o = c);
  }
  let i = new Uint8Array(n),
    a = 0;
  for (let c of t) i.set(c, a), (a += c.length);
  return i;
}
var Bb,
  Uct,
  Sxe = s(() => {
    Exe();
    (Bb = (e) =>
      Uct(e)
        ? $ct(e)
        : new Promise((t, r) => {
            let o = new Nb();
            e.pipe(o),
              e.on("error", (n) => {
                o.end(), r(n);
              }),
              o.on("error", r),
              o.on("finish", function () {
                let n = new Uint8Array(Buffer.concat(this.bufferedBytes));
                t(n);
              });
          })),
      (Uct = (e) =>
        typeof ReadableStream == "function" && e instanceof ReadableStream);
  });
var eL = s(() => {
  XM();
  xxe();
  Sxe();
});
import { fstatSync as Hct, lstatSync as zct } from "fs";
var Mb,
  Cxe = s(() => {
    Mb = (e) => {
      if (!e) return 0;
      if (typeof e == "string") return Buffer.byteLength(e);
      if (typeof e.byteLength == "number") return e.byteLength;
      if (typeof e.size == "number") return e.size;
      if (typeof e.start == "number" && typeof e.end == "number")
        return e.end + 1 - e.start;
      if (typeof e.path == "string" || Buffer.isBuffer(e.path))
        return zct(e.path).size;
      if (typeof e.fd == "number") return Hct(e.fd).size;
      throw new Error(`Body Length computation failed for ${e}`);
    };
  });
var tL = s(() => {
  Cxe();
});
import { Buffer as rL } from "buffer";
var bxe,
  _xe,
  oL = s(() => {
    cr();
    (bxe = (e, t = 0, r = e.byteLength - t) => {
      if (!Ke(e))
        throw new TypeError(
          `The "input" argument must be ArrayBuffer. Received type ${typeof e} (${e})`
        );
      return rL.from(e, t, r);
    }),
      (_xe = (e, t) => {
        if (typeof e != "string")
          throw new TypeError(
            `The "input" argument must be of type string. Received type ${typeof e} (${e})`
          );
        return t ? rL.from(e, t) : rL.from(e);
      });
  });
var qct,
  Lb,
  wxe = s(() => {
    oL();
    (qct = /^[A-Za-z0-9+/]*={0,2}$/),
      (Lb = (e) => {
        if ((e.length * 3) % 4 !== 0)
          throw new TypeError("Incorrect padding on base64 string.");
        if (!qct.exec(e)) throw new TypeError("Invalid base64 string.");
        let t = _xe(e, "base64");
        return new Uint8Array(t.buffer, t.byteOffset, t.byteLength);
      });
  });
var Fb,
  Txe = s(() => {
    oL();
    Lg();
    Fb = (e) => {
      let t;
      if (
        (typeof e == "string" ? (t = Qa(e)) : (t = e),
        typeof t != "object" ||
          typeof t.byteOffset != "number" ||
          typeof t.byteLength != "number")
      )
        throw new Error(
          "@smithy/util-base64: toBase64 encoder function only accepts string | Uint8Array."
        );
      return bxe(t.buffer, t.byteOffset, t.byteLength).toString("base64");
    };
  });
var nL = s(() => {
  wxe();
  Txe();
});
var Bxe,
  ts,
  rs,
  xf,
  Axe,
  Ug,
  gf,
  yf,
  Ji,
  sL,
  iL,
  Rxe,
  Ixe,
  Pxe,
  Mxe,
  Lxe,
  es,
  vxe,
  Fxe,
  Oxe,
  kxe,
  Dxe,
  Nxe,
  jct,
  Uxe,
  $xe = s(() => {
    (Bxe = "required"),
      (ts = "fn"),
      (rs = "argv"),
      (xf = "ref"),
      (Axe = "isSet"),
      (Ug = "booleanEquals"),
      (gf = "error"),
      (yf = "endpoint"),
      (Ji = "tree"),
      (sL = "PartitionResult"),
      (iL = "getAttr"),
      (Rxe = { [Bxe]: !1, type: "String" }),
      (Ixe = { [Bxe]: !0, default: !1, type: "Boolean" }),
      (Pxe = { [xf]: "Endpoint" }),
      (Mxe = { [ts]: Ug, [rs]: [{ [xf]: "UseFIPS" }, !0] }),
      (Lxe = { [ts]: Ug, [rs]: [{ [xf]: "UseDualStack" }, !0] }),
      (es = {}),
      (vxe = { [ts]: iL, [rs]: [{ [xf]: sL }, "supportsFIPS"] }),
      (Fxe = { [xf]: sL }),
      (Oxe = {
        [ts]: Ug,
        [rs]: [!0, { [ts]: iL, [rs]: [Fxe, "supportsDualStack"] }],
      }),
      (kxe = [Mxe]),
      (Dxe = [Lxe]),
      (Nxe = [{ [xf]: "Region" }]),
      (jct = {
        version: "1.0",
        parameters: {
          Region: Rxe,
          UseDualStack: Ixe,
          UseFIPS: Ixe,
          Endpoint: Rxe,
        },
        rules: [
          {
            conditions: [{ [ts]: Axe, [rs]: [Pxe] }],
            rules: [
              {
                conditions: kxe,
                error:
                  "Invalid Configuration: FIPS and custom endpoint are not supported",
                type: gf,
              },
              {
                conditions: Dxe,
                error:
                  "Invalid Configuration: Dualstack and custom endpoint are not supported",
                type: gf,
              },
              { endpoint: { url: Pxe, properties: es, headers: es }, type: yf },
            ],
            type: Ji,
          },
          {
            conditions: [{ [ts]: Axe, [rs]: Nxe }],
            rules: [
              {
                conditions: [{ [ts]: "aws.partition", [rs]: Nxe, assign: sL }],
                rules: [
                  {
                    conditions: [Mxe, Lxe],
                    rules: [
                      {
                        conditions: [{ [ts]: Ug, [rs]: [!0, vxe] }, Oxe],
                        rules: [
                          {
                            endpoint: {
                              url: "https://portal.sso-fips.{Region}.{PartitionResult#dualStackDnsSuffix}",
                              properties: es,
                              headers: es,
                            },
                            type: yf,
                          },
                        ],
                        type: Ji,
                      },
                      {
                        error:
                          "FIPS and DualStack are enabled, but this partition does not support one or both",
                        type: gf,
                      },
                    ],
                    type: Ji,
                  },
                  {
                    conditions: kxe,
                    rules: [
                      {
                        conditions: [{ [ts]: Ug, [rs]: [vxe, !0] }],
                        rules: [
                          {
                            conditions: [
                              {
                                [ts]: "stringEquals",
                                [rs]: [
                                  { [ts]: iL, [rs]: [Fxe, "name"] },
                                  "aws-us-gov",
                                ],
                              },
                            ],
                            endpoint: {
                              url: "https://portal.sso.{Region}.amazonaws.com",
                              properties: es,
                              headers: es,
                            },
                            type: yf,
                          },
                          {
                            endpoint: {
                              url: "https://portal.sso-fips.{Region}.{PartitionResult#dnsSuffix}",
                              properties: es,
                              headers: es,
                            },
                            type: yf,
                          },
                        ],
                        type: Ji,
                      },
                      {
                        error:
                          "FIPS is enabled but this partition does not support FIPS",
                        type: gf,
                      },
                    ],
                    type: Ji,
                  },
                  {
                    conditions: Dxe,
                    rules: [
                      {
                        conditions: [Oxe],
                        rules: [
                          {
                            endpoint: {
                              url: "https://portal.sso.{Region}.{PartitionResult#dualStackDnsSuffix}",
                              properties: es,
                              headers: es,
                            },
                            type: yf,
                          },
                        ],
                        type: Ji,
                      },
                      {
                        error:
                          "DualStack is enabled but this partition does not support DualStack",
                        type: gf,
                      },
                    ],
                    type: Ji,
                  },
                  {
                    endpoint: {
                      url: "https://portal.sso.{Region}.{PartitionResult#dnsSuffix}",
                      properties: es,
                      headers: es,
                    },
                    type: yf,
                  },
                ],
                type: Ji,
              },
            ],
            type: Ji,
          },
          { error: "Invalid Configuration: Missing Region", type: gf },
        ],
      }),
      (Uxe = jct);
  });
var Gct,
  Hxe,
  zxe = s(() => {
    pE();
    $t();
    $xe();
    (Gct = new uo({
      size: 50,
      params: ["Endpoint", "Region", "UseDualStack", "UseFIPS"],
    })),
      (Hxe = (e, t = {}) =>
        Gct.get(e, () => jr(Uxe, { endpointParams: e, logger: t.logger })));
    Jt.aws = $h;
  });
var qxe,
  jxe = s(() => {
    rt();
    Ue();
    ae();
    eg();
    nL();
    Lg();
    MM();
    zxe();
    qxe = (e) => ({
      apiVersion: "2019-06-10",
      base64Decoder: e?.base64Decoder ?? Lb,
      base64Encoder: e?.base64Encoder ?? Fb,
      disableHostPrefix: e?.disableHostPrefix ?? !1,
      endpointProvider: e?.endpointProvider ?? Hxe,
      extensions: e?.extensions ?? [],
      httpAuthSchemeProvider: e?.httpAuthSchemeProvider ?? Mye,
      httpAuthSchemes: e?.httpAuthSchemes ?? [
        {
          schemeId: "aws.auth#sigv4",
          identityProvider: (t) => t.getIdentityProvider("aws.auth#sigv4"),
          signer: new wr(),
        },
        {
          schemeId: "smithy.api#noAuth",
          identityProvider: (t) =>
            t.getIdentityProvider("smithy.api#noAuth") || (async () => ({})),
          signer: new hn(),
        },
      ],
      logger: e?.logger ?? new Da(),
      serviceId: e?.serviceId ?? "SSO",
      urlParser: e?.urlParser ?? ii,
      utf8Decoder: e?.utf8Decoder ?? Qa,
      utf8Encoder: e?.utf8Encoder ?? Db,
    });
  });
var Gxe,
  aL,
  cL,
  Vxe,
  Wxe,
  Kxe,
  Yxe = s(() => {
    (Gxe = "AWS_EXECUTION_ENV"),
      (aL = "AWS_REGION"),
      (cL = "AWS_DEFAULT_REGION"),
      (Vxe = "AWS_EC2_METADATA_DISABLED"),
      (Wxe = ["in-region", "cross-region", "mobile", "standard", "legacy"]),
      (Kxe = "/latest/meta-data/placement/region");
  });
var Vct,
  Wct,
  Qxe,
  Xxe = s(() => {
    (Vct = "AWS_DEFAULTS_MODE"),
      (Wct = "defaults_mode"),
      (Qxe = {
        environmentVariableSelector: (e) => e[Vct],
        configFileSelector: (e) => e[Wct],
        default: "legacy",
      });
  });
var Ub,
  Kct,
  Yct,
  Jxe = s(() => {
    _l();
    od();
    re();
    Yxe();
    Xxe();
    (Ub = ({ region: e = Wt(bl), defaultsMode: t = Wt(Qxe) } = {}) =>
      gr(async () => {
        let r = typeof t == "function" ? await t() : t;
        switch (r?.toLowerCase()) {
          case "auto":
            return Kct(e);
          case "in-region":
          case "cross-region":
          case "mobile":
          case "standard":
          case "legacy":
            return Promise.resolve(r?.toLocaleLowerCase());
          case void 0:
            return Promise.resolve("legacy");
          default:
            throw new Error(
              `Invalid parameter for "defaultsMode", expect ${Wxe.join(", ")}, got ${r}`
            );
        }
      })),
      (Kct = async (e) => {
        if (e) {
          let t = typeof e == "function" ? await e() : e,
            r = await Yct();
          return r ? (t === r ? "in-region" : "cross-region") : "standard";
        }
        return "standard";
      }),
      (Yct = async () => {
        if (process.env[Gxe] && (process.env[aL] || process.env[cL]))
          return process.env[aL] ?? process.env[cL];
        if (!process.env[Vxe])
          try {
            let { getInstanceMetadataEndpoint: e, httpRequest: t } =
                await Promise.resolve().then(() => (dg(), cg)),
              r = await e();
            return (await t({ ...r, path: Kxe })).toString();
          } catch {}
      });
  });
var dL = s(() => {
  Jxe();
});
var Zxe,
  eEe = s(() => {
    Uye();
    rt();
    UM();
    _l();
    GM();
    ng();
    od();
    eL();
    tL();
    ai();
    jxe();
    ae();
    dL();
    ae();
    Zxe = (e) => {
      fS(process.version);
      let t = Ub(e),
        r = () => t().then(lS),
        o = qxe(e);
      $o(process.version);
      let n = { profile: e?.profile, logger: o.logger };
      return {
        ...o,
        ...e,
        runtime: "node",
        defaultsMode: t,
        authSchemePreference: e?.authSchemePreference ?? Wt(Ho, n),
        bodyLengthChecker: e?.bodyLengthChecker ?? Mb,
        defaultUserAgentProvider:
          e?.defaultUserAgentProvider ??
          Ob({ serviceId: o.serviceId, clientVersion: $ye.version }),
        maxAttempts: e?.maxAttempts ?? Wt(iS, e),
        region: e?.region ?? Wt(bl, { ...FE, ...n }),
        requestHandler: hf.create(e?.requestHandler ?? r),
        retryMode:
          e?.retryMode ??
          Wt({ ...cS, default: async () => (await r()).retryMode || Al }, e),
        sha256: e?.sha256 ?? uf.bind(null, "sha256"),
        streamCollector: e?.streamCollector ?? Bb,
        useDualstackEndpoint: e?.useDualstackEndpoint ?? Wt(ME, n),
        useFipsEndpoint: e?.useFipsEndpoint ?? Wt(LE, n),
        userAgentAppId: e?.userAgentAppId ?? Wt(kb, n),
      };
    };
  });
var tEe,
  rEe,
  oEe = s(() => {
    (tEe = (e) => {
      let t = e.httpAuthSchemes,
        r = e.httpAuthSchemeProvider,
        o = e.credentials;
      return {
        setHttpAuthScheme(n) {
          let i = t.findIndex((a) => a.schemeId === n.schemeId);
          i === -1 ? t.push(n) : t.splice(i, 1, n);
        },
        httpAuthSchemes() {
          return t;
        },
        setHttpAuthSchemeProvider(n) {
          r = n;
        },
        httpAuthSchemeProvider() {
          return r;
        },
        setCredentials(n) {
          o = n;
        },
        credentials() {
          return o;
        },
      };
    }),
      (rEe = (e) => ({
        httpAuthSchemes: e.httpAuthSchemes(),
        httpAuthSchemeProvider: e.httpAuthSchemeProvider(),
        credentials: e.credentials(),
      }));
  });
var nEe,
  sEe = s(() => {
    Xi();
    pn();
    ae();
    oEe();
    nEe = (e, t) => {
      let r = Object.assign(Go(e), uS(e), qx(e), tEe(e));
      return (
        t.forEach((o) => o.configure(r)),
        Object.assign(e, Vo(r), pS(r), jx(r), rEe(r))
      );
    };
  });
var pi,
  $g = s(() => {
    LO();
    FO();
    $O();
    BE();
    _l();
    Ue();
    zD();
    ye();
    ng();
    ae();
    MM();
    ff();
    eEe();
    sEe();
    pi = class extends kl {
      config;
      constructor(...[t]) {
        let r = Zxe(t || {});
        super(r), (this.initConfig = r);
        let o = Fye(r),
          n = iE(o),
          i = aS(n),
          a = $E(i),
          c = a,
          d = XE(c),
          m = Lye(d),
          f = nEe(m, t?.extensions || []);
        (this.config = f),
          this.middlewareStack.use(NE(this.config)),
          this.middlewareStack.use(hS(this.config)),
          this.middlewareStack.use(HE(this.config)),
          this.middlewareStack.use(Gx(this.config)),
          this.middlewareStack.use(Vx(this.config)),
          this.middlewareStack.use(Wx(this.config)),
          this.middlewareStack.use(
            Mo(this.config, {
              httpAuthSchemeParametersProvider: Bye,
              identityProviderConfigProvider: async (l) =>
                new fo({ "aws.auth#sigv4": l.credentials }),
            })
          ),
          this.middlewareStack.use(Lo(this.config));
      }
      destroy() {
        super.destroy();
      }
    };
  });
var Zi,
  mL = s(() => {
    ae();
    Zi = class e extends Dl {
      constructor(t) {
        super(t), Object.setPrototypeOf(this, e.prototype);
      }
    };
  });
var $b,
  Hb,
  zb,
  qb,
  iEe,
  Xct,
  aEe,
  cEe,
  dEe,
  mEe,
  Cd = s(() => {
    ae();
    mL();
    ($b = class e extends Zi {
      name = "InvalidRequestException";
      $fault = "client";
      constructor(t) {
        super({ name: "InvalidRequestException", $fault: "client", ...t }),
          Object.setPrototypeOf(this, e.prototype);
      }
    }),
      (Hb = class e extends Zi {
        name = "ResourceNotFoundException";
        $fault = "client";
        constructor(t) {
          super({ name: "ResourceNotFoundException", $fault: "client", ...t }),
            Object.setPrototypeOf(this, e.prototype);
        }
      }),
      (zb = class e extends Zi {
        name = "TooManyRequestsException";
        $fault = "client";
        constructor(t) {
          super({ name: "TooManyRequestsException", $fault: "client", ...t }),
            Object.setPrototypeOf(this, e.prototype);
        }
      }),
      (qb = class e extends Zi {
        name = "UnauthorizedException";
        $fault = "client";
        constructor(t) {
          super({ name: "UnauthorizedException", $fault: "client", ...t }),
            Object.setPrototypeOf(this, e.prototype);
        }
      }),
      (iEe = (e) => ({ ...e, ...(e.accessToken && { accessToken: cd }) })),
      (Xct = (e) => ({
        ...e,
        ...(e.secretAccessKey && { secretAccessKey: cd }),
        ...(e.sessionToken && { sessionToken: cd }),
      })),
      (aEe = (e) => ({
        ...e,
        ...(e.roleCredentials && { roleCredentials: Xct(e.roleCredentials) }),
      })),
      (cEe = (e) => ({ ...e, ...(e.accessToken && { accessToken: cd }) })),
      (dEe = (e) => ({ ...e, ...(e.accessToken && { accessToken: cd }) })),
      (mEe = (e) => ({ ...e, ...(e.accessToken && { accessToken: cd }) }));
  });
var lEe,
  fEe,
  uEe,
  pEe,
  hEe,
  gEe,
  yEe,
  xEe,
  jb,
  Jct,
  Zct,
  edt,
  tdt,
  rdt,
  Xa,
  EEe,
  Gb,
  SEe,
  CEe,
  bEe,
  _Ee,
  wEe,
  odt,
  ndt,
  Vb,
  Hg = s(() => {
    rt();
    Ue();
    ae();
    Cd();
    mL();
    (lEe = async (e, t) => {
      let r = G(e, t),
        o = Ro({}, og, { [Vb]: e[Gb] });
      r.bp("/federation/credentials");
      let n = Ro({
        [ndt]: [, F(e[odt], "roleName")],
        [SEe]: [, F(e[EEe], "accountId")],
      });
      return (
        r
          .m("GET")
          .h(o)
          .q(n)
          .b(void 0),
        r.build()
      );
    }),
      (fEe = async (e, t) => {
        let r = G(e, t),
          o = Ro({}, og, { [Vb]: e[Gb] });
        r.bp("/assignment/roles");
        let n = Ro({
          [wEe]: [, e[_Ee]],
          [bEe]: [() => e.maxResults !== void 0, () => e[CEe].toString()],
          [SEe]: [, F(e[EEe], "accountId")],
        });
        return (
          r
            .m("GET")
            .h(o)
            .q(n)
            .b(void 0),
          r.build()
        );
      }),
      (uEe = async (e, t) => {
        let r = G(e, t),
          o = Ro({}, og, { [Vb]: e[Gb] });
        r.bp("/assignment/accounts");
        let n = Ro({
          [wEe]: [, e[_Ee]],
          [bEe]: [() => e.maxResults !== void 0, () => e[CEe].toString()],
        });
        return (
          r
            .m("GET")
            .h(o)
            .q(n)
            .b(void 0),
          r.build()
        );
      }),
      (pEe = async (e, t) => {
        let r = G(e, t),
          o = Ro({}, og, { [Vb]: e[Gb] });
        return (
          r.bp("/logout"),
          r
            .m("POST")
            .h(o)
            .b(void 0),
          r.build()
        );
      }),
      (hEe = async (e, t) => {
        if (e.statusCode !== 200 && e.statusCode >= 300) return jb(e, t);
        let r = Ro({ $metadata: Xa(e) }),
          o = F(Se(await ie(e.body, t)), "body"),
          n = M(o, { roleCredentials: D });
        return Object.assign(r, n), r;
      }),
      (gEe = async (e, t) => {
        if (e.statusCode !== 200 && e.statusCode >= 300) return jb(e, t);
        let r = Ro({ $metadata: Xa(e) }),
          o = F(Se(await ie(e.body, t)), "body"),
          n = M(o, { nextToken: p, roleList: D });
        return Object.assign(r, n), r;
      }),
      (yEe = async (e, t) => {
        if (e.statusCode !== 200 && e.statusCode >= 300) return jb(e, t);
        let r = Ro({ $metadata: Xa(e) }),
          o = F(Se(await ie(e.body, t)), "body"),
          n = M(o, { accountList: D, nextToken: p });
        return Object.assign(r, n), r;
      }),
      (xEe = async (e, t) => {
        if (e.statusCode !== 200 && e.statusCode >= 300) return jb(e, t);
        let r = Ro({ $metadata: Xa(e) });
        return await ne(e.body, t), r;
      }),
      (jb = async (e, t) => {
        let r = { ...e, body: await Gn(e.body, t) },
          o = Vn(e, r.body);
        switch (o) {
          case "InvalidRequestException":
          case "com.amazonaws.sso#InvalidRequestException":
            throw await Zct(r, t);
          case "ResourceNotFoundException":
          case "com.amazonaws.sso#ResourceNotFoundException":
            throw await edt(r, t);
          case "TooManyRequestsException":
          case "com.amazonaws.sso#TooManyRequestsException":
            throw await tdt(r, t);
          case "UnauthorizedException":
          case "com.amazonaws.sso#UnauthorizedException":
            throw await rdt(r, t);
          default:
            let n = r.body;
            return Jct({ output: e, parsedBody: n, errorCode: o });
        }
      }),
      (Jct = mS(Zi)),
      (Zct = async (e, t) => {
        let r = Ro({}),
          o = e.body,
          n = M(o, { message: p });
        Object.assign(r, n);
        let i = new $b({ $metadata: Xa(e), ...r });
        return Ye(i, e.body);
      }),
      (edt = async (e, t) => {
        let r = Ro({}),
          o = e.body,
          n = M(o, { message: p });
        Object.assign(r, n);
        let i = new Hb({ $metadata: Xa(e), ...r });
        return Ye(i, e.body);
      }),
      (tdt = async (e, t) => {
        let r = Ro({}),
          o = e.body,
          n = M(o, { message: p });
        Object.assign(r, n);
        let i = new zb({ $metadata: Xa(e), ...r });
        return Ye(i, e.body);
      }),
      (rdt = async (e, t) => {
        let r = Ro({}),
          o = e.body,
          n = M(o, { message: p });
        Object.assign(r, n);
        let i = new qb({ $metadata: Xa(e), ...r });
        return Ye(i, e.body);
      }),
      (Xa = (e) => ({
        httpStatusCode: e.statusCode,
        requestId:
          e.headers["x-amzn-requestid"] ??
          e.headers["x-amzn-request-id"] ??
          e.headers["x-amz-request-id"],
        extendedRequestId: e.headers["x-amz-id-2"],
        cfId: e.headers["x-amz-cf-id"],
      })),
      (EEe = "accountId"),
      (Gb = "accessToken"),
      (SEe = "account_id"),
      (CEe = "maxResults"),
      (bEe = "max_result"),
      (_Ee = "nextToken"),
      (wEe = "next_token"),
      (odt = "roleName"),
      (ndt = "role_name"),
      (Vb = "x-amz-sso_bearer_token");
  });
var Ef,
  lL = s(() => {
    ye();
    xe();
    ae();
    ff();
    Cd();
    Hg();
    Ef = class extends (
      L.classBuilder()
        .ep(Ya)
        .m(function (t, r, o, n) {
          return [
            z(o, this.serialize, this.deserialize),
            q(o, t.getEndpointParameterInstructions()),
          ];
        })
        .s("SWBPortalService", "GetRoleCredentials", {})
        .n("SSOClient", "GetRoleCredentialsCommand")
        .f(iEe, aEe)
        .ser(lEe)
        .de(hEe)
        .build()
    ) {};
  });
var Sf,
  Wb = s(() => {
    ye();
    xe();
    ae();
    ff();
    Cd();
    Hg();
    Sf = class extends (
      L.classBuilder()
        .ep(Ya)
        .m(function (t, r, o, n) {
          return [
            z(o, this.serialize, this.deserialize),
            q(o, t.getEndpointParameterInstructions()),
          ];
        })
        .s("SWBPortalService", "ListAccountRoles", {})
        .n("SSOClient", "ListAccountRolesCommand")
        .f(cEe, void 0)
        .ser(fEe)
        .de(gEe)
        .build()
    ) {};
  });
var Cf,
  Kb = s(() => {
    ye();
    xe();
    ae();
    ff();
    Cd();
    Hg();
    Cf = class extends (
      L.classBuilder()
        .ep(Ya)
        .m(function (t, r, o, n) {
          return [
            z(o, this.serialize, this.deserialize),
            q(o, t.getEndpointParameterInstructions()),
          ];
        })
        .s("SWBPortalService", "ListAccounts", {})
        .n("SSOClient", "ListAccountsCommand")
        .f(dEe, void 0)
        .ser(uEe)
        .de(yEe)
        .build()
    ) {};
  });
var Yb,
  fL = s(() => {
    ye();
    xe();
    ae();
    ff();
    Cd();
    Hg();
    Yb = class extends (
      L.classBuilder()
        .ep(Ya)
        .m(function (t, r, o, n) {
          return [
            z(o, this.serialize, this.deserialize),
            q(o, t.getEndpointParameterInstructions()),
          ];
        })
        .s("SWBPortalService", "Logout", {})
        .n("SSOClient", "LogoutCommand")
        .f(mEe, void 0)
        .ser(pEe)
        .de(xEe)
        .build()
    ) {};
  });
var sdt,
  uL,
  TEe = s(() => {
    ae();
    lL();
    Wb();
    Kb();
    fL();
    $g();
    (sdt = {
      GetRoleCredentialsCommand: Ef,
      ListAccountRolesCommand: Sf,
      ListAccountsCommand: Cf,
      LogoutCommand: Yb,
    }),
      (uL = class extends pi {});
    dS(sdt, uL);
  });
var AEe = s(() => {
  lL();
  Wb();
  Kb();
  fL();
});
var REe = s(() => {});
var LAr,
  IEe = s(() => {
    Ue();
    Wb();
    $g();
    LAr = dt(pi, Sf, "nextToken", "nextToken", "maxResults");
  });
var zAr,
  PEe = s(() => {
    Ue();
    Kb();
    $g();
    zAr = dt(pi, Cf, "nextToken", "nextToken", "maxResults");
  });
var vEe = s(() => {
  REe();
  IEe();
  PEe();
});
var OEe = s(() => {
  Cd();
});
var kEe = s(() => {
  $g();
  TEe();
  AEe();
  vEe();
  OEe();
});
var DEe = {};
It(DEe, { GetRoleCredentialsCommand: () => Ef, SSOClient: () => pi });
var NEe = s(() => {
  kEe();
});
var zg,
  pL,
  BEe = s(() => {
    xt();
    Nye();
    re();
    Ls();
    (zg = !1),
      (pL = async ({
        ssoStartUrl: e,
        ssoSession: t,
        ssoAccountId: r,
        ssoRegion: o,
        ssoRoleName: n,
        ssoClient: i,
        clientConfig: a,
        parentClientConfig: c,
        profile: d,
        logger: m,
      }) => {
        let f,
          l =
            "To refresh this SSO session run aws sso login with the corresponding profile.";
        if (t)
          try {
            let yt = await vye({ profile: d })();
            f = {
              accessToken: yt.token,
              expiresAt: new Date(yt.expiration).toISOString(),
            };
          } catch (yt) {
            throw new P(yt.message, { tryNextLink: zg, logger: m });
          }
        else
          try {
            f = await jE(e);
          } catch {
            throw new P(
              `The SSO session associated with this profile is invalid. ${l}`,
              { tryNextLink: zg, logger: m }
            );
          }
        if (new Date(f.expiresAt).getTime() - Date.now() <= 0)
          throw new P(
            `The SSO session associated with this profile has expired. ${l}`,
            { tryNextLink: zg, logger: m }
          );
        let { accessToken: u } = f,
          { SSOClient: h, GetRoleCredentialsCommand: y } =
            await Promise.resolve().then(() => (NEe(), DEe)),
          S =
            i ||
            new h(
              Object.assign({}, a ?? {}, {
                logger: a?.logger ?? c?.logger,
                region: a?.region ?? o,
              })
            ),
          E;
        try {
          E = await S.send(
            new y({ accountId: r, roleName: n, accessToken: u })
          );
        } catch (yt) {
          throw new P(yt, { tryNextLink: zg, logger: m });
        }
        let {
          roleCredentials: {
            accessKeyId: b,
            secretAccessKey: v,
            sessionToken: I,
            expiration: O,
            credentialScope: ge,
            accountId: Fe,
          } = {},
        } = E;
        if (!b || !v || !I || !O)
          throw new P("SSO returns an invalid temporary credential.", {
            tryNextLink: zg,
            logger: m,
          });
        let Vt = {
          accessKeyId: b,
          secretAccessKey: v,
          sessionToken: I,
          expiration: new Date(O),
          ...(ge && { credentialScope: ge }),
          ...(Fe && { accountId: Fe }),
        };
        return (
          t
            ? ce(Vt, "CREDENTIALS_SSO", "s")
            : ce(Vt, "CREDENTIALS_SSO_LEGACY", "u"),
          Vt
        );
      });
  });
var hL,
  gL = s(() => {
    re();
    hL = (e, t) => {
      let {
        sso_start_url: r,
        sso_account_id: o,
        sso_region: n,
        sso_role_name: i,
      } = e;
      if (!r || !o || !n || !i)
        throw new P(
          `Profile is configured with invalid SSO credentials. Required parameters "sso_account_id", "sso_region", "sso_role_name", "sso_start_url". Got ${Object.keys(e).join(", ")}
Reference: https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-sso.html`,
          { tryNextLink: !1, logger: t }
        );
      return e;
    };
  });
var idt,
  MEe = s(() => {
    re();
    Ls();
    tB();
    BEe();
    gL();
    idt =
      (e = {}) =>
      async ({ callerClientConfig: t } = {}) => {
        e.logger?.debug("@aws-sdk/credential-provider-sso - fromSSO");
        let {
            ssoStartUrl: r,
            ssoAccountId: o,
            ssoRegion: n,
            ssoRoleName: i,
            ssoSession: a,
          } = e,
          { ssoClient: c } = e,
          d = Kn({ profile: e.profile ?? t?.profile });
        if (!r && !o && !n && !i && !a) {
          let f = (await Oa(e))[d];
          if (!f)
            throw new P(`Profile ${d} was not found.`, { logger: e.logger });
          if (!eB(f))
            throw new P(
              `Profile ${d} is not configured with SSO credentials.`,
              { logger: e.logger }
            );
          if (f?.sso_session) {
            let b = (await WE(e))[f.sso_session],
              v = ` configurations in profile ${d} and sso-session ${f.sso_session}`;
            if (n && n !== b.sso_region)
              throw new P("Conflicting SSO region" + v, {
                tryNextLink: !1,
                logger: e.logger,
              });
            if (r && r !== b.sso_start_url)
              throw new P("Conflicting SSO start_url" + v, {
                tryNextLink: !1,
                logger: e.logger,
              });
            (f.sso_region = b.sso_region), (f.sso_start_url = b.sso_start_url);
          }
          let {
            sso_start_url: l,
            sso_account_id: u,
            sso_region: h,
            sso_role_name: y,
            sso_session: S,
          } = hL(f, e.logger);
          return pL({
            ssoStartUrl: l,
            ssoSession: S,
            ssoAccountId: u,
            ssoRegion: h,
            ssoRoleName: y,
            ssoClient: c,
            clientConfig: e.clientConfig,
            parentClientConfig: e.parentClientConfig,
            profile: d,
          });
        } else {
          if (!r || !o || !n || !i)
            throw new P(
              'Incomplete configuration. The fromSSO() argument hash must include "ssoStartUrl", "ssoAccountId", "ssoRegion", "ssoRoleName"',
              { tryNextLink: !1, logger: e.logger }
            );
          return pL({
            ssoStartUrl: r,
            ssoSession: a,
            ssoAccountId: o,
            ssoRegion: n,
            ssoRoleName: i,
            ssoClient: c,
            clientConfig: e.clientConfig,
            parentClientConfig: e.parentClientConfig,
            profile: d,
          });
        }
      };
  });
var LEe = s(() => {});
var yL = {};
It(yL, {
  fromSSO: () => idt,
  isSsoProfile: () => eB,
  validateSsoProfile: () => hL,
});
var xL = s(() => {
  MEe();
  tB();
  LEe();
  gL();
});
var FEe,
  EL,
  UEe = s(() => {
    xt();
    re();
    (FEe = (e, t, r) => {
      let o = {
        EcsContainer: async (n) => {
          let { fromHttp: i } = await Promise.resolve().then(() => (ld(), md)),
            { fromContainerMetadata: a } = await Promise.resolve().then(
              () => (dg(), cg)
            );
          return (
            r?.debug(
              "@aws-sdk/credential-provider-ini - credential_source is EcsContainer"
            ),
            async () => Ht(i(n ?? {}), a(n))().then(EL)
          );
        },
        Ec2InstanceMetadata: async (n) => {
          r?.debug(
            "@aws-sdk/credential-provider-ini - credential_source is Ec2InstanceMetadata"
          );
          let { fromInstanceMetadata: i } = await Promise.resolve().then(
            () => (dg(), cg)
          );
          return async () => i(n)().then(EL);
        },
        Environment: async (n) => {
          r?.debug(
            "@aws-sdk/credential-provider-ini - credential_source is Environment"
          );
          let { fromEnv: i } = await Promise.resolve().then(() => (AN(), cce));
          return async () => i(n)().then(EL);
        },
      };
      if (e in o) return o[e];
      throw new P(
        `Unsupported credential source in profile ${t}. Got ${e}, expected EcsContainer or Ec2InstanceMetadata or Environment.`,
        { logger: r }
      );
    }),
      (EL = (e) => ce(e, "CREDENTIALS_PROFILE_NAMED_PROVIDER", "p"));
  });
function adt(e) {
  return {
    schemeId: "aws.auth#sigv4",
    signingProperties: { name: "sts", region: e.region },
    propertiesExtractor: (t, r) => ({
      signingProperties: { config: t, context: r },
    }),
  };
}
function cdt(e) {
  return { schemeId: "smithy.api#noAuth" };
}
var $Ee,
  HEe,
  ddt,
  zEe,
  SL = s(() => {
    rt();
    ct();
    qg();
    $Ee = async (e, t, r) => ({
      operation: bt(t).operation,
      region:
        (await pe(e.region)()) ||
        (() => {
          throw new Error(
            "expected `region` to be configured for `aws.auth#sigv4`"
          );
        })(),
    });
    (HEe = (e) => {
      let t = [];
      switch (e.operation) {
        case "AssumeRoleWithWebIdentity": {
          t.push(cdt(e));
          break;
        }
        default:
          t.push(adt(e));
      }
      return t;
    }),
      (ddt = (e) => Object.assign(e, { stsClientCtor: hi })),
      (zEe = (e) => {
        let t = ddt(e),
          r = zo(t);
        return Object.assign(r, {
          authSchemePreference: pe(e.authSchemePreference ?? []),
        });
      });
  });
var qEe,
  Qb,
  Xb = s(() => {
    (qEe = (e) =>
      Object.assign(e, {
        useDualstackEndpoint: e.useDualstackEndpoint ?? !1,
        useFipsEndpoint: e.useFipsEndpoint ?? !1,
        useGlobalEndpoint: e.useGlobalEndpoint ?? !1,
        defaultSigningName: "sts",
      })),
      (Qb = {
        UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
        UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
        Endpoint: { type: "builtInParams", name: "endpoint" },
        Region: { type: "builtInParams", name: "region" },
        UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
      });
  });
var eSe,
  Ze,
  vt,
  Ot,
  Za,
  Ja,
  Io,
  tSe,
  rSe,
  oSe,
  Er,
  jEe,
  gi,
  bf,
  bL,
  GEe,
  CL,
  nSe,
  VEe,
  Po,
  WEe,
  sSe,
  iSe,
  Wo,
  Nn,
  KEe,
  aSe,
  cSe,
  YEe,
  dSe,
  QEe,
  XEe,
  JEe,
  ZEe,
  mdt,
  mSe,
  lSe = s(() => {
    (eSe = "required"),
      (Ze = "type"),
      (vt = "fn"),
      (Ot = "argv"),
      (Za = "ref"),
      (Ja = "booleanEquals"),
      (Io = "stringEquals"),
      (tSe = "sigv4"),
      (rSe = "sts"),
      (oSe = "us-east-1"),
      (Er = "endpoint"),
      (jEe = "https://sts.{Region}.{PartitionResult#dnsSuffix}"),
      (gi = "tree"),
      (bf = "error"),
      (bL = "getAttr"),
      (GEe = { [eSe]: !1, [Ze]: "String" }),
      (CL = { [eSe]: !0, default: !1, [Ze]: "Boolean" }),
      (nSe = { [Za]: "Endpoint" }),
      (VEe = { [vt]: "isSet", [Ot]: [{ [Za]: "Region" }] }),
      (Po = { [Za]: "Region" }),
      (WEe = { [vt]: "aws.partition", [Ot]: [Po], assign: "PartitionResult" }),
      (sSe = { [Za]: "UseFIPS" }),
      (iSe = { [Za]: "UseDualStack" }),
      (Wo = {
        url: "https://sts.amazonaws.com",
        properties: {
          authSchemes: [{ name: tSe, signingName: rSe, signingRegion: oSe }],
        },
        headers: {},
      }),
      (Nn = {}),
      (KEe = {
        conditions: [{ [vt]: Io, [Ot]: [Po, "aws-global"] }],
        [Er]: Wo,
        [Ze]: Er,
      }),
      (aSe = { [vt]: Ja, [Ot]: [sSe, !0] }),
      (cSe = { [vt]: Ja, [Ot]: [iSe, !0] }),
      (YEe = { [vt]: bL, [Ot]: [{ [Za]: "PartitionResult" }, "supportsFIPS"] }),
      (dSe = { [Za]: "PartitionResult" }),
      (QEe = {
        [vt]: Ja,
        [Ot]: [!0, { [vt]: bL, [Ot]: [dSe, "supportsDualStack"] }],
      }),
      (XEe = [{ [vt]: "isSet", [Ot]: [nSe] }]),
      (JEe = [aSe]),
      (ZEe = [cSe]),
      (mdt = {
        version: "1.0",
        parameters: {
          Region: GEe,
          UseDualStack: CL,
          UseFIPS: CL,
          Endpoint: GEe,
          UseGlobalEndpoint: CL,
        },
        rules: [
          {
            conditions: [
              { [vt]: Ja, [Ot]: [{ [Za]: "UseGlobalEndpoint" }, !0] },
              { [vt]: "not", [Ot]: XEe },
              VEe,
              WEe,
              { [vt]: Ja, [Ot]: [sSe, !1] },
              { [vt]: Ja, [Ot]: [iSe, !1] },
            ],
            rules: [
              {
                conditions: [{ [vt]: Io, [Ot]: [Po, "ap-northeast-1"] }],
                endpoint: Wo,
                [Ze]: Er,
              },
              {
                conditions: [{ [vt]: Io, [Ot]: [Po, "ap-south-1"] }],
                endpoint: Wo,
                [Ze]: Er,
              },
              {
                conditions: [{ [vt]: Io, [Ot]: [Po, "ap-southeast-1"] }],
                endpoint: Wo,
                [Ze]: Er,
              },
              {
                conditions: [{ [vt]: Io, [Ot]: [Po, "ap-southeast-2"] }],
                endpoint: Wo,
                [Ze]: Er,
              },
              KEe,
              {
                conditions: [{ [vt]: Io, [Ot]: [Po, "ca-central-1"] }],
                endpoint: Wo,
                [Ze]: Er,
              },
              {
                conditions: [{ [vt]: Io, [Ot]: [Po, "eu-central-1"] }],
                endpoint: Wo,
                [Ze]: Er,
              },
              {
                conditions: [{ [vt]: Io, [Ot]: [Po, "eu-north-1"] }],
                endpoint: Wo,
                [Ze]: Er,
              },
              {
                conditions: [{ [vt]: Io, [Ot]: [Po, "eu-west-1"] }],
                endpoint: Wo,
                [Ze]: Er,
              },
              {
                conditions: [{ [vt]: Io, [Ot]: [Po, "eu-west-2"] }],
                endpoint: Wo,
                [Ze]: Er,
              },
              {
                conditions: [{ [vt]: Io, [Ot]: [Po, "eu-west-3"] }],
                endpoint: Wo,
                [Ze]: Er,
              },
              {
                conditions: [{ [vt]: Io, [Ot]: [Po, "sa-east-1"] }],
                endpoint: Wo,
                [Ze]: Er,
              },
              {
                conditions: [{ [vt]: Io, [Ot]: [Po, oSe] }],
                endpoint: Wo,
                [Ze]: Er,
              },
              {
                conditions: [{ [vt]: Io, [Ot]: [Po, "us-east-2"] }],
                endpoint: Wo,
                [Ze]: Er,
              },
              {
                conditions: [{ [vt]: Io, [Ot]: [Po, "us-west-1"] }],
                endpoint: Wo,
                [Ze]: Er,
              },
              {
                conditions: [{ [vt]: Io, [Ot]: [Po, "us-west-2"] }],
                endpoint: Wo,
                [Ze]: Er,
              },
              {
                endpoint: {
                  url: jEe,
                  properties: {
                    authSchemes: [
                      {
                        name: tSe,
                        signingName: rSe,
                        signingRegion: "{Region}",
                      },
                    ],
                  },
                  headers: Nn,
                },
                [Ze]: Er,
              },
            ],
            [Ze]: gi,
          },
          {
            conditions: XEe,
            rules: [
              {
                conditions: JEe,
                error:
                  "Invalid Configuration: FIPS and custom endpoint are not supported",
                [Ze]: bf,
              },
              {
                conditions: ZEe,
                error:
                  "Invalid Configuration: Dualstack and custom endpoint are not supported",
                [Ze]: bf,
              },
              { endpoint: { url: nSe, properties: Nn, headers: Nn }, [Ze]: Er },
            ],
            [Ze]: gi,
          },
          {
            conditions: [VEe],
            rules: [
              {
                conditions: [WEe],
                rules: [
                  {
                    conditions: [aSe, cSe],
                    rules: [
                      {
                        conditions: [{ [vt]: Ja, [Ot]: [!0, YEe] }, QEe],
                        rules: [
                          {
                            endpoint: {
                              url: "https://sts-fips.{Region}.{PartitionResult#dualStackDnsSuffix}",
                              properties: Nn,
                              headers: Nn,
                            },
                            [Ze]: Er,
                          },
                        ],
                        [Ze]: gi,
                      },
                      {
                        error:
                          "FIPS and DualStack are enabled, but this partition does not support one or both",
                        [Ze]: bf,
                      },
                    ],
                    [Ze]: gi,
                  },
                  {
                    conditions: JEe,
                    rules: [
                      {
                        conditions: [{ [vt]: Ja, [Ot]: [YEe, !0] }],
                        rules: [
                          {
                            conditions: [
                              {
                                [vt]: Io,
                                [Ot]: [
                                  { [vt]: bL, [Ot]: [dSe, "name"] },
                                  "aws-us-gov",
                                ],
                              },
                            ],
                            endpoint: {
                              url: "https://sts.{Region}.amazonaws.com",
                              properties: Nn,
                              headers: Nn,
                            },
                            [Ze]: Er,
                          },
                          {
                            endpoint: {
                              url: "https://sts-fips.{Region}.{PartitionResult#dnsSuffix}",
                              properties: Nn,
                              headers: Nn,
                            },
                            [Ze]: Er,
                          },
                        ],
                        [Ze]: gi,
                      },
                      {
                        error:
                          "FIPS is enabled but this partition does not support FIPS",
                        [Ze]: bf,
                      },
                    ],
                    [Ze]: gi,
                  },
                  {
                    conditions: ZEe,
                    rules: [
                      {
                        conditions: [QEe],
                        rules: [
                          {
                            endpoint: {
                              url: "https://sts.{Region}.{PartitionResult#dualStackDnsSuffix}",
                              properties: Nn,
                              headers: Nn,
                            },
                            [Ze]: Er,
                          },
                        ],
                        [Ze]: gi,
                      },
                      {
                        error:
                          "DualStack is enabled but this partition does not support DualStack",
                        [Ze]: bf,
                      },
                    ],
                    [Ze]: gi,
                  },
                  KEe,
                  {
                    endpoint: { url: jEe, properties: Nn, headers: Nn },
                    [Ze]: Er,
                  },
                ],
                [Ze]: gi,
              },
            ],
            [Ze]: gi,
          },
          { error: "Invalid Configuration: Missing Region", [Ze]: bf },
        ],
      }),
      (mSe = mdt);
  });
var ldt,
  fSe,
  uSe = s(() => {
    RC();
    $t();
    lSe();
    (ldt = new uo({
      size: 50,
      params: [
        "Endpoint",
        "Region",
        "UseDualStack",
        "UseFIPS",
        "UseGlobalEndpoint",
      ],
    })),
      (fSe = (e, t = {}) =>
        ldt.get(e, () => jr(mSe, { endpointParams: e, logger: t.logger })));
    Jt.aws = ug;
  });
var pSe,
  hSe = s(() => {
    rt();
    Ue();
    Tr();
    pg();
    gM();
    Eg();
    SL();
    uSe();
    pSe = (e) => ({
      apiVersion: "2011-06-15",
      base64Decoder: e?.base64Decoder ?? gb,
      base64Encoder: e?.base64Encoder ?? yb,
      disableHostPrefix: e?.disableHostPrefix ?? !1,
      endpointProvider: e?.endpointProvider ?? fSe,
      extensions: e?.extensions ?? [],
      httpAuthSchemeProvider: e?.httpAuthSchemeProvider ?? HEe,
      httpAuthSchemes: e?.httpAuthSchemes ?? [
        {
          schemeId: "aws.auth#sigv4",
          identityProvider: (t) => t.getIdentityProvider("aws.auth#sigv4"),
          signer: new wr(),
        },
        {
          schemeId: "smithy.api#noAuth",
          identityProvider: (t) =>
            t.getIdentityProvider("smithy.api#noAuth") || (async () => ({})),
          signer: new hn(),
        },
      ],
      logger: e?.logger ?? new ja(),
      serviceId: e?.serviceId ?? "STS",
      urlParser: e?.urlParser ?? li,
      utf8Decoder: e?.utf8Decoder ?? Ga,
      utf8Encoder: e?.utf8Encoder ?? fb,
    });
  });
var gSe,
  ySe = s(() => {
    KB();
    rt();
    XB();
    Vl();
    Ue();
    oM();
    xg();
    pd();
    fM();
    uM();
    fi();
    hSe();
    Tr();
    PM();
    Tr();
    gSe = (e) => {
      nb(process.version);
      let t = Ab(e),
        r = () => t().then(ob),
        o = pSe(e);
      $o(process.version);
      let n = { profile: e?.profile, logger: o.logger };
      return {
        ...o,
        ...e,
        runtime: "node",
        defaultsMode: t,
        authSchemePreference: e?.authSchemePreference ?? mr(Ho, n),
        bodyLengthChecker: e?.bodyLengthChecker ?? hb,
        defaultUserAgentProvider:
          e?.defaultUserAgentProvider ??
          mb({ serviceId: o.serviceId, clientVersion: db.version }),
        httpAuthSchemes: e?.httpAuthSchemes ?? [
          {
            schemeId: "aws.auth#sigv4",
            identityProvider: (i) =>
              i.getIdentityProvider("aws.auth#sigv4") ||
              (async (a) =>
                await e.credentialDefaultProvider(a?.__config || {})()),
            signer: new wr(),
          },
          {
            schemeId: "smithy.api#noAuth",
            identityProvider: (i) =>
              i.getIdentityProvider("smithy.api#noAuth") || (async () => ({})),
            signer: new hn(),
          },
        ],
        maxAttempts: e?.maxAttempts ?? mr(JC, e),
        region: e?.region ?? mr(Gl, { ...BC, ...n }),
        requestHandler: cf.create(e?.requestHandler ?? r),
        retryMode:
          e?.retryMode ??
          mr({ ...eb, default: async () => (await r()).retryMode || Jl }, e),
        sha256: e?.sha256 ?? sf.bind(null, "sha256"),
        streamCollector: e?.streamCollector ?? pb,
        useDualstackEndpoint: e?.useDualstackEndpoint ?? mr(DC, n),
        useFipsEndpoint: e?.useFipsEndpoint ?? mr(NC, n),
        userAgentAppId: e?.userAgentAppId ?? mr(lb, n),
      };
    };
  });
var xSe,
  ESe,
  SSe = s(() => {
    (xSe = (e) => {
      let t = e.httpAuthSchemes,
        r = e.httpAuthSchemeProvider,
        o = e.credentials;
      return {
        setHttpAuthScheme(n) {
          let i = t.findIndex((a) => a.schemeId === n.schemeId);
          i === -1 ? t.push(n) : t.splice(i, 1, n);
        },
        httpAuthSchemes() {
          return t;
        },
        setHttpAuthSchemeProvider(n) {
          r = n;
        },
        httpAuthSchemeProvider() {
          return r;
        },
        setCredentials(n) {
          o = n;
        },
        credentials() {
          return o;
        },
      };
    }),
      (ESe = (e) => ({
        httpAuthSchemes: e.httpAuthSchemes(),
        httpAuthSchemeProvider: e.httpAuthSchemeProvider(),
        credentials: e.credentials(),
      }));
  });
var CSe,
  bSe = s(() => {
    Xi();
    yn();
    Tr();
    SSe();
    CSe = (e, t) => {
      let r = Object.assign(Go(e), sb(e), CC(e), xSe(e));
      return (
        t.forEach((o) => o.configure(r)),
        Object.assign(e, Vo(r), ib(r), bC(r), ESe(r))
      );
    };
  });
var hi,
  qg = s(() => {
    nB();
    sB();
    aB();
    kC();
    Vl();
    Ue();
    yB();
    Xl();
    xg();
    Tr();
    SL();
    Xb();
    ySe();
    bSe();
    hi = class extends qa {
      config;
      constructor(...[t]) {
        let r = gSe(t || {});
        super(r), (this.initConfig = r);
        let o = qEe(r),
          n = AC(o),
          i = ZC(n),
          a = LC(i),
          c = a,
          d = GC(c),
          m = zEe(d),
          f = CSe(m, t?.extensions || []);
        (this.config = f),
          this.middlewareStack.use(OC(this.config)),
          this.middlewareStack.use(cb(this.config)),
          this.middlewareStack.use(FC(this.config)),
          this.middlewareStack.use(_C(this.config)),
          this.middlewareStack.use(wC(this.config)),
          this.middlewareStack.use(TC(this.config)),
          this.middlewareStack.use(
            Mo(this.config, {
              httpAuthSchemeParametersProvider: $Ee,
              identityProviderConfigProvider: async (l) =>
                new fo({ "aws.auth#sigv4": l.credentials }),
            })
          ),
          this.middlewareStack.use(Lo(this.config));
      }
      destroy() {
        super.destroy();
      }
    };
  });
var Sn,
  Jb = s(() => {
    Tr();
    Sn = class e extends nf {
      constructor(t) {
        super(t), Object.setPrototypeOf(this, e.prototype);
      }
    };
  });
var _L,
  wL,
  jg,
  Gg,
  Vg,
  Wg,
  Kg,
  Yg,
  TL,
  AL,
  Qg,
  Xg = s(() => {
    Tr();
    Jb();
    (_L = (e) => ({ ...e, ...(e.SecretAccessKey && { SecretAccessKey: ui }) })),
      (wL = (e) => ({
        ...e,
        ...(e.Credentials && { Credentials: _L(e.Credentials) }),
      })),
      (jg = class e extends Sn {
        name = "ExpiredTokenException";
        $fault = "client";
        constructor(t) {
          super({ name: "ExpiredTokenException", $fault: "client", ...t }),
            Object.setPrototypeOf(this, e.prototype);
        }
      }),
      (Gg = class e extends Sn {
        name = "MalformedPolicyDocumentException";
        $fault = "client";
        constructor(t) {
          super({
            name: "MalformedPolicyDocumentException",
            $fault: "client",
            ...t,
          }),
            Object.setPrototypeOf(this, e.prototype);
        }
      }),
      (Vg = class e extends Sn {
        name = "PackedPolicyTooLargeException";
        $fault = "client";
        constructor(t) {
          super({
            name: "PackedPolicyTooLargeException",
            $fault: "client",
            ...t,
          }),
            Object.setPrototypeOf(this, e.prototype);
        }
      }),
      (Wg = class e extends Sn {
        name = "RegionDisabledException";
        $fault = "client";
        constructor(t) {
          super({ name: "RegionDisabledException", $fault: "client", ...t }),
            Object.setPrototypeOf(this, e.prototype);
        }
      }),
      (Kg = class e extends Sn {
        name = "IDPRejectedClaimException";
        $fault = "client";
        constructor(t) {
          super({ name: "IDPRejectedClaimException", $fault: "client", ...t }),
            Object.setPrototypeOf(this, e.prototype);
        }
      }),
      (Yg = class e extends Sn {
        name = "InvalidIdentityTokenException";
        $fault = "client";
        constructor(t) {
          super({
            name: "InvalidIdentityTokenException",
            $fault: "client",
            ...t,
          }),
            Object.setPrototypeOf(this, e.prototype);
        }
      }),
      (TL = (e) => ({
        ...e,
        ...(e.WebIdentityToken && { WebIdentityToken: ui }),
      })),
      (AL = (e) => ({
        ...e,
        ...(e.Credentials && { Credentials: _L(e.Credentials) }),
      })),
      (Qg = class e extends Sn {
        name = "IDPCommunicationErrorException";
        $fault = "client";
        constructor(t) {
          super({
            name: "IDPCommunicationErrorException",
            $fault: "client",
            ...t,
          }),
            Object.setPrototypeOf(this, e.prototype);
        }
      });
  });
var _Se,
  wSe,
  TSe,
  ASe,
  RSe,
  fdt,
  udt,
  pdt,
  hdt,
  gdt,
  ydt,
  xdt,
  Edt,
  Sdt,
  ISe,
  Cdt,
  bdt,
  _dt,
  wdt,
  Tdt,
  Adt,
  PSe,
  Rdt,
  Idt,
  vSe,
  Pdt,
  vdt,
  Odt,
  kdt,
  Ddt,
  Ndt,
  Bdt,
  ta,
  Mdt,
  OSe,
  kSe,
  DSe,
  NSe,
  RL,
  Ldt,
  IL,
  _f,
  Fdt,
  PL,
  vL,
  wf,
  OL,
  Tf,
  kL,
  DL,
  NL,
  Af,
  Rf,
  BL,
  ML,
  LL,
  If,
  FL,
  Pf,
  vf,
  UL,
  $L,
  ea,
  HL,
  zL,
  qL,
  jL,
  GL,
  BSe,
  VL,
  WL,
  KL,
  Fr,
  MSe,
  Udt,
  YL = s(() => {
    rt();
    yn();
    Tr();
    Xg();
    Jb();
    (_Se = async (e, t) => {
      let r = kSe,
        o;
      return (
        (o = MSe({ ...Edt(e, t), [NSe]: Ldt, [BSe]: DSe })),
        OSe(t, r, "/", void 0, o)
      );
    }),
      (wSe = async (e, t) => {
        let r = kSe,
          o;
        return (
          (o = MSe({ ...Sdt(e, t), [NSe]: Fdt, [BSe]: DSe })),
          OSe(t, r, "/", void 0, o)
        );
      }),
      (TSe = async (e, t) => {
        if (e.statusCode >= 300) return RSe(e, t);
        let r = await De(e.body, t),
          o = {};
        return (o = Rdt(r.AssumeRoleResult, t)), { $metadata: ta(e), ...o };
      }),
      (ASe = async (e, t) => {
        if (e.statusCode >= 300) return RSe(e, t);
        let r = await De(e.body, t),
          o = {};
        return (
          (o = Idt(r.AssumeRoleWithWebIdentityResult, t)),
          { $metadata: ta(e), ...o }
        );
      }),
      (RSe = async (e, t) => {
        let r = { ...e, body: await vE(e.body, t) },
          o = Udt(e, r.body);
        switch (o) {
          case "ExpiredTokenException":
          case "com.amazonaws.sts#ExpiredTokenException":
            throw await fdt(r, t);
          case "MalformedPolicyDocument":
          case "com.amazonaws.sts#MalformedPolicyDocumentException":
            throw await gdt(r, t);
          case "PackedPolicyTooLarge":
          case "com.amazonaws.sts#PackedPolicyTooLargeException":
            throw await ydt(r, t);
          case "RegionDisabledException":
          case "com.amazonaws.sts#RegionDisabledException":
            throw await xdt(r, t);
          case "IDPCommunicationError":
          case "com.amazonaws.sts#IDPCommunicationErrorException":
            throw await udt(r, t);
          case "IDPRejectedClaim":
          case "com.amazonaws.sts#IDPRejectedClaimException":
            throw await pdt(r, t);
          case "InvalidIdentityToken":
          case "com.amazonaws.sts#InvalidIdentityTokenException":
            throw await hdt(r, t);
          default:
            let n = r.body;
            return Mdt({ output: e, parsedBody: n.Error, errorCode: o });
        }
      }),
      (fdt = async (e, t) => {
        let r = e.body,
          o = Pdt(r.Error, t),
          n = new jg({ $metadata: ta(e), ...o });
        return Dr(n, r);
      }),
      (udt = async (e, t) => {
        let r = e.body,
          o = vdt(r.Error, t),
          n = new Qg({ $metadata: ta(e), ...o });
        return Dr(n, r);
      }),
      (pdt = async (e, t) => {
        let r = e.body,
          o = Odt(r.Error, t),
          n = new Kg({ $metadata: ta(e), ...o });
        return Dr(n, r);
      }),
      (hdt = async (e, t) => {
        let r = e.body,
          o = kdt(r.Error, t),
          n = new Yg({ $metadata: ta(e), ...o });
        return Dr(n, r);
      }),
      (gdt = async (e, t) => {
        let r = e.body,
          o = Ddt(r.Error, t),
          n = new Gg({ $metadata: ta(e), ...o });
        return Dr(n, r);
      }),
      (ydt = async (e, t) => {
        let r = e.body,
          o = Ndt(r.Error, t),
          n = new Vg({ $metadata: ta(e), ...o });
        return Dr(n, r);
      }),
      (xdt = async (e, t) => {
        let r = e.body,
          o = Bdt(r.Error, t),
          n = new Wg({ $metadata: ta(e), ...o });
        return Dr(n, r);
      }),
      (Edt = (e, t) => {
        let r = {};
        if (
          (e[Pf] != null && (r[Pf] = e[Pf]),
          e[vf] != null && (r[vf] = e[vf]),
          e[Rf] != null)
        ) {
          let o = ISe(e[Rf], t);
          e[Rf]?.length === 0 && (r.PolicyArns = []),
            Object.entries(o).forEach(([n, i]) => {
              let a = `PolicyArns.${n}`;
              r[a] = i;
            });
        }
        if (
          (e[Af] != null && (r[Af] = e[Af]),
          e[Tf] != null && (r[Tf] = e[Tf]),
          e[qL] != null)
        ) {
          let o = Adt(e[qL], t);
          e[qL]?.length === 0 && (r.Tags = []),
            Object.entries(o).forEach(([n, i]) => {
              let a = `Tags.${n}`;
              r[a] = i;
            });
        }
        if (e[GL] != null) {
          let o = Tdt(e[GL], t);
          e[GL]?.length === 0 && (r.TransitiveTagKeys = []),
            Object.entries(o).forEach(([n, i]) => {
              let a = `TransitiveTagKeys.${n}`;
              r[a] = i;
            });
        }
        if (
          (e[DL] != null && (r[DL] = e[DL]),
          e[HL] != null && (r[HL] = e[HL]),
          e[jL] != null && (r[jL] = e[jL]),
          e[ea] != null && (r[ea] = e[ea]),
          e[ML] != null)
        ) {
          let o = _dt(e[ML], t);
          e[ML]?.length === 0 && (r.ProvidedContexts = []),
            Object.entries(o).forEach(([n, i]) => {
              let a = `ProvidedContexts.${n}`;
              r[a] = i;
            });
        }
        return r;
      }),
      (Sdt = (e, t) => {
        let r = {};
        if (
          (e[Pf] != null && (r[Pf] = e[Pf]),
          e[vf] != null && (r[vf] = e[vf]),
          e[WL] != null && (r[WL] = e[WL]),
          e[LL] != null && (r[LL] = e[LL]),
          e[Rf] != null)
        ) {
          let o = ISe(e[Rf], t);
          e[Rf]?.length === 0 && (r.PolicyArns = []),
            Object.entries(o).forEach(([n, i]) => {
              let a = `PolicyArns.${n}`;
              r[a] = i;
            });
        }
        return (
          e[Af] != null && (r[Af] = e[Af]), e[Tf] != null && (r[Tf] = e[Tf]), r
        );
      }),
      (ISe = (e, t) => {
        let r = {},
          o = 1;
        for (let n of e) {
          if (n === null) continue;
          let i = Cdt(n, t);
          Object.entries(i).forEach(([a, c]) => {
            r[`member.${o}.${a}`] = c;
          }),
            o++;
        }
        return r;
      }),
      (Cdt = (e, t) => {
        let r = {};
        return e[KL] != null && (r[KL] = e[KL]), r;
      }),
      (bdt = (e, t) => {
        let r = {};
        return (
          e[BL] != null && (r[BL] = e[BL]), e[OL] != null && (r[OL] = e[OL]), r
        );
      }),
      (_dt = (e, t) => {
        let r = {},
          o = 1;
        for (let n of e) {
          if (n === null) continue;
          let i = bdt(n, t);
          Object.entries(i).forEach(([a, c]) => {
            r[`member.${o}.${a}`] = c;
          }),
            o++;
        }
        return r;
      }),
      (wdt = (e, t) => {
        let r = {};
        return (
          e[NL] != null && (r[NL] = e[NL]), e[VL] != null && (r[VL] = e[VL]), r
        );
      }),
      (Tdt = (e, t) => {
        let r = {},
          o = 1;
        for (let n of e) n !== null && ((r[`member.${o}`] = n), o++);
        return r;
      }),
      (Adt = (e, t) => {
        let r = {},
          o = 1;
        for (let n of e) {
          if (n === null) continue;
          let i = wdt(n, t);
          Object.entries(i).forEach(([a, c]) => {
            r[`member.${o}.${a}`] = c;
          }),
            o++;
        }
        return r;
      }),
      (PSe = (e, t) => {
        let r = {};
        return (
          e[IL] != null && (r[IL] = p(e[IL])),
          e[PL] != null && (r[PL] = p(e[PL])),
          r
        );
      }),
      (Rdt = (e, t) => {
        let r = {};
        return (
          e[wf] != null && (r[wf] = vSe(e[wf], t)),
          e[_f] != null && (r[_f] = PSe(e[_f], t)),
          e[If] != null && (r[If] = wt(e[If])),
          e[ea] != null && (r[ea] = p(e[ea])),
          r
        );
      }),
      (Idt = (e, t) => {
        let r = {};
        return (
          e[wf] != null && (r[wf] = vSe(e[wf], t)),
          e[$L] != null && (r[$L] = p(e[$L])),
          e[_f] != null && (r[_f] = PSe(e[_f], t)),
          e[If] != null && (r[If] = wt(e[If])),
          e[FL] != null && (r[FL] = p(e[FL])),
          e[vL] != null && (r[vL] = p(e[vL])),
          e[ea] != null && (r[ea] = p(e[ea])),
          r
        );
      }),
      (vSe = (e, t) => {
        let r = {};
        return (
          e[RL] != null && (r[RL] = p(e[RL])),
          e[UL] != null && (r[UL] = p(e[UL])),
          e[zL] != null && (r[zL] = p(e[zL])),
          e[kL] != null && (r[kL] = F(qr(e[kL]))),
          r
        );
      }),
      (Pdt = (e, t) => {
        let r = {};
        return e[Fr] != null && (r[Fr] = p(e[Fr])), r;
      }),
      (vdt = (e, t) => {
        let r = {};
        return e[Fr] != null && (r[Fr] = p(e[Fr])), r;
      }),
      (Odt = (e, t) => {
        let r = {};
        return e[Fr] != null && (r[Fr] = p(e[Fr])), r;
      }),
      (kdt = (e, t) => {
        let r = {};
        return e[Fr] != null && (r[Fr] = p(e[Fr])), r;
      }),
      (Ddt = (e, t) => {
        let r = {};
        return e[Fr] != null && (r[Fr] = p(e[Fr])), r;
      }),
      (Ndt = (e, t) => {
        let r = {};
        return e[Fr] != null && (r[Fr] = p(e[Fr])), r;
      }),
      (Bdt = (e, t) => {
        let r = {};
        return e[Fr] != null && (r[Fr] = p(e[Fr])), r;
      }),
      (ta = (e) => ({
        httpStatusCode: e.statusCode,
        requestId:
          e.headers["x-amzn-requestid"] ??
          e.headers["x-amzn-request-id"] ??
          e.headers["x-amz-request-id"],
        extendedRequestId: e.headers["x-amz-id-2"],
        cfId: e.headers["x-amz-cf-id"],
      })),
      (Mdt = rb(Sn)),
      (OSe = async (e, t, r, o, n) => {
        let {
            hostname: i,
            protocol: a = "https",
            port: c,
            path: d,
          } = await e.endpoint(),
          m = {
            protocol: a,
            hostname: i,
            port: c,
            method: "POST",
            path: d.endsWith("/") ? d.slice(0, -1) + r : d + r,
            headers: t,
          };
        return (
          o !== void 0 && (m.hostname = o),
          n !== void 0 && (m.body = n),
          new jo(m)
        );
      }),
      (kSe = { "content-type": "application/x-www-form-urlencoded" }),
      (DSe = "2011-06-15"),
      (NSe = "Action"),
      (RL = "AccessKeyId"),
      (Ldt = "AssumeRole"),
      (IL = "AssumedRoleId"),
      (_f = "AssumedRoleUser"),
      (Fdt = "AssumeRoleWithWebIdentity"),
      (PL = "Arn"),
      (vL = "Audience"),
      (wf = "Credentials"),
      (OL = "ContextAssertion"),
      (Tf = "DurationSeconds"),
      (kL = "Expiration"),
      (DL = "ExternalId"),
      (NL = "Key"),
      (Af = "Policy"),
      (Rf = "PolicyArns"),
      (BL = "ProviderArn"),
      (ML = "ProvidedContexts"),
      (LL = "ProviderId"),
      (If = "PackedPolicySize"),
      (FL = "Provider"),
      (Pf = "RoleArn"),
      (vf = "RoleSessionName"),
      (UL = "SecretAccessKey"),
      ($L = "SubjectFromWebIdentityToken"),
      (ea = "SourceIdentity"),
      (HL = "SerialNumber"),
      (zL = "SessionToken"),
      (qL = "Tags"),
      (jL = "TokenCode"),
      (GL = "TransitiveTagKeys"),
      (BSe = "Version"),
      (VL = "Value"),
      (WL = "WebIdentityToken"),
      (KL = "arn"),
      (Fr = "message"),
      (MSe = (e) =>
        Object.entries(e)
          .map(([t, r]) => on(t) + "=" + on(r))
          .join("&")),
      (Udt = (e, t) => {
        if (t.Error?.Code !== void 0) return t.Error.Code;
        if (e.statusCode == 404) return "NotFound";
      });
  });
var bd,
  Zb = s(() => {
    Xl();
    hg();
    Tr();
    Xb();
    Xg();
    YL();
    bd = class extends (
      Hs.classBuilder()
        .ep(Qb)
        .m(function (t, r, o, n) {
          return [
            Yl(o, this.serialize, this.deserialize),
            Ql(o, t.getEndpointParameterInstructions()),
          ];
        })
        .s("AWSSecurityTokenServiceV20110615", "AssumeRole", {})
        .n("STSClient", "AssumeRoleCommand")
        .f(void 0, wL)
        .ser(_Se)
        .de(TSe)
        .build()
    ) {};
  });
var _d,
  e_ = s(() => {
    Xl();
    hg();
    Tr();
    Xb();
    Xg();
    YL();
    _d = class extends (
      Hs.classBuilder()
        .ep(Qb)
        .m(function (t, r, o, n) {
          return [
            Yl(o, this.serialize, this.deserialize),
            Ql(o, t.getEndpointParameterInstructions()),
          ];
        })
        .s("AWSSecurityTokenServiceV20110615", "AssumeRoleWithWebIdentity", {})
        .n("STSClient", "AssumeRoleWithWebIdentityCommand")
        .f(TL, AL)
        .ser(wSe)
        .de(ASe)
        .build()
    ) {};
  });
var $dt,
  t_,
  LSe = s(() => {
    Tr();
    Zb();
    e_();
    qg();
    ($dt = { AssumeRoleCommand: bd, AssumeRoleWithWebIdentityCommand: _d }),
      (t_ = class extends hi {});
    tb($dt, t_);
  });
var FSe = s(() => {
  Zb();
  e_();
});
var USe = s(() => {
  Xg();
});
var $Se,
  HSe,
  zSe,
  qSe,
  jSe,
  GSe,
  VSe = s(() => {
    xt();
    Zb();
    e_();
    ($Se = "us-east-1"),
      (HSe = (e) => {
        if (typeof e?.Arn == "string") {
          let t = e.Arn.split(":");
          if (t.length > 4 && t[4] !== "") return t[4];
        }
      }),
      (zSe = async (e, t, r) => {
        let o = typeof e == "function" ? await e() : e,
          n = typeof t == "function" ? await t() : t;
        return (
          r?.debug?.(
            "@aws-sdk/client-sts::resolveRegion",
            "accepting first of:",
            `${o} (provider)`,
            `${n} (parent client)`,
            `${$Se} (STS default)`
          ),
          o ?? n ?? $Se
        );
      }),
      (qSe = (e, t) => {
        let r, o;
        return async (n, i) => {
          if (((o = n), !r)) {
            let {
                logger: f = e?.parentClientConfig?.logger,
                region: l,
                requestHandler: u = e?.parentClientConfig?.requestHandler,
                credentialProviderLogger: h,
              } = e,
              y = await zSe(l, e?.parentClientConfig?.region, h),
              S = !GSe(u);
            r = new t({
              profile: e?.parentClientConfig?.profile,
              credentialDefaultProvider: () => async () => o,
              region: y,
              requestHandler: S ? u : void 0,
              logger: f,
            });
          }
          let { Credentials: a, AssumedRoleUser: c } = await r.send(new bd(i));
          if (!a || !a.AccessKeyId || !a.SecretAccessKey)
            throw new Error(
              `Invalid response from STS.assumeRole call with role ${i.RoleArn}`
            );
          let d = HSe(c),
            m = {
              accessKeyId: a.AccessKeyId,
              secretAccessKey: a.SecretAccessKey,
              sessionToken: a.SessionToken,
              expiration: a.Expiration,
              ...(a.CredentialScope && { credentialScope: a.CredentialScope }),
              ...(d && { accountId: d }),
            };
          return ce(m, "CREDENTIALS_STS_ASSUME_ROLE", "i"), m;
        };
      }),
      (jSe = (e, t) => {
        let r;
        return async (o) => {
          if (!r) {
            let {
                logger: d = e?.parentClientConfig?.logger,
                region: m,
                requestHandler: f = e?.parentClientConfig?.requestHandler,
                credentialProviderLogger: l,
              } = e,
              u = await zSe(m, e?.parentClientConfig?.region, l),
              h = !GSe(f);
            r = new t({
              profile: e?.parentClientConfig?.profile,
              region: u,
              requestHandler: h ? f : void 0,
              logger: d,
            });
          }
          let { Credentials: n, AssumedRoleUser: i } = await r.send(new _d(o));
          if (!n || !n.AccessKeyId || !n.SecretAccessKey)
            throw new Error(
              `Invalid response from STS.assumeRoleWithWebIdentity call with role ${o.RoleArn}`
            );
          let a = HSe(i),
            c = {
              accessKeyId: n.AccessKeyId,
              secretAccessKey: n.SecretAccessKey,
              sessionToken: n.SessionToken,
              expiration: n.Expiration,
              ...(n.CredentialScope && { credentialScope: n.CredentialScope }),
              ...(a && { accountId: a }),
            };
          return (
            a && ce(c, "RESOLVED_ACCOUNT_ID", "T"),
            ce(c, "CREDENTIALS_STS_ASSUME_ROLE_WEB_ID", "k"),
            c
          );
        };
      }),
      (GSe = (e) => e?.metadata?.handlerProtocol === "h2");
  });
var WSe,
  KSe,
  YSe,
  Hdt,
  QSe = s(() => {
    VSe();
    qg();
    (WSe = (e, t) =>
      t
        ? class extends e {
            constructor(o) {
              super(o);
              for (let n of t) this.middlewareStack.use(n);
            }
          }
        : e),
      (KSe = (e = {}, t) => qSe(e, WSe(hi, t))),
      (YSe = (e = {}, t) => jSe(e, WSe(hi, t))),
      (Hdt = (e) => (t) =>
        e({ roleAssumer: KSe(t), roleAssumerWithWebIdentity: YSe(t), ...t }));
  });
var wd = {};
It(wd, {
  $Command: () => Hs,
  AssumeRoleCommand: () => bd,
  AssumeRoleResponseFilterSensitiveLog: () => wL,
  AssumeRoleWithWebIdentityCommand: () => _d,
  AssumeRoleWithWebIdentityRequestFilterSensitiveLog: () => TL,
  AssumeRoleWithWebIdentityResponseFilterSensitiveLog: () => AL,
  CredentialsFilterSensitiveLog: () => _L,
  ExpiredTokenException: () => jg,
  IDPCommunicationErrorException: () => Qg,
  IDPRejectedClaimException: () => Kg,
  InvalidIdentityTokenException: () => Yg,
  MalformedPolicyDocumentException: () => Gg,
  PackedPolicyTooLargeException: () => Vg,
  RegionDisabledException: () => Wg,
  STS: () => t_,
  STSClient: () => hi,
  STSServiceException: () => Sn,
  __Client: () => qa,
  decorateDefaultCredentialProvider: () => Hdt,
  getDefaultRoleAssumer: () => KSe,
  getDefaultRoleAssumerWithWebIdentity: () => YSe,
});
var Td = s(() => {
  qg();
  LSe();
  FSe();
  USe();
  QSe();
  Jb();
});
var JSe,
  zdt,
  qdt,
  ZSe,
  XSe,
  eCe = s(() => {
    xt();
    re();
    Ls();
    UEe();
    QL();
    (JSe = (e, { profile: t = "default", logger: r } = {}) =>
      !!e &&
      typeof e == "object" &&
      typeof e.role_arn == "string" &&
      ["undefined", "string"].indexOf(typeof e.role_session_name) > -1 &&
      ["undefined", "string"].indexOf(typeof e.external_id) > -1 &&
      ["undefined", "string"].indexOf(typeof e.mfa_serial) > -1 &&
      (zdt(e, { profile: t, logger: r }) || qdt(e, { profile: t, logger: r }))),
      (zdt = (e, { profile: t, logger: r }) => {
        let o =
          typeof e.source_profile == "string" &&
          typeof e.credential_source > "u";
        return (
          o &&
            r?.debug?.(
              `    ${t} isAssumeRoleWithSourceProfile source_profile=${e.source_profile}`
            ),
          o
        );
      }),
      (qdt = (e, { profile: t, logger: r }) => {
        let o =
          typeof e.credential_source == "string" &&
          typeof e.source_profile > "u";
        return (
          o &&
            r?.debug?.(
              `    ${t} isCredentialSourceProfile credential_source=${e.credential_source}`
            ),
          o
        );
      }),
      (ZSe = async (e, t, r, o = {}) => {
        r.logger?.debug(
          "@aws-sdk/credential-provider-ini - resolveAssumeRoleCredentials (STS)"
        );
        let n = t[e],
          { source_profile: i, region: a } = n;
        if (!r.roleAssumer) {
          let { getDefaultRoleAssumer: d } = await Promise.resolve().then(
            () => (Td(), wd)
          );
          r.roleAssumer = d(
            {
              ...r.clientConfig,
              credentialProviderLogger: r.logger,
              parentClientConfig: {
                ...r?.parentClientConfig,
                region: a ?? r?.parentClientConfig?.region,
              },
            },
            r.clientPlugins
          );
        }
        if (i && i in o)
          throw new P(
            `Detected a cycle attempting to resolve credentials for profile ${Kn(r)}. Profiles visited: ` +
              Object.keys(o).join(", "),
            { logger: r.logger }
          );
        r.logger?.debug(
          `@aws-sdk/credential-provider-ini - finding credential resolver using ${i ? `source_profile=[${i}]` : `profile=[${e}]`}`
        );
        let c = i
          ? r_(i, t, r, { ...o, [i]: !0 }, XSe(t[i] ?? {}))
          : (await FEe(n.credential_source, e, r.logger)(r))();
        if (XSe(n))
          return c.then((d) =>
            ce(d, "CREDENTIALS_PROFILE_SOURCE_PROFILE", "o")
          );
        {
          let d = {
              RoleArn: n.role_arn,
              RoleSessionName:
                n.role_session_name || `aws-sdk-js-${Date.now()}`,
              ExternalId: n.external_id,
              DurationSeconds: parseInt(n.duration_seconds || "3600", 10),
            },
            { mfa_serial: m } = n;
          if (m) {
            if (!r.mfaCodeProvider)
              throw new P(
                `Profile ${e} requires multi-factor authentication, but no MFA code callback was provided.`,
                { logger: r.logger, tryNextLink: !1 }
              );
            (d.SerialNumber = m), (d.TokenCode = await r.mfaCodeProvider(m));
          }
          let f = await c;
          return r
            .roleAssumer(f, d)
            .then((l) => ce(l, "CREDENTIALS_PROFILE_SOURCE_PROFILE", "o"));
        }
      }),
      (XSe = (e) => !e.role_arn && !!e.credential_source);
  });
var tCe,
  rCe = s(() => {
    xt();
    tCe = (e, t, r) => {
      if (t.Version !== 1)
        throw Error(
          `Profile ${e} credential_process did not return Version 1.`
        );
      if (t.AccessKeyId === void 0 || t.SecretAccessKey === void 0)
        throw Error(
          `Profile ${e} credential_process returned invalid credentials.`
        );
      if (t.Expiration) {
        let i = new Date();
        if (new Date(t.Expiration) < i)
          throw Error(
            `Profile ${e} credential_process returned expired credentials.`
          );
      }
      let o = t.AccountId;
      !o && r?.[e]?.aws_account_id && (o = r[e].aws_account_id);
      let n = {
        accessKeyId: t.AccessKeyId,
        secretAccessKey: t.SecretAccessKey,
        ...(t.SessionToken && { sessionToken: t.SessionToken }),
        ...(t.Expiration && { expiration: new Date(t.Expiration) }),
        ...(t.CredentialScope && { credentialScope: t.CredentialScope }),
        ...(o && { accountId: o }),
      };
      return ce(n, "CREDENTIALS_PROCESS", "w"), n;
    };
  });
import { exec as jdt } from "child_process";
import { promisify as Gdt } from "util";
var oCe,
  nCe = s(() => {
    re();
    rCe();
    oCe = async (e, t, r) => {
      let o = t[e];
      if (t[e]) {
        let n = o.credential_process;
        if (n !== void 0) {
          let i = Gdt(jdt);
          try {
            let { stdout: a } = await i(n),
              c;
            try {
              c = JSON.parse(a.trim());
            } catch {
              throw Error(
                `Profile ${e} credential_process returned invalid JSON.`
              );
            }
            return tCe(e, c, t);
          } catch (a) {
            throw new P(a.message, { logger: r });
          }
        } else
          throw new P(`Profile ${e} did not contain credential_process.`, {
            logger: r,
          });
      } else
        throw new P(
          `Profile ${e} could not be found in shared credentials file.`,
          { logger: r }
        );
    };
  });
var Vdt,
  sCe = s(() => {
    Ls();
    nCe();
    Vdt =
      (e = {}) =>
      async ({ callerClientConfig: t } = {}) => {
        e.logger?.debug("@aws-sdk/credential-provider-process - fromProcess");
        let r = await Oa(e);
        return oCe(Kn({ profile: e.profile ?? t?.profile }), r, e.logger);
      };
  });
var XL = {};
It(XL, { fromProcess: () => Vdt });
var JL = s(() => {
  sCe();
});
var iCe,
  aCe,
  cCe = s(() => {
    xt();
    (iCe = (e) =>
      !!e && typeof e == "object" && typeof e.credential_process == "string"),
      (aCe = async (e, t) =>
        Promise.resolve()
          .then(() => (JL(), XL))
          .then(({ fromProcess: r }) =>
            r({ ...e, profile: t })().then((o) =>
              ce(o, "CREDENTIALS_PROFILE_PROCESS", "v")
            )
          ));
  });
var dCe,
  mCe,
  lCe = s(() => {
    xt();
    (dCe = async (e, t, r = {}) => {
      let { fromSSO: o } = await Promise.resolve().then(() => (xL(), yL));
      return o({
        profile: e,
        logger: r.logger,
        parentClientConfig: r.parentClientConfig,
        clientConfig: r.clientConfig,
      })().then((n) =>
        t.sso_session
          ? ce(n, "CREDENTIALS_PROFILE_SSO", "r")
          : ce(n, "CREDENTIALS_PROFILE_SSO_LEGACY", "t")
      );
    }),
      (mCe = (e) =>
        e &&
        (typeof e.sso_start_url == "string" ||
          typeof e.sso_account_id == "string" ||
          typeof e.sso_session == "string" ||
          typeof e.sso_region == "string" ||
          typeof e.sso_role_name == "string"));
  });
var ZL,
  eF,
  fCe = s(() => {
    xt();
    (ZL = (e) =>
      !!e &&
      typeof e == "object" &&
      typeof e.aws_access_key_id == "string" &&
      typeof e.aws_secret_access_key == "string" &&
      ["undefined", "string"].indexOf(typeof e.aws_session_token) > -1 &&
      ["undefined", "string"].indexOf(typeof e.aws_account_id) > -1),
      (eF = async (e, t) => {
        t?.logger?.debug(
          "@aws-sdk/credential-provider-ini - resolveStaticCredentials"
        );
        let r = {
          accessKeyId: e.aws_access_key_id,
          secretAccessKey: e.aws_secret_access_key,
          sessionToken: e.aws_session_token,
          ...(e.aws_credential_scope && {
            credentialScope: e.aws_credential_scope,
          }),
          ...(e.aws_account_id && { accountId: e.aws_account_id }),
        };
        return ce(r, "CREDENTIALS_PROFILE", "n");
      });
  });
var tF,
  rF = s(() => {
    tF = (e) => async (t) => {
      e.logger?.debug(
        "@aws-sdk/credential-provider-web-identity - fromWebToken"
      );
      let {
          roleArn: r,
          roleSessionName: o,
          webIdentityToken: n,
          providerId: i,
          policyArns: a,
          policy: c,
          durationSeconds: d,
        } = e,
        { roleAssumerWithWebIdentity: m } = e;
      if (!m) {
        let { getDefaultRoleAssumerWithWebIdentity: f } =
          await Promise.resolve().then(() => (Td(), wd));
        m = f(
          {
            ...e.clientConfig,
            credentialProviderLogger: e.logger,
            parentClientConfig: {
              ...t?.callerClientConfig,
              ...e.parentClientConfig,
            },
          },
          e.clientPlugins
        );
      }
      return m({
        RoleArn: r,
        RoleSessionName: o ?? `aws-sdk-js-session-${Date.now()}`,
        WebIdentityToken: n,
        ProviderId: i,
        PolicyArns: a,
        Policy: c,
        DurationSeconds: d,
      });
    };
  });
import { readFileSync as Wdt } from "fs";
var uCe,
  Kdt,
  Ydt,
  Qdt,
  pCe = s(() => {
    xt();
    re();
    rF();
    (uCe = "AWS_WEB_IDENTITY_TOKEN_FILE"),
      (Kdt = "AWS_ROLE_ARN"),
      (Ydt = "AWS_ROLE_SESSION_NAME"),
      (Qdt =
        (e = {}) =>
        async () => {
          e.logger?.debug(
            "@aws-sdk/credential-provider-web-identity - fromTokenFile"
          );
          let t = e?.webIdentityTokenFile ?? process.env[uCe],
            r = e?.roleArn ?? process.env[Kdt],
            o = e?.roleSessionName ?? process.env[Ydt];
          if (!t || !r)
            throw new P("Web identity configuration not specified", {
              logger: e.logger,
            });
          let n = await tF({
            ...e,
            webIdentityToken: Wdt(t, { encoding: "ascii" }),
            roleArn: r,
            roleSessionName: o,
          })();
          return (
            t === process.env[uCe] &&
              ce(n, "CREDENTIALS_ENV_VARS_STS_WEB_ID_TOKEN", "h"),
            n
          );
        });
  });
var oF = {};
It(oF, { fromTokenFile: () => Qdt, fromWebToken: () => tF });
var nF = s(() => {
  pCe();
  rF();
});
var hCe,
  gCe,
  yCe = s(() => {
    xt();
    (hCe = (e) =>
      !!e &&
      typeof e == "object" &&
      typeof e.web_identity_token_file == "string" &&
      typeof e.role_arn == "string" &&
      ["undefined", "string"].indexOf(typeof e.role_session_name) > -1),
      (gCe = async (e, t) =>
        Promise.resolve()
          .then(() => (nF(), oF))
          .then(({ fromTokenFile: r }) =>
            r({
              webIdentityTokenFile: e.web_identity_token_file,
              roleArn: e.role_arn,
              roleSessionName: e.role_session_name,
              roleAssumerWithWebIdentity: t.roleAssumerWithWebIdentity,
              logger: t.logger,
              parentClientConfig: t.parentClientConfig,
            })().then((o) => ce(o, "CREDENTIALS_PROFILE_STS_WEB_ID_TOKEN", "q"))
          ));
  });
var r_,
  QL = s(() => {
    re();
    eCe();
    cCe();
    lCe();
    fCe();
    yCe();
    r_ = async (e, t, r, o = {}, n = !1) => {
      let i = t[e];
      if (Object.keys(o).length > 0 && ZL(i)) return eF(i, r);
      if (n || JSe(i, { profile: e, logger: r.logger })) return ZSe(e, t, r, o);
      if (ZL(i)) return eF(i, r);
      if (hCe(i)) return gCe(i, r);
      if (iCe(i)) return aCe(r, e);
      if (mCe(i)) return await dCe(e, i, r);
      throw new P(
        `Could not resolve credentials using profile: [${e}] in configuration/credentials file(s).`,
        { logger: r.logger }
      );
    };
  });
var Xdt,
  xCe = s(() => {
    Ls();
    QL();
    Xdt =
      (e = {}) =>
      async ({ callerClientConfig: t } = {}) => {
        let r = { ...e, parentClientConfig: { ...t, ...e.parentClientConfig } };
        r.logger?.debug("@aws-sdk/credential-provider-ini - fromIni");
        let o = await Oa(r);
        return r_(Kn({ profile: e.profile ?? t?.profile }), o, r);
      };
  });
var ECe = {};
It(ECe, { fromIni: () => Xdt });
var SCe = s(() => {
  xCe();
});
var CCe,
  bCe,
  Jdt,
  Zdt,
  _Ce = s(() => {
    AN();
    re();
    Ls();
    Sle();
    (CCe = !1),
      (bCe = (e = {}) =>
        gr(
          Ht(
            async () => {
              if (e.profile ?? process.env[GD])
                throw (
                  (process.env[eC] &&
                    process.env[tC] &&
                    (CCe ||
                      ((e.logger?.warn &&
                        e.logger?.constructor?.name !== "NoOpLogger"
                        ? e.logger.warn
                        : console.warn)(`@aws-sdk/credential-provider-node - defaultProvider::fromEnv WARNING:
    Multiple credential sources detected: 
    Both AWS_PROFILE and the pair AWS_ACCESS_KEY_ID/AWS_SECRET_ACCESS_KEY static credentials are set.
    This SDK will proceed with the AWS_PROFILE value.
    
    However, a future version may change this behavior to prefer the ENV static credentials.
    Please ensure that your environment only sets either the AWS_PROFILE or the
    AWS_ACCESS_KEY_ID/AWS_SECRET_ACCESS_KEY pair.
`),
                      (CCe = !0))),
                  new P("AWS_PROFILE is set, skipping fromEnv provider.", {
                    logger: e.logger,
                    tryNextLink: !0,
                  }))
                );
              return (
                e.logger?.debug(
                  "@aws-sdk/credential-provider-node - defaultProvider::fromEnv"
                ),
                TN(e)()
              );
            },
            async () => {
              e.logger?.debug(
                "@aws-sdk/credential-provider-node - defaultProvider::fromSSO"
              );
              let {
                ssoStartUrl: t,
                ssoAccountId: r,
                ssoRegion: o,
                ssoRoleName: n,
                ssoSession: i,
              } = e;
              if (!t && !r && !o && !n && !i)
                throw new P(
                  "Skipping SSO provider in default chain (inputs do not include SSO fields).",
                  { logger: e.logger }
                );
              let { fromSSO: a } = await Promise.resolve().then(
                () => (xL(), yL)
              );
              return a(e)();
            },
            async () => {
              e.logger?.debug(
                "@aws-sdk/credential-provider-node - defaultProvider::fromIni"
              );
              let { fromIni: t } = await Promise.resolve().then(
                () => (SCe(), ECe)
              );
              return t(e)();
            },
            async () => {
              e.logger?.debug(
                "@aws-sdk/credential-provider-node - defaultProvider::fromProcess"
              );
              let { fromProcess: t } = await Promise.resolve().then(
                () => (JL(), XL)
              );
              return t(e)();
            },
            async () => {
              e.logger?.debug(
                "@aws-sdk/credential-provider-node - defaultProvider::fromTokenFile"
              );
              let { fromTokenFile: t } = await Promise.resolve().then(
                () => (nF(), oF)
              );
              return t(e)();
            },
            async () => (
              e.logger?.debug(
                "@aws-sdk/credential-provider-node - defaultProvider::remoteProvider"
              ),
              (await Ele(e))()
            ),
            async () => {
              throw new P("Could not load credentials from any providers", {
                tryNextLink: !1,
                logger: e.logger,
              });
            }
          ),
          Zdt,
          Jdt
        )),
      (Jdt = (e) => e?.expiration !== void 0),
      (Zdt = (e) =>
        e?.expiration !== void 0 && e.expiration.getTime() - Date.now() < 3e5);
  });
var wCe = s(() => {
  _Ce();
});
var dF,
  ze,
  ut,
  pt,
  Vr,
  ec,
  tc,
  Ad,
  vo,
  yi,
  Gr,
  a_,
  rc,
  jCe,
  oc,
  TCe,
  Of,
  mF,
  ACe,
  Jg,
  RCe,
  lF,
  fF,
  zs,
  GCe,
  ICe,
  PCe,
  sF,
  s_,
  vCe,
  VCe,
  OCe,
  i_,
  kCe,
  iF,
  o_,
  n_,
  DCe,
  NCe,
  BCe,
  MCe,
  LCe,
  FCe,
  UCe,
  aF,
  cF,
  $Ce,
  HCe,
  zCe,
  qCe,
  emt,
  WCe,
  KCe = s(() => {
    (dF = "required"),
      (ze = "type"),
      (ut = "fn"),
      (pt = "argv"),
      (Vr = "ref"),
      (ec = "properties"),
      (tc = "headers"),
      (Ad = "isSet"),
      (vo = "error"),
      (yi = "endpoint"),
      (Gr = "tree"),
      (a_ = "PartitionResult"),
      (rc = "stringEquals"),
      (jCe = "dynamodb"),
      (oc = "getAttr"),
      (TCe = "aws.parseArn"),
      (Of = "ParsedArn"),
      (mF = "isValidHostLabel"),
      (ACe = "FirstArn"),
      (Jg = { [dF]: !1, [ze]: "String" }),
      (RCe = { [dF]: !0, default: !1, [ze]: "Boolean" }),
      (lF = { [ut]: "booleanEquals", [pt]: [{ [Vr]: "UseFIPS" }, !0] }),
      (fF = { [ut]: "booleanEquals", [pt]: [{ [Vr]: "UseDualStack" }, !0] }),
      (zs = {}),
      (GCe = { [Vr]: "Region" }),
      (ICe = {
        [ut]: "booleanEquals",
        [pt]: [{ [ut]: oc, [pt]: [{ [Vr]: a_ }, "supportsFIPS"] }, !0],
      }),
      (PCe = {
        [ut]: "booleanEquals",
        [pt]: [{ [ut]: oc, [pt]: [{ [Vr]: a_ }, "supportsDualStack"] }, !0],
      }),
      (sF = {
        conditions: [
          { [ut]: Ad, [pt]: [{ [Vr]: "AccountIdEndpointMode" }] },
          { [ut]: rc, [pt]: [{ [Vr]: "AccountIdEndpointMode" }, "required"] },
        ],
        rules: [
          {
            [vo]: "Invalid Configuration: AccountIdEndpointMode is required and FIPS is enabled, but FIPS account endpoints are not supported",
            [ze]: vo,
          },
        ],
        [ze]: Gr,
      }),
      (s_ = { [ut]: Ad, [pt]: [{ [Vr]: "AccountIdEndpointMode" }] }),
      (vCe = {
        [vo]: "Invalid Configuration: AccountIdEndpointMode is required and FIPS is enabled, but FIPS account endpoints are not supported",
        [ze]: vo,
      }),
      (VCe = { [ut]: oc, [pt]: [{ [Vr]: a_ }, "name"] }),
      (OCe = {
        [yi]: {
          url: "https://dynamodb.{Region}.{PartitionResult#dnsSuffix}",
          [ec]: {},
          [tc]: {},
        },
        [ze]: yi,
      }),
      (i_ = { [ut]: "not", [pt]: [lF] }),
      (kCe = {
        [vo]: "Invalid Configuration: AccountIdEndpointMode is required and DualStack is enabled, but DualStack account endpoints are not supported",
        [ze]: vo,
      }),
      (iF = {
        [ut]: "not",
        [pt]: [
          { [ut]: rc, [pt]: [{ [Vr]: "AccountIdEndpointMode" }, "disabled"] },
        ],
      }),
      (o_ = { [ut]: rc, [pt]: [VCe, "aws"] }),
      (n_ = { [ut]: "not", [pt]: [fF] }),
      (DCe = {
        [ut]: rc,
        [pt]: [{ [ut]: oc, [pt]: [{ [Vr]: Of }, "service"] }, jCe],
      }),
      (NCe = {
        [ut]: mF,
        [pt]: [{ [ut]: oc, [pt]: [{ [Vr]: Of }, "region"] }, !1],
      }),
      (BCe = {
        [ut]: rc,
        [pt]: [{ [ut]: oc, [pt]: [{ [Vr]: Of }, "region"] }, "{Region}"],
      }),
      (MCe = {
        [ut]: mF,
        [pt]: [{ [ut]: oc, [pt]: [{ [Vr]: Of }, "accountId"] }, !1],
      }),
      (LCe = {
        url: "https://{ParsedArn#accountId}.ddb.{Region}.{PartitionResult#dnsSuffix}",
        [ec]: {},
        [tc]: {},
      }),
      (FCe = { [Vr]: "ResourceArnList" }),
      (UCe = { [Vr]: "AccountId" }),
      (aF = [lF]),
      (cF = [fF]),
      ($Ce = [GCe]),
      (HCe = [
        s_,
        { [ut]: rc, [pt]: [{ [Vr]: "AccountIdEndpointMode" }, "required"] },
      ]),
      (zCe = [i_]),
      (qCe = [{ [Vr]: "ResourceArn" }]),
      (emt = {
        version: "1.0",
        parameters: {
          Region: Jg,
          UseDualStack: RCe,
          UseFIPS: RCe,
          Endpoint: Jg,
          AccountId: Jg,
          AccountIdEndpointMode: Jg,
          ResourceArn: Jg,
          ResourceArnList: { [dF]: !1, [ze]: "stringArray" },
        },
        rules: [
          {
            conditions: [{ [ut]: Ad, [pt]: [{ [Vr]: "Endpoint" }] }],
            rules: [
              {
                conditions: aF,
                error:
                  "Invalid Configuration: FIPS and custom endpoint are not supported",
                [ze]: vo,
              },
              {
                conditions: cF,
                error:
                  "Invalid Configuration: Dualstack and custom endpoint are not supported",
                [ze]: vo,
              },
              { endpoint: { url: "{Endpoint}", [ec]: zs, [tc]: zs }, [ze]: yi },
            ],
            [ze]: Gr,
          },
          {
            conditions: [{ [ut]: Ad, [pt]: $Ce }],
            rules: [
              {
                conditions: [{ [ut]: "aws.partition", [pt]: $Ce, assign: a_ }],
                rules: [
                  {
                    conditions: [{ [ut]: rc, [pt]: [GCe, "local"] }],
                    rules: [
                      {
                        conditions: aF,
                        error:
                          "Invalid Configuration: FIPS and local endpoint are not supported",
                        [ze]: vo,
                      },
                      {
                        conditions: cF,
                        error:
                          "Invalid Configuration: Dualstack and local endpoint are not supported",
                        [ze]: vo,
                      },
                      {
                        endpoint: {
                          url: "http://localhost:8000",
                          [ec]: {
                            authSchemes: [
                              {
                                signingRegion: "us-east-1",
                                name: "sigv4",
                                signingName: jCe,
                              },
                            ],
                          },
                          [tc]: zs,
                        },
                        [ze]: yi,
                      },
                    ],
                    [ze]: Gr,
                  },
                  {
                    conditions: [lF, fF],
                    rules: [
                      {
                        conditions: [ICe, PCe],
                        rules: [
                          sF,
                          {
                            endpoint: {
                              url: "https://dynamodb-fips.{Region}.{PartitionResult#dualStackDnsSuffix}",
                              [ec]: zs,
                              [tc]: zs,
                            },
                            [ze]: yi,
                          },
                        ],
                        [ze]: Gr,
                      },
                      {
                        error:
                          "FIPS and DualStack are enabled, but this partition does not support one or both",
                        [ze]: vo,
                      },
                    ],
                    [ze]: Gr,
                  },
                  {
                    conditions: aF,
                    rules: [
                      {
                        conditions: [ICe],
                        rules: [
                          {
                            conditions: [
                              { [ut]: rc, [pt]: [VCe, "aws-us-gov"] },
                            ],
                            rules: [sF, OCe],
                            [ze]: Gr,
                          },
                          sF,
                          {
                            endpoint: {
                              url: "https://dynamodb-fips.{Region}.{PartitionResult#dnsSuffix}",
                              [ec]: zs,
                              [tc]: zs,
                            },
                            [ze]: yi,
                          },
                        ],
                        [ze]: Gr,
                      },
                      {
                        error:
                          "FIPS is enabled but this partition does not support FIPS",
                        [ze]: vo,
                      },
                    ],
                    [ze]: Gr,
                  },
                  {
                    conditions: cF,
                    rules: [
                      {
                        conditions: [PCe],
                        rules: [
                          {
                            conditions: HCe,
                            rules: [
                              { conditions: zCe, rules: [kCe], [ze]: Gr },
                              vCe,
                            ],
                            [ze]: Gr,
                          },
                          {
                            endpoint: {
                              url: "https://dynamodb.{Region}.{PartitionResult#dualStackDnsSuffix}",
                              [ec]: zs,
                              [tc]: zs,
                            },
                            [ze]: yi,
                          },
                        ],
                        [ze]: Gr,
                      },
                      {
                        error:
                          "DualStack is enabled but this partition does not support DualStack",
                        [ze]: vo,
                      },
                    ],
                    [ze]: Gr,
                  },
                  {
                    conditions: [
                      s_,
                      iF,
                      o_,
                      i_,
                      n_,
                      { [ut]: Ad, [pt]: qCe },
                      { [ut]: TCe, [pt]: qCe, assign: Of },
                      DCe,
                      NCe,
                      BCe,
                      MCe,
                    ],
                    endpoint: LCe,
                    [ze]: yi,
                  },
                  {
                    conditions: [
                      s_,
                      iF,
                      o_,
                      i_,
                      n_,
                      { [ut]: Ad, [pt]: [FCe] },
                      { [ut]: oc, [pt]: [FCe, "[0]"], assign: ACe },
                      { [ut]: TCe, [pt]: [{ [Vr]: ACe }], assign: Of },
                      DCe,
                      NCe,
                      BCe,
                      MCe,
                    ],
                    endpoint: LCe,
                    [ze]: yi,
                  },
                  {
                    conditions: [s_, iF, o_, i_, n_, { [ut]: Ad, [pt]: [UCe] }],
                    rules: [
                      {
                        conditions: [{ [ut]: mF, [pt]: [UCe, !1] }],
                        rules: [
                          {
                            endpoint: {
                              url: "https://{AccountId}.ddb.{Region}.{PartitionResult#dnsSuffix}",
                              [ec]: zs,
                              [tc]: zs,
                            },
                            [ze]: yi,
                          },
                        ],
                        [ze]: Gr,
                      },
                      {
                        error:
                          "Credentials-sourced account ID parameter is invalid",
                        [ze]: vo,
                      },
                    ],
                    [ze]: Gr,
                  },
                  {
                    conditions: HCe,
                    rules: [
                      {
                        conditions: zCe,
                        rules: [
                          {
                            conditions: [n_],
                            rules: [
                              {
                                conditions: [o_],
                                rules: [
                                  {
                                    error:
                                      "AccountIdEndpointMode is required but no AccountID was provided or able to be loaded",
                                    [ze]: vo,
                                  },
                                ],
                                [ze]: Gr,
                              },
                              {
                                error:
                                  "Invalid Configuration: AccountIdEndpointMode is required but account endpoints are not supported in this partition",
                                [ze]: vo,
                              },
                            ],
                            [ze]: Gr,
                          },
                          kCe,
                        ],
                        [ze]: Gr,
                      },
                      vCe,
                    ],
                    [ze]: Gr,
                  },
                  OCe,
                ],
                [ze]: Gr,
              },
            ],
            [ze]: Gr,
          },
          { error: "Invalid Configuration: Missing Region", [ze]: vo },
        ],
      }),
      (WCe = emt);
  });
var tmt,
  YCe,
  QCe = s(() => {
    pE();
    $t();
    KCe();
    (tmt = new uo({
      size: 50,
      params: [
        "AccountId",
        "AccountIdEndpointMode",
        "Endpoint",
        "Region",
        "ResourceArn",
        "ResourceArnList",
        "UseDualStack",
        "UseFIPS",
      ],
    })),
      (YCe = (e, t = {}) =>
        tmt.get(e, () => jr(WCe, { endpointParams: e, logger: t.logger })));
    Jt.aws = $h;
  });
var XCe,
  JCe = s(() => {
    rt();
    ae();
    eg();
    nL();
    Lg();
    yN();
    QCe();
    XCe = (e) => ({
      apiVersion: "2012-08-10",
      base64Decoder: e?.base64Decoder ?? Lb,
      base64Encoder: e?.base64Encoder ?? Fb,
      disableHostPrefix: e?.disableHostPrefix ?? !1,
      endpointProvider: e?.endpointProvider ?? YCe,
      extensions: e?.extensions ?? [],
      httpAuthSchemeProvider: e?.httpAuthSchemeProvider ?? Ise,
      httpAuthSchemes: e?.httpAuthSchemes ?? [
        {
          schemeId: "aws.auth#sigv4",
          identityProvider: (t) => t.getIdentityProvider("aws.auth#sigv4"),
          signer: new wr(),
        },
      ],
      logger: e?.logger ?? new Da(),
      serviceId: e?.serviceId ?? "DynamoDB",
      urlParser: e?.urlParser ?? ii,
      utf8Decoder: e?.utf8Decoder ?? Qa,
      utf8Encoder: e?.utf8Encoder ?? Db,
    });
  });
var ZCe,
  ebe = s(() => {
    tce();
    rt();
    TO();
    wCe();
    NO();
    UM();
    _l();
    GM();
    ng();
    od();
    eL();
    tL();
    ai();
    JCe();
    ae();
    dL();
    ae();
    ZCe = (e) => {
      fS(process.version);
      let t = Ub(e),
        r = () => t().then(lS),
        o = XCe(e);
      $o(process.version);
      let n = { profile: e?.profile, logger: o.logger };
      return {
        ...o,
        ...e,
        runtime: "node",
        defaultsMode: t,
        accountIdEndpointMode: e?.accountIdEndpointMode ?? Wt(tW, n),
        authSchemePreference: e?.authSchemePreference ?? Wt(Ho, n),
        bodyLengthChecker: e?.bodyLengthChecker ?? Mb,
        credentialDefaultProvider: e?.credentialDefaultProvider ?? bCe,
        defaultUserAgentProvider:
          e?.defaultUserAgentProvider ??
          Ob({ serviceId: o.serviceId, clientVersion: rce.version }),
        endpointDiscoveryEnabledProvider:
          e?.endpointDiscoveryEnabledProvider ?? Wt(sW, n),
        maxAttempts: e?.maxAttempts ?? Wt(iS, e),
        region: e?.region ?? Wt(bl, { ...FE, ...n }),
        requestHandler: hf.create(e?.requestHandler ?? r),
        retryMode:
          e?.retryMode ??
          Wt({ ...cS, default: async () => (await r()).retryMode || Al }, e),
        sha256: e?.sha256 ?? uf.bind(null, "sha256"),
        streamCollector: e?.streamCollector ?? Bb,
        useDualstackEndpoint: e?.useDualstackEndpoint ?? Wt(ME, n),
        useFipsEndpoint: e?.useFipsEndpoint ?? Wt(LE, n),
        userAgentAppId: e?.userAgentAppId ?? Wt(kb, n),
      };
    };
  });
var tbe,
  rbe,
  obe = s(() => {
    (tbe = (e) => {
      let t = e.httpAuthSchemes,
        r = e.httpAuthSchemeProvider,
        o = e.credentials;
      return {
        setHttpAuthScheme(n) {
          let i = t.findIndex((a) => a.schemeId === n.schemeId);
          i === -1 ? t.push(n) : t.splice(i, 1, n);
        },
        httpAuthSchemes() {
          return t;
        },
        setHttpAuthSchemeProvider(n) {
          r = n;
        },
        httpAuthSchemeProvider() {
          return r;
        },
        setCredentials(n) {
          o = n;
        },
        credentials() {
          return o;
        },
      };
    }),
      (rbe = (e) => ({
        httpAuthSchemes: e.httpAuthSchemes(),
        httpAuthSchemeProvider: e.httpAuthSchemeProvider(),
        credentials: e.credentials(),
      }));
  });
var nbe,
  sbe = s(() => {
    Xi();
    pn();
    ae();
    obe();
    nbe = (e, t) => {
      let r = Object.assign(Go(e), uS(e), qx(e), tbe(e));
      return (
        t.forEach((o) => o.configure(r)),
        Object.assign(e, Vo(r), pS(r), jx(r), rbe(r))
      );
    };
  });
var ho,
  ra = s(() => {
    TO();
    NO();
    LO();
    FO();
    $O();
    BE();
    _l();
    Ue();
    zD();
    ye();
    ng();
    ae();
    yN();
    ZS();
    Ce();
    ebe();
    sbe();
    ho = class extends kl {
      config;
      constructor(...[t]) {
        let r = ZCe(t || {});
        super(r), (this.initConfig = r);
        let o = vse(r),
          n = X8(o),
          i = iE(n),
          a = aS(i),
          c = $E(a),
          d = c,
          m = XE(d),
          f = Pse(m),
          l = K6(f, { endpointDiscoveryCommandCtor: Ll }),
          u = nbe(l, t?.extensions || []);
        (this.config = u),
          this.middlewareStack.use(NE(this.config)),
          this.middlewareStack.use(hS(this.config)),
          this.middlewareStack.use(HE(this.config)),
          this.middlewareStack.use(Gx(this.config)),
          this.middlewareStack.use(Vx(this.config)),
          this.middlewareStack.use(Wx(this.config)),
          this.middlewareStack.use(
            Mo(this.config, {
              httpAuthSchemeParametersProvider: Rse,
              identityProviderConfigProvider: async (h) =>
                new fo({ "aws.auth#sigv4": h.credentials }),
            })
          ),
          this.middlewareStack.use(Lo(this.config));
      }
      destroy() {
        super.destroy();
      }
    };
  });
var c_,
  uF = s(() => {
    ye();
    xe();
    ae();
    Ce();
    be();
    c_ = class extends (
      L.classBuilder()
        .ep(V)
        .m(function (t, r, o, n) {
          return [
            z(o, this.serialize, this.deserialize),
            q(o, t.getEndpointParameterInstructions()),
          ];
        })
        .s("DynamoDB_20120810", "BatchExecuteStatement", {})
        .n("DynamoDBClient", "BatchExecuteStatementCommand")
        .f(void 0, void 0)
        .ser(kse)
        .de(Bie)
        .build()
    ) {};
  });
var d_,
  pF = s(() => {
    ye();
    xe();
    ae();
    Ce();
    be();
    d_ = class extends (
      L.classBuilder()
        .ep({
          ...V,
          ResourceArnList: {
            type: "operationContextParams",
            get: (t) => Object.keys(t?.RequestItems ?? {}),
          },
        })
        .m(function (t, r, o, n) {
          return [
            z(o, this.serialize, this.deserialize),
            q(o, t.getEndpointParameterInstructions()),
          ];
        })
        .s("DynamoDB_20120810", "BatchGetItem", {})
        .n("DynamoDBClient", "BatchGetItemCommand")
        .f(void 0, void 0)
        .ser(Dse)
        .de(Mie)
        .build()
    ) {};
  });
var kf,
  hF = s(() => {
    ye();
    xe();
    ae();
    Ce();
    be();
    kf = class extends (
      L.classBuilder()
        .ep({
          ...V,
          ResourceArnList: {
            type: "operationContextParams",
            get: (t) => Object.keys(t?.RequestItems ?? {}),
          },
        })
        .m(function (t, r, o, n) {
          return [
            z(o, this.serialize, this.deserialize),
            q(o, t.getEndpointParameterInstructions()),
          ];
        })
        .s("DynamoDB_20120810", "BatchWriteItem", {})
        .n("DynamoDBClient", "BatchWriteItemCommand")
        .f(void 0, void 0)
        .ser(Nse)
        .de(Lie)
        .build()
    ) {};
  });
var m_,
  gF = s(() => {
    ye();
    xe();
    ae();
    Ce();
    be();
    m_ = class extends (
      L.classBuilder()
        .ep({ ...V, ResourceArn: { type: "contextParams", name: "TableName" } })
        .m(function (t, r, o, n) {
          return [
            z(o, this.serialize, this.deserialize),
            q(o, t.getEndpointParameterInstructions()),
          ];
        })
        .s("DynamoDB_20120810", "CreateBackup", {})
        .n("DynamoDBClient", "CreateBackupCommand")
        .f(void 0, void 0)
        .ser(Bse)
        .de(Fie)
        .build()
    ) {};
  });
var l_,
  yF = s(() => {
    ye();
    xe();
    ae();
    Ce();
    be();
    l_ = class extends (
      L.classBuilder()
        .ep({
          ...V,
          ResourceArn: { type: "contextParams", name: "GlobalTableName" },
        })
        .m(function (t, r, o, n) {
          return [
            z(o, this.serialize, this.deserialize),
            q(o, t.getEndpointParameterInstructions()),
          ];
        })
        .s("DynamoDB_20120810", "CreateGlobalTable", {})
        .n("DynamoDBClient", "CreateGlobalTableCommand")
        .f(void 0, void 0)
        .ser(Mse)
        .de(Uie)
        .build()
    ) {};
  });
var f_,
  xF = s(() => {
    ye();
    xe();
    ae();
    Ce();
    be();
    f_ = class extends (
      L.classBuilder()
        .ep({ ...V, ResourceArn: { type: "contextParams", name: "TableName" } })
        .m(function (t, r, o, n) {
          return [
            z(o, this.serialize, this.deserialize),
            q(o, t.getEndpointParameterInstructions()),
          ];
        })
        .s("DynamoDB_20120810", "CreateTable", {})
        .n("DynamoDBClient", "CreateTableCommand")
        .f(void 0, void 0)
        .ser(Lse)
        .de($ie)
        .build()
    ) {};
  });
var u_,
  EF = s(() => {
    ye();
    xe();
    ae();
    Ce();
    be();
    u_ = class extends (
      L.classBuilder()
        .ep({ ...V, ResourceArn: { type: "contextParams", name: "BackupArn" } })
        .m(function (t, r, o, n) {
          return [
            z(o, this.serialize, this.deserialize),
            q(o, t.getEndpointParameterInstructions()),
          ];
        })
        .s("DynamoDB_20120810", "DeleteBackup", {})
        .n("DynamoDBClient", "DeleteBackupCommand")
        .f(void 0, void 0)
        .ser(Fse)
        .de(Hie)
        .build()
    ) {};
  });
var p_,
  SF = s(() => {
    ye();
    xe();
    ae();
    Ce();
    be();
    p_ = class extends (
      L.classBuilder()
        .ep({ ...V, ResourceArn: { type: "contextParams", name: "TableName" } })
        .m(function (t, r, o, n) {
          return [
            z(o, this.serialize, this.deserialize),
            q(o, t.getEndpointParameterInstructions()),
          ];
        })
        .s("DynamoDB_20120810", "DeleteItem", {})
        .n("DynamoDBClient", "DeleteItemCommand")
        .f(void 0, void 0)
        .ser(Use)
        .de(zie)
        .build()
    ) {};
  });
var h_,
  CF = s(() => {
    ye();
    xe();
    ae();
    Ce();
    be();
    h_ = class extends (
      L.classBuilder()
        .ep({
          ...V,
          ResourceArn: { type: "contextParams", name: "ResourceArn" },
        })
        .m(function (t, r, o, n) {
          return [
            z(o, this.serialize, this.deserialize),
            q(o, t.getEndpointParameterInstructions()),
          ];
        })
        .s("DynamoDB_20120810", "DeleteResourcePolicy", {})
        .n("DynamoDBClient", "DeleteResourcePolicyCommand")
        .f(void 0, void 0)
        .ser($se)
        .de(qie)
        .build()
    ) {};
  });
var g_,
  bF = s(() => {
    ye();
    xe();
    ae();
    Ce();
    be();
    g_ = class extends (
      L.classBuilder()
        .ep({ ...V, ResourceArn: { type: "contextParams", name: "TableName" } })
        .m(function (t, r, o, n) {
          return [
            z(o, this.serialize, this.deserialize),
            q(o, t.getEndpointParameterInstructions()),
          ];
        })
        .s("DynamoDB_20120810", "DeleteTable", {})
        .n("DynamoDBClient", "DeleteTableCommand")
        .f(void 0, void 0)
        .ser(Hse)
        .de(jie)
        .build()
    ) {};
  });
var y_,
  _F = s(() => {
    ye();
    xe();
    ae();
    Ce();
    be();
    y_ = class extends (
      L.classBuilder()
        .ep({ ...V, ResourceArn: { type: "contextParams", name: "BackupArn" } })
        .m(function (t, r, o, n) {
          return [
            z(o, this.serialize, this.deserialize),
            q(o, t.getEndpointParameterInstructions()),
          ];
        })
        .s("DynamoDB_20120810", "DescribeBackup", {})
        .n("DynamoDBClient", "DescribeBackupCommand")
        .f(void 0, void 0)
        .ser(zse)
        .de(Gie)
        .build()
    ) {};
  });
var x_,
  wF = s(() => {
    ye();
    xe();
    ae();
    Ce();
    be();
    x_ = class extends (
      L.classBuilder()
        .ep({ ...V, ResourceArn: { type: "contextParams", name: "TableName" } })
        .m(function (t, r, o, n) {
          return [
            z(o, this.serialize, this.deserialize),
            q(o, t.getEndpointParameterInstructions()),
          ];
        })
        .s("DynamoDB_20120810", "DescribeContinuousBackups", {})
        .n("DynamoDBClient", "DescribeContinuousBackupsCommand")
        .f(void 0, void 0)
        .ser(qse)
        .de(Vie)
        .build()
    ) {};
  });
var E_,
  TF = s(() => {
    ye();
    xe();
    ae();
    Ce();
    be();
    E_ = class extends (
      L.classBuilder()
        .ep({ ...V, ResourceArn: { type: "contextParams", name: "TableName" } })
        .m(function (t, r, o, n) {
          return [
            z(o, this.serialize, this.deserialize),
            q(o, t.getEndpointParameterInstructions()),
          ];
        })
        .s("DynamoDB_20120810", "DescribeContributorInsights", {})
        .n("DynamoDBClient", "DescribeContributorInsightsCommand")
        .f(void 0, void 0)
        .ser(jse)
        .de(Wie)
        .build()
    ) {};
  });
var S_,
  AF = s(() => {
    ye();
    xe();
    ae();
    Ce();
    be();
    S_ = class extends (
      L.classBuilder()
        .ep({ ...V, ResourceArn: { type: "contextParams", name: "ExportArn" } })
        .m(function (t, r, o, n) {
          return [
            z(o, this.serialize, this.deserialize),
            q(o, t.getEndpointParameterInstructions()),
          ];
        })
        .s("DynamoDB_20120810", "DescribeExport", {})
        .n("DynamoDBClient", "DescribeExportCommand")
        .f(void 0, void 0)
        .ser(Vse)
        .de(Yie)
        .build()
    ) {};
  });
var C_,
  RF = s(() => {
    ye();
    xe();
    ae();
    Ce();
    be();
    C_ = class extends (
      L.classBuilder()
        .ep({
          ...V,
          ResourceArn: { type: "contextParams", name: "GlobalTableName" },
        })
        .m(function (t, r, o, n) {
          return [
            z(o, this.serialize, this.deserialize),
            q(o, t.getEndpointParameterInstructions()),
          ];
        })
        .s("DynamoDB_20120810", "DescribeGlobalTable", {})
        .n("DynamoDBClient", "DescribeGlobalTableCommand")
        .f(void 0, void 0)
        .ser(Wse)
        .de(Qie)
        .build()
    ) {};
  });
var b_,
  IF = s(() => {
    ye();
    xe();
    ae();
    Ce();
    be();
    b_ = class extends (
      L.classBuilder()
        .ep({
          ...V,
          ResourceArn: { type: "contextParams", name: "GlobalTableName" },
        })
        .m(function (t, r, o, n) {
          return [
            z(o, this.serialize, this.deserialize),
            q(o, t.getEndpointParameterInstructions()),
          ];
        })
        .s("DynamoDB_20120810", "DescribeGlobalTableSettings", {})
        .n("DynamoDBClient", "DescribeGlobalTableSettingsCommand")
        .f(void 0, void 0)
        .ser(Kse)
        .de(Xie)
        .build()
    ) {};
  });
var __,
  PF = s(() => {
    ye();
    xe();
    ae();
    Ce();
    be();
    __ = class extends (
      L.classBuilder()
        .ep({ ...V, ResourceArn: { type: "contextParams", name: "ImportArn" } })
        .m(function (t, r, o, n) {
          return [
            z(o, this.serialize, this.deserialize),
            q(o, t.getEndpointParameterInstructions()),
          ];
        })
        .s("DynamoDB_20120810", "DescribeImport", {})
        .n("DynamoDBClient", "DescribeImportCommand")
        .f(void 0, void 0)
        .ser(Yse)
        .de(Jie)
        .build()
    ) {};
  });
var w_,
  vF = s(() => {
    ye();
    xe();
    ae();
    Ce();
    be();
    w_ = class extends (
      L.classBuilder()
        .ep({ ...V, ResourceArn: { type: "contextParams", name: "TableName" } })
        .m(function (t, r, o, n) {
          return [
            z(o, this.serialize, this.deserialize),
            q(o, t.getEndpointParameterInstructions()),
          ];
        })
        .s("DynamoDB_20120810", "DescribeKinesisStreamingDestination", {})
        .n("DynamoDBClient", "DescribeKinesisStreamingDestinationCommand")
        .f(void 0, void 0)
        .ser(Qse)
        .de(Zie)
        .build()
    ) {};
  });
var T_,
  OF = s(() => {
    ye();
    xe();
    ae();
    Ce();
    be();
    T_ = class extends (
      L.classBuilder()
        .ep(V)
        .m(function (t, r, o, n) {
          return [
            z(o, this.serialize, this.deserialize),
            q(o, t.getEndpointParameterInstructions()),
          ];
        })
        .s("DynamoDB_20120810", "DescribeLimits", {})
        .n("DynamoDBClient", "DescribeLimitsCommand")
        .f(void 0, void 0)
        .ser(Xse)
        .de(eae)
        .build()
    ) {};
  });
var A_,
  kF = s(() => {
    ye();
    xe();
    ae();
    Ce();
    be();
    A_ = class extends (
      L.classBuilder()
        .ep({ ...V, ResourceArn: { type: "contextParams", name: "TableName" } })
        .m(function (t, r, o, n) {
          return [
            z(o, this.serialize, this.deserialize),
            q(o, t.getEndpointParameterInstructions()),
          ];
        })
        .s("DynamoDB_20120810", "DescribeTable", {})
        .n("DynamoDBClient", "DescribeTableCommand")
        .f(void 0, void 0)
        .ser(Jse)
        .de(tae)
        .build()
    ) {};
  });
var R_,
  DF = s(() => {
    ye();
    xe();
    ae();
    Ce();
    be();
    R_ = class extends (
      L.classBuilder()
        .ep({ ...V, ResourceArn: { type: "contextParams", name: "TableName" } })
        .m(function (t, r, o, n) {
          return [
            z(o, this.serialize, this.deserialize),
            q(o, t.getEndpointParameterInstructions()),
          ];
        })
        .s("DynamoDB_20120810", "DescribeTableReplicaAutoScaling", {})
        .n("DynamoDBClient", "DescribeTableReplicaAutoScalingCommand")
        .f(void 0, void 0)
        .ser(Zse)
        .de(rae)
        .build()
    ) {};
  });
var I_,
  NF = s(() => {
    ye();
    xe();
    ae();
    Ce();
    be();
    I_ = class extends (
      L.classBuilder()
        .ep({ ...V, ResourceArn: { type: "contextParams", name: "TableName" } })
        .m(function (t, r, o, n) {
          return [
            z(o, this.serialize, this.deserialize),
            q(o, t.getEndpointParameterInstructions()),
          ];
        })
        .s("DynamoDB_20120810", "DescribeTimeToLive", {})
        .n("DynamoDBClient", "DescribeTimeToLiveCommand")
        .f(void 0, void 0)
        .ser(eie)
        .de(oae)
        .build()
    ) {};
  });
var P_,
  BF = s(() => {
    ye();
    xe();
    ae();
    Ce();
    be();
    P_ = class extends (
      L.classBuilder()
        .ep({ ...V, ResourceArn: { type: "contextParams", name: "TableName" } })
        .m(function (t, r, o, n) {
          return [
            z(o, this.serialize, this.deserialize),
            q(o, t.getEndpointParameterInstructions()),
          ];
        })
        .s("DynamoDB_20120810", "DisableKinesisStreamingDestination", {})
        .n("DynamoDBClient", "DisableKinesisStreamingDestinationCommand")
        .f(void 0, void 0)
        .ser(tie)
        .de(nae)
        .build()
    ) {};
  });
var v_,
  MF = s(() => {
    ye();
    xe();
    ae();
    Ce();
    be();
    v_ = class extends (
      L.classBuilder()
        .ep({ ...V, ResourceArn: { type: "contextParams", name: "TableName" } })
        .m(function (t, r, o, n) {
          return [
            z(o, this.serialize, this.deserialize),
            q(o, t.getEndpointParameterInstructions()),
          ];
        })
        .s("DynamoDB_20120810", "EnableKinesisStreamingDestination", {})
        .n("DynamoDBClient", "EnableKinesisStreamingDestinationCommand")
        .f(void 0, void 0)
        .ser(rie)
        .de(sae)
        .build()
    ) {};
  });
var O_,
  LF = s(() => {
    ye();
    xe();
    ae();
    Ce();
    be();
    O_ = class extends (
      L.classBuilder()
        .ep(V)
        .m(function (t, r, o, n) {
          return [
            z(o, this.serialize, this.deserialize),
            q(o, t.getEndpointParameterInstructions()),
          ];
        })
        .s("DynamoDB_20120810", "ExecuteStatement", {})
        .n("DynamoDBClient", "ExecuteStatementCommand")
        .f(void 0, void 0)
        .ser(oie)
        .de(iae)
        .build()
    ) {};
  });
var k_,
  FF = s(() => {
    ye();
    xe();
    ae();
    Ce();
    be();
    k_ = class extends (
      L.classBuilder()
        .ep(V)
        .m(function (t, r, o, n) {
          return [
            z(o, this.serialize, this.deserialize),
            q(o, t.getEndpointParameterInstructions()),
          ];
        })
        .s("DynamoDB_20120810", "ExecuteTransaction", {})
        .n("DynamoDBClient", "ExecuteTransactionCommand")
        .f(void 0, void 0)
        .ser(nie)
        .de(aae)
        .build()
    ) {};
  });
var D_,
  UF = s(() => {
    ye();
    xe();
    ae();
    Ce();
    be();
    D_ = class extends (
      L.classBuilder()
        .ep({ ...V, ResourceArn: { type: "contextParams", name: "TableArn" } })
        .m(function (t, r, o, n) {
          return [
            z(o, this.serialize, this.deserialize),
            q(o, t.getEndpointParameterInstructions()),
          ];
        })
        .s("DynamoDB_20120810", "ExportTableToPointInTime", {})
        .n("DynamoDBClient", "ExportTableToPointInTimeCommand")
        .f(void 0, void 0)
        .ser(sie)
        .de(cae)
        .build()
    ) {};
  });
var N_,
  $F = s(() => {
    ye();
    xe();
    ae();
    Ce();
    be();
    N_ = class extends (
      L.classBuilder()
        .ep({ ...V, ResourceArn: { type: "contextParams", name: "TableName" } })
        .m(function (t, r, o, n) {
          return [
            z(o, this.serialize, this.deserialize),
            q(o, t.getEndpointParameterInstructions()),
          ];
        })
        .s("DynamoDB_20120810", "GetItem", {})
        .n("DynamoDBClient", "GetItemCommand")
        .f(void 0, void 0)
        .ser(iie)
        .de(dae)
        .build()
    ) {};
  });
var B_,
  HF = s(() => {
    ye();
    xe();
    ae();
    Ce();
    be();
    B_ = class extends (
      L.classBuilder()
        .ep({
          ...V,
          ResourceArn: { type: "contextParams", name: "ResourceArn" },
        })
        .m(function (t, r, o, n) {
          return [
            z(o, this.serialize, this.deserialize),
            q(o, t.getEndpointParameterInstructions()),
          ];
        })
        .s("DynamoDB_20120810", "GetResourcePolicy", {})
        .n("DynamoDBClient", "GetResourcePolicyCommand")
        .f(void 0, void 0)
        .ser(aie)
        .de(mae)
        .build()
    ) {};
  });
var M_,
  zF = s(() => {
    ye();
    xe();
    ae();
    Ce();
    be();
    M_ = class extends (
      L.classBuilder()
        .ep({
          ...V,
          ResourceArn: {
            type: "operationContextParams",
            get: (t) => t?.TableCreationParameters?.TableName,
          },
        })
        .m(function (t, r, o, n) {
          return [
            z(o, this.serialize, this.deserialize),
            q(o, t.getEndpointParameterInstructions()),
          ];
        })
        .s("DynamoDB_20120810", "ImportTable", {})
        .n("DynamoDBClient", "ImportTableCommand")
        .f(void 0, void 0)
        .ser(cie)
        .de(lae)
        .build()
    ) {};
  });
var L_,
  qF = s(() => {
    ye();
    xe();
    ae();
    Ce();
    be();
    L_ = class extends (
      L.classBuilder()
        .ep({ ...V, ResourceArn: { type: "contextParams", name: "TableName" } })
        .m(function (t, r, o, n) {
          return [
            z(o, this.serialize, this.deserialize),
            q(o, t.getEndpointParameterInstructions()),
          ];
        })
        .s("DynamoDB_20120810", "ListBackups", {})
        .n("DynamoDBClient", "ListBackupsCommand")
        .f(void 0, void 0)
        .ser(die)
        .de(fae)
        .build()
    ) {};
  });
var Df,
  F_ = s(() => {
    ye();
    xe();
    ae();
    Ce();
    be();
    Df = class extends (
      L.classBuilder()
        .ep({ ...V, ResourceArn: { type: "contextParams", name: "TableName" } })
        .m(function (t, r, o, n) {
          return [
            z(o, this.serialize, this.deserialize),
            q(o, t.getEndpointParameterInstructions()),
          ];
        })
        .s("DynamoDB_20120810", "ListContributorInsights", {})
        .n("DynamoDBClient", "ListContributorInsightsCommand")
        .f(void 0, void 0)
        .ser(mie)
        .de(uae)
        .build()
    ) {};
  });
var Nf,
  U_ = s(() => {
    ye();
    xe();
    ae();
    Ce();
    be();
    Nf = class extends (
      L.classBuilder()
        .ep({ ...V, ResourceArn: { type: "contextParams", name: "TableArn" } })
        .m(function (t, r, o, n) {
          return [
            z(o, this.serialize, this.deserialize),
            q(o, t.getEndpointParameterInstructions()),
          ];
        })
        .s("DynamoDB_20120810", "ListExports", {})
        .n("DynamoDBClient", "ListExportsCommand")
        .f(void 0, void 0)
        .ser(lie)
        .de(pae)
        .build()
    ) {};
  });
var $_,
  jF = s(() => {
    ye();
    xe();
    ae();
    Ce();
    be();
    $_ = class extends (
      L.classBuilder()
        .ep(V)
        .m(function (t, r, o, n) {
          return [
            z(o, this.serialize, this.deserialize),
            q(o, t.getEndpointParameterInstructions()),
          ];
        })
        .s("DynamoDB_20120810", "ListGlobalTables", {})
        .n("DynamoDBClient", "ListGlobalTablesCommand")
        .f(void 0, void 0)
        .ser(fie)
        .de(hae)
        .build()
    ) {};
  });
var Bf,
  H_ = s(() => {
    ye();
    xe();
    ae();
    Ce();
    be();
    Bf = class extends (
      L.classBuilder()
        .ep({ ...V, ResourceArn: { type: "contextParams", name: "TableArn" } })
        .m(function (t, r, o, n) {
          return [
            z(o, this.serialize, this.deserialize),
            q(o, t.getEndpointParameterInstructions()),
          ];
        })
        .s("DynamoDB_20120810", "ListImports", {})
        .n("DynamoDBClient", "ListImportsCommand")
        .f(void 0, void 0)
        .ser(uie)
        .de(gae)
        .build()
    ) {};
  });
var Mf,
  z_ = s(() => {
    ye();
    xe();
    ae();
    Ce();
    be();
    Mf = class extends (
      L.classBuilder()
        .ep(V)
        .m(function (t, r, o, n) {
          return [
            z(o, this.serialize, this.deserialize),
            q(o, t.getEndpointParameterInstructions()),
          ];
        })
        .s("DynamoDB_20120810", "ListTables", {})
        .n("DynamoDBClient", "ListTablesCommand")
        .f(void 0, void 0)
        .ser(pie)
        .de(yae)
        .build()
    ) {};
  });
var q_,
  GF = s(() => {
    ye();
    xe();
    ae();
    Ce();
    be();
    q_ = class extends (
      L.classBuilder()
        .ep({
          ...V,
          ResourceArn: { type: "contextParams", name: "ResourceArn" },
        })
        .m(function (t, r, o, n) {
          return [
            z(o, this.serialize, this.deserialize),
            q(o, t.getEndpointParameterInstructions()),
          ];
        })
        .s("DynamoDB_20120810", "ListTagsOfResource", {})
        .n("DynamoDBClient", "ListTagsOfResourceCommand")
        .f(void 0, void 0)
        .ser(hie)
        .de(xae)
        .build()
    ) {};
  });
var j_,
  VF = s(() => {
    ye();
    xe();
    ae();
    Ce();
    be();
    j_ = class extends (
      L.classBuilder()
        .ep({ ...V, ResourceArn: { type: "contextParams", name: "TableName" } })
        .m(function (t, r, o, n) {
          return [
            z(o, this.serialize, this.deserialize),
            q(o, t.getEndpointParameterInstructions()),
          ];
        })
        .s("DynamoDB_20120810", "PutItem", {})
        .n("DynamoDBClient", "PutItemCommand")
        .f(void 0, void 0)
        .ser(gie)
        .de(Eae)
        .build()
    ) {};
  });
var G_,
  WF = s(() => {
    ye();
    xe();
    ae();
    Ce();
    be();
    G_ = class extends (
      L.classBuilder()
        .ep({
          ...V,
          ResourceArn: { type: "contextParams", name: "ResourceArn" },
        })
        .m(function (t, r, o, n) {
          return [
            z(o, this.serialize, this.deserialize),
            q(o, t.getEndpointParameterInstructions()),
          ];
        })
        .s("DynamoDB_20120810", "PutResourcePolicy", {})
        .n("DynamoDBClient", "PutResourcePolicyCommand")
        .f(void 0, void 0)
        .ser(yie)
        .de(Sae)
        .build()
    ) {};
  });
var xi,
  V_ = s(() => {
    ye();
    xe();
    ae();
    Ce();
    be();
    xi = class extends (
      L.classBuilder()
        .ep({ ...V, ResourceArn: { type: "contextParams", name: "TableName" } })
        .m(function (t, r, o, n) {
          return [
            z(o, this.serialize, this.deserialize),
            q(o, t.getEndpointParameterInstructions()),
          ];
        })
        .s("DynamoDB_20120810", "Query", {})
        .n("DynamoDBClient", "QueryCommand")
        .f(void 0, void 0)
        .ser(xie)
        .de(Cae)
        .build()
    ) {};
  });
var W_,
  KF = s(() => {
    ye();
    xe();
    ae();
    Ce();
    be();
    W_ = class extends (
      L.classBuilder()
        .ep({
          ...V,
          ResourceArn: { type: "contextParams", name: "TargetTableName" },
        })
        .m(function (t, r, o, n) {
          return [
            z(o, this.serialize, this.deserialize),
            q(o, t.getEndpointParameterInstructions()),
          ];
        })
        .s("DynamoDB_20120810", "RestoreTableFromBackup", {})
        .n("DynamoDBClient", "RestoreTableFromBackupCommand")
        .f(void 0, void 0)
        .ser(Eie)
        .de(bae)
        .build()
    ) {};
  });
var K_,
  YF = s(() => {
    ye();
    xe();
    ae();
    Ce();
    be();
    K_ = class extends (
      L.classBuilder()
        .ep({
          ...V,
          ResourceArn: { type: "contextParams", name: "TargetTableName" },
        })
        .m(function (t, r, o, n) {
          return [
            z(o, this.serialize, this.deserialize),
            q(o, t.getEndpointParameterInstructions()),
          ];
        })
        .s("DynamoDB_20120810", "RestoreTableToPointInTime", {})
        .n("DynamoDBClient", "RestoreTableToPointInTimeCommand")
        .f(void 0, void 0)
        .ser(Sie)
        .de(_ae)
        .build()
    ) {};
  });
var Lf,
  Y_ = s(() => {
    ye();
    xe();
    ae();
    Ce();
    be();
    Lf = class extends (
      L.classBuilder()
        .ep({ ...V, ResourceArn: { type: "contextParams", name: "TableName" } })
        .m(function (t, r, o, n) {
          return [
            z(o, this.serialize, this.deserialize),
            q(o, t.getEndpointParameterInstructions()),
          ];
        })
        .s("DynamoDB_20120810", "Scan", {})
        .n("DynamoDBClient", "ScanCommand")
        .f(void 0, void 0)
        .ser(Cie)
        .de(wae)
        .build()
    ) {};
  });
var Q_,
  QF = s(() => {
    ye();
    xe();
    ae();
    Ce();
    be();
    Q_ = class extends (
      L.classBuilder()
        .ep({
          ...V,
          ResourceArn: { type: "contextParams", name: "ResourceArn" },
        })
        .m(function (t, r, o, n) {
          return [
            z(o, this.serialize, this.deserialize),
            q(o, t.getEndpointParameterInstructions()),
          ];
        })
        .s("DynamoDB_20120810", "TagResource", {})
        .n("DynamoDBClient", "TagResourceCommand")
        .f(void 0, void 0)
        .ser(bie)
        .de(Tae)
        .build()
    ) {};
  });
var X_,
  XF = s(() => {
    ye();
    xe();
    ae();
    Ce();
    be();
    X_ = class extends (
      L.classBuilder()
        .ep({
          ...V,
          ResourceArnList: {
            type: "operationContextParams",
            get: (t) => t?.TransactItems?.map((r) => r?.Get?.TableName),
          },
        })
        .m(function (t, r, o, n) {
          return [
            z(o, this.serialize, this.deserialize),
            q(o, t.getEndpointParameterInstructions()),
          ];
        })
        .s("DynamoDB_20120810", "TransactGetItems", {})
        .n("DynamoDBClient", "TransactGetItemsCommand")
        .f(void 0, void 0)
        .ser(_ie)
        .de(Aae)
        .build()
    ) {};
  });
var J_,
  JF = s(() => {
    ye();
    xe();
    ae();
    Ce();
    be();
    J_ = class extends (
      L.classBuilder()
        .ep({
          ...V,
          ResourceArnList: {
            type: "operationContextParams",
            get: (t) =>
              t?.TransactItems?.map((r) =>
                [
                  r?.ConditionCheck?.TableName,
                  r?.Put?.TableName,
                  r?.Delete?.TableName,
                  r?.Update?.TableName,
                ].filter((o) => o)
              ).flat(),
          },
        })
        .m(function (t, r, o, n) {
          return [
            z(o, this.serialize, this.deserialize),
            q(o, t.getEndpointParameterInstructions()),
          ];
        })
        .s("DynamoDB_20120810", "TransactWriteItems", {})
        .n("DynamoDBClient", "TransactWriteItemsCommand")
        .f(void 0, void 0)
        .ser(wie)
        .de(Rae)
        .build()
    ) {};
  });
var Z_,
  ZF = s(() => {
    ye();
    xe();
    ae();
    Ce();
    be();
    Z_ = class extends (
      L.classBuilder()
        .ep({
          ...V,
          ResourceArn: { type: "contextParams", name: "ResourceArn" },
        })
        .m(function (t, r, o, n) {
          return [
            z(o, this.serialize, this.deserialize),
            q(o, t.getEndpointParameterInstructions()),
          ];
        })
        .s("DynamoDB_20120810", "UntagResource", {})
        .n("DynamoDBClient", "UntagResourceCommand")
        .f(void 0, void 0)
        .ser(Tie)
        .de(Iae)
        .build()
    ) {};
  });
var ew,
  eU = s(() => {
    ye();
    xe();
    ae();
    Ce();
    be();
    ew = class extends (
      L.classBuilder()
        .ep({ ...V, ResourceArn: { type: "contextParams", name: "TableName" } })
        .m(function (t, r, o, n) {
          return [
            z(o, this.serialize, this.deserialize),
            q(o, t.getEndpointParameterInstructions()),
          ];
        })
        .s("DynamoDB_20120810", "UpdateContinuousBackups", {})
        .n("DynamoDBClient", "UpdateContinuousBackupsCommand")
        .f(void 0, void 0)
        .ser(Aie)
        .de(Pae)
        .build()
    ) {};
  });
var tw,
  tU = s(() => {
    ye();
    xe();
    ae();
    Ce();
    be();
    tw = class extends (
      L.classBuilder()
        .ep({ ...V, ResourceArn: { type: "contextParams", name: "TableName" } })
        .m(function (t, r, o, n) {
          return [
            z(o, this.serialize, this.deserialize),
            q(o, t.getEndpointParameterInstructions()),
          ];
        })
        .s("DynamoDB_20120810", "UpdateContributorInsights", {})
        .n("DynamoDBClient", "UpdateContributorInsightsCommand")
        .f(void 0, void 0)
        .ser(Rie)
        .de(vae)
        .build()
    ) {};
  });
var rw,
  rU = s(() => {
    ye();
    xe();
    ae();
    Ce();
    be();
    rw = class extends (
      L.classBuilder()
        .ep({
          ...V,
          ResourceArn: { type: "contextParams", name: "GlobalTableName" },
        })
        .m(function (t, r, o, n) {
          return [
            z(o, this.serialize, this.deserialize),
            q(o, t.getEndpointParameterInstructions()),
          ];
        })
        .s("DynamoDB_20120810", "UpdateGlobalTable", {})
        .n("DynamoDBClient", "UpdateGlobalTableCommand")
        .f(void 0, void 0)
        .ser(Iie)
        .de(Oae)
        .build()
    ) {};
  });
var ow,
  oU = s(() => {
    ye();
    xe();
    ae();
    Ce();
    be();
    ow = class extends (
      L.classBuilder()
        .ep({
          ...V,
          ResourceArn: { type: "contextParams", name: "GlobalTableName" },
        })
        .m(function (t, r, o, n) {
          return [
            z(o, this.serialize, this.deserialize),
            q(o, t.getEndpointParameterInstructions()),
          ];
        })
        .s("DynamoDB_20120810", "UpdateGlobalTableSettings", {})
        .n("DynamoDBClient", "UpdateGlobalTableSettingsCommand")
        .f(void 0, void 0)
        .ser(Pie)
        .de(kae)
        .build()
    ) {};
  });
var nw,
  nU = s(() => {
    ye();
    xe();
    ae();
    Ce();
    be();
    nw = class extends (
      L.classBuilder()
        .ep({ ...V, ResourceArn: { type: "contextParams", name: "TableName" } })
        .m(function (t, r, o, n) {
          return [
            z(o, this.serialize, this.deserialize),
            q(o, t.getEndpointParameterInstructions()),
          ];
        })
        .s("DynamoDB_20120810", "UpdateItem", {})
        .n("DynamoDBClient", "UpdateItemCommand")
        .f(void 0, void 0)
        .ser(vie)
        .de(Dae)
        .build()
    ) {};
  });
var sw,
  sU = s(() => {
    ye();
    xe();
    ae();
    Ce();
    be();
    sw = class extends (
      L.classBuilder()
        .ep({ ...V, ResourceArn: { type: "contextParams", name: "TableName" } })
        .m(function (t, r, o, n) {
          return [
            z(o, this.serialize, this.deserialize),
            q(o, t.getEndpointParameterInstructions()),
          ];
        })
        .s("DynamoDB_20120810", "UpdateKinesisStreamingDestination", {})
        .n("DynamoDBClient", "UpdateKinesisStreamingDestinationCommand")
        .f(void 0, void 0)
        .ser(Oie)
        .de(Nae)
        .build()
    ) {};
  });
var iw,
  iU = s(() => {
    ye();
    xe();
    ae();
    Ce();
    be();
    iw = class extends (
      L.classBuilder()
        .ep({ ...V, ResourceArn: { type: "contextParams", name: "TableName" } })
        .m(function (t, r, o, n) {
          return [
            z(o, this.serialize, this.deserialize),
            q(o, t.getEndpointParameterInstructions()),
          ];
        })
        .s("DynamoDB_20120810", "UpdateTable", {})
        .n("DynamoDBClient", "UpdateTableCommand")
        .f(void 0, void 0)
        .ser(kie)
        .de(Bae)
        .build()
    ) {};
  });
var aw,
  aU = s(() => {
    ye();
    xe();
    ae();
    Ce();
    be();
    aw = class extends (
      L.classBuilder()
        .ep({ ...V, ResourceArn: { type: "contextParams", name: "TableName" } })
        .m(function (t, r, o, n) {
          return [
            z(o, this.serialize, this.deserialize),
            q(o, t.getEndpointParameterInstructions()),
          ];
        })
        .s("DynamoDB_20120810", "UpdateTableReplicaAutoScaling", {})
        .n("DynamoDBClient", "UpdateTableReplicaAutoScalingCommand")
        .f(void 0, void 0)
        .ser(Die)
        .de(Mae)
        .build()
    ) {};
  });
var cw,
  cU = s(() => {
    ye();
    xe();
    ae();
    Ce();
    be();
    cw = class extends (
      L.classBuilder()
        .ep({ ...V, ResourceArn: { type: "contextParams", name: "TableName" } })
        .m(function (t, r, o, n) {
          return [
            z(o, this.serialize, this.deserialize),
            q(o, t.getEndpointParameterInstructions()),
          ];
        })
        .s("DynamoDB_20120810", "UpdateTimeToLive", {})
        .n("DynamoDBClient", "UpdateTimeToLiveCommand")
        .f(void 0, void 0)
        .ser(Nie)
        .de(Lae)
        .build()
    ) {};
  });
var rmt,
  dU,
  ibe = s(() => {
    ae();
    uF();
    pF();
    hF();
    gF();
    yF();
    xF();
    EF();
    SF();
    CF();
    bF();
    _F();
    wF();
    TF();
    ZS();
    AF();
    RF();
    IF();
    PF();
    vF();
    OF();
    kF();
    DF();
    NF();
    BF();
    MF();
    LF();
    FF();
    UF();
    $F();
    HF();
    zF();
    qF();
    F_();
    U_();
    jF();
    H_();
    z_();
    GF();
    VF();
    WF();
    V_();
    KF();
    YF();
    Y_();
    QF();
    XF();
    JF();
    ZF();
    eU();
    tU();
    rU();
    oU();
    nU();
    sU();
    iU();
    aU();
    cU();
    ra();
    (rmt = {
      BatchExecuteStatementCommand: c_,
      BatchGetItemCommand: d_,
      BatchWriteItemCommand: kf,
      CreateBackupCommand: m_,
      CreateGlobalTableCommand: l_,
      CreateTableCommand: f_,
      DeleteBackupCommand: u_,
      DeleteItemCommand: p_,
      DeleteResourcePolicyCommand: h_,
      DeleteTableCommand: g_,
      DescribeBackupCommand: y_,
      DescribeContinuousBackupsCommand: x_,
      DescribeContributorInsightsCommand: E_,
      DescribeEndpointsCommand: Ll,
      DescribeExportCommand: S_,
      DescribeGlobalTableCommand: C_,
      DescribeGlobalTableSettingsCommand: b_,
      DescribeImportCommand: __,
      DescribeKinesisStreamingDestinationCommand: w_,
      DescribeLimitsCommand: T_,
      DescribeTableCommand: A_,
      DescribeTableReplicaAutoScalingCommand: R_,
      DescribeTimeToLiveCommand: I_,
      DisableKinesisStreamingDestinationCommand: P_,
      EnableKinesisStreamingDestinationCommand: v_,
      ExecuteStatementCommand: O_,
      ExecuteTransactionCommand: k_,
      ExportTableToPointInTimeCommand: D_,
      GetItemCommand: N_,
      GetResourcePolicyCommand: B_,
      ImportTableCommand: M_,
      ListBackupsCommand: L_,
      ListContributorInsightsCommand: Df,
      ListExportsCommand: Nf,
      ListGlobalTablesCommand: $_,
      ListImportsCommand: Bf,
      ListTablesCommand: Mf,
      ListTagsOfResourceCommand: q_,
      PutItemCommand: j_,
      PutResourcePolicyCommand: G_,
      QueryCommand: xi,
      RestoreTableFromBackupCommand: W_,
      RestoreTableToPointInTimeCommand: K_,
      ScanCommand: Lf,
      TagResourceCommand: Q_,
      TransactGetItemsCommand: X_,
      TransactWriteItemsCommand: J_,
      UntagResourceCommand: Z_,
      UpdateContinuousBackupsCommand: ew,
      UpdateContributorInsightsCommand: tw,
      UpdateGlobalTableCommand: rw,
      UpdateGlobalTableSettingsCommand: ow,
      UpdateItemCommand: nw,
      UpdateKinesisStreamingDestinationCommand: sw,
      UpdateTableCommand: iw,
      UpdateTableReplicaAutoScalingCommand: aw,
      UpdateTimeToLiveCommand: cw,
    }),
      (dU = class extends ho {});
    dS(rmt, dU);
  });
var abe = s(() => {
  uF();
  pF();
  hF();
  gF();
  yF();
  xF();
  EF();
  SF();
  CF();
  bF();
  _F();
  wF();
  TF();
  ZS();
  AF();
  RF();
  IF();
  PF();
  vF();
  OF();
  kF();
  DF();
  NF();
  BF();
  MF();
  LF();
  FF();
  UF();
  $F();
  HF();
  zF();
  qF();
  F_();
  U_();
  jF();
  H_();
  z_();
  GF();
  VF();
  WF();
  V_();
  KF();
  YF();
  Y_();
  QF();
  XF();
  JF();
  ZF();
  eU();
  tU();
  rU();
  oU();
  nU();
  sU();
  iU();
  aU();
  cU();
});
var cbe = s(() => {});
var qFr,
  dbe = s(() => {
    Ue();
    F_();
    ra();
    qFr = dt(ho, Df, "NextToken", "NextToken", "MaxResults");
  });
var KFr,
  mbe = s(() => {
    Ue();
    U_();
    ra();
    KFr = dt(ho, Nf, "NextToken", "NextToken", "MaxResults");
  });
var ZFr,
  lbe = s(() => {
    Ue();
    H_();
    ra();
    ZFr = dt(ho, Bf, "NextToken", "NextToken", "PageSize");
  });
var nUr,
  fbe = s(() => {
    Ue();
    z_();
    ra();
    nUr = dt(
      ho,
      Mf,
      "ExclusiveStartTableName",
      "LastEvaluatedTableName",
      "Limit"
    );
  });
var dUr,
  ube = s(() => {
    Ue();
    V_();
    ra();
    dUr = dt(ho, xi, "ExclusiveStartKey", "LastEvaluatedKey", "Limit");
  });
var pUr,
  pbe = s(() => {
    Ue();
    Y_();
    ra();
    pUr = dt(ho, Lf, "ExclusiveStartKey", "LastEvaluatedKey", "Limit");
  });
var hbe = s(() => {
  cbe();
  dbe();
  mbe();
  lbe();
  fbe();
  ube();
  pbe();
});
var mU = s(() => {});
var Ff,
  dw = s(() => {
    (function (e) {
      (e.ABORTED = "ABORTED"),
        (e.FAILURE = "FAILURE"),
        (e.SUCCESS = "SUCCESS"),
        (e.RETRY = "RETRY"),
        (e.TIMEOUT = "TIMEOUT");
    })(Ff || (Ff = {}));
  });
var gbe = s(() => {
  mU();
  dw();
});
var ybe = s(() => {});
var xbe = s(() => {
  mU();
  ybe();
});
var Ebe = s(() => {
  gbe();
  xbe();
  dw();
});
var lU = s(() => {
  Ebe();
  dw();
});
var Sbe = s(() => {
  lU();
});
var Cbe = s(() => {
  lU();
});
var bbe = s(() => {
  Sbe();
  Cbe();
});
var _be = s(() => {
  EN();
});
var wbe = s(() => {
  ra();
  ibe();
  abe();
  hbe();
  bbe();
  _be();
});
var Tbe,
  Abe = s(() => {
    Tbe = () => {
      let e = process.env.DYNAMO_BATCH_WRITE_COMMAND_CONCURRENCY,
        t = e ? Number.parseInt(e) : void 0;
      return t && !Number.isNaN(t) ? t : 4;
    };
  });
var Rbe = {};
It(Rbe, { default: () => lmt });
import imt from "node:path";
function cmt() {
  return {
    region: amt,
    logger: Qm,
    maxAttempts: wx(process.env.AWS_SDK_DYNAMODB_MAX_ATTEMPTS),
  };
}
function Zg(e) {
  return imt.posix.join(fU ?? "", e);
}
function dmt(e, t, r) {
  return {
    path: { S: Zg(e) },
    tag: { S: Zg(t) },
    revalidatedAt: { N: `${r ?? Date.now()}` },
  };
}
var amt,
  mw,
  fU,
  lw,
  mmt,
  lmt,
  Ibe = s(() => {
    wbe();
    mo();
    Eh();
    Abe();
    ({
      CACHE_BUCKET_REGION: amt,
      CACHE_DYNAMO_TABLE: mw,
      NEXT_BUILD_ID: fU,
    } = process.env);
    lw = new ho(cmt());
    (mmt = {
      mode: "original",
      async getByPath(e) {
        try {
          if (globalThis.openNextConfig.dangerous?.disableTagCache) return [];
          let r =
            (
              await lw.send(
                new xi({
                  TableName: mw,
                  IndexName: "revalidate",
                  KeyConditionExpression: "#key = :key",
                  ExpressionAttributeNames: { "#key": "path" },
                  ExpressionAttributeValues: { ":key": { S: Zg(e) } },
                })
              )
            ).Items?.map((o) => o.tag.S ?? "") ?? [];
          return (
            He("tags for path", e, r), r.map((o) => o.replace(`${fU}/`, ""))
          );
        } catch (t) {
          return kr("Failed to get tags by path", t), [];
        }
      },
      async getByTag(e) {
        try {
          if (globalThis.openNextConfig.dangerous?.disableTagCache) return [];
          let { Items: t } = await lw.send(
            new xi({
              TableName: mw,
              KeyConditionExpression: "#tag = :tag",
              ExpressionAttributeNames: { "#tag": "tag" },
              ExpressionAttributeValues: { ":tag": { S: Zg(e) } },
            })
          );
          return (
            t?.map(({ path: { S: r } }) => r?.replace(`${fU}/`, "") ?? "") ?? []
          );
        } catch (t) {
          return kr("Failed to get by tag", t), [];
        }
      },
      async getLastModified(e, t) {
        try {
          if (globalThis.openNextConfig.dangerous?.disableTagCache)
            return t ?? Date.now();
          let o =
            (
              await lw.send(
                new xi({
                  TableName: mw,
                  IndexName: "revalidate",
                  KeyConditionExpression:
                    "#key = :key AND #revalidatedAt > :lastModified",
                  ExpressionAttributeNames: {
                    "#key": "path",
                    "#revalidatedAt": "revalidatedAt",
                  },
                  ExpressionAttributeValues: {
                    ":key": { S: Zg(e) },
                    ":lastModified": { N: String(t ?? 0) },
                  },
                })
              )
            ).Items ?? [];
          return (
            He("revalidatedTags", o), o.length > 0 ? -1 : (t ?? Date.now())
          );
        } catch (r) {
          return kr("Failed to get revalidated tags", r), t ?? Date.now();
        }
      },
      async writeTags(e) {
        try {
          if (globalThis.openNextConfig.dangerous?.disableTagCache) return;
          let t = cO(e, 25).map((o) => ({
              RequestItems: {
                [mw ?? ""]: o.map((n) => ({
                  PutRequest: {
                    Item: { ...dmt(n.path, n.tag, n.revalidatedAt) },
                  },
                })),
              },
            })),
            r = cO(t, Tbe());
          for (let o of r)
            await Promise.all(o.map(async (n) => lw.send(new kf(n))));
        } catch (t) {
          kr("Failed to batch write dynamo item", t);
        }
      },
      name: "dynamoDb",
    }),
      (lmt = mmt);
  });
var fw,
  uw,
  Pbe = s(() => {
    (fw = (e) => ({
      setHttpHandler(t) {
        e.httpHandler = t;
      },
      httpHandler() {
        return e.httpHandler;
      },
      updateHttpClientConfig(t, r) {
        e.httpHandler?.updateHttpClientConfig(t, r);
      },
      httpHandlerConfigs() {
        return e.httpHandler.httpHandlerConfigs();
      },
    })),
      (uw = (e) => ({ httpHandler: e.httpHandler() }));
  });
var vbe = s(() => {
  Pbe();
});
var Obe = s(() => {});
var kbe,
  Dbe = s(() => {
    (function (e) {
      (e.HEADER = "header"), (e.QUERY = "query");
    })(kbe || (kbe = {}));
  });
var Nbe,
  Bbe = s(() => {
    (function (e) {
      (e.HEADER = "header"), (e.QUERY = "query");
    })(Nbe || (Nbe = {}));
  });
var Mbe = s(() => {});
var Lbe = s(() => {});
var Fbe = s(() => {});
var Ube = s(() => {});
var $be = s(() => {
  Dbe();
  Bbe();
  Mbe();
  Lbe();
  Fbe();
  Ube();
});
var Hbe = s(() => {});
var zbe = s(() => {});
var qbe = s(() => {});
var jbe = s(() => {});
var Gbe = s(() => {});
var Vbe = s(() => {});
var Wbe = s(() => {});
var Kbe = s(() => {
  Gbe();
  Vbe();
  Wbe();
});
var Ybe = s(() => {});
var Qbe = s(() => {});
var Xbe,
  Jbe = s(() => {
    (function (e) {
      (e.HTTP = "http"), (e.HTTPS = "https");
    })(Xbe || (Xbe = {}));
  });
var Zbe = s(() => {});
var e_e = s(() => {});
var t_e = s(() => {});
var r_e = s(() => {});
var o_e = s(() => {});
var n_e = s(() => {
  Zbe();
  e_e();
  t_e();
  r_e();
  o_e();
});
var s_e = s(() => {});
var Uf,
  uU = s(() => {
    (function (e) {
      (e.MD5 = "md5"),
        (e.CRC32 = "crc32"),
        (e.CRC32C = "crc32c"),
        (e.SHA1 = "sha1"),
        (e.SHA256 = "sha256");
    })(Uf || (Uf = {}));
  });
var i_e = s(() => {
  uU();
});
var a_e = s(() => {});
var c_e = s(() => {
  i_e();
  a_e();
  uU();
});
var d_e = s(() => {});
var pU,
  m_e = s(() => {
    (function (e) {
      (e[(e.HEADER = 0)] = "HEADER"), (e[(e.TRAILER = 1)] = "TRAILER");
    })(pU || (pU = {}));
  });
var l_e = s(() => {});
var f_e = s(() => {});
var u_e = s(() => {});
var p_e = s(() => {});
var h_e = s(() => {});
var g_e = s(() => {
  f_e();
  u_e();
  p_e();
  h_e();
});
var y_e = s(() => {});
var x_e,
  E_e = s(() => {
    x_e = "__smithy_context";
  });
var S_e = s(() => {});
var oa,
  C_e = s(() => {
    (function (e) {
      (e.PROFILE = "profile"),
        (e.SSO_SESSION = "sso-session"),
        (e.SERVICES = "services");
    })(oa || (oa = {}));
  });
var b_e = s(() => {});
var __e = s(() => {});
var w_e = s(() => {});
var T_e = s(() => {});
var A_e = s(() => {});
var R_e = s(() => {});
var I_e = s(() => {});
var P_e = s(() => {});
var v_e = s(() => {});
var O_e = s(() => {});
var k_e = s(() => {});
var D_e,
  N_e = s(() => {
    (function (e) {
      (e.HTTP_0_9 = "http/0.9"),
        (e.HTTP_1_0 = "http/1.0"),
        (e.TDS_8_0 = "tds/8.0");
    })(D_e || (D_e = {}));
  });
var B_e = s(() => {});
var M_e = s(() => {});
var L_e = s(() => {});
var F_e = s(() => {});
var U_e = s(() => {});
var $_e = s(() => {});
var H_e = s(() => {});
var Rd = s(() => {
  Obe();
  $be();
  Hbe();
  zbe();
  qbe();
  jbe();
  Kbe();
  Ybe();
  Qbe();
  Jbe();
  n_e();
  s_e();
  c_e();
  d_e();
  m_e();
  l_e();
  g_e();
  y_e();
  E_e();
  S_e();
  C_e();
  b_e();
  __e();
  w_e();
  T_e();
  A_e();
  R_e();
  I_e();
  P_e();
  v_e();
  O_e();
  k_e();
  N_e();
  B_e();
  M_e();
  L_e();
  F_e();
  U_e();
  $_e();
  H_e();
});
var z_e = s(() => {
  Rd();
});
var q_e = s(() => {});
var j_e = s(() => {});
function fmt(e) {
  return Object.keys(e).reduce((t, r) => {
    let o = e[r];
    return { ...t, [r]: Array.isArray(o) ? [...o] : o };
  }, {});
}
var Ko,
  G_e = s(() => {
    Ko = class e {
      constructor(t) {
        (this.method = t.method || "GET"),
          (this.hostname = t.hostname || "localhost"),
          (this.port = t.port),
          (this.query = t.query || {}),
          (this.headers = t.headers || {}),
          (this.body = t.body),
          (this.protocol = t.protocol
            ? t.protocol.slice(-1) !== ":"
              ? `${t.protocol}:`
              : t.protocol
            : "https:"),
          (this.path = t.path
            ? t.path.charAt(0) !== "/"
              ? `/${t.path}`
              : t.path
            : "/"),
          (this.username = t.username),
          (this.password = t.password),
          (this.fragment = t.fragment);
      }
      static clone(t) {
        let r = new e({ ...t, headers: { ...t.headers } });
        return r.query && (r.query = fmt(r.query)), r;
      }
      static isInstance(t) {
        if (!t) return !1;
        let r = t;
        return (
          "method" in r &&
          "protocol" in r &&
          "hostname" in r &&
          "path" in r &&
          typeof r.query == "object" &&
          typeof r.headers == "object"
        );
      }
      clone() {
        return e.clone(this);
      }
    };
  });
var Ei,
  V_e = s(() => {
    Ei = class {
      constructor(t) {
        (this.statusCode = t.statusCode),
          (this.reason = t.reason),
          (this.headers = t.headers || {}),
          (this.body = t.body);
      }
      static isInstance(t) {
        if (!t) return !1;
        let r = t;
        return typeof r.statusCode == "number" && typeof r.headers == "object";
      }
    };
  });
var W_e = s(() => {});
var K_e = s(() => {});
var Cn = s(() => {
  vbe();
  z_e();
  q_e();
  j_e();
  G_e();
  V_e();
  W_e();
  K_e();
});
var umt,
  pmt,
  pw,
  hU = s(() => {
    Cn();
    (umt = (e) => (t) => async (r) => {
      if (!Ko.isInstance(r.request)) return t(r);
      let { request: o } = r,
        { handlerProtocol: n = "" } = e.requestHandler.metadata || {};
      if (n.indexOf("h2") >= 0 && !o.headers[":authority"])
        delete o.headers.host,
          (o.headers[":authority"] = o.hostname + (o.port ? ":" + o.port : ""));
      else if (!o.headers.host) {
        let i = o.hostname;
        o.port != null && (i += `:${o.port}`), (o.headers.host = i);
      }
      return t(r);
    }),
      (pmt = {
        name: "hostHeaderMiddleware",
        step: "build",
        priority: "low",
        tags: ["HOST"],
        override: !0,
      }),
      (pw = (e) => ({
        applyToStack: (t) => {
          t.add(umt(e), pmt);
        },
      }));
  });
var hmt,
  gmt,
  hw,
  Y_e = s(() => {
    (hmt = () => (e, t) => async (r) => {
      try {
        let o = await e(r),
          {
            clientName: n,
            commandName: i,
            logger: a,
            dynamoDbDocumentClientOptions: c = {},
          } = t,
          {
            overrideInputFilterSensitiveLog: d,
            overrideOutputFilterSensitiveLog: m,
          } = c,
          f = d ?? t.inputFilterSensitiveLog,
          l = m ?? t.outputFilterSensitiveLog,
          { $metadata: u, ...h } = o.output;
        return (
          a?.info?.({
            clientName: n,
            commandName: i,
            input: f(r.input),
            output: l(h),
            metadata: u,
          }),
          o
        );
      } catch (o) {
        let {
            clientName: n,
            commandName: i,
            logger: a,
            dynamoDbDocumentClientOptions: c = {},
          } = t,
          { overrideInputFilterSensitiveLog: d } = c,
          m = d ?? t.inputFilterSensitiveLog;
        throw (
          (a?.error?.({
            clientName: n,
            commandName: i,
            input: m(r.input),
            error: o,
            metadata: o.$metadata,
          }),
          o)
        );
      }
    }),
      (gmt = {
        name: "loggerMiddleware",
        tags: ["LOGGER"],
        step: "initialize",
        override: !0,
      }),
      (hw = (e) => ({
        applyToStack: (t) => {
          t.add(hmt(), gmt);
        },
      }));
  });
var gU = s(() => {
  Y_e();
});
var yU,
  ymt,
  xmt,
  Emt,
  Smt,
  gw,
  xU = s(() => {
    Cn();
    (yU = "X-Amzn-Trace-Id"),
      (ymt = "AWS_LAMBDA_FUNCTION_NAME"),
      (xmt = "_X_AMZN_TRACE_ID"),
      (Emt = (e) => (t) => async (r) => {
        let { request: o } = r;
        if (!Ko.isInstance(o) || e.runtime !== "node") return t(r);
        let n =
          Object.keys(o.headers ?? {}).find(
            (d) => d.toLowerCase() === yU.toLowerCase()
          ) ?? yU;
        if (o.headers.hasOwnProperty(n)) return t(r);
        let i = process.env[ymt],
          a = process.env[xmt],
          c = (d) => typeof d == "string" && d.length > 0;
        return c(i) && c(a) && (o.headers[yU] = a), t({ ...r, request: o });
      }),
      (Smt = {
        step: "build",
        tags: ["RECURSION_DETECTION"],
        name: "recursionDetectionMiddleware",
        override: !0,
        priority: "low",
      }),
      (gw = (e) => ({
        applyToStack: (t) => {
          t.add(Emt(e), Smt);
        },
      }));
  });
var Q_e = s(() => {});
var EU = s(() => {
  Q_e();
});
var X_e = s(() => {
  EU();
});
var J_e = s(() => {
  Dt();
});
var Z_e = s(() => {});
var ewe,
  twe = s(() => {
    (function (e) {
      (e.HEADER = "header"), (e.QUERY = "query");
    })(ewe || (ewe = {}));
  });
var rwe,
  owe = s(() => {
    (function (e) {
      (e.HEADER = "header"), (e.QUERY = "query");
    })(rwe || (rwe = {}));
  });
var nwe = s(() => {});
var swe = s(() => {});
var iwe = s(() => {});
var awe = s(() => {});
var cwe = s(() => {
  twe();
  owe();
  nwe();
  swe();
  iwe();
  awe();
});
var dwe = s(() => {});
var mwe = s(() => {});
var lwe = s(() => {});
var fwe = s(() => {});
var uwe = s(() => {});
var pwe = s(() => {});
var hwe = s(() => {});
var gwe = s(() => {
  uwe();
  pwe();
  hwe();
});
var ywe = s(() => {});
var xwe = s(() => {});
var Ewe,
  Swe = s(() => {
    (function (e) {
      (e.HTTP = "http"), (e.HTTPS = "https");
    })(Ewe || (Ewe = {}));
  });
var Cwe = s(() => {});
var bwe = s(() => {});
var _we = s(() => {});
var wwe = s(() => {});
var Twe = s(() => {});
var Awe = s(() => {
  Cwe();
  bwe();
  _we();
  wwe();
  Twe();
});
var Rwe = s(() => {});
var yw,
  SU = s(() => {
    (function (e) {
      (e.MD5 = "md5"),
        (e.CRC32 = "crc32"),
        (e.CRC32C = "crc32c"),
        (e.SHA1 = "sha1"),
        (e.SHA256 = "sha256");
    })(yw || (yw = {}));
  });
var Iwe = s(() => {
  SU();
});
var Pwe = s(() => {});
var vwe = s(() => {
  Iwe();
  Pwe();
  SU();
});
var Owe = s(() => {});
var kwe,
  Dwe = s(() => {
    (function (e) {
      (e[(e.HEADER = 0)] = "HEADER"), (e[(e.TRAILER = 1)] = "TRAILER");
    })(kwe || (kwe = {}));
  });
var Nwe = s(() => {});
var Bwe = s(() => {});
var Mwe = s(() => {});
var Lwe = s(() => {});
var Fwe = s(() => {});
var Uwe = s(() => {
  Bwe();
  Mwe();
  Lwe();
  Fwe();
});
var $we = s(() => {});
var Hwe = s(() => {});
var zwe = s(() => {});
var qwe,
  jwe = s(() => {
    (function (e) {
      (e.PROFILE = "profile"),
        (e.SSO_SESSION = "sso-session"),
        (e.SERVICES = "services");
    })(qwe || (qwe = {}));
  });
var Gwe = s(() => {});
var Vwe = s(() => {});
var Wwe = s(() => {});
var Kwe = s(() => {});
var Ywe = s(() => {});
var Qwe = s(() => {});
var Xwe = s(() => {});
var Jwe = s(() => {});
var Zwe = s(() => {});
var eTe = s(() => {});
var tTe = s(() => {});
var rTe,
  oTe = s(() => {
    (function (e) {
      (e.HTTP_0_9 = "http/0.9"),
        (e.HTTP_1_0 = "http/1.0"),
        (e.TDS_8_0 = "tds/8.0");
    })(rTe || (rTe = {}));
  });
var nTe = s(() => {});
var sTe = s(() => {});
var iTe = s(() => {});
var aTe = s(() => {});
var cTe = s(() => {});
var dTe = s(() => {});
var mTe = s(() => {});
var CU = s(() => {
  Z_e();
  cwe();
  dwe();
  mwe();
  lwe();
  fwe();
  gwe();
  ywe();
  xwe();
  Swe();
  Awe();
  Rwe();
  vwe();
  Owe();
  Dwe();
  Nwe();
  Uwe();
  $we();
  Hwe();
  zwe();
  jwe();
  Gwe();
  Vwe();
  Wwe();
  Kwe();
  Ywe();
  Qwe();
  Xwe();
  Jwe();
  Zwe();
  eTe();
  tTe();
  oTe();
  nTe();
  sTe();
  iTe();
  aTe();
  cTe();
  dTe();
  mTe();
});
var lTe = s(() => {
  EU();
  CU();
});
var fTe = s(() => {});
var uTe = s(() => {});
var bU = s(() => {});
var pTe = s(() => {
  bU();
});
var hTe = s(() => {});
var gTe = s(() => {});
var yTe = s(() => {
  Dt();
});
var xTe = s(() => {
  CU();
});
var ETe = s(() => {});
var STe = s(() => {
  xTe();
  ETe();
});
var CTe = s(() => {
  STe();
});
var bTe = s(() => {});
var _Te = s(() => {});
var wTe = s(() => {});
var xw,
  TTe = s(() => {
    xw = class {
      trace() {}
      debug() {}
      info() {}
      warn() {}
      error() {}
    };
  });
var ATe = s(() => {});
var RTe = s(() => {
  Dt();
});
var ITe = s(() => {});
var PTe = s(() => {});
var vTe = s(() => {
  X_e();
  J_e();
  lTe();
  fTe();
  uTe();
  pTe();
  hTe();
  gTe();
  bU();
  yTe();
  CTe();
  bTe();
  _Te();
  wTe();
  TTe();
  ATe();
  RTe();
  ITe();
  PTe();
  Uo();
});
function bmt({ useQueueUrlAsEndpoint: e, endpoint: t }) {
  return (r, o) => async (n) => {
    let { input: i } = n,
      a = o.endpointV2;
    if (!t && i.QueueUrl && a && e) {
      let c = o.logger instanceof xw || !o.logger?.warn ? console : o.logger;
      try {
        let d = new URL(i.QueueUrl),
          m = new URL(d.origin);
        a.url.origin !== m.origin &&
          (c.warn(`QueueUrl=${i.QueueUrl} differs from SQSClient resolved endpoint=${a.url.toString()}, using QueueUrl host as endpoint.
Set [endpoint=string] or [useQueueUrlAsEndpoint=false] on the SQSClient.`),
          (o.endpointV2 = { ...a, url: m }));
      } catch (d) {
        c.warn(d);
      }
    }
    return r(n);
  };
}
var OTe,
  _mt,
  kTe,
  DTe = s(() => {
    vTe();
    OTe = (e) =>
      Object.assign(e, {
        useQueueUrlAsEndpoint: e.useQueueUrlAsEndpoint ?? !0,
      });
    (_mt = {
      name: "queueUrlMiddleware",
      relation: "after",
      toMiddleware: "endpointV2Middleware",
      override: !0,
    }),
      (kTe = (e) => ({
        applyToStack: (t) => {
          t.addRelativeTo(bmt(e), _mt);
        },
      }));
  });
import { Buffer as NTe } from "buffer";
var BTe,
  _U = s(() => {
    cr();
    BTe = (e, t) => {
      if (typeof e != "string")
        throw new TypeError(
          `The "input" argument must be of type string. Received type ${typeof e} (${e})`
        );
      return t ? NTe.from(e, t) : NTe.from(e);
    };
  });
var MTe,
  wU = s(() => {
    _U();
    MTe = (e) => {
      let t = BTe(e, "utf8");
      return new Uint8Array(
        t.buffer,
        t.byteOffset,
        t.byteLength / Uint8Array.BYTES_PER_ELEMENT
      );
    };
  });
var $f,
  LTe = s(() => {
    wU();
    $f = (e) =>
      typeof e == "string"
        ? MTe(e)
        : ArrayBuffer.isView(e)
          ? new Uint8Array(
              e.buffer,
              e.byteOffset,
              e.byteLength / Uint8Array.BYTES_PER_ELEMENT
            )
          : new Uint8Array(e);
  });
var FTe = s(() => {
  _U();
});
var Ew = s(() => {
  wU();
  LTe();
  FTe();
});
function wmt(e) {
  return (t) => async (r) => {
    let o = await t({ ...r });
    if (e.md5 === !1) return o;
    let n = o.output,
      i = [];
    if (n.Messages !== void 0)
      for (let a of n.Messages) {
        let c = a.MD5OfBody,
          d = new e.md5();
        d.update($f(a.Body || "")),
          c !== _t(await d.digest()) && i.push(a.MessageId);
      }
    if (i.length > 0)
      throw new Error("Invalid MD5 checksum on messages: " + i.join(", "));
    return o;
  };
}
var Tmt,
  UTe,
  $Te = s(() => {
    Fo();
    Ew();
    (Tmt = {
      step: "initialize",
      tags: ["VALIDATE_BODY_MD5"],
      name: "receiveMessageMiddleware",
      override: !0,
    }),
      (UTe = (e) => ({
        applyToStack: (t) => {
          t.add(wmt(e), Tmt);
        },
      }));
  });
var Amt,
  Rmt,
  HTe,
  zTe = s(() => {
    Fo();
    Ew();
    (Amt = (e) => (t) => async (r) => {
      let o = await t({ ...r });
      if (e.md5 === !1) return o;
      let n = o.output,
        i = new e.md5();
      if (
        (i.update($f(r.input.MessageBody || "")),
        n.MD5OfMessageBody !== _t(await i.digest()))
      )
        throw new Error("InvalidChecksumError");
      return o;
    }),
      (Rmt = {
        step: "initialize",
        tags: ["VALIDATE_BODY_MD5"],
        name: "sendMessageMiddleware",
        override: !0,
      }),
      (HTe = (e) => ({
        applyToStack: (t) => {
          t.add(Amt(e), Rmt);
        },
      }));
  });
var Imt,
  Pmt,
  qTe,
  jTe = s(() => {
    Fo();
    Ew();
    (Imt = (e) => (t) => async (r) => {
      let o = await t({ ...r });
      if (e.md5 === !1) return o;
      let n = o.output,
        i = [],
        a = {};
      if (n.Successful !== void 0)
        for (let c of n.Successful) c.Id !== void 0 && (a[c.Id] = c);
      for (let c of r.input.Entries)
        if (a[c.Id]) {
          let d = a[c.Id].MD5OfMessageBody,
            m = new e.md5();
          m.update($f(c.MessageBody || "")),
            d !== _t(await m.digest()) && i.push(a[c.Id].MessageId);
        }
      if (i.length > 0)
        throw new Error("Invalid MD5 checksum on messages: " + i.join(", "));
      return o;
    }),
      (Pmt = {
        step: "initialize",
        tags: ["VALIDATE_BODY_MD5"],
        name: "sendMessageBatchMiddleware",
        override: !0,
      }),
      (qTe = (e) => ({
        applyToStack: (t) => {
          t.add(Imt(e), Pmt);
        },
      }));
  });
var ey = s(() => {
  DTe();
  $Te();
  zTe();
  jTe();
});
function vmt(e) {
  return e === void 0 ? !0 : typeof e == "string" && e.length <= 50;
}
function Sw(e) {
  let t = rn(e.userAgentAppId ?? TU),
    { customUserAgent: r } = e;
  return Object.assign(e, {
    customUserAgent: typeof r == "string" ? [[r]] : r,
    userAgentAppId: async () => {
      let o = await t();
      if (!vmt(o)) {
        let n =
          e.logger?.constructor?.name === "NoOpLogger" || !e.logger
            ? console
            : e.logger;
        typeof o != "string"
          ? n?.warn("userAgentAppId must be a string or undefined.")
          : o.length > 50 &&
            n?.warn(
              "The provided userAgentAppId exceeds the maximum length of 50 characters."
            );
      }
      return o;
    },
  });
}
var TU,
  GTe = s(() => {
    Ue();
    TU = void 0;
  });
var AU = s(() => {
  $t();
});
var RU,
  VTe = s(() => {
    $t();
    AU();
    RU = (e, t = !1) => {
      if (t) {
        for (let r of e.split(".")) if (!RU(r)) return !1;
        return !0;
      }
      return !(
        !Ms(e) ||
        e.length < 3 ||
        e.length > 63 ||
        e !== e.toLowerCase() ||
        gn(e)
      );
    };
  });
var WTe,
  Omt,
  KTe,
  YTe = s(() => {
    (WTe = ":"),
      (Omt = "/"),
      (KTe = (e) => {
        let t = e.split(WTe);
        if (t.length < 6) return null;
        let [r, o, n, i, a, ...c] = t;
        if (r !== "arn" || o === "" || n === "" || c.join(WTe) === "")
          return null;
        let d = c.map((m) => m.split(Omt)).flat();
        return {
          partition: o,
          service: n,
          region: i,
          accountId: a,
          resourceId: d,
        };
      });
  });
var XTe,
  QTe = s(() => {
    XTe = {
      partitions: [
        {
          id: "aws",
          outputs: {
            dnsSuffix: "amazonaws.com",
            dualStackDnsSuffix: "api.aws",
            implicitGlobalRegion: "us-east-1",
            name: "aws",
            supportsDualStack: !0,
            supportsFIPS: !0,
          },
          regionRegex: "^(us|eu|ap|sa|ca|me|af|il|mx)\\-\\w+\\-\\d+$",
          regions: {
            "af-south-1": { description: "Africa (Cape Town)" },
            "ap-east-1": { description: "Asia Pacific (Hong Kong)" },
            "ap-east-2": { description: "Asia Pacific (Taipei)" },
            "ap-northeast-1": { description: "Asia Pacific (Tokyo)" },
            "ap-northeast-2": { description: "Asia Pacific (Seoul)" },
            "ap-northeast-3": { description: "Asia Pacific (Osaka)" },
            "ap-south-1": { description: "Asia Pacific (Mumbai)" },
            "ap-south-2": { description: "Asia Pacific (Hyderabad)" },
            "ap-southeast-1": { description: "Asia Pacific (Singapore)" },
            "ap-southeast-2": { description: "Asia Pacific (Sydney)" },
            "ap-southeast-3": { description: "Asia Pacific (Jakarta)" },
            "ap-southeast-4": { description: "Asia Pacific (Melbourne)" },
            "ap-southeast-5": { description: "Asia Pacific (Malaysia)" },
            "ap-southeast-7": { description: "Asia Pacific (Thailand)" },
            "aws-global": { description: "AWS Standard global region" },
            "ca-central-1": { description: "Canada (Central)" },
            "ca-west-1": { description: "Canada West (Calgary)" },
            "eu-central-1": { description: "Europe (Frankfurt)" },
            "eu-central-2": { description: "Europe (Zurich)" },
            "eu-north-1": { description: "Europe (Stockholm)" },
            "eu-south-1": { description: "Europe (Milan)" },
            "eu-south-2": { description: "Europe (Spain)" },
            "eu-west-1": { description: "Europe (Ireland)" },
            "eu-west-2": { description: "Europe (London)" },
            "eu-west-3": { description: "Europe (Paris)" },
            "il-central-1": { description: "Israel (Tel Aviv)" },
            "me-central-1": { description: "Middle East (UAE)" },
            "me-south-1": { description: "Middle East (Bahrain)" },
            "mx-central-1": { description: "Mexico (Central)" },
            "sa-east-1": { description: "South America (Sao Paulo)" },
            "us-east-1": { description: "US East (N. Virginia)" },
            "us-east-2": { description: "US East (Ohio)" },
            "us-west-1": { description: "US West (N. California)" },
            "us-west-2": { description: "US West (Oregon)" },
          },
        },
        {
          id: "aws-cn",
          outputs: {
            dnsSuffix: "amazonaws.com.cn",
            dualStackDnsSuffix: "api.amazonwebservices.com.cn",
            implicitGlobalRegion: "cn-northwest-1",
            name: "aws-cn",
            supportsDualStack: !0,
            supportsFIPS: !0,
          },
          regionRegex: "^cn\\-\\w+\\-\\d+$",
          regions: {
            "aws-cn-global": { description: "AWS China global region" },
            "cn-north-1": { description: "China (Beijing)" },
            "cn-northwest-1": { description: "China (Ningxia)" },
          },
        },
        {
          id: "aws-us-gov",
          outputs: {
            dnsSuffix: "amazonaws.com",
            dualStackDnsSuffix: "api.aws",
            implicitGlobalRegion: "us-gov-west-1",
            name: "aws-us-gov",
            supportsDualStack: !0,
            supportsFIPS: !0,
          },
          regionRegex: "^us\\-gov\\-\\w+\\-\\d+$",
          regions: {
            "aws-us-gov-global": {
              description: "AWS GovCloud (US) global region",
            },
            "us-gov-east-1": { description: "AWS GovCloud (US-East)" },
            "us-gov-west-1": { description: "AWS GovCloud (US-West)" },
          },
        },
        {
          id: "aws-iso",
          outputs: {
            dnsSuffix: "c2s.ic.gov",
            dualStackDnsSuffix: "c2s.ic.gov",
            implicitGlobalRegion: "us-iso-east-1",
            name: "aws-iso",
            supportsDualStack: !1,
            supportsFIPS: !0,
          },
          regionRegex: "^us\\-iso\\-\\w+\\-\\d+$",
          regions: {
            "aws-iso-global": { description: "AWS ISO (US) global region" },
            "us-iso-east-1": { description: "US ISO East" },
            "us-iso-west-1": { description: "US ISO WEST" },
          },
        },
        {
          id: "aws-iso-b",
          outputs: {
            dnsSuffix: "sc2s.sgov.gov",
            dualStackDnsSuffix: "sc2s.sgov.gov",
            implicitGlobalRegion: "us-isob-east-1",
            name: "aws-iso-b",
            supportsDualStack: !1,
            supportsFIPS: !0,
          },
          regionRegex: "^us\\-isob\\-\\w+\\-\\d+$",
          regions: {
            "aws-iso-b-global": { description: "AWS ISOB (US) global region" },
            "us-isob-east-1": { description: "US ISOB East (Ohio)" },
          },
        },
        {
          id: "aws-iso-e",
          outputs: {
            dnsSuffix: "cloud.adc-e.uk",
            dualStackDnsSuffix: "cloud.adc-e.uk",
            implicitGlobalRegion: "eu-isoe-west-1",
            name: "aws-iso-e",
            supportsDualStack: !1,
            supportsFIPS: !0,
          },
          regionRegex: "^eu\\-isoe\\-\\w+\\-\\d+$",
          regions: {
            "aws-iso-e-global": {
              description: "AWS ISOE (Europe) global region",
            },
            "eu-isoe-west-1": { description: "EU ISOE West" },
          },
        },
        {
          id: "aws-iso-f",
          outputs: {
            dnsSuffix: "csp.hci.ic.gov",
            dualStackDnsSuffix: "csp.hci.ic.gov",
            implicitGlobalRegion: "us-isof-south-1",
            name: "aws-iso-f",
            supportsDualStack: !1,
            supportsFIPS: !0,
          },
          regionRegex: "^us\\-isof\\-\\w+\\-\\d+$",
          regions: {
            "aws-iso-f-global": { description: "AWS ISOF global region" },
            "us-isof-east-1": { description: "US ISOF EAST" },
            "us-isof-south-1": { description: "US ISOF SOUTH" },
          },
        },
        {
          id: "aws-eusc",
          outputs: {
            dnsSuffix: "amazonaws.eu",
            dualStackDnsSuffix: "amazonaws.eu",
            implicitGlobalRegion: "eusc-de-east-1",
            name: "aws-eusc",
            supportsDualStack: !1,
            supportsFIPS: !0,
          },
          regionRegex: "^eusc\\-(de)\\-\\w+\\-\\d+$",
          regions: { "eusc-de-east-1": { description: "EU (Germany)" } },
        },
      ],
      version: "1.1",
    };
  });
var Dmt,
  Nmt,
  JTe,
  ZTe,
  IU = s(() => {
    QTe();
    (Dmt = XTe),
      (Nmt = ""),
      (JTe = (e) => {
        let { partitions: t } = Dmt;
        for (let o of t) {
          let { regions: n, outputs: i } = o;
          for (let [a, c] of Object.entries(n))
            if (a === e) return { ...i, ...c };
        }
        for (let o of t) {
          let { regionRegex: n, outputs: i } = o;
          if (new RegExp(n).test(e)) return { ...i };
        }
        let r = t.find((o) => o.id === "aws");
        if (!r)
          throw new Error(
            "Provided region was not found in the partition array or regex, and default partition with id 'aws' doesn't exist."
          );
        return { ...r.outputs };
      }),
      (ZTe = () => Nmt);
  });
var ty,
  eAe = s(() => {
    $t();
    VTe();
    YTe();
    IU();
    ty = { isVirtualHostableS3Bucket: RU, parseArn: KTe, partition: JTe };
    Jt.aws = ty;
  });
var tAe = s(() => {
  $t();
});
var rAe = s(() => {
  $t();
});
var oAe = s(() => {});
var nAe = s(() => {});
var sAe = s(() => {});
var iAe = s(() => {});
var aAe = s(() => {});
var cAe = s(() => {
  rAe();
  oAe();
  nAe();
  sAe();
  iAe();
  aAe();
});
var Cw = s(() => {
  eAe();
  IU();
  AU();
  tAe();
  cAe();
});
async function dAe(e, t, r) {
  if (
    (r.request?.headers?.["smithy-protocol"] === "rpc-v2-cbor" &&
      _e(e, "PROTOCOL_RPC_V2_CBOR", "M"),
    typeof t.retryStrategy == "function")
  ) {
    let i = await t.retryStrategy();
    typeof i.acquireInitialRetryToken == "function"
      ? i.constructor?.name?.includes("Adaptive")
        ? _e(e, "RETRY_MODE_ADAPTIVE", "F")
        : _e(e, "RETRY_MODE_STANDARD", "E")
      : _e(e, "RETRY_MODE_LEGACY", "D");
  }
  if (typeof t.accountIdEndpointMode == "function") {
    let i = e.endpointV2;
    switch (
      (String(i?.url?.hostname).match(Bmt) && _e(e, "ACCOUNT_ID_ENDPOINT", "O"),
      await t.accountIdEndpointMode?.())
    ) {
      case "disabled":
        _e(e, "ACCOUNT_ID_MODE_DISABLED", "Q");
        break;
      case "preferred":
        _e(e, "ACCOUNT_ID_MODE_PREFERRED", "P");
        break;
      case "required":
        _e(e, "ACCOUNT_ID_MODE_REQUIRED", "R");
        break;
    }
  }
  let n = e.__smithy_context?.selectedHttpAuthScheme?.identity;
  if (n?.$source) {
    let i = n;
    i.accountId && _e(e, "RESOLVED_ACCOUNT_ID", "T");
    for (let [a, c] of Object.entries(i.$source ?? {})) _e(e, a, c);
  }
}
var Bmt,
  mAe = s(() => {
    rt();
    Bmt = /\d{12}\.ddb/;
  });
var PU,
  bw,
  vU,
  _w,
  lAe,
  fAe,
  OU,
  uAe = s(() => {
    (PU = "user-agent"),
      (bw = "x-amz-user-agent"),
      (vU = " "),
      (_w = "/"),
      (lAe = /[^\!\$\%\&\'\*\+\-\.\^\_\`\|\~\d\w]/g),
      (fAe = /[^\!\$\%\&\'\*\+\-\.\^\_\`\|\~\d\w\#]/g),
      (OU = "-");
  });
function pAe(e) {
  let t = "";
  for (let r in e) {
    let o = e[r];
    if (t.length + o.length + 1 <= 1024) {
      t.length ? (t += "," + o) : (t += o);
      continue;
    }
    break;
  }
  return t;
}
var hAe = s(() => {});
var Mmt,
  ww,
  Lmt,
  Tw,
  gAe = s(() => {
    Cw();
    Cn();
    mAe();
    uAe();
    hAe();
    (Mmt = (e) => (t, r) => async (o) => {
      let { request: n } = o;
      if (!Ko.isInstance(n)) return t(o);
      let { headers: i } = n,
        a = r?.userAgent?.map(ww) || [],
        c = (await e.defaultUserAgentProvider()).map(ww);
      await dAe(r, e, o);
      let d = r;
      c.push(
        `m/${pAe(Object.assign({}, r.__smithy_context?.features, d.__aws_sdk_context?.features))}`
      );
      let m = e?.customUserAgent?.map(ww) || [],
        f = await e.userAgentAppId();
      f && c.push(ww([`app/${f}`]));
      let l = ZTe(),
        u = (l ? [l] : []).concat([...c, ...a, ...m]).join(vU),
        h = [...c.filter((y) => y.startsWith("aws-sdk-")), ...m].join(vU);
      return (
        e.runtime !== "browser"
          ? (h && (i[bw] = i[bw] ? `${i[PU]} ${h}` : h), (i[PU] = u))
          : (i[bw] = u),
        t({ ...o, request: n })
      );
    }),
      (ww = (e) => {
        let t = e[0]
            .split(_w)
            .map((a) => a.replace(lAe, OU))
            .join(_w),
          r = e[1]?.replace(fAe, OU),
          o = t.indexOf(_w),
          n = t.substring(0, o),
          i = t.substring(o + 1);
        return (
          n === "api" && (i = i.toLowerCase()),
          [n, i, r]
            .filter((a) => a && a.length > 0)
            .reduce((a, c, d) => {
              switch (d) {
                case 0:
                  return c;
                case 1:
                  return `${a}/${c}`;
                default:
                  return `${a}#${c}`;
              }
            }, "")
        );
      }),
      (Lmt = {
        name: "getUserAgentMiddleware",
        step: "build",
        priority: "low",
        tags: ["SET_USER_AGENT", "USER_AGENT"],
        override: !0,
      }),
      (Tw = (e) => ({
        applyToStack: (t) => {
          t.add(Mmt(e), Lmt);
        },
      }));
  });
var Aw = s(() => {
  GTe();
  gAe();
});
var Fmt,
  Umt,
  Rw,
  yAe = s(() => {
    Wn();
    (Fmt = "AWS_USE_DUALSTACK_ENDPOINT"),
      (Umt = "use_dualstack_endpoint"),
      (Rw = {
        environmentVariableSelector: (e) => Nt(e, Fmt, Tt.ENV),
        configFileSelector: (e) => Nt(e, Umt, Tt.CONFIG),
        default: !1,
      });
  });
var $mt,
  Hmt,
  Iw,
  xAe = s(() => {
    Wn();
    ($mt = "AWS_USE_FIPS_ENDPOINT"),
      (Hmt = "use_fips_endpoint"),
      (Iw = {
        environmentVariableSelector: (e) => Nt(e, $mt, Tt.ENV),
        configFileSelector: (e) => Nt(e, Hmt, Tt.CONFIG),
        default: !1,
      });
  });
var EAe = s(() => {
  ct();
});
var SAe = s(() => {});
var CAe = s(() => {
  ct();
  SAe();
});
var bAe = s(() => {
  yAe();
  xAe();
  EAe();
  CAe();
});
var zmt,
  qmt,
  Hf,
  Pw,
  _Ae = s(() => {
    (zmt = "AWS_REGION"),
      (qmt = "region"),
      (Hf = {
        environmentVariableSelector: (e) => e[zmt],
        configFileSelector: (e) => e[qmt],
        default: () => {
          throw new Error("Region is missing");
        },
      }),
      (Pw = { preferredFile: "credentials" });
  });
var vw,
  kU = s(() => {
    vw = (e) =>
      typeof e == "string" && (e.startsWith("fips-") || e.endsWith("-fips"));
  });
var DU,
  wAe = s(() => {
    kU();
    DU = (e) =>
      vw(e)
        ? ["fips-aws-global", "aws-fips"].includes(e)
          ? "us-east-1"
          : e.replace(/fips-(dkr-|prod-)?|-fips/, "")
        : e;
  });
var Ow,
  TAe = s(() => {
    wAe();
    kU();
    Ow = (e) => {
      let { region: t, useFipsEndpoint: r } = e;
      if (!t) throw new Error("Region is missing");
      return Object.assign(e, {
        region: async () => {
          if (typeof t == "string") return DU(t);
          let o = await t();
          return DU(o);
        },
        useFipsEndpoint: async () => {
          let o = typeof t == "string" ? t : await t();
          return vw(o)
            ? !0
            : typeof r != "function"
              ? Promise.resolve(!!r)
              : r();
        },
      });
    };
  });
var AAe = s(() => {
  _Ae();
  TAe();
});
var RAe = s(() => {});
var IAe = s(() => {});
var PAe = s(() => {});
var vAe = s(() => {});
var OAe = s(() => {});
var kAe = s(() => {});
var DAe = s(() => {
  PAe();
  vAe();
  OAe();
  kAe();
});
var NAe = s(() => {
  RAe();
  IAe();
  DAe();
});
var zf = s(() => {
  bAe();
  AAe();
  NAe();
});
function jmt(e) {
  return (t) => async (r) => {
    let o = r.request;
    if (Ko.isInstance(o)) {
      let { body: n, headers: i } = o;
      if (
        n &&
        Object.keys(i)
          .map((a) => a.toLowerCase())
          .indexOf(BAe) === -1
      )
        try {
          let a = e(n);
          o.headers = { ...o.headers, [BAe]: String(a) };
        } catch {}
    }
    return t({ ...r, request: o });
  };
}
var BAe,
  Gmt,
  kw,
  NU = s(() => {
    Cn();
    BAe = "content-length";
    (Gmt = {
      step: "build",
      tags: ["SET_CONTENT_LENGTH", "CONTENT_LENGTH"],
      name: "contentLengthMiddleware",
      override: !0,
    }),
      (kw = (e) => ({
        applyToStack: (t) => {
          t.add(jmt(e.bodyLengthChecker), Gmt);
        },
      }));
  });
var MAe,
  Vmt,
  Wmt,
  Kmt,
  Ymt,
  Qmt,
  LAe = s(() => {
    (MAe = async (e) => {
      let t = e?.Bucket || "";
      if (
        (typeof e.Bucket == "string" &&
          (e.Bucket = t
            .replace(/#/g, encodeURIComponent("#"))
            .replace(/\?/g, encodeURIComponent("?"))),
        Qmt(t))
      ) {
        if (e.ForcePathStyle === !0)
          throw new Error(
            "Path-style addressing cannot be used with ARN buckets"
          );
      } else
        (!Ymt(t) ||
          (t.indexOf(".") !== -1 && !String(e.Endpoint).startsWith("http:")) ||
          t.toLowerCase() !== t ||
          t.length < 3) &&
          (e.ForcePathStyle = !0);
      return (
        e.DisableMultiRegionAccessPoints &&
          ((e.disableMultiRegionAccessPoints = !0), (e.DisableMRAP = !0)),
        e
      );
    }),
      (Vmt = /^[a-z0-9][a-z0-9\.\-]{1,61}[a-z0-9]$/),
      (Wmt = /(\d+\.){3}\d+/),
      (Kmt = /\.\./),
      (Ymt = (e) => Vmt.test(e) && !Wmt.test(e) && !Kmt.test(e)),
      (Qmt = (e) => {
        let [t, r, o, , , n] = e.split(":"),
          i = t === "arn" && e.split(":").length >= 6,
          a = !!(i && r && o && n);
        if (i && !a) throw new Error(`Invalid ARN: ${e} was an invalid ARN.`);
        return a;
      });
  });
var FAe = s(() => {
  LAe();
});
var UAe,
  $Ae = s(() => {
    UAe = (e, t, r) => {
      let o = async () => {
        let n = r[e] ?? r[t];
        return typeof n == "function" ? n() : n;
      };
      return e === "credentialScope" || t === "CredentialScope"
        ? async () => {
            let n =
              typeof r.credentials == "function"
                ? await r.credentials()
                : r.credentials;
            return n?.credentialScope ?? n?.CredentialScope;
          }
        : e === "accountId" || t === "AccountId"
          ? async () => {
              let n =
                typeof r.credentials == "function"
                  ? await r.credentials()
                  : r.credentials;
              return n?.accountId ?? n?.AccountId;
            }
          : e === "endpoint" || t === "endpoint"
            ? async () => {
                let n = await o();
                if (n && typeof n == "object") {
                  if ("url" in n) return n.url.href;
                  if ("hostname" in n) {
                    let { protocol: i, hostname: a, port: c, path: d } = n;
                    return `${i}//${a}${c ? ":" + c : ""}${d}`;
                  }
                }
                return n;
              }
            : o;
    };
  });
function Dw(e) {
  try {
    let t = new Set(Array.from(e.match(/([A-Z_]){3,}/g) ?? []));
    return (
      t.delete("CONFIG"),
      t.delete("CONFIG_PREFIX_SEPARATOR"),
      t.delete("ENV"),
      [...t].join(", ")
    );
  } catch {
    return e;
  }
}
var BU = s(() => {});
var HAe,
  zAe = s(() => {
    re();
    BU();
    HAe = (e, t) => async () => {
      try {
        let r = e(process.env, t);
        if (r === void 0) throw new Error();
        return r;
      } catch (r) {
        throw new P(r.message || `Not found in ENV: ${Dw(e.toString())}`, {
          logger: t?.logger,
        });
      }
    };
  });
import { homedir as Xmt } from "os";
import { sep as Jmt } from "path";
var MU,
  Zmt,
  nc,
  qf = s(() => {
    (MU = {}),
      (Zmt = () =>
        process && process.geteuid ? `${process.geteuid()}` : "DEFAULT"),
      (nc = () => {
        let {
          HOME: e,
          USERPROFILE: t,
          HOMEPATH: r,
          HOMEDRIVE: o = `C:${Jmt}`,
        } = process.env;
        if (e) return e;
        if (t) return t;
        if (r) return `${o}${r}`;
        let n = Zmt();
        return MU[n] || (MU[n] = Xmt()), MU[n];
      });
  });
var LU,
  elt,
  os,
  qAe = s(() => {
    (LU = "AWS_PROFILE"),
      (elt = "default"),
      (os = (e) => e.profile || process.env[LU] || elt);
  });
import { createHash as tlt } from "crypto";
import { join as rlt } from "path";
var Nw,
  FU = s(() => {
    qf();
    Nw = (e) => {
      let r = tlt("sha1").update(e).digest("hex");
      return rlt(nc(), ".aws", "sso", "cache", `${r}.json`);
    };
  });
import { promises as olt } from "fs";
var nlt,
  Bw,
  jAe = s(() => {
    FU();
    ({ readFile: nlt } = olt),
      (Bw = async (e) => {
        let t = Nw(e),
          r = await nlt(t, "utf8");
        return JSON.parse(r);
      });
  });
var GAe,
  VAe = s(() => {
    Rd();
    jf();
    GAe = (e) =>
      Object.entries(e)
        .filter(([t]) => {
          let r = t.indexOf(ns);
          return r === -1 ? !1 : Object.values(oa).includes(t.substring(0, r));
        })
        .reduce(
          (t, [r, o]) => {
            let n = r.indexOf(ns),
              i = r.substring(0, n) === oa.PROFILE ? r.substring(n + 1) : r;
            return (t[i] = o), t;
          },
          { ...(e.default && { default: e.default }) }
        );
  });
import { join as slt } from "path";
var ilt,
  Mw,
  UU = s(() => {
    qf();
    (ilt = "AWS_CONFIG_FILE"),
      (Mw = () => process.env[ilt] || slt(nc(), ".aws", "config"));
  });
import { join as alt } from "path";
var clt,
  WAe,
  KAe = s(() => {
    qf();
    (clt = "AWS_SHARED_CREDENTIALS_FILE"),
      (WAe = () => process.env[clt] || alt(nc(), ".aws", "credentials"));
  });
var dlt,
  mlt,
  ry,
  $U = s(() => {
    Rd();
    jf();
    (dlt = /^([\w-]+)\s(["'])?([\w-@\+\.%:/]+)\2$/),
      (mlt = ["__proto__", "profile __proto__"]),
      (ry = (e) => {
        let t = {},
          r,
          o;
        for (let n of e.split(/\r?\n/)) {
          let i = n.split(/(^|\s)[;#]/)[0].trim();
          if (i[0] === "[" && i[i.length - 1] === "]") {
            (r = void 0), (o = void 0);
            let c = i.substring(1, i.length - 1),
              d = dlt.exec(c);
            if (d) {
              let [, m, , f] = d;
              Object.values(oa).includes(m) && (r = [m, f].join(ns));
            } else r = c;
            if (mlt.includes(c))
              throw new Error(`Found invalid profile name "${c}"`);
          } else if (r) {
            let c = i.indexOf("=");
            if (![0, -1].includes(c)) {
              let [d, m] = [
                i.substring(0, c).trim(),
                i.substring(c + 1).trim(),
              ];
              if (m === "") o = d;
              else {
                o && n.trimStart() === n && (o = void 0), (t[r] = t[r] || {});
                let f = o ? [o, d].join(ns) : d;
                t[r][f] = m;
              }
            }
          }
        }
        return t;
      });
  });
import { promises as llt } from "fs";
var flt,
  HU,
  oy,
  zU = s(() => {
    ({ readFile: flt } = llt),
      (HU = {}),
      (oy = (e, t) => (
        (!HU[e] || t?.ignoreCache) && (HU[e] = flt(e, "utf8")), HU[e]
      ));
  });
import { join as YAe } from "path";
var QAe,
  ns,
  Lw,
  jf = s(() => {
    VAe();
    UU();
    KAe();
    qf();
    $U();
    zU();
    (QAe = () => ({})),
      (ns = "."),
      (Lw = async (e = {}) => {
        let { filepath: t = WAe(), configFilepath: r = Mw() } = e,
          o = nc(),
          n = "~/",
          i = t;
        t.startsWith(n) && (i = YAe(o, t.slice(2)));
        let a = r;
        r.startsWith(n) && (a = YAe(o, r.slice(2)));
        let c = await Promise.all([
          oy(a, { ignoreCache: e.ignoreCache }).then(ry).then(GAe).catch(QAe),
          oy(i, { ignoreCache: e.ignoreCache }).then(ry).catch(QAe),
        ]);
        return { configFile: c[0], credentialsFile: c[1] };
      });
  });
var XAe,
  JAe = s(() => {
    Rd();
    jf();
    XAe = (e) =>
      Object.entries(e)
        .filter(([t]) => t.startsWith(oa.SSO_SESSION + ns))
        .reduce(
          (t, [r, o]) => ({ ...t, [r.substring(r.indexOf(ns) + 1)]: o }),
          {}
        );
  });
var ult,
  Fw,
  ZAe = s(() => {
    UU();
    JAe();
    $U();
    zU();
    (ult = () => ({})),
      (Fw = async (e = {}) =>
        oy(e.configFilepath ?? Mw())
          .then(ry)
          .then(XAe)
          .catch(ult));
  });
var eRe,
  tRe = s(() => {
    eRe = (...e) => {
      let t = {};
      for (let r of e)
        for (let [o, n] of Object.entries(r))
          t[o] !== void 0 ? Object.assign(t[o], n) : (t[o] = n);
      return t;
    };
  });
var sc,
  rRe = s(() => {
    jf();
    tRe();
    sc = async (e) => {
      let t = await Lw(e);
      return eRe(t.configFile, t.credentialsFile);
    };
  });
var oRe = s(() => {});
var qs = s(() => {
  qf();
  qAe();
  FU();
  jAe();
  jf();
  ZAe();
  rRe();
  oRe();
});
var nRe,
  sRe = s(() => {
    re();
    qs();
    BU();
    nRe =
      (e, { preferredFile: t = "config", ...r } = {}) =>
      async () => {
        let o = os(r),
          { configFile: n, credentialsFile: i } = await Lw(r),
          a = i[o] || {},
          c = n[o] || {},
          d = t === "config" ? { ...a, ...c } : { ...c, ...a };
        try {
          let f = e(d, t === "config" ? n : i);
          if (f === void 0) throw new Error();
          return f;
        } catch (m) {
          throw new P(
            m.message ||
              `Not found in config files w/ profile [${o}]: ${Dw(e.toString())}`,
            { logger: r.logger }
          );
        }
      };
  });
var plt,
  iRe,
  aRe = s(() => {
    re();
    (plt = (e) => typeof e == "function"),
      (iRe = (e) => (plt(e) ? async () => await e() : Ra(e)));
  });
var lr,
  cRe = s(() => {
    re();
    zAe();
    sRe();
    aRe();
    lr = (
      { environmentVariableSelector: e, configFileSelector: t, default: r },
      o = {}
    ) => {
      let { signingName: n, logger: i } = o;
      return gr(Ht(HAe(e, { signingName: n, logger: i }), nRe(t, o), iRe(r)));
    };
  });
var Id = s(() => {
  cRe();
});
var dRe,
  mRe,
  lRe,
  fRe = s(() => {
    qs();
    (dRe = "AWS_ENDPOINT_URL"),
      (mRe = "endpoint_url"),
      (lRe = (e) => ({
        environmentVariableSelector: (t) => {
          let r = e.split(" ").map((i) => i.toUpperCase()),
            o = t[[dRe, ...r].join("_")];
          if (o) return o;
          let n = t[dRe];
          if (n) return n;
        },
        configFileSelector: (t, r) => {
          if (r && t.services) {
            let n = r[["services", t.services].join(ns)];
            if (n) {
              let i = e.split(" ").map((c) => c.toLowerCase()),
                a = n[[i.join("_"), mRe].join(ns)];
              if (a) return a;
            }
          }
          let o = t[mRe];
          if (o) return o;
        },
        default: void 0,
      }));
  });
var Uw,
  qU = s(() => {
    Id();
    fRe();
    Uw = async (e) => lr(lRe(e ?? ""))();
  });
function uRe(e) {
  let t = {};
  if (((e = e.replace(/^\?/, "")), e))
    for (let r of e.split("&")) {
      let [o, n = null] = r.split("=");
      (o = decodeURIComponent(o)),
        n && (n = decodeURIComponent(n)),
        o in t
          ? Array.isArray(t[o])
            ? t[o].push(n)
            : (t[o] = [t[o], n])
          : (t[o] = n);
    }
  return t;
}
var pRe = s(() => {});
var Si,
  ny = s(() => {
    pRe();
    Si = (e) => {
      if (typeof e == "string") return Si(new URL(e));
      let { hostname: t, pathname: r, port: o, protocol: n, search: i } = e,
        a;
      return (
        i && (a = uRe(i)),
        {
          hostname: t,
          port: o ? parseInt(o) : void 0,
          protocol: n,
          path: r,
          query: a,
        }
      );
    };
  });
var $w,
  Hw = s(() => {
    ny();
    $w = (e) => (typeof e == "object" ? ("url" in e ? Si(e.url) : e) : Si(e));
  });
var hRe,
  hlt,
  jU = s(() => {
    FAe();
    $Ae();
    qU();
    Hw();
    (hRe = async (e, t, r, o) => {
      if (!r.endpoint) {
        let a;
        r.serviceConfiguredEndpoint
          ? (a = await r.serviceConfiguredEndpoint())
          : (a = await Uw(r.serviceId)),
          a && (r.endpoint = () => Promise.resolve($w(a)));
      }
      let n = await hlt(e, t, r);
      if (typeof r.endpointProvider != "function")
        throw new Error("config.endpointProvider is not set.");
      return r.endpointProvider(n, o);
    }),
      (hlt = async (e, t, r) => {
        let o = {},
          n = t?.getEndpointParameterInstructions?.() || {};
        for (let [i, a] of Object.entries(n))
          switch (a.type) {
            case "staticContextParams":
              o[i] = a.value;
              break;
            case "contextParams":
              o[i] = e[a.name];
              break;
            case "clientContextParams":
            case "builtInParams":
              o[i] = await UAe(a.name, i, r)();
              break;
            case "operationContextParams":
              o[i] = a.get(e);
              break;
            default:
              throw new Error(
                "Unrecognized endpoint parameter instruction: " +
                  JSON.stringify(a)
              );
          }
        return (
          Object.keys(n).length === 0 && Object.assign(o, r),
          String(r.serviceId).toLowerCase() === "s3" && (await MAe(o)),
          o
        );
      });
  });
var gRe = s(() => {
  jU();
  Hw();
});
var yRe,
  GU = s(() => {
    Ue();
    ct();
    jU();
    yRe =
      ({ config: e, instructions: t }) =>
      (r, o) =>
      async (n) => {
        e.endpoint && Ta(o, "ENDPOINT_OVERRIDE", "N");
        let i = await hRe(
          n.input,
          {
            getEndpointParameterInstructions() {
              return t;
            },
          },
          { ...e },
          o
        );
        (o.endpointV2 = i), (o.authSchemes = i.properties?.authSchemes);
        let a = o.authSchemes?.[0];
        if (a) {
          (o.signing_region = a.signingRegion),
            (o.signing_service = a.signingName);
          let d = bt(o)?.selectedHttpAuthScheme?.httpAuthOption;
          d &&
            (d.signingProperties = Object.assign(
              d.signingProperties || {},
              {
                signing_region: a.signingRegion,
                signingRegion: a.signingRegion,
                signing_service: a.signingName,
                signingName: a.signingName,
                signingRegionSet: a.signingRegionSet,
              },
              a.properties
            ));
        }
        return r({ ...n });
      };
  });
var xRe,
  VU,
  WU = s(() => {
    Cn();
    (xRe = (e, t) => (r, o) => async (n) => {
      let { response: i } = await r(n);
      try {
        let a = await t(i, e);
        return { response: i, output: a };
      } catch (a) {
        if (
          (Object.defineProperty(a, "$response", { value: i }),
          !("$metadata" in a))
        ) {
          let c =
            "Deserialization error: to see the raw response, inspect the hidden field {error}.$response on this object.";
          try {
            a.message +=
              `
  ` + c;
          } catch {
            !o.logger || o.logger?.constructor?.name === "NoOpLogger"
              ? console.warn(c)
              : o.logger?.warn?.(c);
          }
          typeof a.$responseBodyText < "u" &&
            a.$response &&
            (a.$response.body = a.$responseBodyText);
          try {
            if (Ei.isInstance(i)) {
              let { headers: d = {} } = i,
                m = Object.entries(d);
              a.$metadata = {
                httpStatusCode: i.statusCode,
                requestId: VU(/^x-[\w-]+-request-?id$/, m),
                extendedRequestId: VU(/^x-[\w-]+-id-2$/, m),
                cfId: VU(/^x-[\w-]+-cf-id$/, m),
              };
            }
          } catch {}
        }
        throw a;
      }
    }),
      (VU = (e, t) => (t.find(([r]) => r.match(e)) || [void 0, void 0])[1]);
  });
var ERe,
  KU = s(() => {
    ERe = (e, t) => (r, o) => async (n) => {
      let i = e,
        a =
          o.endpointV2?.url && i.urlParser
            ? async () => i.urlParser(o.endpointV2.url)
            : i.endpoint;
      if (!a) throw new Error("No valid endpoint provider available.");
      let c = await t(n.input, { ...e, endpoint: a });
      return r({ ...n, request: c });
    };
  });
function Pe(e, t, r) {
  return {
    applyToStack: (o) => {
      o.add(xRe(e, r), glt), o.add(ERe(e, t), YU);
    },
  };
}
var glt,
  YU,
  SRe = s(() => {
    WU();
    KU();
    (glt = {
      name: "deserializerMiddleware",
      step: "deserialize",
      tags: ["DESERIALIZER"],
      override: !0,
    }),
      (YU = {
        name: "serializerMiddleware",
        step: "serialize",
        tags: ["SERIALIZER"],
        override: !0,
      });
  });
var zt = s(() => {
  WU();
  SRe();
  KU();
});
var ylt,
  ve,
  CRe = s(() => {
    zt();
    GU();
    (ylt = {
      step: "serialize",
      tags: ["ENDPOINT_PARAMETERS", "ENDPOINT_V2", "ENDPOINT"],
      name: "endpointV2Middleware",
      override: !0,
      relation: "before",
      toMiddleware: YU.name,
    }),
      (ve = (e, t) => ({
        applyToStack: (r) => {
          r.addRelativeTo(yRe({ config: e, instructions: t }), ylt);
        },
      }));
  });
var zw,
  bRe = s(() => {
    ct();
    qU();
    Hw();
    zw = (e) => {
      let t = e.tls ?? !0,
        { endpoint: r, useDualstackEndpoint: o, useFipsEndpoint: n } = e,
        i = r != null ? async () => $w(await pe(r)()) : void 0,
        c = Object.assign(e, {
          endpoint: i,
          tls: t,
          isCustomEndpoint: !!r,
          useDualstackEndpoint: pe(o ?? !1),
          useFipsEndpoint: pe(n ?? !1),
        }),
        d;
      return (
        (c.serviceConfiguredEndpoint = async () => (
          e.serviceId && !d && (d = Uw(e.serviceId)), d
        )),
        c
      );
    };
  });
var _Re = s(() => {});
var wRe = s(() => {});
var Lt = s(() => {
  gRe();
  GU();
  CRe();
  bRe();
  _Re();
  wRe();
});
var js,
  Pd,
  Gf,
  qw = s(() => {
    (function (e) {
      (e.STANDARD = "standard"), (e.ADAPTIVE = "adaptive");
    })(js || (js = {}));
    (Pd = 3), (Gf = js.STANDARD);
  });
var TRe,
  ARe,
  RRe,
  IRe,
  PRe,
  vRe = s(() => {
    (TRe = [
      "BandwidthLimitExceeded",
      "EC2ThrottledException",
      "LimitExceededException",
      "PriorRequestNotComplete",
      "ProvisionedThroughputExceededException",
      "RequestLimitExceeded",
      "RequestThrottled",
      "RequestThrottledException",
      "SlowDown",
      "ThrottledException",
      "Throttling",
      "ThrottlingException",
      "TooManyRequestsException",
      "TransactionInProgressException",
    ]),
      (ARe = ["TimeoutError", "RequestTimeout", "RequestTimeoutException"]),
      (RRe = [500, 502, 503, 504]),
      (IRe = ["ECONNRESET", "ECONNREFUSED", "EPIPE", "ETIMEDOUT"]),
      (PRe = ["EHOSTUNREACH", "ENETUNREACH", "ENOTFOUND"]);
  });
var xlt,
  Elt,
  Vf,
  sy,
  ORe,
  iy = s(() => {
    vRe();
    (xlt = (e) => e.$metadata?.clockSkewCorrected),
      (Elt = (e) => {
        let t = new Set([
          "Failed to fetch",
          "NetworkError when attempting to fetch resource",
          "The Internet connection appears to be offline",
          "Load failed",
          "Network request failed",
        ]);
        return e && e instanceof TypeError ? t.has(e.message) : !1;
      }),
      (Vf = (e) =>
        e.$metadata?.httpStatusCode === 429 ||
        TRe.includes(e.name) ||
        e.$retryable?.throttling == !0),
      (sy = (e, t = 0) =>
        xlt(e) ||
        ARe.includes(e.name) ||
        IRe.includes(e?.code || "") ||
        PRe.includes(e?.code || "") ||
        RRe.includes(e.$metadata?.httpStatusCode || 0) ||
        Elt(e) ||
        (e.cause !== void 0 && t <= 10 && sy(e.cause, t + 1))),
      (ORe = (e) => {
        if (e.$metadata?.httpStatusCode !== void 0) {
          let t = e.$metadata.httpStatusCode;
          return 500 <= t && t <= 599 && !sy(e);
        }
        return !1;
      });
  });
var Wf,
  QU = s(() => {
    iy();
    Wf = class e {
      constructor(t) {
        (this.currentCapacity = 0),
          (this.enabled = !1),
          (this.lastMaxRate = 0),
          (this.measuredTxRate = 0),
          (this.requestCount = 0),
          (this.lastTimestamp = 0),
          (this.timeWindow = 0),
          (this.beta = t?.beta ?? 0.7),
          (this.minCapacity = t?.minCapacity ?? 1),
          (this.minFillRate = t?.minFillRate ?? 0.5),
          (this.scaleConstant = t?.scaleConstant ?? 0.4),
          (this.smooth = t?.smooth ?? 0.8);
        let r = this.getCurrentTimeInSeconds();
        (this.lastThrottleTime = r),
          (this.lastTxRateBucket = Math.floor(this.getCurrentTimeInSeconds())),
          (this.fillRate = this.minFillRate),
          (this.maxCapacity = this.minCapacity);
      }
      getCurrentTimeInSeconds() {
        return Date.now() / 1e3;
      }
      async getSendToken() {
        return this.acquireTokenBucket(1);
      }
      async acquireTokenBucket(t) {
        if (this.enabled) {
          if ((this.refillTokenBucket(), t > this.currentCapacity)) {
            let r = ((t - this.currentCapacity) / this.fillRate) * 1e3;
            await new Promise((o) => e.setTimeoutFn(o, r));
          }
          this.currentCapacity = this.currentCapacity - t;
        }
      }
      refillTokenBucket() {
        let t = this.getCurrentTimeInSeconds();
        if (!this.lastTimestamp) {
          this.lastTimestamp = t;
          return;
        }
        let r = (t - this.lastTimestamp) * this.fillRate;
        (this.currentCapacity = Math.min(
          this.maxCapacity,
          this.currentCapacity + r
        )),
          (this.lastTimestamp = t);
      }
      updateClientSendingRate(t) {
        let r;
        if ((this.updateMeasuredRate(), Vf(t))) {
          let n = this.enabled
            ? Math.min(this.measuredTxRate, this.fillRate)
            : this.measuredTxRate;
          (this.lastMaxRate = n),
            this.calculateTimeWindow(),
            (this.lastThrottleTime = this.getCurrentTimeInSeconds()),
            (r = this.cubicThrottle(n)),
            this.enableTokenBucket();
        } else
          this.calculateTimeWindow(),
            (r = this.cubicSuccess(this.getCurrentTimeInSeconds()));
        let o = Math.min(r, 2 * this.measuredTxRate);
        this.updateTokenBucketRate(o);
      }
      calculateTimeWindow() {
        this.timeWindow = this.getPrecise(
          Math.pow(
            (this.lastMaxRate * (1 - this.beta)) / this.scaleConstant,
            1 / 3
          )
        );
      }
      cubicThrottle(t) {
        return this.getPrecise(t * this.beta);
      }
      cubicSuccess(t) {
        return this.getPrecise(
          this.scaleConstant *
            Math.pow(t - this.lastThrottleTime - this.timeWindow, 3) +
            this.lastMaxRate
        );
      }
      enableTokenBucket() {
        this.enabled = !0;
      }
      updateTokenBucketRate(t) {
        this.refillTokenBucket(),
          (this.fillRate = Math.max(t, this.minFillRate)),
          (this.maxCapacity = Math.max(t, this.minCapacity)),
          (this.currentCapacity = Math.min(
            this.currentCapacity,
            this.maxCapacity
          ));
      }
      updateMeasuredRate() {
        let t = this.getCurrentTimeInSeconds(),
          r = Math.floor(t * 2) / 2;
        if ((this.requestCount++, r > this.lastTxRateBucket)) {
          let o = this.requestCount / (r - this.lastTxRateBucket);
          (this.measuredTxRate = this.getPrecise(
            o * this.smooth + this.measuredTxRate * (1 - this.smooth)
          )),
            (this.requestCount = 0),
            (this.lastTxRateBucket = r);
        }
      }
      getPrecise(t) {
        return parseFloat(t.toFixed(8));
      }
    };
    Wf.setTimeoutFn = setTimeout;
  });
var jw,
  Gw,
  Kf = s(() => {
    (jw = "amz-sdk-invocation-id"), (Gw = "amz-sdk-request");
  });
var kRe,
  DRe = s(() => {
    Kf();
    kRe = () => {
      let e = 100;
      return {
        computeNextBackoffDelay: (o) =>
          Math.floor(Math.min(2e4, Math.random() * 2 ** o * e)),
        setDelayBase: (o) => {
          e = o;
        },
      };
    };
  });
var XU,
  NRe = s(() => {
    Kf();
    XU = ({ retryDelay: e, retryCount: t, retryCost: r }) => ({
      getRetryCount: () => t,
      getRetryDelay: () => Math.min(2e4, e),
      getRetryCost: () => r,
    });
  });
var vd,
  Ww = s(() => {
    qw();
    Kf();
    DRe();
    NRe();
    vd = class {
      constructor(t) {
        (this.maxAttempts = t),
          (this.mode = js.STANDARD),
          (this.capacity = 500),
          (this.retryBackoffStrategy = kRe()),
          (this.maxAttemptsProvider =
            typeof t == "function" ? t : async () => t);
      }
      async acquireInitialRetryToken(t) {
        return XU({ retryDelay: 100, retryCount: 0 });
      }
      async refreshRetryTokenForRetry(t, r) {
        let o = await this.getMaxAttempts();
        if (this.shouldRetry(t, r, o)) {
          let n = r.errorType;
          this.retryBackoffStrategy.setDelayBase(
            n === "THROTTLING" ? 500 : 100
          );
          let i = this.retryBackoffStrategy.computeNextBackoffDelay(
              t.getRetryCount()
            ),
            a = r.retryAfterHint
              ? Math.max(r.retryAfterHint.getTime() - Date.now() || 0, i)
              : i,
            c = this.getCapacityCost(n);
          return (
            (this.capacity -= c),
            XU({
              retryDelay: a,
              retryCount: t.getRetryCount() + 1,
              retryCost: c,
            })
          );
        }
        throw new Error("No retry token available");
      }
      recordSuccess(t) {
        this.capacity = Math.max(500, this.capacity + (t.getRetryCost() ?? 1));
      }
      getCapacity() {
        return this.capacity;
      }
      async getMaxAttempts() {
        try {
          return await this.maxAttemptsProvider();
        } catch {
          return (
            console.warn(
              `Max attempts provider could not resolve. Using default of ${Pd}`
            ),
            Pd
          );
        }
      }
      shouldRetry(t, r, o) {
        return (
          t.getRetryCount() + 1 < o &&
          this.capacity >= this.getCapacityCost(r.errorType) &&
          this.isRetryableError(r.errorType)
        );
      }
      getCapacityCost(t) {
        return t === "TRANSIENT" ? 10 : 5;
      }
      isRetryableError(t) {
        return t === "THROTTLING" || t === "TRANSIENT";
      }
    };
  });
var Kw,
  URe = s(() => {
    qw();
    QU();
    Ww();
    Kw = class {
      constructor(t, r) {
        (this.maxAttemptsProvider = t), (this.mode = js.ADAPTIVE);
        let { rateLimiter: o } = r ?? {};
        (this.rateLimiter = o ?? new Wf()),
          (this.standardRetryStrategy = new vd(t));
      }
      async acquireInitialRetryToken(t) {
        return (
          await this.rateLimiter.getSendToken(),
          this.standardRetryStrategy.acquireInitialRetryToken(t)
        );
      }
      async refreshRetryTokenForRetry(t, r) {
        return (
          this.rateLimiter.updateClientSendingRate(r),
          this.standardRetryStrategy.refreshRetryTokenForRetry(t, r)
        );
      }
      recordSuccess(t) {
        this.rateLimiter.updateClientSendingRate({}),
          this.standardRetryStrategy.recordSuccess(t);
      }
    };
  });
var $Re = s(() => {
  Kf();
  Ww();
});
var HRe = s(() => {});
var Ci = s(() => {
  URe();
  $Re();
  QU();
  Ww();
  qw();
  Kf();
  HRe();
});
var zRe = s(() => {
  Ci();
});
var ZU = s(() => {
  Ci();
});
var e$ = s(() => {
  iy();
});
var t$,
  r$ = s(() => {
    t$ = (e) =>
      e instanceof Error
        ? e
        : e instanceof Object
          ? Object.assign(new Error(), e)
          : typeof e == "string"
            ? new Error(e)
            : new Error(`AWS SDK error wrapper for ${e}`);
  });
var o$ = s(() => {
  Cn();
  iy();
  Ci();
  zRe();
  ZU();
  e$();
  r$();
});
var qRe = s(() => {
  Ci();
  o$();
});
var jRe,
  GRe,
  Yw,
  Qw,
  Slt,
  Clt,
  Xw,
  VRe = s(() => {
    ct();
    Ci();
    (jRe = "AWS_MAX_ATTEMPTS"),
      (GRe = "max_attempts"),
      (Yw = {
        environmentVariableSelector: (e) => {
          let t = e[jRe];
          if (!t) return;
          let r = parseInt(t);
          if (Number.isNaN(r))
            throw new Error(
              `Environment variable ${jRe} mast be a number, got "${t}"`
            );
          return r;
        },
        configFileSelector: (e) => {
          let t = e[GRe];
          if (!t) return;
          let r = parseInt(t);
          if (Number.isNaN(r))
            throw new Error(
              `Shared config file entry ${GRe} mast be a number, got "${t}"`
            );
          return r;
        },
        default: Pd,
      }),
      (Qw = (e) => {
        let { retryStrategy: t, retryMode: r, maxAttempts: o } = e,
          n = pe(o ?? Pd);
        return Object.assign(e, {
          maxAttempts: n,
          retryStrategy: async () =>
            t || ((await pe(r)()) === js.ADAPTIVE ? new Kw(n) : new vd(n)),
        });
      }),
      (Slt = "AWS_RETRY_MODE"),
      (Clt = "retry_mode"),
      (Xw = {
        environmentVariableSelector: (e) => e[Slt],
        configFileSelector: (e) => e[Clt],
        default: Gf,
      });
  });
var WRe = s(() => {
  Cn();
  Ci();
});
var Od,
  ic,
  Qf,
  KRe,
  YRe,
  QRe = s(() => {
    (Od = (e, t) => {
      let r = [];
      if ((e && r.push(e), t)) for (let o of t) r.push(o);
      return r;
    }),
      (ic = (e, t) =>
        `${e || "anonymous"}${t && t.length > 0 ? ` (a.k.a. ${t.join(",")})` : ""}`),
      (Qf = () => {
        let e = [],
          t = [],
          r = !1,
          o = new Set(),
          n = (l) =>
            l.sort(
              (u, h) =>
                KRe[h.step] - KRe[u.step] ||
                YRe[h.priority || "normal"] - YRe[u.priority || "normal"]
            ),
          i = (l) => {
            let u = !1,
              h = (y) => {
                let S = Od(y.name, y.aliases);
                if (S.includes(l)) {
                  u = !0;
                  for (let E of S) o.delete(E);
                  return !1;
                }
                return !0;
              };
            return (e = e.filter(h)), (t = t.filter(h)), u;
          },
          a = (l) => {
            let u = !1,
              h = (y) => {
                if (y.middleware === l) {
                  u = !0;
                  for (let S of Od(y.name, y.aliases)) o.delete(S);
                  return !1;
                }
                return !0;
              };
            return (e = e.filter(h)), (t = t.filter(h)), u;
          },
          c = (l) => (
            e.forEach((u) => {
              l.add(u.middleware, { ...u });
            }),
            t.forEach((u) => {
              l.addRelativeTo(u.middleware, { ...u });
            }),
            l.identifyOnResolve?.(f.identifyOnResolve()),
            l
          ),
          d = (l) => {
            let u = [];
            return (
              l.before.forEach((h) => {
                h.before.length === 0 && h.after.length === 0
                  ? u.push(h)
                  : u.push(...d(h));
              }),
              u.push(l),
              l.after.reverse().forEach((h) => {
                h.before.length === 0 && h.after.length === 0
                  ? u.push(h)
                  : u.push(...d(h));
              }),
              u
            );
          },
          m = (l = !1) => {
            let u = [],
              h = [],
              y = {};
            return (
              e.forEach((E) => {
                let b = { ...E, before: [], after: [] };
                for (let v of Od(b.name, b.aliases)) y[v] = b;
                u.push(b);
              }),
              t.forEach((E) => {
                let b = { ...E, before: [], after: [] };
                for (let v of Od(b.name, b.aliases)) y[v] = b;
                h.push(b);
              }),
              h.forEach((E) => {
                if (E.toMiddleware) {
                  let b = y[E.toMiddleware];
                  if (b === void 0) {
                    if (l) return;
                    throw new Error(
                      `${E.toMiddleware} is not found when adding ${ic(E.name, E.aliases)} middleware ${E.relation} ${E.toMiddleware}`
                    );
                  }
                  E.relation === "after" && b.after.push(E),
                    E.relation === "before" && b.before.push(E);
                }
              }),
              n(u)
                .map(d)
                .reduce((E, b) => (E.push(...b), E), [])
            );
          },
          f = {
            add: (l, u = {}) => {
              let { name: h, override: y, aliases: S } = u,
                E = {
                  step: "initialize",
                  priority: "normal",
                  middleware: l,
                  ...u,
                },
                b = Od(h, S);
              if (b.length > 0) {
                if (b.some((v) => o.has(v))) {
                  if (!y)
                    throw new Error(`Duplicate middleware name '${ic(h, S)}'`);
                  for (let v of b) {
                    let I = e.findIndex(
                      (ge) =>
                        ge.name === v || ge.aliases?.some((Fe) => Fe === v)
                    );
                    if (I === -1) continue;
                    let O = e[I];
                    if (O.step !== E.step || E.priority !== O.priority)
                      throw new Error(
                        `"${ic(O.name, O.aliases)}" middleware with ${O.priority} priority in ${O.step} step cannot be overridden by "${ic(h, S)}" middleware with ${E.priority} priority in ${E.step} step.`
                      );
                    e.splice(I, 1);
                  }
                }
                for (let v of b) o.add(v);
              }
              e.push(E);
            },
            addRelativeTo: (l, u) => {
              let { name: h, override: y, aliases: S } = u,
                E = { middleware: l, ...u },
                b = Od(h, S);
              if (b.length > 0) {
                if (b.some((v) => o.has(v))) {
                  if (!y)
                    throw new Error(`Duplicate middleware name '${ic(h, S)}'`);
                  for (let v of b) {
                    let I = t.findIndex(
                      (ge) =>
                        ge.name === v || ge.aliases?.some((Fe) => Fe === v)
                    );
                    if (I === -1) continue;
                    let O = t[I];
                    if (
                      O.toMiddleware !== E.toMiddleware ||
                      O.relation !== E.relation
                    )
                      throw new Error(
                        `"${ic(O.name, O.aliases)}" middleware ${O.relation} "${O.toMiddleware}" middleware cannot be overridden by "${ic(h, S)}" middleware ${E.relation} "${E.toMiddleware}" middleware.`
                      );
                    t.splice(I, 1);
                  }
                }
                for (let v of b) o.add(v);
              }
              t.push(E);
            },
            clone: () => c(Qf()),
            use: (l) => {
              l.applyToStack(f);
            },
            remove: (l) => (typeof l == "string" ? i(l) : a(l)),
            removeByTag: (l) => {
              let u = !1,
                h = (y) => {
                  let { tags: S, name: E, aliases: b } = y;
                  if (S && S.includes(l)) {
                    let v = Od(E, b);
                    for (let I of v) o.delete(I);
                    return (u = !0), !1;
                  }
                  return !0;
                };
              return (e = e.filter(h)), (t = t.filter(h)), u;
            },
            concat: (l) => {
              let u = c(Qf());
              return (
                u.use(l),
                u.identifyOnResolve(
                  r || u.identifyOnResolve() || (l.identifyOnResolve?.() ?? !1)
                ),
                u
              );
            },
            applyToStack: c,
            identify: () =>
              m(!0).map((l) => {
                let u = l.step ?? l.relation + " " + l.toMiddleware;
                return ic(l.name, l.aliases) + " - " + u;
              }),
            identifyOnResolve(l) {
              return typeof l == "boolean" && (r = l), r;
            },
            resolve: (l, u) => {
              for (let h of m()
                .map((y) => y.middleware)
                .reverse())
                l = h(l, u);
              return r && console.log(f.identify()), l;
            },
          };
        return f;
      }),
      (KRe = {
        initialize: 5,
        serialize: 4,
        build: 3,
        finalizeRequest: 2,
        deserialize: 1,
      }),
      (YRe = { high: 3, normal: 2, low: 1 });
  });
var n$ = s(() => {
  QRe();
});
var Xf,
  XRe = s(() => {
    n$();
    Xf = class {
      constructor(t) {
        (this.config = t), (this.middlewareStack = Qf());
      }
      send(t, r, o) {
        let n = typeof r != "function" ? r : void 0,
          i = typeof r == "function" ? r : o,
          a = n === void 0 && this.config.cacheMiddleware === !0,
          c;
        if (a) {
          this.handlers || (this.handlers = new WeakMap());
          let d = this.handlers;
          d.has(t.constructor)
            ? (c = d.get(t.constructor))
            : ((c = t.resolveMiddleware(this.middlewareStack, this.config, n)),
              d.set(t.constructor, c));
        } else
          delete this.handlers,
            (c = t.resolveMiddleware(this.middlewareStack, this.config, n));
        if (i)
          c(t)
            .then(
              (d) => i(null, d.output),
              (d) => i(d)
            )
            .catch(() => {});
        else return c(t).then((d) => d.output);
      }
      destroy() {
        this.config?.requestHandler?.destroy?.(), delete this.handlers;
      }
    };
  });
var JRe = s(() => {
  Dt();
});
var Ie,
  s$,
  ZRe = s(() => {
    n$();
    Rd();
    (Ie = class {
      constructor() {
        this.middlewareStack = Qf();
      }
      static classBuilder() {
        return new s$();
      }
      resolveMiddlewareWithContext(
        t,
        r,
        o,
        {
          middlewareFn: n,
          clientName: i,
          commandName: a,
          inputFilterSensitiveLog: c,
          outputFilterSensitiveLog: d,
          smithyContext: m,
          additionalContext: f,
          CommandCtor: l,
        }
      ) {
        for (let E of n.bind(this)(l, t, r, o)) this.middlewareStack.use(E);
        let u = t.concat(this.middlewareStack),
          { logger: h } = r,
          y = {
            logger: h,
            clientName: i,
            commandName: a,
            inputFilterSensitiveLog: c,
            outputFilterSensitiveLog: d,
            [x_e]: { commandInstance: this, ...m },
            ...f,
          },
          { requestHandler: S } = r;
        return u.resolve((E) => S.handle(E.request, o || {}), y);
      }
    }),
      (s$ = class {
        constructor() {
          (this._init = () => {}),
            (this._ep = {}),
            (this._middlewareFn = () => []),
            (this._commandName = ""),
            (this._clientName = ""),
            (this._additionalContext = {}),
            (this._smithyContext = {}),
            (this._inputFilterSensitiveLog = (t) => t),
            (this._outputFilterSensitiveLog = (t) => t),
            (this._serializer = null),
            (this._deserializer = null);
        }
        init(t) {
          this._init = t;
        }
        ep(t) {
          return (this._ep = t), this;
        }
        m(t) {
          return (this._middlewareFn = t), this;
        }
        s(t, r, o = {}) {
          return (
            (this._smithyContext = { service: t, operation: r, ...o }), this
          );
        }
        c(t = {}) {
          return (this._additionalContext = t), this;
        }
        n(t, r) {
          return (this._clientName = t), (this._commandName = r), this;
        }
        f(t = (o) => o, r = (o) => o) {
          return (
            (this._inputFilterSensitiveLog = t),
            (this._outputFilterSensitiveLog = r),
            this
          );
        }
        ser(t) {
          return (this._serializer = t), this;
        }
        de(t) {
          return (this._deserializer = t), this;
        }
        sc(t) {
          return (
            (this._operationSchema = t),
            (this._smithyContext.operationSchema = t),
            this
          );
        }
        build() {
          let t = this,
            r;
          return (r = class extends Ie {
            static getEndpointParameterInstructions() {
              return t._ep;
            }
            constructor(...[o]) {
              super(),
                (this.serialize = t._serializer),
                (this.deserialize = t._deserializer),
                (this.input = o ?? {}),
                t._init(this),
                (this.schema = t._operationSchema);
            }
            resolveMiddleware(o, n, i) {
              return this.resolveMiddlewareWithContext(o, n, i, {
                CommandCtor: r,
                middlewareFn: t._middlewareFn,
                clientName: t._clientName,
                commandName: t._commandName,
                inputFilterSensitiveLog: t._inputFilterSensitiveLog,
                outputFilterSensitiveLog: t._outputFilterSensitiveLog,
                smithyContext: t._smithyContext,
                additionalContext: t._additionalContext,
              });
            }
          });
        }
      });
  });
var kd,
  eIe = s(() => {
    kd = "***SensitiveInformation***";
  });
var Jw,
  tIe = s(() => {
    Jw = (e, t) => {
      for (let r of Object.keys(e)) {
        let o = e[r],
          n = async function (a, c, d) {
            let m = new o(a);
            if (typeof c == "function") this.send(m, c);
            else if (typeof d == "function") {
              if (typeof c != "object")
                throw new Error(`Expected http options but got ${typeof c}`);
              this.send(m, c || {}, d);
            } else return this.send(m, c);
          },
          i = (r[0].toLowerCase() + r.slice(1)).replace(/Command$/, "");
        t.prototype[i] = n;
      }
    };
  });
var Jf,
  ht,
  i$ = s(() => {
    (Jf = class e extends Error {
      constructor(t) {
        super(t.message),
          Object.setPrototypeOf(
            this,
            Object.getPrototypeOf(this).constructor.prototype
          ),
          (this.name = t.name),
          (this.$fault = t.$fault),
          (this.$metadata = t.$metadata);
      }
      static isInstance(t) {
        if (!t) return !1;
        let r = t;
        return (
          e.prototype.isPrototypeOf(r) ||
          (!!r.$fault &&
            !!r.$metadata &&
            (r.$fault === "client" || r.$fault === "server"))
        );
      }
      static [Symbol.hasInstance](t) {
        if (!t) return !1;
        let r = t;
        return this === e
          ? e.isInstance(t)
          : e.isInstance(t)
            ? r.name && this.name
              ? this.prototype.isPrototypeOf(t) || r.name === this.name
              : this.prototype.isPrototypeOf(t)
            : !1;
      }
    }),
      (ht = (e, t = {}) => {
        Object.entries(t)
          .filter(([, o]) => o !== void 0)
          .forEach(([o, n]) => {
            (e[o] == null || e[o] === "") && (e[o] = n);
          });
        let r = e.message || e.Message || "UnknownError";
        return (e.message = r), delete e.Message, e;
      });
  });
var blt,
  Zw,
  _lt,
  rIe = s(() => {
    i$();
    (blt = ({ output: e, parsedBody: t, exceptionCtor: r, errorCode: o }) => {
      let n = _lt(e),
        i = n.httpStatusCode ? n.httpStatusCode + "" : void 0,
        a = new r({
          name: t?.code || t?.Code || o || i || "UnknownError",
          $fault: "client",
          $metadata: n,
        });
      throw ht(a, t);
    }),
      (Zw =
        (e) =>
        ({ output: t, parsedBody: r, errorCode: o }) => {
          blt({ output: t, parsedBody: r, exceptionCtor: e, errorCode: o });
        }),
      (_lt = (e) => ({
        httpStatusCode: e.statusCode,
        requestId:
          e.headers["x-amzn-requestid"] ??
          e.headers["x-amzn-request-id"] ??
          e.headers["x-amz-request-id"],
        extendedRequestId: e.headers["x-amz-id-2"],
        cfId: e.headers["x-amz-cf-id"],
      }));
  });
var eT,
  oIe = s(() => {
    eT = (e) => {
      switch (e) {
        case "standard":
          return { retryMode: "standard", connectionTimeout: 3100 };
        case "in-region":
          return { retryMode: "standard", connectionTimeout: 1100 };
        case "cross-region":
          return { retryMode: "standard", connectionTimeout: 3100 };
        case "mobile":
          return { retryMode: "standard", connectionTimeout: 3e4 };
        default:
          return {};
      }
    };
  });
var nIe,
  tT,
  sIe = s(() => {
    (nIe = !1),
      (tT = (e) => {
        e &&
          !nIe &&
          parseInt(e.substring(1, e.indexOf("."))) < 16 &&
          (nIe = !0);
      });
  });
var iIe = s(() => {
  Dt();
});
var aIe,
  cIe,
  dIe = s(() => {
    Rd();
    (aIe = (e) => {
      let t = [];
      for (let r in Uf) {
        let o = Uf[r];
        e[o] !== void 0 &&
          t.push({ algorithmId: () => o, checksumConstructor: () => e[o] });
      }
      return {
        addChecksumAlgorithm(r) {
          t.push(r);
        },
        checksumAlgorithms() {
          return t;
        },
      };
    }),
      (cIe = (e) => {
        let t = {};
        return (
          e.checksumAlgorithms().forEach((r) => {
            t[r.algorithmId()] = r.checksumConstructor();
          }),
          t
        );
      });
  });
var mIe,
  lIe,
  fIe = s(() => {
    (mIe = (e) => ({
      setRetryStrategy(t) {
        e.retryStrategy = t;
      },
      retryStrategy() {
        return e.retryStrategy;
      },
    })),
      (lIe = (e) => {
        let t = {};
        return (t.retryStrategy = e.retryStrategy()), t;
      });
  });
var rT,
  oT,
  uIe = s(() => {
    dIe();
    fIe();
    (rT = (e) => Object.assign(aIe(e), mIe(e))),
      (oT = (e) => Object.assign(cIe(e), lIe(e)));
  });
var pIe = s(() => {
  uIe();
});
var hIe = s(() => {});
var gIe = s(() => {});
var ay,
  yIe = s(() => {
    ay = (e) => e != null;
  });
var ac,
  xIe = s(() => {
    ac = class {
      trace() {}
      debug() {}
      info() {}
      warn() {}
      error() {}
    };
  });
function Oo(e, t, r) {
  let o, n, i;
  if (typeof t > "u" && typeof r > "u") (o = {}), (i = e);
  else {
    if (((o = e), typeof t == "function"))
      return (n = t), (i = r), wlt(o, n, i);
    i = t;
  }
  for (let a of Object.keys(i)) {
    if (!Array.isArray(i[a])) {
      o[a] = i[a];
      continue;
    }
    EIe(o, null, i, a);
  }
  return o;
}
var ot,
  wlt,
  EIe,
  Tlt,
  Alt,
  SIe = s(() => {
    (ot = (e, t) => {
      let r = {};
      for (let o in t) EIe(r, e, t, o);
      return r;
    }),
      (wlt = (e, t, r) =>
        Oo(
          e,
          Object.entries(r).reduce(
            (o, [n, i]) => (
              Array.isArray(i)
                ? (o[n] = i)
                : typeof i == "function"
                  ? (o[n] = [t, i()])
                  : (o[n] = [t, i]),
              o
            ),
            {}
          )
        )),
      (EIe = (e, t, r, o) => {
        if (t !== null) {
          let a = r[o];
          typeof a == "function" && (a = [, a]);
          let [c = Tlt, d = Alt, m = o] = a;
          ((typeof c == "function" && c(t[m])) ||
            (typeof c != "function" && c)) &&
            (e[o] = d(t[m]));
          return;
        }
        let [n, i] = r[o];
        if (typeof i == "function") {
          let a,
            c = n === void 0 && (a = i()) != null,
            d =
              (typeof n == "function" && !!n(void 0)) ||
              (typeof n != "function" && !!n);
          c ? (e[o] = a) : d && (e[o] = i());
        } else {
          let a = n === void 0 && i != null,
            c =
              (typeof n == "function" && !!n(i)) ||
              (typeof n != "function" && !!n);
          (a || c) && (e[o] = i);
        }
      }),
      (Tlt = (e) => e != null),
      (Alt = (e) => e);
  });
var CIe = s(() => {
  Dt();
});
var bIe = s(() => {});
var Me,
  _Ie = s(() => {
    Me = (e) => {
      if (e == null) return {};
      if (Array.isArray(e)) return e.filter((t) => t != null).map(Me);
      if (typeof e == "object") {
        let t = {};
        for (let r of Object.keys(e)) e[r] != null && (t[r] = Me(e[r]));
        return t;
      }
      return e;
    };
  });
var qe = s(() => {
  XRe();
  JRe();
  ZRe();
  eIe();
  tIe();
  rIe();
  oIe();
  sIe();
  i$();
  iIe();
  pIe();
  hIe();
  gIe();
  yIe();
  xIe();
  SIe();
  CIe();
  bIe();
  _Ie();
  Uo();
});
import { Readable as Rlt } from "stream";
var wIe,
  TIe = s(() => {
    wIe = (e) =>
      e?.body instanceof Rlt ||
      (typeof ReadableStream < "u" && e?.body instanceof ReadableStream);
  });
var Ilt,
  Plt,
  vlt,
  Olt,
  klt,
  nT,
  Dlt,
  AIe = s(() => {
    Cn();
    iy();
    qe();
    Ci();
    id();
    TIe();
    r$();
    (Ilt = (e) => (t, r) => async (o) => {
      let n = await e.retryStrategy(),
        i = await e.maxAttempts();
      if (Plt(n)) {
        n = n;
        let a = await n.acquireInitialRetryToken(r.partition_id),
          c = new Error(),
          d = 0,
          m = 0,
          { request: f } = o,
          l = Ko.isInstance(f);
        for (l && (f.headers[jw] = qo()); ; )
          try {
            l && (f.headers[Gw] = `attempt=${d + 1}; max=${i}`);
            let { response: u, output: h } = await t(o);
            return (
              n.recordSuccess(a),
              (h.$metadata.attempts = d + 1),
              (h.$metadata.totalRetryDelay = m),
              { response: u, output: h }
            );
          } catch (u) {
            let h = vlt(u);
            if (((c = t$(u)), l && wIe(f)))
              throw (
                ((r.logger instanceof ac ? console : r.logger)?.warn(
                  "An error was encountered in a non-retryable streaming request."
                ),
                c)
              );
            try {
              a = await n.refreshRetryTokenForRetry(a, h);
            } catch {
              throw (
                (c.$metadata || (c.$metadata = {}),
                (c.$metadata.attempts = d + 1),
                (c.$metadata.totalRetryDelay = m),
                c)
              );
            }
            d = a.getRetryCount();
            let y = a.getRetryDelay();
            (m += y), await new Promise((S) => setTimeout(S, y));
          }
      } else
        return (
          (n = n),
          n?.mode &&
            (r.userAgent = [
              ...(r.userAgent || []),
              ["cfg/retry-mode", n.mode],
            ]),
          n.retry(t, o)
        );
    }),
      (Plt = (e) =>
        typeof e.acquireInitialRetryToken < "u" &&
        typeof e.refreshRetryTokenForRetry < "u" &&
        typeof e.recordSuccess < "u"),
      (vlt = (e) => {
        let t = { error: e, errorType: Olt(e) },
          r = Dlt(e.$response);
        return r && (t.retryAfterHint = r), t;
      }),
      (Olt = (e) =>
        Vf(e)
          ? "THROTTLING"
          : sy(e)
            ? "TRANSIENT"
            : ORe(e)
              ? "SERVER_ERROR"
              : "CLIENT_ERROR"),
      (klt = {
        name: "retryMiddleware",
        tags: ["RETRY"],
        step: "finalizeRequest",
        priority: "high",
        override: !0,
      }),
      (nT = (e) => ({
        applyToStack: (t) => {
          t.add(Ilt(e), klt);
        },
      })),
      (Dlt = (e) => {
        if (!Ei.isInstance(e)) return;
        let t = Object.keys(e.headers).find(
          (i) => i.toLowerCase() === "retry-after"
        );
        if (!t) return;
        let r = e.headers[t],
          o = Number(r);
        return Number.isNaN(o) ? new Date(r) : new Date(o * 1e3);
      });
  });
var cy = s(() => {
  qRe();
  o$();
  VRe();
  ZU();
  WRe();
  e$();
  AIe();
});
function Nlt(e) {
  return {
    schemeId: "aws.auth#sigv4",
    signingProperties: { name: "sqs", region: e.region },
    propertiesExtractor: (t, r) => ({
      signingProperties: { config: t, context: r },
    }),
  };
}
var RIe,
  IIe,
  PIe,
  a$ = s(() => {
    rt();
    ct();
    RIe = async (e, t, r) => ({
      operation: bt(t).operation,
      region:
        (await pe(e.region)()) ||
        (() => {
          throw new Error(
            "expected `region` to be configured for `aws.auth#sigv4`"
          );
        })(),
    });
    (IIe = (e) => {
      let t = [];
      switch (e.operation) {
        default:
          t.push(Nlt(e));
      }
      return t;
    }),
      (PIe = (e) => {
        let t = zo(e);
        return Object.assign(t, {
          authSchemePreference: pe(e.authSchemePreference ?? []),
        });
      });
  });
var vIe,
  je,
  yr = s(() => {
    (vIe = (e) =>
      Object.assign(e, {
        useDualstackEndpoint: e.useDualstackEndpoint ?? !1,
        useFipsEndpoint: e.useFipsEndpoint ?? !1,
        defaultSigningName: "sqs",
      })),
      (je = {
        UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
        Endpoint: { type: "builtInParams", name: "endpoint" },
        Region: { type: "builtInParams", name: "region" },
        UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
      });
  });
var kIe,
  OIe = s(() => {
    kIe = {
      name: "@aws-sdk/client-sqs",
      description:
        "AWS SDK for JavaScript Sqs Client for Node.js, Browser and React Native",
      version: "3.839.0",
      scripts: {
        build:
          "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
        "build:cjs": "node ../../scripts/compilation/inline client-sqs",
        "build:es": "tsc -p tsconfig.es.json",
        "build:include:deps":
          "lerna run --scope $npm_package_name --include-dependencies build",
        "build:types": "tsc -p tsconfig.types.json",
        "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
        clean: "rimraf ./dist-* && rimraf *.tsbuildinfo",
        "extract:docs": "api-extractor run --local",
        "generate:client":
          "node ../../scripts/generate-clients/single-service --solo sqs",
      },
      main: "./dist-cjs/index.js",
      types: "./dist-types/index.d.ts",
      module: "./dist-es/index.js",
      sideEffects: !1,
      dependencies: {
        "@aws-crypto/sha256-browser": "5.2.0",
        "@aws-crypto/sha256-js": "5.2.0",
        "@aws-sdk/core": "3.839.0",
        "@aws-sdk/credential-provider-node": "3.839.0",
        "@aws-sdk/middleware-host-header": "3.821.0",
        "@aws-sdk/middleware-logger": "3.821.0",
        "@aws-sdk/middleware-recursion-detection": "3.821.0",
        "@aws-sdk/middleware-sdk-sqs": "3.839.0",
        "@aws-sdk/middleware-user-agent": "3.839.0",
        "@aws-sdk/region-config-resolver": "3.821.0",
        "@aws-sdk/types": "3.821.0",
        "@aws-sdk/util-endpoints": "3.828.0",
        "@aws-sdk/util-user-agent-browser": "3.821.0",
        "@aws-sdk/util-user-agent-node": "3.839.0",
        "@smithy/config-resolver": "^4.1.4",
        "@smithy/core": "^3.6.0",
        "@smithy/fetch-http-handler": "^5.0.4",
        "@smithy/hash-node": "^4.0.4",
        "@smithy/invalid-dependency": "^4.0.4",
        "@smithy/md5-js": "^4.0.4",
        "@smithy/middleware-content-length": "^4.0.4",
        "@smithy/middleware-endpoint": "^4.1.13",
        "@smithy/middleware-retry": "^4.1.14",
        "@smithy/middleware-serde": "^4.0.8",
        "@smithy/middleware-stack": "^4.0.4",
        "@smithy/node-config-provider": "^4.1.3",
        "@smithy/node-http-handler": "^4.0.6",
        "@smithy/protocol-http": "^5.1.2",
        "@smithy/smithy-client": "^4.4.5",
        "@smithy/types": "^4.3.1",
        "@smithy/url-parser": "^4.0.4",
        "@smithy/util-base64": "^4.0.0",
        "@smithy/util-body-length-browser": "^4.0.0",
        "@smithy/util-body-length-node": "^4.0.0",
        "@smithy/util-defaults-mode-browser": "^4.0.21",
        "@smithy/util-defaults-mode-node": "^4.0.21",
        "@smithy/util-endpoints": "^3.0.6",
        "@smithy/util-middleware": "^4.0.4",
        "@smithy/util-retry": "^4.0.6",
        "@smithy/util-utf8": "^4.0.0",
        tslib: "^2.6.2",
      },
      devDependencies: {
        "@tsconfig/node18": "18.2.4",
        "@types/node": "^18.19.69",
        concurrently: "7.0.0",
        "downlevel-dts": "0.10.1",
        rimraf: "3.0.2",
        typescript: "~5.8.3",
      },
      engines: { node: ">=18.0.0" },
      typesVersions: { "<4.0": { "dist-types/*": ["dist-types/ts3.4/*"] } },
      files: ["dist-*/**"],
      author: {
        name: "AWS SDK for JavaScript Team",
        url: "https://aws.amazon.com/javascript/",
      },
      license: "Apache-2.0",
      browser: { "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.browser" },
      "react-native": {
        "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.native",
      },
      homepage:
        "https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-sqs",
      repository: {
        type: "git",
        url: "https://github.com/aws/aws-sdk-js-v3.git",
        directory: "clients/client-sqs",
      },
    };
  });
var sT,
  iT,
  DIe,
  NIe,
  BIe,
  MIe,
  c$,
  LIe = s(() => {
    xt();
    re();
    (sT = "AWS_ACCESS_KEY_ID"),
      (iT = "AWS_SECRET_ACCESS_KEY"),
      (DIe = "AWS_SESSION_TOKEN"),
      (NIe = "AWS_CREDENTIAL_EXPIRATION"),
      (BIe = "AWS_CREDENTIAL_SCOPE"),
      (MIe = "AWS_ACCOUNT_ID"),
      (c$ = (e) => async () => {
        e?.logger?.debug("@aws-sdk/credential-provider-env - fromEnv");
        let t = process.env[sT],
          r = process.env[iT],
          o = process.env[DIe],
          n = process.env[NIe],
          i = process.env[BIe],
          a = process.env[MIe];
        if (t && r) {
          let c = {
            accessKeyId: t,
            secretAccessKey: r,
            ...(o && { sessionToken: o }),
            ...(n && { expiration: new Date(n) }),
            ...(i && { credentialScope: i }),
            ...(a && { accountId: a }),
          };
          return ce(c, "CREDENTIALS_ENV_VARS", "g"), c;
        }
        throw new P("Unable to find environment variable credentials.", {
          logger: e?.logger,
        });
      });
  });
var FIe = {};
It(FIe, {
  ENV_ACCOUNT_ID: () => MIe,
  ENV_CREDENTIAL_SCOPE: () => BIe,
  ENV_EXPIRATION: () => NIe,
  ENV_KEY: () => sT,
  ENV_SECRET: () => iT,
  ENV_SESSION: () => DIe,
  fromEnv: () => c$,
});
var d$ = s(() => {
  LIe();
});
import { Buffer as Mlt } from "buffer";
import { request as Llt } from "http";
function cc(e) {
  return new Promise((t, r) => {
    let o = Llt({
      method: "GET",
      ...e,
      hostname: e.hostname?.replace(/^\[(.+)\]$/, "$1"),
    });
    o.on("error", (n) => {
      r(
        Object.assign(
          new Zt("Unable to connect to instance metadata service"),
          n
        )
      ),
        o.destroy();
    }),
      o.on("timeout", () => {
        r(new Zt("TimeoutError from instance metadata service")), o.destroy();
      }),
      o.on("response", (n) => {
        let { statusCode: i = 400 } = n;
        (i < 200 || 300 <= i) &&
          (r(
            Object.assign(
              new Zt("Error response received from instance metadata service"),
              { statusCode: i }
            )
          ),
          o.destroy());
        let a = [];
        n.on("data", (c) => {
          a.push(c);
        }),
          n.on("end", () => {
            t(Mlt.concat(a)), o.destroy();
          });
      }),
      o.end();
  });
}
var aT = s(() => {
  re();
});
var cT,
  dT,
  m$ = s(() => {
    (cT = (e) =>
      !!e &&
      typeof e == "object" &&
      typeof e.AccessKeyId == "string" &&
      typeof e.SecretAccessKey == "string" &&
      typeof e.Token == "string" &&
      typeof e.Expiration == "string"),
      (dT = (e) => ({
        accessKeyId: e.AccessKeyId,
        secretAccessKey: e.SecretAccessKey,
        sessionToken: e.Token,
        expiration: new Date(e.Expiration),
        ...(e.AccountId && { accountId: e.AccountId }),
      }));
  });
var oWr,
  nWr,
  dy,
  mT = s(() => {
    (oWr = 1e3),
      (nWr = 0),
      (dy = ({ maxRetries: e = 0, timeout: t = 1e3 }) => ({
        maxRetries: e,
        timeout: t,
      }));
  });
var my,
  l$ = s(() => {
    my = (e, t) => {
      let r = e();
      for (let o = 0; o < t; o++) r = r.catch(e);
      return r;
    };
  });
import { parse as Flt } from "url";
var lT,
  fT,
  f$,
  Ult,
  $lt,
  Hlt,
  zlt,
  qlt,
  jlt,
  UIe = s(() => {
    re();
    aT();
    m$();
    mT();
    l$();
    (lT = "AWS_CONTAINER_CREDENTIALS_FULL_URI"),
      (fT = "AWS_CONTAINER_CREDENTIALS_RELATIVE_URI"),
      (f$ = "AWS_CONTAINER_AUTHORIZATION_TOKEN"),
      (Ult = (e = {}) => {
        let { timeout: t, maxRetries: r } = dy(e);
        return () =>
          my(async () => {
            let o = await jlt({ logger: e.logger }),
              n = JSON.parse(await $lt(t, o));
            if (!cT(n))
              throw new P(
                "Invalid response received from instance metadata service.",
                { logger: e.logger }
              );
            return dT(n);
          }, r);
      }),
      ($lt = async (e, t) => (
        process.env[f$] &&
          (t.headers = { ...t.headers, Authorization: process.env[f$] }),
        (await cc({ ...t, timeout: e })).toString()
      )),
      (Hlt = "169.254.170.2"),
      (zlt = { localhost: !0, "127.0.0.1": !0 }),
      (qlt = { "http:": !0, "https:": !0 }),
      (jlt = async ({ logger: e }) => {
        if (process.env[fT]) return { hostname: Hlt, path: process.env[fT] };
        if (process.env[lT]) {
          let t = Flt(process.env[lT]);
          if (!t.hostname || !(t.hostname in zlt))
            throw new P(
              `${t.hostname} is not a valid container metadata service hostname`,
              { tryNextLink: !1, logger: e }
            );
          if (!t.protocol || !(t.protocol in qlt))
            throw new P(
              `${t.protocol} is not a valid container metadata service protocol`,
              { tryNextLink: !1, logger: e }
            );
          return { ...t, port: t.port ? parseInt(t.port, 10) : void 0 };
        }
        throw new P(
          `The container metadata credential provider cannot be used unless the ${fT} or ${lT} environment variable is set`,
          { tryNextLink: !1, logger: e }
        );
      });
  });
var uT,
  $Ie = s(() => {
    re();
    uT = class e extends P {
      constructor(t, r = !0) {
        super(t, r),
          (this.tryNextLink = r),
          (this.name = "InstanceMetadataV1FallbackError"),
          Object.setPrototypeOf(this, e.prototype);
      }
    };
  });
var Dd,
  u$ = s(() => {
    (function (e) {
      (e.IPv4 = "http://169.254.169.254"), (e.IPv6 = "http://[fd00:ec2::254]");
    })(Dd || (Dd = {}));
  });
var Glt,
  Vlt,
  HIe,
  zIe = s(() => {
    (Glt = "AWS_EC2_METADATA_SERVICE_ENDPOINT"),
      (Vlt = "ec2_metadata_service_endpoint"),
      (HIe = {
        environmentVariableSelector: (e) => e[Glt],
        configFileSelector: (e) => e[Vlt],
        default: void 0,
      });
  });
var dc,
  p$ = s(() => {
    (function (e) {
      (e.IPv4 = "IPv4"), (e.IPv6 = "IPv6");
    })(dc || (dc = {}));
  });
var Wlt,
  Klt,
  qIe,
  jIe = s(() => {
    p$();
    (Wlt = "AWS_EC2_METADATA_SERVICE_ENDPOINT_MODE"),
      (Klt = "ec2_metadata_service_endpoint_mode"),
      (qIe = {
        environmentVariableSelector: (e) => e[Wlt],
        configFileSelector: (e) => e[Klt],
        default: dc.IPv4,
      });
  });
var pT,
  Ylt,
  Qlt,
  h$ = s(() => {
    Id();
    ny();
    u$();
    zIe();
    p$();
    jIe();
    (pT = async () => Si((await Ylt()) || (await Qlt()))),
      (Ylt = async () => lr(HIe)()),
      (Qlt = async () => {
        let e = await lr(qIe)();
        switch (e) {
          case dc.IPv4:
            return Dd.IPv4;
          case dc.IPv6:
            return Dd.IPv6;
          default:
            throw new Error(
              `Unsupported endpoint mode: ${e}. Select from ${Object.values(dc)}`
            );
        }
      });
  });
var Xlt,
  g$,
  GIe = s(() => {
    (Xlt =
      "https://docs.aws.amazon.com/sdkref/latest/guide/feature-static-credentials.html"),
      (g$ = (e, t) => {
        let r = 300 + Math.floor(Math.random() * 300),
          o = new Date(Date.now() + r * 1e3);
        t.warn(
          `Attempting credential expiration extension due to a credential service availability issue. A refresh of these credentials will be attempted after ${new Date(o)}.
For more information, please visit: ` + Xlt
        );
        let n = e.originalExpiration ?? e.expiration;
        return { ...e, ...(n ? { originalExpiration: n } : {}), expiration: o };
      });
  });
var VIe,
  WIe = s(() => {
    GIe();
    VIe = (e, t = {}) => {
      let r = t?.logger || console,
        o;
      return async () => {
        let n;
        try {
          (n = await e()),
            n.expiration &&
              n.expiration.getTime() < Date.now() &&
              (n = g$(n, r));
        } catch (i) {
          if (o) r.warn("Credential renew failed: ", i), (n = g$(o, r));
          else throw i;
        }
        return (o = n), n;
      };
    };
  });
var QIe,
  Jlt,
  y$,
  KIe,
  YIe,
  Zlt,
  eft,
  tft,
  rft,
  oft,
  XIe = s(() => {
    Id();
    re();
    $Ie();
    aT();
    m$();
    mT();
    l$();
    h$();
    WIe();
    (QIe = "/latest/meta-data/iam/security-credentials/"),
      (Jlt = "/latest/api/token"),
      (y$ = "AWS_EC2_METADATA_V1_DISABLED"),
      (KIe = "ec2_metadata_v1_disabled"),
      (YIe = "x-aws-ec2-metadata-token"),
      (Zlt = (e = {}) => VIe(eft(e), { logger: e.logger })),
      (eft = (e = {}) => {
        let t = !1,
          { logger: r, profile: o } = e,
          { timeout: n, maxRetries: i } = dy(e),
          a = async (c, d) => {
            if (t || d.headers?.[YIe] == null) {
              let l = !1,
                u = !1,
                h = await lr(
                  {
                    environmentVariableSelector: (y) => {
                      let S = y[y$];
                      if (((u = !!S && S !== "false"), S === void 0))
                        throw new P(
                          `${y$} not set in env, checking config file next.`,
                          { logger: e.logger }
                        );
                      return u;
                    },
                    configFileSelector: (y) => {
                      let S = y[KIe];
                      return (l = !!S && S !== "false"), l;
                    },
                    default: !1,
                  },
                  { profile: o }
                )();
              if (e.ec2MetadataV1Disabled || h) {
                let y = [];
                throw (
                  (e.ec2MetadataV1Disabled &&
                    y.push(
                      "credential provider initialization (runtime option ec2MetadataV1Disabled)"
                    ),
                  l && y.push(`config file profile (${KIe})`),
                  u && y.push(`process environment variable (${y$})`),
                  new uT(
                    `AWS EC2 Metadata v1 fallback has been blocked by AWS SDK configuration in the following: [${y.join(", ")}].`
                  ))
                );
              }
            }
            let f = (
              await my(async () => {
                let l;
                try {
                  l = await rft(d);
                } catch (u) {
                  throw (u.statusCode === 401 && (t = !1), u);
                }
                return l;
              }, c)
            ).trim();
            return my(async () => {
              let l;
              try {
                l = await oft(f, d, e);
              } catch (u) {
                throw (u.statusCode === 401 && (t = !1), u);
              }
              return l;
            }, c);
          };
        return async () => {
          let c = await pT();
          if (t)
            return (
              r?.debug(
                "AWS SDK Instance Metadata",
                "using v1 fallback (no token fetch)"
              ),
              a(i, { ...c, timeout: n })
            );
          {
            let d;
            try {
              d = (await tft({ ...c, timeout: n })).toString();
            } catch (m) {
              if (m?.statusCode === 400)
                throw Object.assign(m, {
                  message: "EC2 Metadata token request returned error",
                });
              return (
                (m.message === "TimeoutError" ||
                  [403, 404, 405].includes(m.statusCode)) &&
                  (t = !0),
                r?.debug(
                  "AWS SDK Instance Metadata",
                  "using v1 fallback (initial)"
                ),
                a(i, { ...c, timeout: n })
              );
            }
            return a(i, { ...c, headers: { [YIe]: d }, timeout: n });
          }
        };
      }),
      (tft = async (e) =>
        cc({
          ...e,
          path: Jlt,
          method: "PUT",
          headers: { "x-aws-ec2-metadata-token-ttl-seconds": "21600" },
        })),
      (rft = async (e) => (await cc({ ...e, path: QIe })).toString()),
      (oft = async (e, t, r) => {
        let o = JSON.parse((await cc({ ...t, path: QIe + e })).toString());
        if (!cT(o))
          throw new P(
            "Invalid response received from instance metadata service.",
            { logger: r.logger }
          );
        return dT(o);
      });
  });
var JIe = s(() => {});
var ly = {};
It(ly, {
  DEFAULT_MAX_RETRIES: () => nWr,
  DEFAULT_TIMEOUT: () => oWr,
  ENV_CMDS_AUTH_TOKEN: () => f$,
  ENV_CMDS_FULL_URI: () => lT,
  ENV_CMDS_RELATIVE_URI: () => fT,
  Endpoint: () => Dd,
  fromContainerMetadata: () => Ult,
  fromInstanceMetadata: () => Zlt,
  getInstanceMetadataEndpoint: () => pT,
  httpRequest: () => cc,
  providerConfigFromInit: () => dy,
});
var fy = s(() => {
  UIe();
  XIe();
  mT();
  JIe();
  aT();
  h$();
  u$();
});
var ZIe,
  ePe,
  tPe = s(() => {
    re();
    (ZIe = "AWS_EC2_METADATA_DISABLED"),
      (ePe = async (e) => {
        let {
          ENV_CMDS_FULL_URI: t,
          ENV_CMDS_RELATIVE_URI: r,
          fromContainerMetadata: o,
          fromInstanceMetadata: n,
        } = await Promise.resolve().then(() => (fy(), ly));
        if (process.env[r] || process.env[t]) {
          e.logger?.debug(
            "@aws-sdk/credential-provider-node - remoteProvider::fromHttp/fromContainerMetadata"
          );
          let { fromHttp: i } = await Promise.resolve().then(() => (ld(), md));
          return Ht(i(e), o(e));
        }
        return process.env[ZIe] && process.env[ZIe] !== "false"
          ? async () => {
              throw new P("EC2 Instance Metadata Service access disabled", {
                logger: e.logger,
              });
            }
          : (e.logger?.debug(
              "@aws-sdk/credential-provider-node - remoteProvider::fromInstanceMetadata"
            ),
            n(e));
      });
  });
var x$,
  E$ = s(() => {
    x$ = (e) =>
      e &&
      (typeof e.sso_start_url == "string" ||
        typeof e.sso_account_id == "string" ||
        typeof e.sso_session == "string" ||
        typeof e.sso_region == "string" ||
        typeof e.sso_role_name == "string");
  });
var rPe = s(() => {
  re();
});
var Zf,
  hT = s(() => {
    Zf =
      "To refresh this SSO session run 'aws sso login' with the corresponding profile.";
  });
var oPe,
  nPe = s(() => {
    oPe = async (e, t = {}) => {
      let { SSOOIDCClient: r } = await Promise.resolve().then(() => (Sd(), Ed));
      return new r(
        Object.assign({}, t.clientConfig ?? {}, {
          region: e ?? t.clientConfig?.region,
          logger: t.clientConfig?.logger ?? t.parentClientConfig?.logger,
        })
      );
    };
  });
var sPe,
  iPe = s(() => {
    nPe();
    sPe = async (e, t, r = {}) => {
      let { CreateTokenCommand: o } = await Promise.resolve().then(
        () => (Sd(), Ed)
      );
      return (await oPe(t, r)).send(
        new o({
          clientId: e.clientId,
          clientSecret: e.clientSecret,
          refreshToken: e.refreshToken,
          grantType: "refresh_token",
        })
      );
    };
  });
var S$,
  aPe = s(() => {
    re();
    hT();
    S$ = (e) => {
      if (e.expiration && e.expiration.getTime() < Date.now())
        throw new Je(`Token is expired. ${Zf}`, !1);
    };
  });
var mc,
  cPe = s(() => {
    re();
    hT();
    mc = (e, t, r = !1) => {
      if (typeof t > "u")
        throw new Je(
          `Value not present for '${e}' in SSO Token${r ? ". Cannot refresh" : ""}. ${Zf}`,
          !1
        );
    };
  });
import { promises as nft } from "fs";
var sft,
  dPe,
  mPe = s(() => {
    qs();
    ({ writeFile: sft } = nft),
      (dPe = (e, t) => {
        let r = Nw(e),
          o = JSON.stringify(t, null, 2);
        return sft(r, o);
      });
  });
var lPe,
  fPe,
  uPe = s(() => {
    re();
    qs();
    hT();
    iPe();
    aPe();
    cPe();
    mPe();
    (lPe = new Date(0)),
      (fPe =
        (e = {}) =>
        async ({ callerClientConfig: t } = {}) => {
          let r = {
            ...e,
            parentClientConfig: { ...t, ...e.parentClientConfig },
          };
          r.logger?.debug("@aws-sdk/token-providers - fromSso");
          let o = await sc(r),
            n = os({ profile: r.profile ?? t?.profile }),
            i = o[n];
          if (i) {
            if (!i.sso_session)
              throw new Je(
                `Profile '${n}' is missing required property 'sso_session'.`
              );
          } else
            throw new Je(
              `Profile '${n}' could not be found in shared credentials file.`,
              !1
            );
          let a = i.sso_session,
            d = (await Fw(r))[a];
          if (!d)
            throw new Je(
              `Sso session '${a}' could not be found in shared credentials file.`,
              !1
            );
          for (let S of ["sso_start_url", "sso_region"])
            if (!d[S])
              throw new Je(
                `Sso session '${a}' is missing required property '${S}'.`,
                !1
              );
          let m = d.sso_start_url,
            f = d.sso_region,
            l;
          try {
            l = await Bw(a);
          } catch {
            throw new Je(
              `The SSO session token associated with profile=${n} was not found or is invalid. ${Zf}`,
              !1
            );
          }
          mc("accessToken", l.accessToken), mc("expiresAt", l.expiresAt);
          let { accessToken: u, expiresAt: h } = l,
            y = { token: u, expiration: new Date(h) };
          if (y.expiration.getTime() - Date.now() > 3e5) return y;
          if (Date.now() - lPe.getTime() < 30 * 1e3) return S$(y), y;
          mc("clientId", l.clientId, !0),
            mc("clientSecret", l.clientSecret, !0),
            mc("refreshToken", l.refreshToken, !0);
          try {
            lPe.setTime(Date.now());
            let S = await sPe(l, f, r);
            mc("accessToken", S.accessToken), mc("expiresIn", S.expiresIn);
            let E = new Date(Date.now() + S.expiresIn * 1e3);
            try {
              await dPe(a, {
                ...l,
                accessToken: S.accessToken,
                expiresAt: E.toISOString(),
                refreshToken: S.refreshToken,
              });
            } catch {}
            return { token: S.accessToken, expiration: E };
          } catch {
            return S$(y), y;
          }
        });
  });
var pPe = s(() => {
  re();
});
var hPe = s(() => {
  re();
});
var gPe = s(() => {
  rPe();
  uPe();
  pPe();
  hPe();
});
function aft(e) {
  return {
    schemeId: "aws.auth#sigv4",
    signingProperties: { name: "awsssoportal", region: e.region },
    propertiesExtractor: (t, r) => ({
      signingProperties: { config: t, context: r },
    }),
  };
}
function gT(e) {
  return { schemeId: "smithy.api#noAuth" };
}
var yPe,
  xPe,
  EPe,
  C$ = s(() => {
    rt();
    ct();
    yPe = async (e, t, r) => ({
      operation: bt(t).operation,
      region:
        (await pe(e.region)()) ||
        (() => {
          throw new Error(
            "expected `region` to be configured for `aws.auth#sigv4`"
          );
        })(),
    });
    (xPe = (e) => {
      let t = [];
      switch (e.operation) {
        case "GetRoleCredentials": {
          t.push(gT(e));
          break;
        }
        case "ListAccountRoles": {
          t.push(gT(e));
          break;
        }
        case "ListAccounts": {
          t.push(gT(e));
          break;
        }
        case "Logout": {
          t.push(gT(e));
          break;
        }
        default:
          t.push(aft(e));
      }
      return t;
    }),
      (EPe = (e) => {
        let t = zo(e);
        return Object.assign(t, {
          authSchemePreference: pe(e.authSchemePreference ?? []),
        });
      });
  });
var SPe,
  lc,
  eu = s(() => {
    (SPe = (e) =>
      Object.assign(e, {
        useDualstackEndpoint: e.useDualstackEndpoint ?? !1,
        useFipsEndpoint: e.useFipsEndpoint ?? !1,
        defaultSigningName: "awsssoportal",
      })),
      (lc = {
        UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
        Endpoint: { type: "builtInParams", name: "endpoint" },
        Region: { type: "builtInParams", name: "region" },
        UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
      });
  });
var bPe,
  CPe = s(() => {
    bPe = {
      name: "@aws-sdk/client-sso",
      description:
        "AWS SDK for JavaScript Sso Client for Node.js, Browser and React Native",
      version: "3.839.0",
      scripts: {
        build:
          "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
        "build:cjs": "node ../../scripts/compilation/inline client-sso",
        "build:es": "tsc -p tsconfig.es.json",
        "build:include:deps":
          "lerna run --scope $npm_package_name --include-dependencies build",
        "build:types": "tsc -p tsconfig.types.json",
        "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
        clean: "rimraf ./dist-* && rimraf *.tsbuildinfo",
        "extract:docs": "api-extractor run --local",
        "generate:client":
          "node ../../scripts/generate-clients/single-service --solo sso",
      },
      main: "./dist-cjs/index.js",
      types: "./dist-types/index.d.ts",
      module: "./dist-es/index.js",
      sideEffects: !1,
      dependencies: {
        "@aws-crypto/sha256-browser": "5.2.0",
        "@aws-crypto/sha256-js": "5.2.0",
        "@aws-sdk/core": "3.839.0",
        "@aws-sdk/middleware-host-header": "3.821.0",
        "@aws-sdk/middleware-logger": "3.821.0",
        "@aws-sdk/middleware-recursion-detection": "3.821.0",
        "@aws-sdk/middleware-user-agent": "3.839.0",
        "@aws-sdk/region-config-resolver": "3.821.0",
        "@aws-sdk/types": "3.821.0",
        "@aws-sdk/util-endpoints": "3.828.0",
        "@aws-sdk/util-user-agent-browser": "3.821.0",
        "@aws-sdk/util-user-agent-node": "3.839.0",
        "@smithy/config-resolver": "^4.1.4",
        "@smithy/core": "^3.6.0",
        "@smithy/fetch-http-handler": "^5.0.4",
        "@smithy/hash-node": "^4.0.4",
        "@smithy/invalid-dependency": "^4.0.4",
        "@smithy/middleware-content-length": "^4.0.4",
        "@smithy/middleware-endpoint": "^4.1.13",
        "@smithy/middleware-retry": "^4.1.14",
        "@smithy/middleware-serde": "^4.0.8",
        "@smithy/middleware-stack": "^4.0.4",
        "@smithy/node-config-provider": "^4.1.3",
        "@smithy/node-http-handler": "^4.0.6",
        "@smithy/protocol-http": "^5.1.2",
        "@smithy/smithy-client": "^4.4.5",
        "@smithy/types": "^4.3.1",
        "@smithy/url-parser": "^4.0.4",
        "@smithy/util-base64": "^4.0.0",
        "@smithy/util-body-length-browser": "^4.0.0",
        "@smithy/util-body-length-node": "^4.0.0",
        "@smithy/util-defaults-mode-browser": "^4.0.21",
        "@smithy/util-defaults-mode-node": "^4.0.21",
        "@smithy/util-endpoints": "^3.0.6",
        "@smithy/util-middleware": "^4.0.4",
        "@smithy/util-retry": "^4.0.6",
        "@smithy/util-utf8": "^4.0.0",
        tslib: "^2.6.2",
      },
      devDependencies: {
        "@tsconfig/node18": "18.2.4",
        "@types/node": "^18.19.69",
        concurrently: "7.0.0",
        "downlevel-dts": "0.10.1",
        rimraf: "3.0.2",
        typescript: "~5.8.3",
      },
      engines: { node: ">=18.0.0" },
      typesVersions: { "<4.0": { "dist-types/*": ["dist-types/ts3.4/*"] } },
      files: ["dist-*/**"],
      author: {
        name: "AWS SDK for JavaScript Team",
        url: "https://aws.amazon.com/javascript/",
      },
      license: "Apache-2.0",
      browser: { "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.browser" },
      "react-native": {
        "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.native",
      },
      homepage:
        "https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-sso",
      repository: {
        type: "git",
        url: "https://github.com/aws/aws-sdk-js-v3.git",
        directory: "clients/client-sso",
      },
    };
  });
var b$,
  _$ = s(() => {
    b$ = { isCrtAvailable: !1 };
  });
var _Pe,
  wPe = s(() => {
    _$();
    _Pe = () => (b$.isCrtAvailable ? ["md/crt-avail"] : null);
  });
import { platform as dft, release as mft } from "os";
import { env as TPe, versions as lft } from "process";
var yT,
  APe = s(() => {
    wPe();
    _$();
    yT =
      ({ serviceId: e, clientVersion: t }) =>
      async (r) => {
        let o = [
            ["aws-sdk-js", t],
            ["ua", "2.1"],
            [`os/${dft()}`, mft()],
            ["lang/js"],
            ["md/nodejs", `${lft.node}`],
          ],
          n = _Pe();
        n && o.push(n),
          e && o.push([`api/${e}`, t]),
          TPe.AWS_EXECUTION_ENV &&
            o.push([`exec-env/${TPe.AWS_EXECUTION_ENV}`]);
        let i = await r?.userAgentAppId?.();
        return i ? [...o, [`app/${i}`]] : [...o];
      };
  });
var fft,
  uft,
  pft,
  xT,
  RPe = s(() => {
    Aw();
    (fft = "AWS_SDK_UA_APP_ID"),
      (uft = "sdk_ua_app_id"),
      (pft = "sdk-ua-app-id"),
      (xT = {
        environmentVariableSelector: (e) => e[fft],
        configFileSelector: (e) => e[uft] ?? e[pft],
        default: TU,
      });
  });
var w$ = s(() => {
  APe();
  RPe();
});
import { Buffer as T$ } from "buffer";
var A$,
  IPe,
  PPe = s(() => {
    cr();
    (A$ = (e, t = 0, r = e.byteLength - t) => {
      if (!Ke(e))
        throw new TypeError(
          `The "input" argument must be ArrayBuffer. Received type ${typeof e} (${e})`
        );
      return T$.from(e, t, r);
    }),
      (IPe = (e, t) => {
        if (typeof e != "string")
          throw new TypeError(
            `The "input" argument must be of type string. Received type ${typeof e} (${e})`
          );
        return t ? T$.from(e, t) : T$.from(e);
      });
  });
import { Buffer as R$ } from "buffer";
var vPe,
  OPe,
  I$ = s(() => {
    cr();
    (vPe = (e, t = 0, r = e.byteLength - t) => {
      if (!Ke(e))
        throw new TypeError(
          `The "input" argument must be ArrayBuffer. Received type ${typeof e} (${e})`
        );
      return R$.from(e, t, r);
    }),
      (OPe = (e, t) => {
        if (typeof e != "string")
          throw new TypeError(
            `The "input" argument must be of type string. Received type ${typeof e} (${e})`
          );
        return t ? R$.from(e, t) : R$.from(e);
      });
  });
var fc,
  P$ = s(() => {
    I$();
    fc = (e) => {
      let t = OPe(e, "utf8");
      return new Uint8Array(
        t.buffer,
        t.byteOffset,
        t.byteLength / Uint8Array.BYTES_PER_ELEMENT
      );
    };
  });
var kPe,
  DPe = s(() => {
    P$();
    kPe = (e) =>
      typeof e == "string"
        ? fc(e)
        : ArrayBuffer.isView(e)
          ? new Uint8Array(
              e.buffer,
              e.byteOffset,
              e.byteLength / Uint8Array.BYTES_PER_ELEMENT
            )
          : new Uint8Array(e);
  });
var ET,
  NPe = s(() => {
    I$();
    ET = (e) => {
      if (typeof e == "string") return e;
      if (
        typeof e != "object" ||
        typeof e.byteOffset != "number" ||
        typeof e.byteLength != "number"
      )
        throw new Error(
          "@smithy/util-utf8: toUtf8 encoder function only accepts string | Uint8Array."
        );
      return vPe(e.buffer, e.byteOffset, e.byteLength).toString("utf8");
    };
  });
var uy = s(() => {
  P$();
  DPe();
  NPe();
});
import { Buffer as hft } from "buffer";
import { createHash as gft, createHmac as yft } from "crypto";
function BPe(e, t) {
  return hft.isBuffer(e)
    ? e
    : typeof e == "string"
      ? IPe(e, t)
      : ArrayBuffer.isView(e)
        ? A$(e.buffer, e.byteOffset, e.byteLength)
        : A$(e);
}
var Nd,
  v$ = s(() => {
    PPe();
    uy();
    Nd = class {
      constructor(t, r) {
        (this.algorithmIdentifier = t), (this.secret = r), this.reset();
      }
      update(t, r) {
        this.hash.update(kPe(BPe(t, r)));
      }
      digest() {
        return Promise.resolve(this.hash.digest());
      }
      reset() {
        this.hash = this.secret
          ? yft(this.algorithmIdentifier, BPe(this.secret))
          : gft(this.algorithmIdentifier);
      }
    };
  });
var py,
  xft,
  O$ = s(() => {
    (py = (e) => encodeURIComponent(e).replace(/[!'()*]/g, xft)),
      (xft = (e) => `%${e.charCodeAt(0).toString(16).toUpperCase()}`);
  });
var MPe = s(() => {
  O$();
});
var LPe = s(() => {
  O$();
  MPe();
});
function k$(e) {
  let t = [];
  for (let r of Object.keys(e).sort()) {
    let o = e[r];
    if (((r = py(r)), Array.isArray(o)))
      for (let n = 0, i = o.length; n < i; n++) t.push(`${r}=${py(o[n])}`);
    else {
      let n = r;
      (o || typeof o == "string") && (n += `=${py(o)}`), t.push(n);
    }
  }
  return t.join("&");
}
var D$ = s(() => {
  LPe();
});
var FPe,
  UPe = s(() => {
    FPe = ["ECONNRESET", "EPIPE", "ETIMEDOUT"];
  });
var N$,
  B$ = s(() => {
    N$ = (e) => {
      let t = {};
      for (let r of Object.keys(e)) {
        let o = e[r];
        t[r] = Array.isArray(o) ? o.join(",") : o;
      }
      return t;
    };
  });
var ro,
  tu = s(() => {
    ro = {
      setTimeout: (e, t) => setTimeout(e, t),
      clearTimeout: (e) => clearTimeout(e),
    };
  });
var $Pe,
  HPe,
  zPe = s(() => {
    tu();
    ($Pe = 1e3),
      (HPe = (e, t, r = 0) => {
        if (!r) return -1;
        let o = (n) => {
          let i = ro.setTimeout(() => {
              e.destroy(),
                t(
                  Object.assign(
                    new Error(
                      `Socket timed out without establishing a connection within ${r} ms`
                    ),
                    { name: "TimeoutError" }
                  )
                );
            }, r - n),
            a = (c) => {
              c?.connecting
                ? c.on("connect", () => {
                    ro.clearTimeout(i);
                  })
                : ro.clearTimeout(i);
            };
          e.socket ? a(e.socket) : e.on("socket", a);
        };
        return r < 2e3 ? (o(0), 0) : ro.setTimeout(o.bind(null, $Pe), $Pe);
      });
  });
var Eft,
  qPe,
  jPe = s(() => {
    tu();
    (Eft = 3e3),
      (qPe = (e, { keepAlive: t, keepAliveMsecs: r }, o = Eft) => {
        if (t !== !0) return -1;
        let n = () => {
          e.socket
            ? e.socket.setKeepAlive(t, r || 0)
            : e.on("socket", (i) => {
                i.setKeepAlive(t, r || 0);
              });
        };
        return o === 0 ? (n(), 0) : ro.setTimeout(n, o);
      });
  });
var GPe,
  VPe,
  WPe = s(() => {
    M$();
    tu();
    (GPe = 3e3),
      (VPe = (e, t, r = KPe) => {
        let o = (n) => {
          let i = r - n,
            a = () => {
              e.destroy(),
                t(
                  Object.assign(
                    new Error(`Connection timed out after ${r} ms`),
                    { name: "TimeoutError" }
                  )
                );
            };
          e.socket
            ? (e.socket.setTimeout(i, a),
              e.on("close", () => e.socket?.removeListener("timeout", a)))
            : e.setTimeout(i, a);
        };
        return 0 < r && r < 6e3
          ? (o(0), 0)
          : ro.setTimeout(o.bind(null, r === 0 ? 0 : GPe), GPe);
      });
  });
import { Readable as Sft } from "stream";
async function L$(e, t, r = YPe) {
  let o = t.headers ?? {},
    n = o.Expect || o.expect,
    i = -1,
    a = !0;
  n === "100-continue" &&
    (a = await Promise.race([
      new Promise((c) => {
        i = Number(ro.setTimeout(() => c(!0), Math.max(YPe, r)));
      }),
      new Promise((c) => {
        e.on("continue", () => {
          ro.clearTimeout(i), c(!0);
        }),
          e.on("response", () => {
            ro.clearTimeout(i), c(!1);
          }),
          e.on("error", () => {
            ro.clearTimeout(i), c(!1);
          });
      }),
    ])),
    a && Cft(e, t.body);
}
function Cft(e, t) {
  if (t instanceof Sft) {
    t.pipe(e);
    return;
  }
  if (t) {
    if (Buffer.isBuffer(t) || typeof t == "string") {
      e.end(t);
      return;
    }
    let r = t;
    if (
      typeof r == "object" &&
      r.buffer &&
      typeof r.byteOffset == "number" &&
      typeof r.byteLength == "number"
    ) {
      e.end(Buffer.from(r.buffer, r.byteOffset, r.byteLength));
      return;
    }
    e.end(Buffer.from(t));
    return;
  }
  e.end();
}
var YPe,
  F$ = s(() => {
    tu();
    YPe = 6e3;
  });
import { Agent as QPe, request as bft } from "http";
import { Agent as XPe, request as _ft } from "https";
var KPe,
  ru,
  M$ = s(() => {
    Cn();
    D$();
    UPe();
    B$();
    zPe();
    jPe();
    WPe();
    tu();
    F$();
    (KPe = 0),
      (ru = class e {
        static create(t) {
          return typeof t?.handle == "function" ? t : new e(t);
        }
        static checkSocketUsage(t, r, o = console) {
          let { sockets: n, requests: i, maxSockets: a } = t;
          if (typeof a != "number" || a === 1 / 0 || Date.now() - 15e3 < r)
            return r;
          if (n && i)
            for (let d in n) {
              let m = n[d]?.length ?? 0,
                f = i[d]?.length ?? 0;
              if (m >= a && f >= 2 * a)
                return (
                  o?.warn?.(`@smithy/node-http-handler:WARN - socket usage at capacity=${m} and ${f} additional requests are enqueued.
See https://docs.aws.amazon.com/sdk-for-javascript/v3/developer-guide/node-configuring-maxsockets.html
or increase socketAcquisitionWarningTimeout=(millis) in the NodeHttpHandler config.`),
                  Date.now()
                );
            }
          return r;
        }
        constructor(t) {
          (this.socketWarningTimestamp = 0),
            (this.metadata = { handlerProtocol: "http/1.1" }),
            (this.configProvider = new Promise((r, o) => {
              typeof t == "function"
                ? t()
                    .then((n) => {
                      r(this.resolveDefaultConfig(n));
                    })
                    .catch(o)
                : r(this.resolveDefaultConfig(t));
            }));
        }
        resolveDefaultConfig(t) {
          let {
              requestTimeout: r,
              connectionTimeout: o,
              socketTimeout: n,
              socketAcquisitionWarningTimeout: i,
              httpAgent: a,
              httpsAgent: c,
            } = t || {},
            d = !0,
            m = 50;
          return {
            connectionTimeout: o,
            requestTimeout: r ?? n,
            socketAcquisitionWarningTimeout: i,
            httpAgent:
              a instanceof QPe || typeof a?.destroy == "function"
                ? a
                : new QPe({ keepAlive: d, maxSockets: m, ...a }),
            httpsAgent:
              c instanceof XPe || typeof c?.destroy == "function"
                ? c
                : new XPe({ keepAlive: d, maxSockets: m, ...c }),
            logger: console,
          };
        }
        destroy() {
          this.config?.httpAgent?.destroy(), this.config?.httpsAgent?.destroy();
        }
        async handle(t, { abortSignal: r } = {}) {
          return (
            this.config || (this.config = await this.configProvider),
            new Promise((o, n) => {
              let i,
                a = [],
                c = async (I) => {
                  await i, a.forEach(ro.clearTimeout), o(I);
                },
                d = async (I) => {
                  await i, a.forEach(ro.clearTimeout), n(I);
                };
              if (!this.config)
                throw new Error(
                  "Node HTTP request handler config is not resolved"
                );
              if (r?.aborted) {
                let I = new Error("Request aborted");
                (I.name = "AbortError"), d(I);
                return;
              }
              let m = t.protocol === "https:",
                f = m ? this.config.httpsAgent : this.config.httpAgent;
              a.push(
                ro.setTimeout(
                  () => {
                    this.socketWarningTimestamp = e.checkSocketUsage(
                      f,
                      this.socketWarningTimestamp,
                      this.config.logger
                    );
                  },
                  this.config.socketAcquisitionWarningTimeout ??
                    (this.config.requestTimeout ?? 2e3) +
                      (this.config.connectionTimeout ?? 1e3)
                )
              );
              let l = k$(t.query || {}),
                u;
              if (t.username != null || t.password != null) {
                let I = t.username ?? "",
                  O = t.password ?? "";
                u = `${I}:${O}`;
              }
              let h = t.path;
              l && (h += `?${l}`), t.fragment && (h += `#${t.fragment}`);
              let y = t.hostname ?? "";
              y[0] === "[" && y.endsWith("]")
                ? (y = t.hostname.slice(1, -1))
                : (y = t.hostname);
              let S = {
                  headers: t.headers,
                  host: y,
                  method: t.method,
                  path: h,
                  port: t.port,
                  agent: f,
                  auth: u,
                },
                b = (m ? _ft : bft)(S, (I) => {
                  let O = new Ei({
                    statusCode: I.statusCode || -1,
                    reason: I.statusMessage,
                    headers: N$(I.headers),
                    body: I,
                  });
                  c({ response: O });
                });
              if (
                (b.on("error", (I) => {
                  FPe.includes(I.code)
                    ? d(Object.assign(I, { name: "TimeoutError" }))
                    : d(I);
                }),
                r)
              ) {
                let I = () => {
                  b.destroy();
                  let O = new Error("Request aborted");
                  (O.name = "AbortError"), d(O);
                };
                if (typeof r.addEventListener == "function") {
                  let O = r;
                  O.addEventListener("abort", I, { once: !0 }),
                    b.once("close", () => O.removeEventListener("abort", I));
                } else r.onabort = I;
              }
              a.push(HPe(b, d, this.config.connectionTimeout)),
                a.push(VPe(b, d, this.config.requestTimeout));
              let v = S.agent;
              typeof v == "object" &&
                "keepAlive" in v &&
                a.push(
                  qPe(b, {
                    keepAlive: v.keepAlive,
                    keepAliveMsecs: v.keepAliveMsecs,
                  })
                ),
                (i = L$(b, t, this.config.requestTimeout).catch(
                  (I) => (a.forEach(ro.clearTimeout), n(I))
                ));
            })
          );
        }
        updateHttpClientConfig(t, r) {
          (this.config = void 0),
            (this.configProvider = this.configProvider.then((o) => ({
              ...o,
              [t]: r,
            })));
        }
        httpHandlerConfigs() {
          return this.config ?? {};
        }
      });
  });
var JPe = s(() => {});
var ZPe = s(() => {
  JPe();
});
var eve = s(() => {
  Cn();
  D$();
  B$();
  ZPe();
  F$();
});
import { Writable as wft } from "stream";
var ST,
  tve = s(() => {
    ST = class extends wft {
      constructor() {
        super(...arguments), (this.bufferedBytes = []);
      }
      _write(t, r, o) {
        this.bufferedBytes.push(t), o();
      }
    };
  });
async function Aft(e) {
  let t = [],
    r = e.getReader(),
    o = !1,
    n = 0;
  for (; !o; ) {
    let { done: c, value: d } = await r.read();
    d && (t.push(d), (n += d.length)), (o = c);
  }
  let i = new Uint8Array(n),
    a = 0;
  for (let c of t) i.set(c, a), (a += c.length);
  return i;
}
var CT,
  Tft,
  rve = s(() => {
    tve();
    (CT = (e) =>
      Tft(e)
        ? Aft(e)
        : new Promise((t, r) => {
            let o = new ST();
            e.pipe(o),
              e.on("error", (n) => {
                o.end(), r(n);
              }),
              o.on("error", r),
              o.on("finish", function () {
                let n = new Uint8Array(Buffer.concat(this.bufferedBytes));
                t(n);
              });
          })),
      (Tft = (e) =>
        typeof ReadableStream == "function" && e instanceof ReadableStream);
  });
var U$ = s(() => {
  M$();
  eve();
  rve();
});
import { fstatSync as Rft, lstatSync as Ift } from "fs";
var bT,
  ove = s(() => {
    bT = (e) => {
      if (!e) return 0;
      if (typeof e == "string") return Buffer.byteLength(e);
      if (typeof e.byteLength == "number") return e.byteLength;
      if (typeof e.size == "number") return e.size;
      if (typeof e.start == "number" && typeof e.end == "number")
        return e.end + 1 - e.start;
      if (typeof e.path == "string" || Buffer.isBuffer(e.path))
        return Ift(e.path).size;
      if (typeof e.fd == "number") return Rft(e.fd).size;
      throw new Error(`Body Length computation failed for ${e}`);
    };
  });
var $$ = s(() => {
  ove();
});
import { Buffer as H$ } from "buffer";
var nve,
  sve,
  z$ = s(() => {
    cr();
    (nve = (e, t = 0, r = e.byteLength - t) => {
      if (!Ke(e))
        throw new TypeError(
          `The "input" argument must be ArrayBuffer. Received type ${typeof e} (${e})`
        );
      return H$.from(e, t, r);
    }),
      (sve = (e, t) => {
        if (typeof e != "string")
          throw new TypeError(
            `The "input" argument must be of type string. Received type ${typeof e} (${e})`
          );
        return t ? H$.from(e, t) : H$.from(e);
      });
  });
var Pft,
  _T,
  ive = s(() => {
    z$();
    (Pft = /^[A-Za-z0-9+/]*={0,2}$/),
      (_T = (e) => {
        if ((e.length * 3) % 4 !== 0)
          throw new TypeError("Incorrect padding on base64 string.");
        if (!Pft.exec(e)) throw new TypeError("Invalid base64 string.");
        let t = sve(e, "base64");
        return new Uint8Array(t.buffer, t.byteOffset, t.byteLength);
      });
  });
var wT,
  ave = s(() => {
    z$();
    uy();
    wT = (e) => {
      let t;
      if (
        (typeof e == "string" ? (t = fc(e)) : (t = e),
        typeof t != "object" ||
          typeof t.byteOffset != "number" ||
          typeof t.byteLength != "number")
      )
        throw new Error(
          "@smithy/util-base64: toBase64 encoder function only accepts string | Uint8Array."
        );
      return nve(t.buffer, t.byteOffset, t.byteLength).toString("base64");
    };
  });
var q$ = s(() => {
  ive();
  ave();
});
var yve,
  is,
  as,
  su,
  cve,
  hy,
  ou,
  nu,
  na,
  j$,
  G$,
  dve,
  mve,
  lve,
  xve,
  Eve,
  ss,
  fve,
  Sve,
  uve,
  pve,
  hve,
  gve,
  vft,
  Cve,
  bve = s(() => {
    (yve = "required"),
      (is = "fn"),
      (as = "argv"),
      (su = "ref"),
      (cve = "isSet"),
      (hy = "booleanEquals"),
      (ou = "error"),
      (nu = "endpoint"),
      (na = "tree"),
      (j$ = "PartitionResult"),
      (G$ = "getAttr"),
      (dve = { [yve]: !1, type: "String" }),
      (mve = { [yve]: !0, default: !1, type: "Boolean" }),
      (lve = { [su]: "Endpoint" }),
      (xve = { [is]: hy, [as]: [{ [su]: "UseFIPS" }, !0] }),
      (Eve = { [is]: hy, [as]: [{ [su]: "UseDualStack" }, !0] }),
      (ss = {}),
      (fve = { [is]: G$, [as]: [{ [su]: j$ }, "supportsFIPS"] }),
      (Sve = { [su]: j$ }),
      (uve = {
        [is]: hy,
        [as]: [!0, { [is]: G$, [as]: [Sve, "supportsDualStack"] }],
      }),
      (pve = [xve]),
      (hve = [Eve]),
      (gve = [{ [su]: "Region" }]),
      (vft = {
        version: "1.0",
        parameters: {
          Region: dve,
          UseDualStack: mve,
          UseFIPS: mve,
          Endpoint: dve,
        },
        rules: [
          {
            conditions: [{ [is]: cve, [as]: [lve] }],
            rules: [
              {
                conditions: pve,
                error:
                  "Invalid Configuration: FIPS and custom endpoint are not supported",
                type: ou,
              },
              {
                conditions: hve,
                error:
                  "Invalid Configuration: Dualstack and custom endpoint are not supported",
                type: ou,
              },
              { endpoint: { url: lve, properties: ss, headers: ss }, type: nu },
            ],
            type: na,
          },
          {
            conditions: [{ [is]: cve, [as]: gve }],
            rules: [
              {
                conditions: [{ [is]: "aws.partition", [as]: gve, assign: j$ }],
                rules: [
                  {
                    conditions: [xve, Eve],
                    rules: [
                      {
                        conditions: [{ [is]: hy, [as]: [!0, fve] }, uve],
                        rules: [
                          {
                            endpoint: {
                              url: "https://portal.sso-fips.{Region}.{PartitionResult#dualStackDnsSuffix}",
                              properties: ss,
                              headers: ss,
                            },
                            type: nu,
                          },
                        ],
                        type: na,
                      },
                      {
                        error:
                          "FIPS and DualStack are enabled, but this partition does not support one or both",
                        type: ou,
                      },
                    ],
                    type: na,
                  },
                  {
                    conditions: pve,
                    rules: [
                      {
                        conditions: [{ [is]: hy, [as]: [fve, !0] }],
                        rules: [
                          {
                            conditions: [
                              {
                                [is]: "stringEquals",
                                [as]: [
                                  { [is]: G$, [as]: [Sve, "name"] },
                                  "aws-us-gov",
                                ],
                              },
                            ],
                            endpoint: {
                              url: "https://portal.sso.{Region}.amazonaws.com",
                              properties: ss,
                              headers: ss,
                            },
                            type: nu,
                          },
                          {
                            endpoint: {
                              url: "https://portal.sso-fips.{Region}.{PartitionResult#dnsSuffix}",
                              properties: ss,
                              headers: ss,
                            },
                            type: nu,
                          },
                        ],
                        type: na,
                      },
                      {
                        error:
                          "FIPS is enabled but this partition does not support FIPS",
                        type: ou,
                      },
                    ],
                    type: na,
                  },
                  {
                    conditions: hve,
                    rules: [
                      {
                        conditions: [uve],
                        rules: [
                          {
                            endpoint: {
                              url: "https://portal.sso.{Region}.{PartitionResult#dualStackDnsSuffix}",
                              properties: ss,
                              headers: ss,
                            },
                            type: nu,
                          },
                        ],
                        type: na,
                      },
                      {
                        error:
                          "DualStack is enabled but this partition does not support DualStack",
                        type: ou,
                      },
                    ],
                    type: na,
                  },
                  {
                    endpoint: {
                      url: "https://portal.sso.{Region}.{PartitionResult#dnsSuffix}",
                      properties: ss,
                      headers: ss,
                    },
                    type: nu,
                  },
                ],
                type: na,
              },
            ],
            type: na,
          },
          { error: "Invalid Configuration: Missing Region", type: ou },
        ],
      }),
      (Cve = vft);
  });
var Oft,
  _ve,
  wve = s(() => {
    Cw();
    $t();
    bve();
    (Oft = new uo({
      size: 50,
      params: ["Endpoint", "Region", "UseDualStack", "UseFIPS"],
    })),
      (_ve = (e, t = {}) =>
        Oft.get(e, () => jr(Cve, { endpointParams: e, logger: t.logger })));
    Jt.aws = ty;
  });
var Tve,
  Ave = s(() => {
    rt();
    Ue();
    qe();
    ny();
    q$();
    uy();
    C$();
    wve();
    Tve = (e) => ({
      apiVersion: "2019-06-10",
      base64Decoder: e?.base64Decoder ?? _T,
      base64Encoder: e?.base64Encoder ?? wT,
      disableHostPrefix: e?.disableHostPrefix ?? !1,
      endpointProvider: e?.endpointProvider ?? _ve,
      extensions: e?.extensions ?? [],
      httpAuthSchemeProvider: e?.httpAuthSchemeProvider ?? xPe,
      httpAuthSchemes: e?.httpAuthSchemes ?? [
        {
          schemeId: "aws.auth#sigv4",
          identityProvider: (t) => t.getIdentityProvider("aws.auth#sigv4"),
          signer: new wr(),
        },
        {
          schemeId: "smithy.api#noAuth",
          identityProvider: (t) =>
            t.getIdentityProvider("smithy.api#noAuth") || (async () => ({})),
          signer: new hn(),
        },
      ],
      logger: e?.logger ?? new ac(),
      serviceId: e?.serviceId ?? "SSO",
      urlParser: e?.urlParser ?? Si,
      utf8Decoder: e?.utf8Decoder ?? fc,
      utf8Encoder: e?.utf8Encoder ?? ET,
    });
  });
var Rve,
  V$,
  W$,
  Ive,
  Pve,
  vve,
  Ove = s(() => {
    (Rve = "AWS_EXECUTION_ENV"),
      (V$ = "AWS_REGION"),
      (W$ = "AWS_DEFAULT_REGION"),
      (Ive = "AWS_EC2_METADATA_DISABLED"),
      (Pve = ["in-region", "cross-region", "mobile", "standard", "legacy"]),
      (vve = "/latest/meta-data/placement/region");
  });
var kft,
  Dft,
  kve,
  Dve = s(() => {
    (kft = "AWS_DEFAULTS_MODE"),
      (Dft = "defaults_mode"),
      (kve = {
        environmentVariableSelector: (e) => e[kft],
        configFileSelector: (e) => e[Dft],
        default: "legacy",
      });
  });
var TT,
  Nft,
  Bft,
  Nve = s(() => {
    zf();
    Id();
    re();
    Ove();
    Dve();
    (TT = ({ region: e = lr(Hf), defaultsMode: t = lr(kve) } = {}) =>
      gr(async () => {
        let r = typeof t == "function" ? await t() : t;
        switch (r?.toLowerCase()) {
          case "auto":
            return Nft(e);
          case "in-region":
          case "cross-region":
          case "mobile":
          case "standard":
          case "legacy":
            return Promise.resolve(r?.toLocaleLowerCase());
          case void 0:
            return Promise.resolve("legacy");
          default:
            throw new Error(
              `Invalid parameter for "defaultsMode", expect ${Pve.join(", ")}, got ${r}`
            );
        }
      })),
      (Nft = async (e) => {
        if (e) {
          let t = typeof e == "function" ? await e() : e,
            r = await Bft();
          return r ? (t === r ? "in-region" : "cross-region") : "standard";
        }
        return "standard";
      }),
      (Bft = async () => {
        if (process.env[Rve] && (process.env[V$] || process.env[W$]))
          return process.env[V$] ?? process.env[W$];
        if (!process.env[Ive])
          try {
            let { getInstanceMetadataEndpoint: e, httpRequest: t } =
                await Promise.resolve().then(() => (fy(), ly)),
              r = await e();
            return (await t({ ...r, path: vve })).toString();
          } catch {}
      });
  });
var K$ = s(() => {
  Nve();
});
var Bve,
  Mve = s(() => {
    CPe();
    rt();
    w$();
    zf();
    v$();
    cy();
    Id();
    U$();
    $$();
    Ci();
    Ave();
    qe();
    K$();
    qe();
    Bve = (e) => {
      tT(process.version);
      let t = TT(e),
        r = () => t().then(eT),
        o = Tve(e);
      $o(process.version);
      let n = { profile: e?.profile, logger: o.logger };
      return {
        ...o,
        ...e,
        runtime: "node",
        defaultsMode: t,
        authSchemePreference: e?.authSchemePreference ?? lr(Ho, n),
        bodyLengthChecker: e?.bodyLengthChecker ?? bT,
        defaultUserAgentProvider:
          e?.defaultUserAgentProvider ??
          yT({ serviceId: o.serviceId, clientVersion: bPe.version }),
        maxAttempts: e?.maxAttempts ?? lr(Yw, e),
        region: e?.region ?? lr(Hf, { ...Pw, ...n }),
        requestHandler: ru.create(e?.requestHandler ?? r),
        retryMode:
          e?.retryMode ??
          lr({ ...Xw, default: async () => (await r()).retryMode || Gf }, e),
        sha256: e?.sha256 ?? Nd.bind(null, "sha256"),
        streamCollector: e?.streamCollector ?? CT,
        useDualstackEndpoint: e?.useDualstackEndpoint ?? lr(Rw, n),
        useFipsEndpoint: e?.useFipsEndpoint ?? lr(Iw, n),
        userAgentAppId: e?.userAgentAppId ?? lr(xT, n),
      };
    };
  });
var Lve,
  Fve,
  Uve = s(() => {
    (Lve = (e) => {
      let t = e.httpAuthSchemes,
        r = e.httpAuthSchemeProvider,
        o = e.credentials;
      return {
        setHttpAuthScheme(n) {
          let i = t.findIndex((a) => a.schemeId === n.schemeId);
          i === -1 ? t.push(n) : t.splice(i, 1, n);
        },
        httpAuthSchemes() {
          return t;
        },
        setHttpAuthSchemeProvider(n) {
          r = n;
        },
        httpAuthSchemeProvider() {
          return r;
        },
        setCredentials(n) {
          o = n;
        },
        credentials() {
          return o;
        },
      };
    }),
      (Fve = (e) => ({
        httpAuthSchemes: e.httpAuthSchemes(),
        httpAuthSchemeProvider: e.httpAuthSchemeProvider(),
        credentials: e.credentials(),
      }));
  });
var $ve,
  Hve = s(() => {
    Xi();
    Cn();
    qe();
    Uve();
    $ve = (e, t) => {
      let r = Object.assign(Go(e), rT(e), fw(e), Lve(e));
      return (
        t.forEach((o) => o.configure(r)),
        Object.assign(e, Vo(r), oT(r), uw(r), Fve(r))
      );
    };
  });
var bi,
  gy = s(() => {
    hU();
    gU();
    xU();
    Aw();
    zf();
    Ue();
    NU();
    Lt();
    cy();
    qe();
    C$();
    eu();
    Mve();
    Hve();
    bi = class extends Xf {
      config;
      constructor(...[t]) {
        let r = Bve(t || {});
        super(r), (this.initConfig = r);
        let o = SPe(r),
          n = Sw(o),
          i = Qw(n),
          a = Ow(i),
          c = a,
          d = zw(c),
          m = EPe(d),
          f = $ve(m, t?.extensions || []);
        (this.config = f),
          this.middlewareStack.use(Tw(this.config)),
          this.middlewareStack.use(nT(this.config)),
          this.middlewareStack.use(kw(this.config)),
          this.middlewareStack.use(pw(this.config)),
          this.middlewareStack.use(hw(this.config)),
          this.middlewareStack.use(gw(this.config)),
          this.middlewareStack.use(
            Mo(this.config, {
              httpAuthSchemeParametersProvider: yPe,
              identityProviderConfigProvider: async (l) =>
                new fo({ "aws.auth#sigv4": l.credentials }),
            })
          ),
          this.middlewareStack.use(Lo(this.config));
      }
      destroy() {
        super.destroy();
      }
    };
  });
var sa,
  Y$ = s(() => {
    qe();
    sa = class e extends Jf {
      constructor(t) {
        super(t), Object.setPrototypeOf(this, e.prototype);
      }
    };
  });
var AT,
  RT,
  IT,
  PT,
  zve,
  Lft,
  qve,
  jve,
  Gve,
  Vve,
  Bd = s(() => {
    qe();
    Y$();
    (AT = class e extends sa {
      name = "InvalidRequestException";
      $fault = "client";
      constructor(t) {
        super({ name: "InvalidRequestException", $fault: "client", ...t }),
          Object.setPrototypeOf(this, e.prototype);
      }
    }),
      (RT = class e extends sa {
        name = "ResourceNotFoundException";
        $fault = "client";
        constructor(t) {
          super({ name: "ResourceNotFoundException", $fault: "client", ...t }),
            Object.setPrototypeOf(this, e.prototype);
        }
      }),
      (IT = class e extends sa {
        name = "TooManyRequestsException";
        $fault = "client";
        constructor(t) {
          super({ name: "TooManyRequestsException", $fault: "client", ...t }),
            Object.setPrototypeOf(this, e.prototype);
        }
      }),
      (PT = class e extends sa {
        name = "UnauthorizedException";
        $fault = "client";
        constructor(t) {
          super({ name: "UnauthorizedException", $fault: "client", ...t }),
            Object.setPrototypeOf(this, e.prototype);
        }
      }),
      (zve = (e) => ({ ...e, ...(e.accessToken && { accessToken: kd }) })),
      (Lft = (e) => ({
        ...e,
        ...(e.secretAccessKey && { secretAccessKey: kd }),
        ...(e.sessionToken && { sessionToken: kd }),
      })),
      (qve = (e) => ({
        ...e,
        ...(e.roleCredentials && { roleCredentials: Lft(e.roleCredentials) }),
      })),
      (jve = (e) => ({ ...e, ...(e.accessToken && { accessToken: kd }) })),
      (Gve = (e) => ({ ...e, ...(e.accessToken && { accessToken: kd }) })),
      (Vve = (e) => ({ ...e, ...(e.accessToken && { accessToken: kd }) }));
  });
var Wve,
  Kve,
  Yve,
  Qve,
  Xve,
  Jve,
  Zve,
  e0e,
  vT,
  Fft,
  Uft,
  $ft,
  Hft,
  zft,
  uc,
  t0e,
  OT,
  r0e,
  o0e,
  n0e,
  s0e,
  i0e,
  qft,
  jft,
  kT,
  yy = s(() => {
    rt();
    Ue();
    qe();
    Bd();
    Y$();
    (Wve = async (e, t) => {
      let r = G(e, t),
        o = Oo({}, ay, { [kT]: e[OT] });
      r.bp("/federation/credentials");
      let n = Oo({
        [jft]: [, F(e[qft], "roleName")],
        [r0e]: [, F(e[t0e], "accountId")],
      });
      return (
        r
          .m("GET")
          .h(o)
          .q(n)
          .b(void 0),
        r.build()
      );
    }),
      (Kve = async (e, t) => {
        let r = G(e, t),
          o = Oo({}, ay, { [kT]: e[OT] });
        r.bp("/assignment/roles");
        let n = Oo({
          [i0e]: [, e[s0e]],
          [n0e]: [() => e.maxResults !== void 0, () => e[o0e].toString()],
          [r0e]: [, F(e[t0e], "accountId")],
        });
        return (
          r
            .m("GET")
            .h(o)
            .q(n)
            .b(void 0),
          r.build()
        );
      }),
      (Yve = async (e, t) => {
        let r = G(e, t),
          o = Oo({}, ay, { [kT]: e[OT] });
        r.bp("/assignment/accounts");
        let n = Oo({
          [i0e]: [, e[s0e]],
          [n0e]: [() => e.maxResults !== void 0, () => e[o0e].toString()],
        });
        return (
          r
            .m("GET")
            .h(o)
            .q(n)
            .b(void 0),
          r.build()
        );
      }),
      (Qve = async (e, t) => {
        let r = G(e, t),
          o = Oo({}, ay, { [kT]: e[OT] });
        return (
          r.bp("/logout"),
          r
            .m("POST")
            .h(o)
            .b(void 0),
          r.build()
        );
      }),
      (Xve = async (e, t) => {
        if (e.statusCode !== 200 && e.statusCode >= 300) return vT(e, t);
        let r = Oo({ $metadata: uc(e) }),
          o = F(Se(await ie(e.body, t)), "body"),
          n = ot(o, { roleCredentials: Me });
        return Object.assign(r, n), r;
      }),
      (Jve = async (e, t) => {
        if (e.statusCode !== 200 && e.statusCode >= 300) return vT(e, t);
        let r = Oo({ $metadata: uc(e) }),
          o = F(Se(await ie(e.body, t)), "body"),
          n = ot(o, { nextToken: p, roleList: Me });
        return Object.assign(r, n), r;
      }),
      (Zve = async (e, t) => {
        if (e.statusCode !== 200 && e.statusCode >= 300) return vT(e, t);
        let r = Oo({ $metadata: uc(e) }),
          o = F(Se(await ie(e.body, t)), "body"),
          n = ot(o, { accountList: Me, nextToken: p });
        return Object.assign(r, n), r;
      }),
      (e0e = async (e, t) => {
        if (e.statusCode !== 200 && e.statusCode >= 300) return vT(e, t);
        let r = Oo({ $metadata: uc(e) });
        return await ne(e.body, t), r;
      }),
      (vT = async (e, t) => {
        let r = { ...e, body: await Gn(e.body, t) },
          o = Vn(e, r.body);
        switch (o) {
          case "InvalidRequestException":
          case "com.amazonaws.sso#InvalidRequestException":
            throw await Uft(r, t);
          case "ResourceNotFoundException":
          case "com.amazonaws.sso#ResourceNotFoundException":
            throw await $ft(r, t);
          case "TooManyRequestsException":
          case "com.amazonaws.sso#TooManyRequestsException":
            throw await Hft(r, t);
          case "UnauthorizedException":
          case "com.amazonaws.sso#UnauthorizedException":
            throw await zft(r, t);
          default:
            let n = r.body;
            return Fft({ output: e, parsedBody: n, errorCode: o });
        }
      }),
      (Fft = Zw(sa)),
      (Uft = async (e, t) => {
        let r = Oo({}),
          o = e.body,
          n = ot(o, { message: p });
        Object.assign(r, n);
        let i = new AT({ $metadata: uc(e), ...r });
        return ht(i, e.body);
      }),
      ($ft = async (e, t) => {
        let r = Oo({}),
          o = e.body,
          n = ot(o, { message: p });
        Object.assign(r, n);
        let i = new RT({ $metadata: uc(e), ...r });
        return ht(i, e.body);
      }),
      (Hft = async (e, t) => {
        let r = Oo({}),
          o = e.body,
          n = ot(o, { message: p });
        Object.assign(r, n);
        let i = new IT({ $metadata: uc(e), ...r });
        return ht(i, e.body);
      }),
      (zft = async (e, t) => {
        let r = Oo({}),
          o = e.body,
          n = ot(o, { message: p });
        Object.assign(r, n);
        let i = new PT({ $metadata: uc(e), ...r });
        return ht(i, e.body);
      }),
      (uc = (e) => ({
        httpStatusCode: e.statusCode,
        requestId:
          e.headers["x-amzn-requestid"] ??
          e.headers["x-amzn-request-id"] ??
          e.headers["x-amz-request-id"],
        extendedRequestId: e.headers["x-amz-id-2"],
        cfId: e.headers["x-amz-cf-id"],
      })),
      (t0e = "accountId"),
      (OT = "accessToken"),
      (r0e = "account_id"),
      (o0e = "maxResults"),
      (n0e = "max_result"),
      (s0e = "nextToken"),
      (i0e = "next_token"),
      (qft = "roleName"),
      (jft = "role_name"),
      (kT = "x-amz-sso_bearer_token");
  });
var iu,
  Q$ = s(() => {
    Lt();
    zt();
    qe();
    eu();
    Bd();
    yy();
    iu = class extends (
      Ie.classBuilder()
        .ep(lc)
        .m(function (t, r, o, n) {
          return [
            Pe(o, this.serialize, this.deserialize),
            ve(o, t.getEndpointParameterInstructions()),
          ];
        })
        .s("SWBPortalService", "GetRoleCredentials", {})
        .n("SSOClient", "GetRoleCredentialsCommand")
        .f(zve, qve)
        .ser(Wve)
        .de(Xve)
        .build()
    ) {};
  });
var au,
  DT = s(() => {
    Lt();
    zt();
    qe();
    eu();
    Bd();
    yy();
    au = class extends (
      Ie.classBuilder()
        .ep(lc)
        .m(function (t, r, o, n) {
          return [
            Pe(o, this.serialize, this.deserialize),
            ve(o, t.getEndpointParameterInstructions()),
          ];
        })
        .s("SWBPortalService", "ListAccountRoles", {})
        .n("SSOClient", "ListAccountRolesCommand")
        .f(jve, void 0)
        .ser(Kve)
        .de(Jve)
        .build()
    ) {};
  });
var cu,
  NT = s(() => {
    Lt();
    zt();
    qe();
    eu();
    Bd();
    yy();
    cu = class extends (
      Ie.classBuilder()
        .ep(lc)
        .m(function (t, r, o, n) {
          return [
            Pe(o, this.serialize, this.deserialize),
            ve(o, t.getEndpointParameterInstructions()),
          ];
        })
        .s("SWBPortalService", "ListAccounts", {})
        .n("SSOClient", "ListAccountsCommand")
        .f(Gve, void 0)
        .ser(Yve)
        .de(Zve)
        .build()
    ) {};
  });
var BT,
  X$ = s(() => {
    Lt();
    zt();
    qe();
    eu();
    Bd();
    yy();
    BT = class extends (
      Ie.classBuilder()
        .ep(lc)
        .m(function (t, r, o, n) {
          return [
            Pe(o, this.serialize, this.deserialize),
            ve(o, t.getEndpointParameterInstructions()),
          ];
        })
        .s("SWBPortalService", "Logout", {})
        .n("SSOClient", "LogoutCommand")
        .f(Vve, void 0)
        .ser(Qve)
        .de(e0e)
        .build()
    ) {};
  });
var Gft,
  J$,
  a0e = s(() => {
    qe();
    Q$();
    DT();
    NT();
    X$();
    gy();
    (Gft = {
      GetRoleCredentialsCommand: iu,
      ListAccountRolesCommand: au,
      ListAccountsCommand: cu,
      LogoutCommand: BT,
    }),
      (J$ = class extends bi {});
    Jw(Gft, J$);
  });
var c0e = s(() => {
  Q$();
  DT();
  NT();
  X$();
});
var d0e = s(() => {});
var DYr,
  m0e = s(() => {
    Ue();
    DT();
    gy();
    DYr = dt(bi, au, "nextToken", "nextToken", "maxResults");
  });
var FYr,
  l0e = s(() => {
    Ue();
    NT();
    gy();
    FYr = dt(bi, cu, "nextToken", "nextToken", "maxResults");
  });
var f0e = s(() => {
  d0e();
  m0e();
  l0e();
});
var u0e = s(() => {
  Bd();
});
var p0e = s(() => {
  gy();
  a0e();
  c0e();
  f0e();
  u0e();
});
var h0e = {};
It(h0e, { GetRoleCredentialsCommand: () => iu, SSOClient: () => bi });
var g0e = s(() => {
  p0e();
});
var xy,
  Z$,
  y0e = s(() => {
    xt();
    gPe();
    re();
    qs();
    (xy = !1),
      (Z$ = async ({
        ssoStartUrl: e,
        ssoSession: t,
        ssoAccountId: r,
        ssoRegion: o,
        ssoRoleName: n,
        ssoClient: i,
        clientConfig: a,
        parentClientConfig: c,
        profile: d,
        logger: m,
      }) => {
        let f,
          l =
            "To refresh this SSO session run aws sso login with the corresponding profile.";
        if (t)
          try {
            let yt = await fPe({ profile: d })();
            f = {
              accessToken: yt.token,
              expiresAt: new Date(yt.expiration).toISOString(),
            };
          } catch (yt) {
            throw new P(yt.message, { tryNextLink: xy, logger: m });
          }
        else
          try {
            f = await Bw(e);
          } catch {
            throw new P(
              `The SSO session associated with this profile is invalid. ${l}`,
              { tryNextLink: xy, logger: m }
            );
          }
        if (new Date(f.expiresAt).getTime() - Date.now() <= 0)
          throw new P(
            `The SSO session associated with this profile has expired. ${l}`,
            { tryNextLink: xy, logger: m }
          );
        let { accessToken: u } = f,
          { SSOClient: h, GetRoleCredentialsCommand: y } =
            await Promise.resolve().then(() => (g0e(), h0e)),
          S =
            i ||
            new h(
              Object.assign({}, a ?? {}, {
                logger: a?.logger ?? c?.logger,
                region: a?.region ?? o,
              })
            ),
          E;
        try {
          E = await S.send(
            new y({ accountId: r, roleName: n, accessToken: u })
          );
        } catch (yt) {
          throw new P(yt, { tryNextLink: xy, logger: m });
        }
        let {
          roleCredentials: {
            accessKeyId: b,
            secretAccessKey: v,
            sessionToken: I,
            expiration: O,
            credentialScope: ge,
            accountId: Fe,
          } = {},
        } = E;
        if (!b || !v || !I || !O)
          throw new P("SSO returns an invalid temporary credential.", {
            tryNextLink: xy,
            logger: m,
          });
        let Vt = {
          accessKeyId: b,
          secretAccessKey: v,
          sessionToken: I,
          expiration: new Date(O),
          ...(ge && { credentialScope: ge }),
          ...(Fe && { accountId: Fe }),
        };
        return (
          t
            ? ce(Vt, "CREDENTIALS_SSO", "s")
            : ce(Vt, "CREDENTIALS_SSO_LEGACY", "u"),
          Vt
        );
      });
  });
var e1,
  t1 = s(() => {
    re();
    e1 = (e, t) => {
      let {
        sso_start_url: r,
        sso_account_id: o,
        sso_region: n,
        sso_role_name: i,
      } = e;
      if (!r || !o || !n || !i)
        throw new P(
          `Profile is configured with invalid SSO credentials. Required parameters "sso_account_id", "sso_region", "sso_role_name", "sso_start_url". Got ${Object.keys(e).join(", ")}
Reference: https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-sso.html`,
          { tryNextLink: !1, logger: t }
        );
      return e;
    };
  });
var Vft,
  x0e = s(() => {
    re();
    qs();
    E$();
    y0e();
    t1();
    Vft =
      (e = {}) =>
      async ({ callerClientConfig: t } = {}) => {
        e.logger?.debug("@aws-sdk/credential-provider-sso - fromSSO");
        let {
            ssoStartUrl: r,
            ssoAccountId: o,
            ssoRegion: n,
            ssoRoleName: i,
            ssoSession: a,
          } = e,
          { ssoClient: c } = e,
          d = os({ profile: e.profile ?? t?.profile });
        if (!r && !o && !n && !i && !a) {
          let f = (await sc(e))[d];
          if (!f)
            throw new P(`Profile ${d} was not found.`, { logger: e.logger });
          if (!x$(f))
            throw new P(
              `Profile ${d} is not configured with SSO credentials.`,
              { logger: e.logger }
            );
          if (f?.sso_session) {
            let b = (await Fw(e))[f.sso_session],
              v = ` configurations in profile ${d} and sso-session ${f.sso_session}`;
            if (n && n !== b.sso_region)
              throw new P("Conflicting SSO region" + v, {
                tryNextLink: !1,
                logger: e.logger,
              });
            if (r && r !== b.sso_start_url)
              throw new P("Conflicting SSO start_url" + v, {
                tryNextLink: !1,
                logger: e.logger,
              });
            (f.sso_region = b.sso_region), (f.sso_start_url = b.sso_start_url);
          }
          let {
            sso_start_url: l,
            sso_account_id: u,
            sso_region: h,
            sso_role_name: y,
            sso_session: S,
          } = e1(f, e.logger);
          return Z$({
            ssoStartUrl: l,
            ssoSession: S,
            ssoAccountId: u,
            ssoRegion: h,
            ssoRoleName: y,
            ssoClient: c,
            clientConfig: e.clientConfig,
            parentClientConfig: e.parentClientConfig,
            profile: d,
          });
        } else {
          if (!r || !o || !n || !i)
            throw new P(
              'Incomplete configuration. The fromSSO() argument hash must include "ssoStartUrl", "ssoAccountId", "ssoRegion", "ssoRoleName"',
              { tryNextLink: !1, logger: e.logger }
            );
          return Z$({
            ssoStartUrl: r,
            ssoSession: a,
            ssoAccountId: o,
            ssoRegion: n,
            ssoRoleName: i,
            ssoClient: c,
            clientConfig: e.clientConfig,
            parentClientConfig: e.parentClientConfig,
            profile: d,
          });
        }
      };
  });
var E0e = s(() => {});
var r1 = {};
It(r1, {
  fromSSO: () => Vft,
  isSsoProfile: () => x$,
  validateSsoProfile: () => e1,
});
var o1 = s(() => {
  x0e();
  E$();
  E0e();
  t1();
});
var S0e,
  n1,
  C0e = s(() => {
    xt();
    re();
    (S0e = (e, t, r) => {
      let o = {
        EcsContainer: async (n) => {
          let { fromHttp: i } = await Promise.resolve().then(() => (ld(), md)),
            { fromContainerMetadata: a } = await Promise.resolve().then(
              () => (fy(), ly)
            );
          return (
            r?.debug(
              "@aws-sdk/credential-provider-ini - credential_source is EcsContainer"
            ),
            async () => Ht(i(n ?? {}), a(n))().then(n1)
          );
        },
        Ec2InstanceMetadata: async (n) => {
          r?.debug(
            "@aws-sdk/credential-provider-ini - credential_source is Ec2InstanceMetadata"
          );
          let { fromInstanceMetadata: i } = await Promise.resolve().then(
            () => (fy(), ly)
          );
          return async () => i(n)().then(n1);
        },
        Environment: async (n) => {
          r?.debug(
            "@aws-sdk/credential-provider-ini - credential_source is Environment"
          );
          let { fromEnv: i } = await Promise.resolve().then(() => (d$(), FIe));
          return async () => i(n)().then(n1);
        },
      };
      if (e in o) return o[e];
      throw new P(
        `Unsupported credential source in profile ${t}. Got ${e}, expected EcsContainer or Ec2InstanceMetadata or Environment.`,
        { logger: r }
      );
    }),
      (n1 = (e) => ce(e, "CREDENTIALS_PROFILE_NAMED_PROVIDER", "p"));
  });
var _0e,
  Wft,
  Kft,
  w0e,
  b0e,
  T0e = s(() => {
    xt();
    re();
    qs();
    C0e();
    s1();
    (_0e = (e, { profile: t = "default", logger: r } = {}) =>
      !!e &&
      typeof e == "object" &&
      typeof e.role_arn == "string" &&
      ["undefined", "string"].indexOf(typeof e.role_session_name) > -1 &&
      ["undefined", "string"].indexOf(typeof e.external_id) > -1 &&
      ["undefined", "string"].indexOf(typeof e.mfa_serial) > -1 &&
      (Wft(e, { profile: t, logger: r }) || Kft(e, { profile: t, logger: r }))),
      (Wft = (e, { profile: t, logger: r }) => {
        let o =
          typeof e.source_profile == "string" &&
          typeof e.credential_source > "u";
        return (
          o &&
            r?.debug?.(
              `    ${t} isAssumeRoleWithSourceProfile source_profile=${e.source_profile}`
            ),
          o
        );
      }),
      (Kft = (e, { profile: t, logger: r }) => {
        let o =
          typeof e.credential_source == "string" &&
          typeof e.source_profile > "u";
        return (
          o &&
            r?.debug?.(
              `    ${t} isCredentialSourceProfile credential_source=${e.credential_source}`
            ),
          o
        );
      }),
      (w0e = async (e, t, r, o = {}) => {
        r.logger?.debug(
          "@aws-sdk/credential-provider-ini - resolveAssumeRoleCredentials (STS)"
        );
        let n = t[e],
          { source_profile: i, region: a } = n;
        if (!r.roleAssumer) {
          let { getDefaultRoleAssumer: d } = await Promise.resolve().then(
            () => (Td(), wd)
          );
          r.roleAssumer = d(
            {
              ...r.clientConfig,
              credentialProviderLogger: r.logger,
              parentClientConfig: {
                ...r?.parentClientConfig,
                region: a ?? r?.parentClientConfig?.region,
              },
            },
            r.clientPlugins
          );
        }
        if (i && i in o)
          throw new P(
            `Detected a cycle attempting to resolve credentials for profile ${os(r)}. Profiles visited: ` +
              Object.keys(o).join(", "),
            { logger: r.logger }
          );
        r.logger?.debug(
          `@aws-sdk/credential-provider-ini - finding credential resolver using ${i ? `source_profile=[${i}]` : `profile=[${e}]`}`
        );
        let c = i
          ? MT(i, t, r, { ...o, [i]: !0 }, b0e(t[i] ?? {}))
          : (await S0e(n.credential_source, e, r.logger)(r))();
        if (b0e(n))
          return c.then((d) =>
            ce(d, "CREDENTIALS_PROFILE_SOURCE_PROFILE", "o")
          );
        {
          let d = {
              RoleArn: n.role_arn,
              RoleSessionName:
                n.role_session_name || `aws-sdk-js-${Date.now()}`,
              ExternalId: n.external_id,
              DurationSeconds: parseInt(n.duration_seconds || "3600", 10),
            },
            { mfa_serial: m } = n;
          if (m) {
            if (!r.mfaCodeProvider)
              throw new P(
                `Profile ${e} requires multi-factor authentication, but no MFA code callback was provided.`,
                { logger: r.logger, tryNextLink: !1 }
              );
            (d.SerialNumber = m), (d.TokenCode = await r.mfaCodeProvider(m));
          }
          let f = await c;
          return r
            .roleAssumer(f, d)
            .then((l) => ce(l, "CREDENTIALS_PROFILE_SOURCE_PROFILE", "o"));
        }
      }),
      (b0e = (e) => !e.role_arn && !!e.credential_source);
  });
var A0e,
  R0e = s(() => {
    xt();
    A0e = (e, t, r) => {
      if (t.Version !== 1)
        throw Error(
          `Profile ${e} credential_process did not return Version 1.`
        );
      if (t.AccessKeyId === void 0 || t.SecretAccessKey === void 0)
        throw Error(
          `Profile ${e} credential_process returned invalid credentials.`
        );
      if (t.Expiration) {
        let i = new Date();
        if (new Date(t.Expiration) < i)
          throw Error(
            `Profile ${e} credential_process returned expired credentials.`
          );
      }
      let o = t.AccountId;
      !o && r?.[e]?.aws_account_id && (o = r[e].aws_account_id);
      let n = {
        accessKeyId: t.AccessKeyId,
        secretAccessKey: t.SecretAccessKey,
        ...(t.SessionToken && { sessionToken: t.SessionToken }),
        ...(t.Expiration && { expiration: new Date(t.Expiration) }),
        ...(t.CredentialScope && { credentialScope: t.CredentialScope }),
        ...(o && { accountId: o }),
      };
      return ce(n, "CREDENTIALS_PROCESS", "w"), n;
    };
  });
import { exec as Yft } from "child_process";
import { promisify as Qft } from "util";
var I0e,
  P0e = s(() => {
    re();
    R0e();
    I0e = async (e, t, r) => {
      let o = t[e];
      if (t[e]) {
        let n = o.credential_process;
        if (n !== void 0) {
          let i = Qft(Yft);
          try {
            let { stdout: a } = await i(n),
              c;
            try {
              c = JSON.parse(a.trim());
            } catch {
              throw Error(
                `Profile ${e} credential_process returned invalid JSON.`
              );
            }
            return A0e(e, c, t);
          } catch (a) {
            throw new P(a.message, { logger: r });
          }
        } else
          throw new P(`Profile ${e} did not contain credential_process.`, {
            logger: r,
          });
      } else
        throw new P(
          `Profile ${e} could not be found in shared credentials file.`,
          { logger: r }
        );
    };
  });
var Xft,
  v0e = s(() => {
    qs();
    P0e();
    Xft =
      (e = {}) =>
      async ({ callerClientConfig: t } = {}) => {
        e.logger?.debug("@aws-sdk/credential-provider-process - fromProcess");
        let r = await sc(e);
        return I0e(os({ profile: e.profile ?? t?.profile }), r, e.logger);
      };
  });
var i1 = {};
It(i1, { fromProcess: () => Xft });
var a1 = s(() => {
  v0e();
});
var O0e,
  k0e,
  D0e = s(() => {
    xt();
    (O0e = (e) =>
      !!e && typeof e == "object" && typeof e.credential_process == "string"),
      (k0e = async (e, t) =>
        Promise.resolve()
          .then(() => (a1(), i1))
          .then(({ fromProcess: r }) =>
            r({ ...e, profile: t })().then((o) =>
              ce(o, "CREDENTIALS_PROFILE_PROCESS", "v")
            )
          ));
  });
var N0e,
  B0e,
  M0e = s(() => {
    xt();
    (N0e = async (e, t, r = {}) => {
      let { fromSSO: o } = await Promise.resolve().then(() => (o1(), r1));
      return o({
        profile: e,
        logger: r.logger,
        parentClientConfig: r.parentClientConfig,
        clientConfig: r.clientConfig,
      })().then((n) =>
        t.sso_session
          ? ce(n, "CREDENTIALS_PROFILE_SSO", "r")
          : ce(n, "CREDENTIALS_PROFILE_SSO_LEGACY", "t")
      );
    }),
      (B0e = (e) =>
        e &&
        (typeof e.sso_start_url == "string" ||
          typeof e.sso_account_id == "string" ||
          typeof e.sso_session == "string" ||
          typeof e.sso_region == "string" ||
          typeof e.sso_role_name == "string"));
  });
var c1,
  d1,
  L0e = s(() => {
    xt();
    (c1 = (e) =>
      !!e &&
      typeof e == "object" &&
      typeof e.aws_access_key_id == "string" &&
      typeof e.aws_secret_access_key == "string" &&
      ["undefined", "string"].indexOf(typeof e.aws_session_token) > -1 &&
      ["undefined", "string"].indexOf(typeof e.aws_account_id) > -1),
      (d1 = async (e, t) => {
        t?.logger?.debug(
          "@aws-sdk/credential-provider-ini - resolveStaticCredentials"
        );
        let r = {
          accessKeyId: e.aws_access_key_id,
          secretAccessKey: e.aws_secret_access_key,
          sessionToken: e.aws_session_token,
          ...(e.aws_credential_scope && {
            credentialScope: e.aws_credential_scope,
          }),
          ...(e.aws_account_id && { accountId: e.aws_account_id }),
        };
        return ce(r, "CREDENTIALS_PROFILE", "n");
      });
  });
var m1,
  l1 = s(() => {
    m1 = (e) => async (t) => {
      e.logger?.debug(
        "@aws-sdk/credential-provider-web-identity - fromWebToken"
      );
      let {
          roleArn: r,
          roleSessionName: o,
          webIdentityToken: n,
          providerId: i,
          policyArns: a,
          policy: c,
          durationSeconds: d,
        } = e,
        { roleAssumerWithWebIdentity: m } = e;
      if (!m) {
        let { getDefaultRoleAssumerWithWebIdentity: f } =
          await Promise.resolve().then(() => (Td(), wd));
        m = f(
          {
            ...e.clientConfig,
            credentialProviderLogger: e.logger,
            parentClientConfig: {
              ...t?.callerClientConfig,
              ...e.parentClientConfig,
            },
          },
          e.clientPlugins
        );
      }
      return m({
        RoleArn: r,
        RoleSessionName: o ?? `aws-sdk-js-session-${Date.now()}`,
        WebIdentityToken: n,
        ProviderId: i,
        PolicyArns: a,
        Policy: c,
        DurationSeconds: d,
      });
    };
  });
import { readFileSync as Jft } from "fs";
var F0e,
  Zft,
  eut,
  tut,
  U0e = s(() => {
    xt();
    re();
    l1();
    (F0e = "AWS_WEB_IDENTITY_TOKEN_FILE"),
      (Zft = "AWS_ROLE_ARN"),
      (eut = "AWS_ROLE_SESSION_NAME"),
      (tut =
        (e = {}) =>
        async () => {
          e.logger?.debug(
            "@aws-sdk/credential-provider-web-identity - fromTokenFile"
          );
          let t = e?.webIdentityTokenFile ?? process.env[F0e],
            r = e?.roleArn ?? process.env[Zft],
            o = e?.roleSessionName ?? process.env[eut];
          if (!t || !r)
            throw new P("Web identity configuration not specified", {
              logger: e.logger,
            });
          let n = await m1({
            ...e,
            webIdentityToken: Jft(t, { encoding: "ascii" }),
            roleArn: r,
            roleSessionName: o,
          })();
          return (
            t === process.env[F0e] &&
              ce(n, "CREDENTIALS_ENV_VARS_STS_WEB_ID_TOKEN", "h"),
            n
          );
        });
  });
var f1 = {};
It(f1, { fromTokenFile: () => tut, fromWebToken: () => m1 });
var u1 = s(() => {
  U0e();
  l1();
});
var $0e,
  H0e,
  z0e = s(() => {
    xt();
    ($0e = (e) =>
      !!e &&
      typeof e == "object" &&
      typeof e.web_identity_token_file == "string" &&
      typeof e.role_arn == "string" &&
      ["undefined", "string"].indexOf(typeof e.role_session_name) > -1),
      (H0e = async (e, t) =>
        Promise.resolve()
          .then(() => (u1(), f1))
          .then(({ fromTokenFile: r }) =>
            r({
              webIdentityTokenFile: e.web_identity_token_file,
              roleArn: e.role_arn,
              roleSessionName: e.role_session_name,
              roleAssumerWithWebIdentity: t.roleAssumerWithWebIdentity,
              logger: t.logger,
              parentClientConfig: t.parentClientConfig,
            })().then((o) => ce(o, "CREDENTIALS_PROFILE_STS_WEB_ID_TOKEN", "q"))
          ));
  });
var MT,
  s1 = s(() => {
    re();
    T0e();
    D0e();
    M0e();
    L0e();
    z0e();
    MT = async (e, t, r, o = {}, n = !1) => {
      let i = t[e];
      if (Object.keys(o).length > 0 && c1(i)) return d1(i, r);
      if (n || _0e(i, { profile: e, logger: r.logger })) return w0e(e, t, r, o);
      if (c1(i)) return d1(i, r);
      if ($0e(i)) return H0e(i, r);
      if (O0e(i)) return k0e(r, e);
      if (B0e(i)) return await N0e(e, i, r);
      throw new P(
        `Could not resolve credentials using profile: [${e}] in configuration/credentials file(s).`,
        { logger: r.logger }
      );
    };
  });
var rut,
  q0e = s(() => {
    qs();
    s1();
    rut =
      (e = {}) =>
      async ({ callerClientConfig: t } = {}) => {
        let r = { ...e, parentClientConfig: { ...t, ...e.parentClientConfig } };
        r.logger?.debug("@aws-sdk/credential-provider-ini - fromIni");
        let o = await sc(r);
        return MT(os({ profile: e.profile ?? t?.profile }), o, r);
      };
  });
var j0e = {};
It(j0e, { fromIni: () => rut });
var G0e = s(() => {
  q0e();
});
var V0e,
  W0e,
  out,
  nut,
  K0e = s(() => {
    d$();
    re();
    qs();
    tPe();
    (V0e = !1),
      (W0e = (e = {}) =>
        gr(
          Ht(
            async () => {
              if (e.profile ?? process.env[LU])
                throw (
                  (process.env[sT] &&
                    process.env[iT] &&
                    (V0e ||
                      ((e.logger?.warn &&
                        e.logger?.constructor?.name !== "NoOpLogger"
                        ? e.logger.warn
                        : console.warn)(`@aws-sdk/credential-provider-node - defaultProvider::fromEnv WARNING:
    Multiple credential sources detected: 
    Both AWS_PROFILE and the pair AWS_ACCESS_KEY_ID/AWS_SECRET_ACCESS_KEY static credentials are set.
    This SDK will proceed with the AWS_PROFILE value.
    
    However, a future version may change this behavior to prefer the ENV static credentials.
    Please ensure that your environment only sets either the AWS_PROFILE or the
    AWS_ACCESS_KEY_ID/AWS_SECRET_ACCESS_KEY pair.
`),
                      (V0e = !0))),
                  new P("AWS_PROFILE is set, skipping fromEnv provider.", {
                    logger: e.logger,
                    tryNextLink: !0,
                  }))
                );
              return (
                e.logger?.debug(
                  "@aws-sdk/credential-provider-node - defaultProvider::fromEnv"
                ),
                c$(e)()
              );
            },
            async () => {
              e.logger?.debug(
                "@aws-sdk/credential-provider-node - defaultProvider::fromSSO"
              );
              let {
                ssoStartUrl: t,
                ssoAccountId: r,
                ssoRegion: o,
                ssoRoleName: n,
                ssoSession: i,
              } = e;
              if (!t && !r && !o && !n && !i)
                throw new P(
                  "Skipping SSO provider in default chain (inputs do not include SSO fields).",
                  { logger: e.logger }
                );
              let { fromSSO: a } = await Promise.resolve().then(
                () => (o1(), r1)
              );
              return a(e)();
            },
            async () => {
              e.logger?.debug(
                "@aws-sdk/credential-provider-node - defaultProvider::fromIni"
              );
              let { fromIni: t } = await Promise.resolve().then(
                () => (G0e(), j0e)
              );
              return t(e)();
            },
            async () => {
              e.logger?.debug(
                "@aws-sdk/credential-provider-node - defaultProvider::fromProcess"
              );
              let { fromProcess: t } = await Promise.resolve().then(
                () => (a1(), i1)
              );
              return t(e)();
            },
            async () => {
              e.logger?.debug(
                "@aws-sdk/credential-provider-node - defaultProvider::fromTokenFile"
              );
              let { fromTokenFile: t } = await Promise.resolve().then(
                () => (u1(), f1)
              );
              return t(e)();
            },
            async () => (
              e.logger?.debug(
                "@aws-sdk/credential-provider-node - defaultProvider::remoteProvider"
              ),
              (await ePe(e))()
            ),
            async () => {
              throw new P("Could not load credentials from any providers", {
                tryNextLink: !1,
                logger: e.logger,
              });
            }
          ),
          nut,
          out
        )),
      (out = (e) => e?.expiration !== void 0),
      (nut = (e) =>
        e?.expiration !== void 0 && e.expiration.getTime() - Date.now() < 3e5);
  });
var Y0e = s(() => {
  K0e();
});
var sOe,
  ds,
  ms,
  lu,
  Q0e,
  Ey,
  du,
  mu,
  ia,
  p1,
  h1,
  X0e,
  J0e,
  Z0e,
  iOe,
  aOe,
  cs,
  eOe,
  cOe,
  tOe,
  rOe,
  oOe,
  nOe,
  sut,
  dOe,
  mOe = s(() => {
    (sOe = "required"),
      (ds = "fn"),
      (ms = "argv"),
      (lu = "ref"),
      (Q0e = "isSet"),
      (Ey = "booleanEquals"),
      (du = "error"),
      (mu = "endpoint"),
      (ia = "tree"),
      (p1 = "PartitionResult"),
      (h1 = "getAttr"),
      (X0e = { [sOe]: !1, type: "String" }),
      (J0e = { [sOe]: !0, default: !1, type: "Boolean" }),
      (Z0e = { [lu]: "Endpoint" }),
      (iOe = { [ds]: Ey, [ms]: [{ [lu]: "UseFIPS" }, !0] }),
      (aOe = { [ds]: Ey, [ms]: [{ [lu]: "UseDualStack" }, !0] }),
      (cs = {}),
      (eOe = { [ds]: h1, [ms]: [{ [lu]: p1 }, "supportsFIPS"] }),
      (cOe = { [lu]: p1 }),
      (tOe = {
        [ds]: Ey,
        [ms]: [!0, { [ds]: h1, [ms]: [cOe, "supportsDualStack"] }],
      }),
      (rOe = [iOe]),
      (oOe = [aOe]),
      (nOe = [{ [lu]: "Region" }]),
      (sut = {
        version: "1.0",
        parameters: {
          Region: X0e,
          UseDualStack: J0e,
          UseFIPS: J0e,
          Endpoint: X0e,
        },
        rules: [
          {
            conditions: [{ [ds]: Q0e, [ms]: [Z0e] }],
            rules: [
              {
                conditions: rOe,
                error:
                  "Invalid Configuration: FIPS and custom endpoint are not supported",
                type: du,
              },
              {
                conditions: oOe,
                error:
                  "Invalid Configuration: Dualstack and custom endpoint are not supported",
                type: du,
              },
              { endpoint: { url: Z0e, properties: cs, headers: cs }, type: mu },
            ],
            type: ia,
          },
          {
            conditions: [{ [ds]: Q0e, [ms]: nOe }],
            rules: [
              {
                conditions: [{ [ds]: "aws.partition", [ms]: nOe, assign: p1 }],
                rules: [
                  {
                    conditions: [iOe, aOe],
                    rules: [
                      {
                        conditions: [{ [ds]: Ey, [ms]: [!0, eOe] }, tOe],
                        rules: [
                          {
                            endpoint: {
                              url: "https://sqs-fips.{Region}.{PartitionResult#dualStackDnsSuffix}",
                              properties: cs,
                              headers: cs,
                            },
                            type: mu,
                          },
                        ],
                        type: ia,
                      },
                      {
                        error:
                          "FIPS and DualStack are enabled, but this partition does not support one or both",
                        type: du,
                      },
                    ],
                    type: ia,
                  },
                  {
                    conditions: rOe,
                    rules: [
                      {
                        conditions: [{ [ds]: Ey, [ms]: [eOe, !0] }],
                        rules: [
                          {
                            conditions: [
                              {
                                [ds]: "stringEquals",
                                [ms]: [
                                  { [ds]: h1, [ms]: [cOe, "name"] },
                                  "aws-us-gov",
                                ],
                              },
                            ],
                            endpoint: {
                              url: "https://sqs.{Region}.amazonaws.com",
                              properties: cs,
                              headers: cs,
                            },
                            type: mu,
                          },
                          {
                            endpoint: {
                              url: "https://sqs-fips.{Region}.{PartitionResult#dnsSuffix}",
                              properties: cs,
                              headers: cs,
                            },
                            type: mu,
                          },
                        ],
                        type: ia,
                      },
                      {
                        error:
                          "FIPS is enabled but this partition does not support FIPS",
                        type: du,
                      },
                    ],
                    type: ia,
                  },
                  {
                    conditions: oOe,
                    rules: [
                      {
                        conditions: [tOe],
                        rules: [
                          {
                            endpoint: {
                              url: "https://sqs.{Region}.{PartitionResult#dualStackDnsSuffix}",
                              properties: cs,
                              headers: cs,
                            },
                            type: mu,
                          },
                        ],
                        type: ia,
                      },
                      {
                        error:
                          "DualStack is enabled but this partition does not support DualStack",
                        type: du,
                      },
                    ],
                    type: ia,
                  },
                  {
                    endpoint: {
                      url: "https://sqs.{Region}.{PartitionResult#dnsSuffix}",
                      properties: cs,
                      headers: cs,
                    },
                    type: mu,
                  },
                ],
                type: ia,
              },
            ],
            type: ia,
          },
          { error: "Invalid Configuration: Missing Region", type: du },
        ],
      }),
      (dOe = sut);
  });
var iut,
  lOe,
  fOe = s(() => {
    Cw();
    $t();
    mOe();
    (iut = new uo({
      size: 50,
      params: ["Endpoint", "Region", "UseDualStack", "UseFIPS"],
    })),
      (lOe = (e, t = {}) =>
        iut.get(e, () => jr(dOe, { endpointParams: e, logger: t.logger })));
    Jt.aws = ty;
  });
var uOe,
  pOe = s(() => {
    rt();
    qe();
    ny();
    q$();
    uy();
    a$();
    fOe();
    uOe = (e) => ({
      apiVersion: "2012-11-05",
      base64Decoder: e?.base64Decoder ?? _T,
      base64Encoder: e?.base64Encoder ?? wT,
      disableHostPrefix: e?.disableHostPrefix ?? !1,
      endpointProvider: e?.endpointProvider ?? lOe,
      extensions: e?.extensions ?? [],
      httpAuthSchemeProvider: e?.httpAuthSchemeProvider ?? IIe,
      httpAuthSchemes: e?.httpAuthSchemes ?? [
        {
          schemeId: "aws.auth#sigv4",
          identityProvider: (t) => t.getIdentityProvider("aws.auth#sigv4"),
          signer: new wr(),
        },
      ],
      logger: e?.logger ?? new ac(),
      serviceId: e?.serviceId ?? "SQS",
      urlParser: e?.urlParser ?? Si,
      utf8Decoder: e?.utf8Decoder ?? fc,
      utf8Encoder: e?.utf8Encoder ?? ET,
    });
  });
var hOe,
  gOe = s(() => {
    OIe();
    rt();
    Y0e();
    w$();
    zf();
    v$();
    cy();
    Id();
    U$();
    $$();
    Ci();
    pOe();
    qe();
    K$();
    qe();
    hOe = (e) => {
      tT(process.version);
      let t = TT(e),
        r = () => t().then(eT),
        o = uOe(e);
      $o(process.version);
      let n = { profile: e?.profile, logger: o.logger };
      return {
        ...o,
        ...e,
        runtime: "node",
        defaultsMode: t,
        authSchemePreference: e?.authSchemePreference ?? lr(Ho, n),
        bodyLengthChecker: e?.bodyLengthChecker ?? bT,
        credentialDefaultProvider: e?.credentialDefaultProvider ?? W0e,
        defaultUserAgentProvider:
          e?.defaultUserAgentProvider ??
          yT({ serviceId: o.serviceId, clientVersion: kIe.version }),
        maxAttempts: e?.maxAttempts ?? lr(Yw, e),
        md5: e?.md5 ?? Nd.bind(null, "md5"),
        region: e?.region ?? lr(Hf, { ...Pw, ...n }),
        requestHandler: ru.create(e?.requestHandler ?? r),
        retryMode:
          e?.retryMode ??
          lr({ ...Xw, default: async () => (await r()).retryMode || Gf }, e),
        sha256: e?.sha256 ?? Nd.bind(null, "sha256"),
        streamCollector: e?.streamCollector ?? CT,
        useDualstackEndpoint: e?.useDualstackEndpoint ?? lr(Rw, n),
        useFipsEndpoint: e?.useFipsEndpoint ?? lr(Iw, n),
        userAgentAppId: e?.userAgentAppId ?? lr(xT, n),
      };
    };
  });
var yOe,
  xOe,
  EOe = s(() => {
    (yOe = (e) => {
      let t = e.httpAuthSchemes,
        r = e.httpAuthSchemeProvider,
        o = e.credentials;
      return {
        setHttpAuthScheme(n) {
          let i = t.findIndex((a) => a.schemeId === n.schemeId);
          i === -1 ? t.push(n) : t.splice(i, 1, n);
        },
        httpAuthSchemes() {
          return t;
        },
        setHttpAuthSchemeProvider(n) {
          r = n;
        },
        httpAuthSchemeProvider() {
          return r;
        },
        setCredentials(n) {
          o = n;
        },
        credentials() {
          return o;
        },
      };
    }),
      (xOe = (e) => ({
        httpAuthSchemes: e.httpAuthSchemes(),
        httpAuthSchemeProvider: e.httpAuthSchemeProvider(),
        credentials: e.credentials(),
      }));
  });
var SOe,
  COe = s(() => {
    Xi();
    Cn();
    qe();
    EOe();
    SOe = (e, t) => {
      let r = Object.assign(Go(e), rT(e), fw(e), yOe(e));
      return (
        t.forEach((o) => o.configure(r)),
        Object.assign(e, Vo(r), oT(r), uw(r), xOe(r))
      );
    };
  });
var _i,
  Sy = s(() => {
    hU();
    gU();
    xU();
    ey();
    Aw();
    zf();
    Ue();
    NU();
    Lt();
    cy();
    qe();
    a$();
    yr();
    gOe();
    COe();
    _i = class extends Xf {
      config;
      constructor(...[t]) {
        let r = hOe(t || {});
        super(r), (this.initConfig = r);
        let o = vIe(r),
          n = Sw(o),
          i = Qw(n),
          a = Ow(i),
          c = a,
          d = zw(c),
          m = OTe(d),
          f = PIe(m),
          l = SOe(f, t?.extensions || []);
        (this.config = l),
          this.middlewareStack.use(Tw(this.config)),
          this.middlewareStack.use(nT(this.config)),
          this.middlewareStack.use(kw(this.config)),
          this.middlewareStack.use(pw(this.config)),
          this.middlewareStack.use(hw(this.config)),
          this.middlewareStack.use(gw(this.config)),
          this.middlewareStack.use(kTe(this.config)),
          this.middlewareStack.use(
            Mo(this.config, {
              httpAuthSchemeParametersProvider: RIe,
              identityProviderConfigProvider: async (u) =>
                new fo({ "aws.auth#sigv4": u.credentials }),
            })
          ),
          this.middlewareStack.use(Lo(this.config));
      }
      destroy() {
        super.destroy();
      }
    };
  });
var At,
  g1 = s(() => {
    qe();
    At = class e extends Jf {
      constructor(t) {
        super(t), Object.setPrototypeOf(this, e.prototype);
      }
    };
  });
var LT,
  FT,
  UT,
  $T,
  HT,
  zT,
  qT,
  jT,
  GT,
  VT,
  WT,
  KT,
  YT,
  QT,
  XT,
  JT,
  ZT,
  eA,
  tA,
  rA,
  oA,
  nA,
  sA,
  iA,
  aA,
  cA,
  dA,
  mA,
  y1 = s(() => {
    g1();
    (LT = class e extends At {
      name = "InvalidAddress";
      $fault = "client";
      constructor(t) {
        super({ name: "InvalidAddress", $fault: "client", ...t }),
          Object.setPrototypeOf(this, e.prototype);
      }
    }),
      (FT = class e extends At {
        name = "InvalidSecurity";
        $fault = "client";
        constructor(t) {
          super({ name: "InvalidSecurity", $fault: "client", ...t }),
            Object.setPrototypeOf(this, e.prototype);
        }
      }),
      (UT = class e extends At {
        name = "OverLimit";
        $fault = "client";
        constructor(t) {
          super({ name: "OverLimit", $fault: "client", ...t }),
            Object.setPrototypeOf(this, e.prototype);
        }
      }),
      ($T = class e extends At {
        name = "QueueDoesNotExist";
        $fault = "client";
        constructor(t) {
          super({ name: "QueueDoesNotExist", $fault: "client", ...t }),
            Object.setPrototypeOf(this, e.prototype);
        }
      }),
      (HT = class e extends At {
        name = "RequestThrottled";
        $fault = "client";
        constructor(t) {
          super({ name: "RequestThrottled", $fault: "client", ...t }),
            Object.setPrototypeOf(this, e.prototype);
        }
      }),
      (zT = class e extends At {
        name = "UnsupportedOperation";
        $fault = "client";
        constructor(t) {
          super({ name: "UnsupportedOperation", $fault: "client", ...t }),
            Object.setPrototypeOf(this, e.prototype);
        }
      }),
      (qT = class e extends At {
        name = "ResourceNotFoundException";
        $fault = "client";
        constructor(t) {
          super({ name: "ResourceNotFoundException", $fault: "client", ...t }),
            Object.setPrototypeOf(this, e.prototype);
        }
      }),
      (jT = class e extends At {
        name = "MessageNotInflight";
        $fault = "client";
        constructor(t) {
          super({ name: "MessageNotInflight", $fault: "client", ...t }),
            Object.setPrototypeOf(this, e.prototype);
        }
      }),
      (GT = class e extends At {
        name = "ReceiptHandleIsInvalid";
        $fault = "client";
        constructor(t) {
          super({ name: "ReceiptHandleIsInvalid", $fault: "client", ...t }),
            Object.setPrototypeOf(this, e.prototype);
        }
      }),
      (VT = class e extends At {
        name = "BatchEntryIdsNotDistinct";
        $fault = "client";
        constructor(t) {
          super({ name: "BatchEntryIdsNotDistinct", $fault: "client", ...t }),
            Object.setPrototypeOf(this, e.prototype);
        }
      }),
      (WT = class e extends At {
        name = "EmptyBatchRequest";
        $fault = "client";
        constructor(t) {
          super({ name: "EmptyBatchRequest", $fault: "client", ...t }),
            Object.setPrototypeOf(this, e.prototype);
        }
      }),
      (KT = class e extends At {
        name = "InvalidBatchEntryId";
        $fault = "client";
        constructor(t) {
          super({ name: "InvalidBatchEntryId", $fault: "client", ...t }),
            Object.setPrototypeOf(this, e.prototype);
        }
      }),
      (YT = class e extends At {
        name = "TooManyEntriesInBatchRequest";
        $fault = "client";
        constructor(t) {
          super({
            name: "TooManyEntriesInBatchRequest",
            $fault: "client",
            ...t,
          }),
            Object.setPrototypeOf(this, e.prototype);
        }
      }),
      (QT = class e extends At {
        name = "InvalidAttributeName";
        $fault = "client";
        constructor(t) {
          super({ name: "InvalidAttributeName", $fault: "client", ...t }),
            Object.setPrototypeOf(this, e.prototype);
        }
      }),
      (XT = class e extends At {
        name = "InvalidAttributeValue";
        $fault = "client";
        constructor(t) {
          super({ name: "InvalidAttributeValue", $fault: "client", ...t }),
            Object.setPrototypeOf(this, e.prototype);
        }
      }),
      (JT = class e extends At {
        name = "QueueDeletedRecently";
        $fault = "client";
        constructor(t) {
          super({ name: "QueueDeletedRecently", $fault: "client", ...t }),
            Object.setPrototypeOf(this, e.prototype);
        }
      }),
      (ZT = class e extends At {
        name = "QueueNameExists";
        $fault = "client";
        constructor(t) {
          super({ name: "QueueNameExists", $fault: "client", ...t }),
            Object.setPrototypeOf(this, e.prototype);
        }
      }),
      (eA = class e extends At {
        name = "InvalidIdFormat";
        $fault = "client";
        constructor(t) {
          super({ name: "InvalidIdFormat", $fault: "client", ...t }),
            Object.setPrototypeOf(this, e.prototype);
        }
      }),
      (tA = class e extends At {
        name = "PurgeQueueInProgress";
        $fault = "client";
        constructor(t) {
          super({ name: "PurgeQueueInProgress", $fault: "client", ...t }),
            Object.setPrototypeOf(this, e.prototype);
        }
      }),
      (rA = class e extends At {
        name = "KmsAccessDenied";
        $fault = "client";
        constructor(t) {
          super({ name: "KmsAccessDenied", $fault: "client", ...t }),
            Object.setPrototypeOf(this, e.prototype);
        }
      }),
      (oA = class e extends At {
        name = "KmsDisabled";
        $fault = "client";
        constructor(t) {
          super({ name: "KmsDisabled", $fault: "client", ...t }),
            Object.setPrototypeOf(this, e.prototype);
        }
      }),
      (nA = class e extends At {
        name = "KmsInvalidKeyUsage";
        $fault = "client";
        constructor(t) {
          super({ name: "KmsInvalidKeyUsage", $fault: "client", ...t }),
            Object.setPrototypeOf(this, e.prototype);
        }
      }),
      (sA = class e extends At {
        name = "KmsInvalidState";
        $fault = "client";
        constructor(t) {
          super({ name: "KmsInvalidState", $fault: "client", ...t }),
            Object.setPrototypeOf(this, e.prototype);
        }
      }),
      (iA = class e extends At {
        name = "KmsNotFound";
        $fault = "client";
        constructor(t) {
          super({ name: "KmsNotFound", $fault: "client", ...t }),
            Object.setPrototypeOf(this, e.prototype);
        }
      }),
      (aA = class e extends At {
        name = "KmsOptInRequired";
        $fault = "client";
        constructor(t) {
          super({ name: "KmsOptInRequired", $fault: "client", ...t }),
            Object.setPrototypeOf(this, e.prototype);
        }
      }),
      (cA = class e extends At {
        name = "KmsThrottled";
        $fault = "client";
        constructor(t) {
          super({ name: "KmsThrottled", $fault: "client", ...t }),
            Object.setPrototypeOf(this, e.prototype);
        }
      }),
      (dA = class e extends At {
        name = "InvalidMessageContents";
        $fault = "client";
        constructor(t) {
          super({ name: "InvalidMessageContents", $fault: "client", ...t }),
            Object.setPrototypeOf(this, e.prototype);
        }
      }),
      (mA = class e extends At {
        name = "BatchRequestTooLong";
        $fault = "client";
        constructor(t) {
          super({ name: "BatchRequestTooLong", $fault: "client", ...t }),
            Object.setPrototypeOf(this, e.prototype);
        }
      });
  });
function Ir(e) {
  return {
    "content-type": "application/x-amz-json-1.0",
    "x-amz-target": `AmazonSQS.${e}`,
    "x-amzn-query-mode": "true",
  };
}
var bOe,
  _Oe,
  wOe,
  TOe,
  AOe,
  ROe,
  IOe,
  POe,
  vOe,
  OOe,
  kOe,
  DOe,
  NOe,
  BOe,
  MOe,
  LOe,
  FOe,
  UOe,
  $Oe,
  HOe,
  zOe,
  qOe,
  jOe,
  GOe,
  VOe,
  WOe,
  KOe,
  YOe,
  QOe,
  XOe,
  JOe,
  ZOe,
  eke,
  tke,
  rke,
  oke,
  nke,
  ske,
  ike,
  ake,
  cke,
  dke,
  mke,
  lke,
  fke,
  uke,
  Ar,
  aut,
  cut,
  dut,
  mut,
  lut,
  fut,
  uut,
  put,
  hut,
  gut,
  yut,
  xut,
  Eut,
  Sut,
  Cut,
  but,
  _ut,
  wut,
  Tut,
  Aut,
  Rut,
  Iut,
  Put,
  vut,
  Out,
  kut,
  Dut,
  Nut,
  But,
  Mut,
  pke,
  Lut,
  hke,
  Fut,
  Uut,
  $ut,
  Hut,
  zut,
  qut,
  jut,
  Gut,
  Vut,
  Wut,
  Kut,
  Yut,
  Qut,
  Xut,
  Jut,
  Zut,
  ept,
  tpt,
  rpt,
  gke,
  yke,
  opt,
  npt,
  spt,
  xke,
  ipt,
  apt,
  cpt,
  dpt,
  mpt,
  lpt,
  fpt,
  upt,
  Eke,
  ppt,
  Ske,
  hpt,
  gpt,
  ypt,
  xpt,
  Ept,
  Spt,
  Cpt,
  bpt,
  Be,
  _pt,
  Rr,
  wpt,
  Sr = s(() => {
    rt();
    Cn();
    qe();
    y1();
    g1();
    (bOe = async (e, t) => {
      let r = Ir("AddPermission"),
        o;
      return (o = JSON.stringify(Mut(e, t))), Rr(t, r, "/", void 0, o);
    }),
      (_Oe = async (e, t) => {
        let r = Ir("CancelMessageMoveTask"),
          o;
        return (o = JSON.stringify(Fut(e, t))), Rr(t, r, "/", void 0, o);
      }),
      (wOe = async (e, t) => {
        let r = Ir("ChangeMessageVisibility"),
          o;
        return (o = JSON.stringify(zut(e, t))), Rr(t, r, "/", void 0, o);
      }),
      (TOe = async (e, t) => {
        let r = Ir("ChangeMessageVisibilityBatch"),
          o;
        return (o = JSON.stringify(Uut(e, t))), Rr(t, r, "/", void 0, o);
      }),
      (AOe = async (e, t) => {
        let r = Ir("CreateQueue"),
          o;
        return (o = JSON.stringify(qut(e, t))), Rr(t, r, "/", void 0, o);
      }),
      (ROe = async (e, t) => {
        let r = Ir("DeleteMessage"),
          o;
        return (o = JSON.stringify(Wut(e, t))), Rr(t, r, "/", void 0, o);
      }),
      (IOe = async (e, t) => {
        let r = Ir("DeleteMessageBatch"),
          o;
        return (o = JSON.stringify(jut(e, t))), Rr(t, r, "/", void 0, o);
      }),
      (POe = async (e, t) => {
        let r = Ir("DeleteQueue"),
          o;
        return (o = JSON.stringify(Kut(e, t))), Rr(t, r, "/", void 0, o);
      }),
      (vOe = async (e, t) => {
        let r = Ir("GetQueueAttributes"),
          o;
        return (o = JSON.stringify(Yut(e, t))), Rr(t, r, "/", void 0, o);
      }),
      (OOe = async (e, t) => {
        let r = Ir("GetQueueUrl"),
          o;
        return (o = JSON.stringify(Qut(e, t))), Rr(t, r, "/", void 0, o);
      }),
      (kOe = async (e, t) => {
        let r = Ir("ListDeadLetterSourceQueues"),
          o;
        return (o = JSON.stringify(Xut(e, t))), Rr(t, r, "/", void 0, o);
      }),
      (DOe = async (e, t) => {
        let r = Ir("ListMessageMoveTasks"),
          o;
        return (o = JSON.stringify(Jut(e, t))), Rr(t, r, "/", void 0, o);
      }),
      (NOe = async (e, t) => {
        let r = Ir("ListQueues"),
          o;
        return (o = JSON.stringify(Zut(e, t))), Rr(t, r, "/", void 0, o);
      }),
      (BOe = async (e, t) => {
        let r = Ir("ListQueueTags"),
          o;
        return (o = JSON.stringify(ept(e, t))), Rr(t, r, "/", void 0, o);
      }),
      (MOe = async (e, t) => {
        let r = Ir("PurgeQueue"),
          o;
        return (o = JSON.stringify(spt(e, t))), Rr(t, r, "/", void 0, o);
      }),
      (LOe = async (e, t) => {
        let r = Ir("ReceiveMessage"),
          o;
        return (o = JSON.stringify(ipt(e, t))), Rr(t, r, "/", void 0, o);
      }),
      (FOe = async (e, t) => {
        let r = Ir("RemovePermission"),
          o;
        return (o = JSON.stringify(apt(e, t))), Rr(t, r, "/", void 0, o);
      }),
      (UOe = async (e, t) => {
        let r = Ir("SendMessage"),
          o;
        return (o = JSON.stringify(lpt(e, t))), Rr(t, r, "/", void 0, o);
      }),
      ($Oe = async (e, t) => {
        let r = Ir("SendMessageBatch"),
          o;
        return (o = JSON.stringify(cpt(e, t))), Rr(t, r, "/", void 0, o);
      }),
      (HOe = async (e, t) => {
        let r = Ir("SetQueueAttributes"),
          o;
        return (o = JSON.stringify(fpt(e, t))), Rr(t, r, "/", void 0, o);
      }),
      (zOe = async (e, t) => {
        let r = Ir("StartMessageMoveTask"),
          o;
        return (o = JSON.stringify(upt(e, t))), Rr(t, r, "/", void 0, o);
      }),
      (qOe = async (e, t) => {
        let r = Ir("TagQueue"),
          o;
        return (o = JSON.stringify(hpt(e, t))), Rr(t, r, "/", void 0, o);
      }),
      (jOe = async (e, t) => {
        let r = Ir("UntagQueue"),
          o;
        return (o = JSON.stringify(gpt(e, t))), Rr(t, r, "/", void 0, o);
      }),
      (GOe = async (e, t) =>
        e.statusCode >= 300
          ? Ar(e, t)
          : (await ne(e.body, t), { $metadata: Be(e) })),
      (VOe = async (e, t) => {
        if (e.statusCode >= 300) return Ar(e, t);
        let r = await ie(e.body, t),
          o = {};
        return (o = Me(r)), { $metadata: Be(e), ...o };
      }),
      (WOe = async (e, t) =>
        e.statusCode >= 300
          ? Ar(e, t)
          : (await ne(e.body, t), { $metadata: Be(e) })),
      (KOe = async (e, t) => {
        if (e.statusCode >= 300) return Ar(e, t);
        let r = await ie(e.body, t),
          o = {};
        return (o = Me(r)), { $metadata: Be(e), ...o };
      }),
      (YOe = async (e, t) => {
        if (e.statusCode >= 300) return Ar(e, t);
        let r = await ie(e.body, t),
          o = {};
        return (o = Me(r)), { $metadata: Be(e), ...o };
      }),
      (QOe = async (e, t) =>
        e.statusCode >= 300
          ? Ar(e, t)
          : (await ne(e.body, t), { $metadata: Be(e) })),
      (XOe = async (e, t) => {
        if (e.statusCode >= 300) return Ar(e, t);
        let r = await ie(e.body, t),
          o = {};
        return (o = Me(r)), { $metadata: Be(e), ...o };
      }),
      (JOe = async (e, t) =>
        e.statusCode >= 300
          ? Ar(e, t)
          : (await ne(e.body, t), { $metadata: Be(e) })),
      (ZOe = async (e, t) => {
        if (e.statusCode >= 300) return Ar(e, t);
        let r = await ie(e.body, t),
          o = {};
        return (o = Me(r)), { $metadata: Be(e), ...o };
      }),
      (eke = async (e, t) => {
        if (e.statusCode >= 300) return Ar(e, t);
        let r = await ie(e.body, t),
          o = {};
        return (o = Me(r)), { $metadata: Be(e), ...o };
      }),
      (tke = async (e, t) => {
        if (e.statusCode >= 300) return Ar(e, t);
        let r = await ie(e.body, t),
          o = {};
        return (o = Me(r)), { $metadata: Be(e), ...o };
      }),
      (rke = async (e, t) => {
        if (e.statusCode >= 300) return Ar(e, t);
        let r = await ie(e.body, t),
          o = {};
        return (o = Me(r)), { $metadata: Be(e), ...o };
      }),
      (oke = async (e, t) => {
        if (e.statusCode >= 300) return Ar(e, t);
        let r = await ie(e.body, t),
          o = {};
        return (o = Me(r)), { $metadata: Be(e), ...o };
      }),
      (nke = async (e, t) => {
        if (e.statusCode >= 300) return Ar(e, t);
        let r = await ie(e.body, t),
          o = {};
        return (o = Me(r)), { $metadata: Be(e), ...o };
      }),
      (ske = async (e, t) =>
        e.statusCode >= 300
          ? Ar(e, t)
          : (await ne(e.body, t), { $metadata: Be(e) })),
      (ike = async (e, t) => {
        if (e.statusCode >= 300) return Ar(e, t);
        let r = await ie(e.body, t),
          o = {};
        return (o = bpt(r, t)), { $metadata: Be(e), ...o };
      }),
      (ake = async (e, t) =>
        e.statusCode >= 300
          ? Ar(e, t)
          : (await ne(e.body, t), { $metadata: Be(e) })),
      (cke = async (e, t) => {
        if (e.statusCode >= 300) return Ar(e, t);
        let r = await ie(e.body, t),
          o = {};
        return (o = Me(r)), { $metadata: Be(e), ...o };
      }),
      (dke = async (e, t) => {
        if (e.statusCode >= 300) return Ar(e, t);
        let r = await ie(e.body, t),
          o = {};
        return (o = Me(r)), { $metadata: Be(e), ...o };
      }),
      (mke = async (e, t) =>
        e.statusCode >= 300
          ? Ar(e, t)
          : (await ne(e.body, t), { $metadata: Be(e) })),
      (lke = async (e, t) => {
        if (e.statusCode >= 300) return Ar(e, t);
        let r = await ie(e.body, t),
          o = {};
        return (o = Me(r)), { $metadata: Be(e), ...o };
      }),
      (fke = async (e, t) =>
        e.statusCode >= 300
          ? Ar(e, t)
          : (await ne(e.body, t), { $metadata: Be(e) })),
      (uke = async (e, t) =>
        e.statusCode >= 300
          ? Ar(e, t)
          : (await ne(e.body, t), { $metadata: Be(e) })),
      (Ar = async (e, t) => {
        let r = { ...e, body: await Gn(e.body, t) };
        wpt(r, e.headers);
        let o = Vn(e, r.body);
        switch (o) {
          case "InvalidAddress":
          case "com.amazonaws.sqs#InvalidAddress":
            throw await mut(r, t);
          case "InvalidSecurity":
          case "com.amazonaws.sqs#InvalidSecurity":
            throw await gut(r, t);
          case "OverLimit":
          case "com.amazonaws.sqs#OverLimit":
            throw await Tut(r, t);
          case "QueueDoesNotExist":
          case "com.amazonaws.sqs#QueueDoesNotExist":
          case "AWS.SimpleQueueService.NonExistentQueue":
            throw await Iut(r, t);
          case "RequestThrottled":
          case "com.amazonaws.sqs#RequestThrottled":
            throw await Out(r, t);
          case "UnsupportedOperation":
          case "com.amazonaws.sqs#UnsupportedOperation":
          case "AWS.SimpleQueueService.UnsupportedOperation":
            throw await Nut(r, t);
          case "ResourceNotFoundException":
          case "com.amazonaws.sqs#ResourceNotFoundException":
            throw await kut(r, t);
          case "MessageNotInflight":
          case "com.amazonaws.sqs#MessageNotInflight":
          case "AWS.SimpleQueueService.MessageNotInflight":
            throw await wut(r, t);
          case "ReceiptHandleIsInvalid":
          case "com.amazonaws.sqs#ReceiptHandleIsInvalid":
            throw await vut(r, t);
          case "BatchEntryIdsNotDistinct":
          case "com.amazonaws.sqs#BatchEntryIdsNotDistinct":
          case "AWS.SimpleQueueService.BatchEntryIdsNotDistinct":
            throw await aut(r, t);
          case "EmptyBatchRequest":
          case "com.amazonaws.sqs#EmptyBatchRequest":
          case "AWS.SimpleQueueService.EmptyBatchRequest":
            throw await dut(r, t);
          case "InvalidBatchEntryId":
          case "com.amazonaws.sqs#InvalidBatchEntryId":
          case "AWS.SimpleQueueService.InvalidBatchEntryId":
            throw await uut(r, t);
          case "TooManyEntriesInBatchRequest":
          case "com.amazonaws.sqs#TooManyEntriesInBatchRequest":
          case "AWS.SimpleQueueService.TooManyEntriesInBatchRequest":
            throw await Dut(r, t);
          case "InvalidAttributeName":
          case "com.amazonaws.sqs#InvalidAttributeName":
            throw await lut(r, t);
          case "InvalidAttributeValue":
          case "com.amazonaws.sqs#InvalidAttributeValue":
            throw await fut(r, t);
          case "QueueDeletedRecently":
          case "com.amazonaws.sqs#QueueDeletedRecently":
          case "AWS.SimpleQueueService.QueueDeletedRecently":
            throw await Rut(r, t);
          case "QueueNameExists":
          case "com.amazonaws.sqs#QueueNameExists":
          case "QueueAlreadyExists":
            throw await Put(r, t);
          case "InvalidIdFormat":
          case "com.amazonaws.sqs#InvalidIdFormat":
            throw await put(r, t);
          case "PurgeQueueInProgress":
          case "com.amazonaws.sqs#PurgeQueueInProgress":
          case "AWS.SimpleQueueService.PurgeQueueInProgress":
            throw await Aut(r, t);
          case "KmsAccessDenied":
          case "com.amazonaws.sqs#KmsAccessDenied":
          case "KMS.AccessDeniedException":
            throw await yut(r, t);
          case "KmsDisabled":
          case "com.amazonaws.sqs#KmsDisabled":
          case "KMS.DisabledException":
            throw await xut(r, t);
          case "KmsInvalidKeyUsage":
          case "com.amazonaws.sqs#KmsInvalidKeyUsage":
          case "KMS.InvalidKeyUsageException":
            throw await Eut(r, t);
          case "KmsInvalidState":
          case "com.amazonaws.sqs#KmsInvalidState":
          case "KMS.InvalidStateException":
            throw await Sut(r, t);
          case "KmsNotFound":
          case "com.amazonaws.sqs#KmsNotFound":
          case "KMS.NotFoundException":
            throw await Cut(r, t);
          case "KmsOptInRequired":
          case "com.amazonaws.sqs#KmsOptInRequired":
          case "KMS.OptInRequired":
            throw await but(r, t);
          case "KmsThrottled":
          case "com.amazonaws.sqs#KmsThrottled":
          case "KMS.ThrottlingException":
            throw await _ut(r, t);
          case "InvalidMessageContents":
          case "com.amazonaws.sqs#InvalidMessageContents":
            throw await hut(r, t);
          case "BatchRequestTooLong":
          case "com.amazonaws.sqs#BatchRequestTooLong":
          case "AWS.SimpleQueueService.BatchRequestTooLong":
            throw await cut(r, t);
          default:
            let n = r.body;
            return _pt({ output: e, parsedBody: n, errorCode: o });
        }
      }),
      (aut = async (e, t) => {
        let r = e.body,
          o = Me(r),
          n = new VT({ $metadata: Be(e), ...o });
        return ht(n, r);
      }),
      (cut = async (e, t) => {
        let r = e.body,
          o = Me(r),
          n = new mA({ $metadata: Be(e), ...o });
        return ht(n, r);
      }),
      (dut = async (e, t) => {
        let r = e.body,
          o = Me(r),
          n = new WT({ $metadata: Be(e), ...o });
        return ht(n, r);
      }),
      (mut = async (e, t) => {
        let r = e.body,
          o = Me(r),
          n = new LT({ $metadata: Be(e), ...o });
        return ht(n, r);
      }),
      (lut = async (e, t) => {
        let r = e.body,
          o = Me(r),
          n = new QT({ $metadata: Be(e), ...o });
        return ht(n, r);
      }),
      (fut = async (e, t) => {
        let r = e.body,
          o = Me(r),
          n = new XT({ $metadata: Be(e), ...o });
        return ht(n, r);
      }),
      (uut = async (e, t) => {
        let r = e.body,
          o = Me(r),
          n = new KT({ $metadata: Be(e), ...o });
        return ht(n, r);
      }),
      (put = async (e, t) => {
        let r = e.body,
          o = Me(r),
          n = new eA({ $metadata: Be(e), ...o });
        return ht(n, r);
      }),
      (hut = async (e, t) => {
        let r = e.body,
          o = Me(r),
          n = new dA({ $metadata: Be(e), ...o });
        return ht(n, r);
      }),
      (gut = async (e, t) => {
        let r = e.body,
          o = Me(r),
          n = new FT({ $metadata: Be(e), ...o });
        return ht(n, r);
      }),
      (yut = async (e, t) => {
        let r = e.body,
          o = Me(r),
          n = new rA({ $metadata: Be(e), ...o });
        return ht(n, r);
      }),
      (xut = async (e, t) => {
        let r = e.body,
          o = Me(r),
          n = new oA({ $metadata: Be(e), ...o });
        return ht(n, r);
      }),
      (Eut = async (e, t) => {
        let r = e.body,
          o = Me(r),
          n = new nA({ $metadata: Be(e), ...o });
        return ht(n, r);
      }),
      (Sut = async (e, t) => {
        let r = e.body,
          o = Me(r),
          n = new sA({ $metadata: Be(e), ...o });
        return ht(n, r);
      }),
      (Cut = async (e, t) => {
        let r = e.body,
          o = Me(r),
          n = new iA({ $metadata: Be(e), ...o });
        return ht(n, r);
      }),
      (but = async (e, t) => {
        let r = e.body,
          o = Me(r),
          n = new aA({ $metadata: Be(e), ...o });
        return ht(n, r);
      }),
      (_ut = async (e, t) => {
        let r = e.body,
          o = Me(r),
          n = new cA({ $metadata: Be(e), ...o });
        return ht(n, r);
      }),
      (wut = async (e, t) => {
        let r = e.body,
          o = Me(r),
          n = new jT({ $metadata: Be(e), ...o });
        return ht(n, r);
      }),
      (Tut = async (e, t) => {
        let r = e.body,
          o = Me(r),
          n = new UT({ $metadata: Be(e), ...o });
        return ht(n, r);
      }),
      (Aut = async (e, t) => {
        let r = e.body,
          o = Me(r),
          n = new tA({ $metadata: Be(e), ...o });
        return ht(n, r);
      }),
      (Rut = async (e, t) => {
        let r = e.body,
          o = Me(r),
          n = new JT({ $metadata: Be(e), ...o });
        return ht(n, r);
      }),
      (Iut = async (e, t) => {
        let r = e.body,
          o = Me(r),
          n = new $T({ $metadata: Be(e), ...o });
        return ht(n, r);
      }),
      (Put = async (e, t) => {
        let r = e.body,
          o = Me(r),
          n = new ZT({ $metadata: Be(e), ...o });
        return ht(n, r);
      }),
      (vut = async (e, t) => {
        let r = e.body,
          o = Me(r),
          n = new GT({ $metadata: Be(e), ...o });
        return ht(n, r);
      }),
      (Out = async (e, t) => {
        let r = e.body,
          o = Me(r),
          n = new HT({ $metadata: Be(e), ...o });
        return ht(n, r);
      }),
      (kut = async (e, t) => {
        let r = e.body,
          o = Me(r),
          n = new qT({ $metadata: Be(e), ...o });
        return ht(n, r);
      }),
      (Dut = async (e, t) => {
        let r = e.body,
          o = Me(r),
          n = new YT({ $metadata: Be(e), ...o });
        return ht(n, r);
      }),
      (Nut = async (e, t) => {
        let r = e.body,
          o = Me(r),
          n = new zT({ $metadata: Be(e), ...o });
        return ht(n, r);
      }),
      (But = (e, t) => e.filter((r) => r != null).map((r) => we(r))),
      (Mut = (e, t) =>
        ot(e, {
          AWSAccountIds: (r) => Lut(r, t),
          Actions: (r) => But(r, t),
          Label: we,
          QueueUrl: we,
        })),
      (pke = (e, t) => e.filter((r) => r != null).map((r) => we(r))),
      (Lut = (e, t) => e.filter((r) => r != null).map((r) => we(r))),
      (hke = (e, t) =>
        e.filter((r) => r != null).map((r) => t.base64Encoder(r))),
      (Fut = (e, t) => ot(e, { TaskHandle: we })),
      (Uut = (e, t) => ot(e, { Entries: (r) => Hut(r, t), QueueUrl: we })),
      ($ut = (e, t) =>
        ot(e, { Id: we, ReceiptHandle: we, VisibilityTimeout: jn })),
      (Hut = (e, t) => e.filter((r) => r != null).map((r) => $ut(r, t))),
      (zut = (e, t) =>
        ot(e, { QueueUrl: we, ReceiptHandle: we, VisibilityTimeout: jn })),
      (qut = (e, t) =>
        ot(e, {
          Attributes: (r) => xke(r, t),
          QueueName: we,
          tags: (r) => Ske(r, t),
        })),
      (jut = (e, t) => ot(e, { Entries: (r) => Vut(r, t), QueueUrl: we })),
      (Gut = (e, t) => ot(e, { Id: we, ReceiptHandle: we })),
      (Vut = (e, t) => e.filter((r) => r != null).map((r) => Gut(r, t))),
      (Wut = (e, t) => ot(e, { QueueUrl: we, ReceiptHandle: we })),
      (Kut = (e, t) => ot(e, { QueueUrl: we })),
      (Yut = (e, t) =>
        ot(e, { AttributeNames: (r) => pke(r, t), QueueUrl: we })),
      (Qut = (e, t) => ot(e, { QueueName: we, QueueOwnerAWSAccountId: we })),
      (Xut = (e, t) => ot(e, { MaxResults: jn, NextToken: we, QueueUrl: we })),
      (Jut = (e, t) => ot(e, { MaxResults: jn, SourceArn: we })),
      (Zut = (e, t) =>
        ot(e, { MaxResults: jn, NextToken: we, QueueNamePrefix: we })),
      (ept = (e, t) => ot(e, { QueueUrl: we })),
      (tpt = (e, t) => e.filter((r) => r != null).map((r) => we(r))),
      (rpt = (e, t) =>
        ot(e, {
          BinaryListValues: (r) => hke(r, t),
          BinaryValue: t.base64Encoder,
          DataType: we,
          StringListValues: (r) => Eke(r, t),
          StringValue: we,
        })),
      (gke = (e, t) =>
        Object.entries(e).reduce(
          (r, [o, n]) => (n === null || (r[o] = rpt(n, t)), r),
          {}
        )),
      (yke = (e, t) =>
        Object.entries(e).reduce(
          (r, [o, n]) => (n === null || (r[o] = npt(n, t)), r),
          {}
        )),
      (opt = (e, t) => e.filter((r) => r != null).map((r) => we(r))),
      (npt = (e, t) =>
        ot(e, {
          BinaryListValues: (r) => hke(r, t),
          BinaryValue: t.base64Encoder,
          DataType: we,
          StringListValues: (r) => Eke(r, t),
          StringValue: we,
        })),
      (spt = (e, t) => ot(e, { QueueUrl: we })),
      (xke = (e, t) =>
        Object.entries(e).reduce(
          (r, [o, n]) => (n === null || (r[o] = we(n)), r),
          {}
        )),
      (ipt = (e, t) =>
        ot(e, {
          AttributeNames: (r) => pke(r, t),
          MaxNumberOfMessages: jn,
          MessageAttributeNames: (r) => tpt(r, t),
          MessageSystemAttributeNames: (r) => opt(r, t),
          QueueUrl: we,
          ReceiveRequestAttemptId: we,
          VisibilityTimeout: jn,
          WaitTimeSeconds: jn,
        })),
      (apt = (e, t) => ot(e, { Label: we, QueueUrl: we })),
      (cpt = (e, t) => ot(e, { Entries: (r) => mpt(r, t), QueueUrl: we })),
      (dpt = (e, t) =>
        ot(e, {
          DelaySeconds: jn,
          Id: we,
          MessageAttributes: (r) => gke(r, t),
          MessageBody: we,
          MessageDeduplicationId: we,
          MessageGroupId: we,
          MessageSystemAttributes: (r) => yke(r, t),
        })),
      (mpt = (e, t) => e.filter((r) => r != null).map((r) => dpt(r, t))),
      (lpt = (e, t) =>
        ot(e, {
          DelaySeconds: jn,
          MessageAttributes: (r) => gke(r, t),
          MessageBody: we,
          MessageDeduplicationId: we,
          MessageGroupId: we,
          MessageSystemAttributes: (r) => yke(r, t),
          QueueUrl: we,
        })),
      (fpt = (e, t) => ot(e, { Attributes: (r) => xke(r, t), QueueUrl: we })),
      (upt = (e, t) =>
        ot(e, {
          DestinationArn: we,
          MaxNumberOfMessagesPerSecond: jn,
          SourceArn: we,
        })),
      (Eke = (e, t) => e.filter((r) => r != null).map((r) => we(r))),
      (ppt = (e, t) => e.filter((r) => r != null).map((r) => we(r))),
      (Ske = (e, t) =>
        Object.entries(e).reduce(
          (r, [o, n]) => (n === null || (r[o] = we(n)), r),
          {}
        )),
      (hpt = (e, t) => ot(e, { QueueUrl: we, Tags: (r) => Ske(r, t) })),
      (gpt = (e, t) => ot(e, { QueueUrl: we, TagKeys: (r) => ppt(r, t) })),
      (ypt = (e, t) =>
        (e || []).filter((o) => o != null).map((o) => t.base64Decoder(o))),
      (xpt = (e, t) =>
        ot(e, {
          Attributes: Me,
          Body: p,
          MD5OfBody: p,
          MD5OfMessageAttributes: p,
          MessageAttributes: (r) => Spt(r, t),
          MessageId: p,
          ReceiptHandle: p,
        })),
      (Ept = (e, t) =>
        ot(e, {
          BinaryListValues: (r) => ypt(r, t),
          BinaryValue: t.base64Decoder,
          DataType: p,
          StringListValues: Me,
          StringValue: p,
        })),
      (Spt = (e, t) =>
        Object.entries(e).reduce(
          (r, [o, n]) => (n === null || (r[o] = Ept(n, t)), r),
          {}
        )),
      (Cpt = (e, t) =>
        (e || []).filter((o) => o != null).map((o) => xpt(o, t))),
      (bpt = (e, t) => ot(e, { Messages: (r) => Cpt(r, t) })),
      (Be = (e) => ({
        httpStatusCode: e.statusCode,
        requestId:
          e.headers["x-amzn-requestid"] ??
          e.headers["x-amzn-request-id"] ??
          e.headers["x-amz-request-id"],
        extendedRequestId: e.headers["x-amz-id-2"],
        cfId: e.headers["x-amz-cf-id"],
      })),
      (_pt = Zw(At)),
      (Rr = async (e, t, r, o, n) => {
        let {
            hostname: i,
            protocol: a = "https",
            port: c,
            path: d,
          } = await e.endpoint(),
          m = {
            protocol: a,
            hostname: i,
            port: c,
            method: "POST",
            path: d.endsWith("/") ? d.slice(0, -1) + r : d + r,
            headers: t,
          };
        return (
          o !== void 0 && (m.hostname = o),
          n !== void 0 && (m.body = n),
          new Ko(m)
        );
      });
    wpt = (e, t) => {
      let r = t["x-amzn-query-error"];
      if (e.body !== void 0 && r != null) {
        let [o, n] = r.split(";"),
          i = Object.entries(e.body),
          a = { Type: n, Code: o };
        Object.assign(e.body, a);
        for (let [c, d] of i) a[c] = d;
        delete a.__type, (e.body.Error = a);
      }
    };
  });
var lA,
  x1 = s(() => {
    Lt();
    zt();
    qe();
    yr();
    Sr();
    lA = class extends (
      Ie.classBuilder()
        .ep(je)
        .m(function (t, r, o, n) {
          return [
            Pe(o, this.serialize, this.deserialize),
            ve(o, t.getEndpointParameterInstructions()),
          ];
        })
        .s("AmazonSQS", "AddPermission", {})
        .n("SQSClient", "AddPermissionCommand")
        .f(void 0, void 0)
        .ser(bOe)
        .de(GOe)
        .build()
    ) {};
  });
var fA,
  E1 = s(() => {
    Lt();
    zt();
    qe();
    yr();
    Sr();
    fA = class extends (
      Ie.classBuilder()
        .ep(je)
        .m(function (t, r, o, n) {
          return [
            Pe(o, this.serialize, this.deserialize),
            ve(o, t.getEndpointParameterInstructions()),
          ];
        })
        .s("AmazonSQS", "CancelMessageMoveTask", {})
        .n("SQSClient", "CancelMessageMoveTaskCommand")
        .f(void 0, void 0)
        .ser(_Oe)
        .de(VOe)
        .build()
    ) {};
  });
var uA,
  S1 = s(() => {
    Lt();
    zt();
    qe();
    yr();
    Sr();
    uA = class extends (
      Ie.classBuilder()
        .ep(je)
        .m(function (t, r, o, n) {
          return [
            Pe(o, this.serialize, this.deserialize),
            ve(o, t.getEndpointParameterInstructions()),
          ];
        })
        .s("AmazonSQS", "ChangeMessageVisibilityBatch", {})
        .n("SQSClient", "ChangeMessageVisibilityBatchCommand")
        .f(void 0, void 0)
        .ser(TOe)
        .de(KOe)
        .build()
    ) {};
  });
var pA,
  C1 = s(() => {
    Lt();
    zt();
    qe();
    yr();
    Sr();
    pA = class extends (
      Ie.classBuilder()
        .ep(je)
        .m(function (t, r, o, n) {
          return [
            Pe(o, this.serialize, this.deserialize),
            ve(o, t.getEndpointParameterInstructions()),
          ];
        })
        .s("AmazonSQS", "ChangeMessageVisibility", {})
        .n("SQSClient", "ChangeMessageVisibilityCommand")
        .f(void 0, void 0)
        .ser(wOe)
        .de(WOe)
        .build()
    ) {};
  });
var hA,
  b1 = s(() => {
    Lt();
    zt();
    qe();
    yr();
    Sr();
    hA = class extends (
      Ie.classBuilder()
        .ep(je)
        .m(function (t, r, o, n) {
          return [
            Pe(o, this.serialize, this.deserialize),
            ve(o, t.getEndpointParameterInstructions()),
          ];
        })
        .s("AmazonSQS", "CreateQueue", {})
        .n("SQSClient", "CreateQueueCommand")
        .f(void 0, void 0)
        .ser(AOe)
        .de(YOe)
        .build()
    ) {};
  });
var gA,
  _1 = s(() => {
    Lt();
    zt();
    qe();
    yr();
    Sr();
    gA = class extends (
      Ie.classBuilder()
        .ep(je)
        .m(function (t, r, o, n) {
          return [
            Pe(o, this.serialize, this.deserialize),
            ve(o, t.getEndpointParameterInstructions()),
          ];
        })
        .s("AmazonSQS", "DeleteMessageBatch", {})
        .n("SQSClient", "DeleteMessageBatchCommand")
        .f(void 0, void 0)
        .ser(IOe)
        .de(XOe)
        .build()
    ) {};
  });
var yA,
  w1 = s(() => {
    Lt();
    zt();
    qe();
    yr();
    Sr();
    yA = class extends (
      Ie.classBuilder()
        .ep(je)
        .m(function (t, r, o, n) {
          return [
            Pe(o, this.serialize, this.deserialize),
            ve(o, t.getEndpointParameterInstructions()),
          ];
        })
        .s("AmazonSQS", "DeleteMessage", {})
        .n("SQSClient", "DeleteMessageCommand")
        .f(void 0, void 0)
        .ser(ROe)
        .de(QOe)
        .build()
    ) {};
  });
var xA,
  T1 = s(() => {
    Lt();
    zt();
    qe();
    yr();
    Sr();
    xA = class extends (
      Ie.classBuilder()
        .ep(je)
        .m(function (t, r, o, n) {
          return [
            Pe(o, this.serialize, this.deserialize),
            ve(o, t.getEndpointParameterInstructions()),
          ];
        })
        .s("AmazonSQS", "DeleteQueue", {})
        .n("SQSClient", "DeleteQueueCommand")
        .f(void 0, void 0)
        .ser(POe)
        .de(JOe)
        .build()
    ) {};
  });
var EA,
  A1 = s(() => {
    Lt();
    zt();
    qe();
    yr();
    Sr();
    EA = class extends (
      Ie.classBuilder()
        .ep(je)
        .m(function (t, r, o, n) {
          return [
            Pe(o, this.serialize, this.deserialize),
            ve(o, t.getEndpointParameterInstructions()),
          ];
        })
        .s("AmazonSQS", "GetQueueAttributes", {})
        .n("SQSClient", "GetQueueAttributesCommand")
        .f(void 0, void 0)
        .ser(vOe)
        .de(ZOe)
        .build()
    ) {};
  });
var SA,
  R1 = s(() => {
    Lt();
    zt();
    qe();
    yr();
    Sr();
    SA = class extends (
      Ie.classBuilder()
        .ep(je)
        .m(function (t, r, o, n) {
          return [
            Pe(o, this.serialize, this.deserialize),
            ve(o, t.getEndpointParameterInstructions()),
          ];
        })
        .s("AmazonSQS", "GetQueueUrl", {})
        .n("SQSClient", "GetQueueUrlCommand")
        .f(void 0, void 0)
        .ser(OOe)
        .de(eke)
        .build()
    ) {};
  });
var fu,
  CA = s(() => {
    Lt();
    zt();
    qe();
    yr();
    Sr();
    fu = class extends (
      Ie.classBuilder()
        .ep(je)
        .m(function (t, r, o, n) {
          return [
            Pe(o, this.serialize, this.deserialize),
            ve(o, t.getEndpointParameterInstructions()),
          ];
        })
        .s("AmazonSQS", "ListDeadLetterSourceQueues", {})
        .n("SQSClient", "ListDeadLetterSourceQueuesCommand")
        .f(void 0, void 0)
        .ser(kOe)
        .de(tke)
        .build()
    ) {};
  });
var bA,
  I1 = s(() => {
    Lt();
    zt();
    qe();
    yr();
    Sr();
    bA = class extends (
      Ie.classBuilder()
        .ep(je)
        .m(function (t, r, o, n) {
          return [
            Pe(o, this.serialize, this.deserialize),
            ve(o, t.getEndpointParameterInstructions()),
          ];
        })
        .s("AmazonSQS", "ListMessageMoveTasks", {})
        .n("SQSClient", "ListMessageMoveTasksCommand")
        .f(void 0, void 0)
        .ser(DOe)
        .de(rke)
        .build()
    ) {};
  });
var uu,
  _A = s(() => {
    Lt();
    zt();
    qe();
    yr();
    Sr();
    uu = class extends (
      Ie.classBuilder()
        .ep(je)
        .m(function (t, r, o, n) {
          return [
            Pe(o, this.serialize, this.deserialize),
            ve(o, t.getEndpointParameterInstructions()),
          ];
        })
        .s("AmazonSQS", "ListQueues", {})
        .n("SQSClient", "ListQueuesCommand")
        .f(void 0, void 0)
        .ser(NOe)
        .de(oke)
        .build()
    ) {};
  });
var wA,
  P1 = s(() => {
    Lt();
    zt();
    qe();
    yr();
    Sr();
    wA = class extends (
      Ie.classBuilder()
        .ep(je)
        .m(function (t, r, o, n) {
          return [
            Pe(o, this.serialize, this.deserialize),
            ve(o, t.getEndpointParameterInstructions()),
          ];
        })
        .s("AmazonSQS", "ListQueueTags", {})
        .n("SQSClient", "ListQueueTagsCommand")
        .f(void 0, void 0)
        .ser(BOe)
        .de(nke)
        .build()
    ) {};
  });
var TA,
  v1 = s(() => {
    Lt();
    zt();
    qe();
    yr();
    Sr();
    TA = class extends (
      Ie.classBuilder()
        .ep(je)
        .m(function (t, r, o, n) {
          return [
            Pe(o, this.serialize, this.deserialize),
            ve(o, t.getEndpointParameterInstructions()),
          ];
        })
        .s("AmazonSQS", "PurgeQueue", {})
        .n("SQSClient", "PurgeQueueCommand")
        .f(void 0, void 0)
        .ser(MOe)
        .de(ske)
        .build()
    ) {};
  });
var AA,
  O1 = s(() => {
    ey();
    Lt();
    zt();
    qe();
    yr();
    Sr();
    AA = class extends (
      Ie.classBuilder()
        .ep(je)
        .m(function (t, r, o, n) {
          return [
            Pe(o, this.serialize, this.deserialize),
            ve(o, t.getEndpointParameterInstructions()),
            UTe(o),
          ];
        })
        .s("AmazonSQS", "ReceiveMessage", {})
        .n("SQSClient", "ReceiveMessageCommand")
        .f(void 0, void 0)
        .ser(LOe)
        .de(ike)
        .build()
    ) {};
  });
var RA,
  k1 = s(() => {
    Lt();
    zt();
    qe();
    yr();
    Sr();
    RA = class extends (
      Ie.classBuilder()
        .ep(je)
        .m(function (t, r, o, n) {
          return [
            Pe(o, this.serialize, this.deserialize),
            ve(o, t.getEndpointParameterInstructions()),
          ];
        })
        .s("AmazonSQS", "RemovePermission", {})
        .n("SQSClient", "RemovePermissionCommand")
        .f(void 0, void 0)
        .ser(FOe)
        .de(ake)
        .build()
    ) {};
  });
var IA,
  D1 = s(() => {
    ey();
    Lt();
    zt();
    qe();
    yr();
    Sr();
    IA = class extends (
      Ie.classBuilder()
        .ep(je)
        .m(function (t, r, o, n) {
          return [
            Pe(o, this.serialize, this.deserialize),
            ve(o, t.getEndpointParameterInstructions()),
            qTe(o),
          ];
        })
        .s("AmazonSQS", "SendMessageBatch", {})
        .n("SQSClient", "SendMessageBatchCommand")
        .f(void 0, void 0)
        .ser($Oe)
        .de(dke)
        .build()
    ) {};
  });
var pu,
  N1 = s(() => {
    ey();
    Lt();
    zt();
    qe();
    yr();
    Sr();
    pu = class extends (
      Ie.classBuilder()
        .ep(je)
        .m(function (t, r, o, n) {
          return [
            Pe(o, this.serialize, this.deserialize),
            ve(o, t.getEndpointParameterInstructions()),
            HTe(o),
          ];
        })
        .s("AmazonSQS", "SendMessage", {})
        .n("SQSClient", "SendMessageCommand")
        .f(void 0, void 0)
        .ser(UOe)
        .de(cke)
        .build()
    ) {};
  });
var PA,
  B1 = s(() => {
    Lt();
    zt();
    qe();
    yr();
    Sr();
    PA = class extends (
      Ie.classBuilder()
        .ep(je)
        .m(function (t, r, o, n) {
          return [
            Pe(o, this.serialize, this.deserialize),
            ve(o, t.getEndpointParameterInstructions()),
          ];
        })
        .s("AmazonSQS", "SetQueueAttributes", {})
        .n("SQSClient", "SetQueueAttributesCommand")
        .f(void 0, void 0)
        .ser(HOe)
        .de(mke)
        .build()
    ) {};
  });
var vA,
  M1 = s(() => {
    Lt();
    zt();
    qe();
    yr();
    Sr();
    vA = class extends (
      Ie.classBuilder()
        .ep(je)
        .m(function (t, r, o, n) {
          return [
            Pe(o, this.serialize, this.deserialize),
            ve(o, t.getEndpointParameterInstructions()),
          ];
        })
        .s("AmazonSQS", "StartMessageMoveTask", {})
        .n("SQSClient", "StartMessageMoveTaskCommand")
        .f(void 0, void 0)
        .ser(zOe)
        .de(lke)
        .build()
    ) {};
  });
var OA,
  L1 = s(() => {
    Lt();
    zt();
    qe();
    yr();
    Sr();
    OA = class extends (
      Ie.classBuilder()
        .ep(je)
        .m(function (t, r, o, n) {
          return [
            Pe(o, this.serialize, this.deserialize),
            ve(o, t.getEndpointParameterInstructions()),
          ];
        })
        .s("AmazonSQS", "TagQueue", {})
        .n("SQSClient", "TagQueueCommand")
        .f(void 0, void 0)
        .ser(qOe)
        .de(fke)
        .build()
    ) {};
  });
var kA,
  F1 = s(() => {
    Lt();
    zt();
    qe();
    yr();
    Sr();
    kA = class extends (
      Ie.classBuilder()
        .ep(je)
        .m(function (t, r, o, n) {
          return [
            Pe(o, this.serialize, this.deserialize),
            ve(o, t.getEndpointParameterInstructions()),
          ];
        })
        .s("AmazonSQS", "UntagQueue", {})
        .n("SQSClient", "UntagQueueCommand")
        .f(void 0, void 0)
        .ser(jOe)
        .de(uke)
        .build()
    ) {};
  });
var Tpt,
  U1,
  Cke = s(() => {
    qe();
    x1();
    E1();
    S1();
    C1();
    b1();
    _1();
    w1();
    T1();
    A1();
    R1();
    CA();
    I1();
    _A();
    P1();
    v1();
    O1();
    k1();
    D1();
    N1();
    B1();
    M1();
    L1();
    F1();
    Sy();
    (Tpt = {
      AddPermissionCommand: lA,
      CancelMessageMoveTaskCommand: fA,
      ChangeMessageVisibilityCommand: pA,
      ChangeMessageVisibilityBatchCommand: uA,
      CreateQueueCommand: hA,
      DeleteMessageCommand: yA,
      DeleteMessageBatchCommand: gA,
      DeleteQueueCommand: xA,
      GetQueueAttributesCommand: EA,
      GetQueueUrlCommand: SA,
      ListDeadLetterSourceQueuesCommand: fu,
      ListMessageMoveTasksCommand: bA,
      ListQueuesCommand: uu,
      ListQueueTagsCommand: wA,
      PurgeQueueCommand: TA,
      ReceiveMessageCommand: AA,
      RemovePermissionCommand: RA,
      SendMessageCommand: pu,
      SendMessageBatchCommand: IA,
      SetQueueAttributesCommand: PA,
      StartMessageMoveTaskCommand: vA,
      TagQueueCommand: OA,
      UntagQueueCommand: kA,
    }),
      (U1 = class extends _i {});
    Jw(Tpt, U1);
  });
var bke = s(() => {
  x1();
  E1();
  S1();
  C1();
  b1();
  _1();
  w1();
  T1();
  A1();
  R1();
  CA();
  I1();
  P1();
  _A();
  v1();
  O1();
  k1();
  D1();
  N1();
  B1();
  M1();
  L1();
  F1();
});
var _ke = s(() => {});
var tto,
  wke = s(() => {
    Ue();
    CA();
    Sy();
    tto = dt(_i, fu, "NextToken", "NextToken", "MaxResults");
  });
var ito,
  Tke = s(() => {
    Ue();
    _A();
    Sy();
    ito = dt(_i, uu, "NextToken", "NextToken", "MaxResults");
  });
var Ake = s(() => {
  _ke();
  wke();
  Tke();
});
var Rke = s(() => {
  y1();
});
var Ike = s(() => {
  Sy();
  Cke();
  bke();
  Ake();
  Rke();
});
var Pke = {};
It(Pke, { default: () => vpt });
var Apt,
  Rpt,
  Ipt,
  Ppt,
  vpt,
  vke = s(() => {
    Ike();
    mo();
    ({ REVALIDATION_QUEUE_REGION: Apt, REVALIDATION_QUEUE_URL: Rpt } =
      process.env),
      (Ipt = new _i({ region: Apt, logger: Qm })),
      (Ppt = {
        send: async ({
          MessageBody: e,
          MessageDeduplicationId: t,
          MessageGroupId: r,
        }) => {
          await Ipt.send(
            new pu({
              QueueUrl: Rpt,
              MessageBody: JSON.stringify(e),
              MessageDeduplicationId: t,
              MessageGroupId: r,
            })
          );
        },
        name: "sqs",
      }),
      (vpt = Ppt);
  });
var Oke = s(() => {});
var kke = s(() => {
  Oke();
});
var Dke = s(() => {});
var Nke,
  Bke = s(() => {
    (function (e) {
      (e.HEADER = "header"), (e.QUERY = "query");
    })(Nke || (Nke = {}));
  });
var Mke,
  Lke = s(() => {
    (function (e) {
      (e.HEADER = "header"), (e.QUERY = "query");
    })(Mke || (Mke = {}));
  });
var Fke = s(() => {});
var Uke = s(() => {});
var $ke = s(() => {});
var Hke = s(() => {});
var zke = s(() => {
  Bke();
  Lke();
  Fke();
  Uke();
  $ke();
  Hke();
});
var qke = s(() => {});
var jke = s(() => {});
var Gke = s(() => {});
var Vke = s(() => {});
var Wke = s(() => {});
var Kke = s(() => {});
var Yke = s(() => {});
var Qke = s(() => {
  Wke();
  Kke();
  Yke();
});
var Xke = s(() => {});
var Jke = s(() => {});
var Zke,
  eDe = s(() => {
    (function (e) {
      (e.HTTP = "http"), (e.HTTPS = "https");
    })(Zke || (Zke = {}));
  });
var tDe = s(() => {});
var rDe = s(() => {});
var oDe = s(() => {});
var nDe = s(() => {});
var sDe = s(() => {});
var iDe = s(() => {
  tDe();
  rDe();
  oDe();
  nDe();
  sDe();
});
var aDe = s(() => {});
var $1,
  H1 = s(() => {
    (function (e) {
      (e.MD5 = "md5"),
        (e.CRC32 = "crc32"),
        (e.CRC32C = "crc32c"),
        (e.SHA1 = "sha1"),
        (e.SHA256 = "sha256");
    })($1 || ($1 = {}));
  });
var cDe = s(() => {
  H1();
});
var dDe = s(() => {});
var mDe = s(() => {
  cDe();
  dDe();
  H1();
});
var lDe = s(() => {});
var z1,
  fDe = s(() => {
    (function (e) {
      (e[(e.HEADER = 0)] = "HEADER"), (e[(e.TRAILER = 1)] = "TRAILER");
    })(z1 || (z1 = {}));
  });
var uDe = s(() => {});
var pDe = s(() => {});
var hDe = s(() => {});
var gDe = s(() => {});
var yDe = s(() => {});
var xDe = s(() => {
  pDe();
  hDe();
  gDe();
  yDe();
});
var EDe = s(() => {});
var SDe = s(() => {});
var CDe = s(() => {});
var bDe,
  _De = s(() => {
    (function (e) {
      (e.PROFILE = "profile"),
        (e.SSO_SESSION = "sso-session"),
        (e.SERVICES = "services");
    })(bDe || (bDe = {}));
  });
var wDe = s(() => {});
var TDe = s(() => {});
var ADe = s(() => {});
var RDe = s(() => {});
var IDe = s(() => {});
var PDe = s(() => {});
var vDe = s(() => {});
var ODe = s(() => {});
var kDe = s(() => {});
var DDe = s(() => {});
var NDe = s(() => {});
var BDe,
  MDe = s(() => {
    (function (e) {
      (e.HTTP_0_9 = "http/0.9"),
        (e.HTTP_1_0 = "http/1.0"),
        (e.TDS_8_0 = "tds/8.0");
    })(BDe || (BDe = {}));
  });
var LDe = s(() => {});
var FDe = s(() => {});
var UDe = s(() => {});
var $De = s(() => {});
var HDe = s(() => {});
var zDe = s(() => {});
var qDe = s(() => {});
var jDe = s(() => {
  Dke();
  zke();
  qke();
  jke();
  Gke();
  Vke();
  Qke();
  Xke();
  Jke();
  eDe();
  iDe();
  aDe();
  mDe();
  lDe();
  fDe();
  uDe();
  xDe();
  EDe();
  SDe();
  CDe();
  _De();
  wDe();
  TDe();
  ADe();
  RDe();
  IDe();
  PDe();
  vDe();
  ODe();
  kDe();
  DDe();
  NDe();
  MDe();
  LDe();
  FDe();
  UDe();
  $De();
  HDe();
  zDe();
  qDe();
});
var GDe = s(() => {
  jDe();
});
var VDe = s(() => {});
var WDe = s(() => {});
function Opt(e) {
  return Object.keys(e).reduce((t, r) => {
    let o = e[r];
    return { ...t, [r]: Array.isArray(o) ? [...o] : o };
  }, {});
}
var DA,
  KDe = s(() => {
    DA = class e {
      constructor(t) {
        (this.method = t.method || "GET"),
          (this.hostname = t.hostname || "localhost"),
          (this.port = t.port),
          (this.query = t.query || {}),
          (this.headers = t.headers || {}),
          (this.body = t.body),
          (this.protocol = t.protocol
            ? t.protocol.slice(-1) !== ":"
              ? `${t.protocol}:`
              : t.protocol
            : "https:"),
          (this.path = t.path
            ? t.path.charAt(0) !== "/"
              ? `/${t.path}`
              : t.path
            : "/"),
          (this.username = t.username),
          (this.password = t.password),
          (this.fragment = t.fragment);
      }
      static clone(t) {
        let r = new e({ ...t, headers: { ...t.headers } });
        return r.query && (r.query = Opt(r.query)), r;
      }
      static isInstance(t) {
        if (!t) return !1;
        let r = t;
        return (
          "method" in r &&
          "protocol" in r &&
          "hostname" in r &&
          "path" in r &&
          typeof r.query == "object" &&
          typeof r.headers == "object"
        );
      }
      clone() {
        return e.clone(this);
      }
    };
  });
var YDe = s(() => {});
var QDe = s(() => {});
var XDe = s(() => {});
var JDe = s(() => {
  kke();
  GDe();
  VDe();
  WDe();
  KDe();
  YDe();
  QDe();
  XDe();
});
function kpt(e) {
  return (t) => async (r) => {
    let { request: o } = r;
    return (
      DA.isInstance(o) &&
        o.body &&
        e.runtime === "node" &&
        e.requestHandler?.constructor?.name !== "FetchHttpHandler" &&
        (o.headers = { ...o.headers, Expect: "100-continue" }),
      t({ ...r, request: o })
    );
  };
}
var Dpt,
  ZDe,
  eNe = s(() => {
    JDe();
    (Dpt = {
      step: "build",
      tags: ["SET_EXPECT_HEADER", "EXPECT_HEADER"],
      name: "addExpectContinueMiddleware",
      override: !0,
    }),
      (ZDe = (e) => ({
        applyToStack: (t) => {
          t.add(kpt(e), Dpt);
        },
      }));
  });
var ls,
  NA,
  Md,
  BA,
  kt,
  tNe,
  Cy,
  fs = s(() => {
    (ls = { WHEN_SUPPORTED: "WHEN_SUPPORTED", WHEN_REQUIRED: "WHEN_REQUIRED" }),
      (NA = ls.WHEN_SUPPORTED),
      (Md = {
        WHEN_SUPPORTED: "WHEN_SUPPORTED",
        WHEN_REQUIRED: "WHEN_REQUIRED",
      }),
      (BA = ls.WHEN_SUPPORTED);
    (function (e) {
      (e.MD5 = "MD5"),
        (e.CRC32 = "CRC32"),
        (e.CRC32C = "CRC32C"),
        (e.CRC64NVME = "CRC64NVME"),
        (e.SHA1 = "SHA1"),
        (e.SHA256 = "SHA256");
    })(kt || (kt = {}));
    (function (e) {
      (e.HEADER = "header"), (e.TRAILER = "trailer");
    })(tNe || (tNe = {}));
    Cy = kt.CRC32;
  });
var pc,
  hu,
  q1 = s(() => {
    (function (e) {
      (e.ENV = "env"), (e.CONFIG = "shared config entry");
    })(pc || (pc = {}));
    hu = (e, t, r, o) => {
      if (!(t in e)) return;
      let n = e[t].toUpperCase();
      if (!Object.values(r).includes(n))
        throw new TypeError(
          `Cannot load ${o} '${t}'. Expected one of ${Object.values(r)}, got '${e[t]}'.`
        );
      return n;
    };
  });
var Npt,
  Bpt,
  rNe,
  oNe = s(() => {
    fs();
    q1();
    (Npt = "AWS_REQUEST_CHECKSUM_CALCULATION"),
      (Bpt = "request_checksum_calculation"),
      (rNe = {
        environmentVariableSelector: (e) => hu(e, Npt, ls, pc.ENV),
        configFileSelector: (e) => hu(e, Bpt, ls, pc.CONFIG),
        default: NA,
      });
  });
var Mpt,
  Lpt,
  nNe,
  sNe = s(() => {
    fs();
    q1();
    (Mpt = "AWS_RESPONSE_CHECKSUM_VALIDATION"),
      (Lpt = "response_checksum_validation"),
      (nNe = {
        environmentVariableSelector: (e) => hu(e, Mpt, Md, pc.ENV),
        configFileSelector: (e) => hu(e, Lpt, Md, pc.CONFIG),
        default: BA,
      });
  });
var j1,
  G1 = s(() => {
    j1 = { CrtCrc64Nvme: null };
  });
var iNe = s(() => {});
var aNe = s(() => {
  iNe();
});
var cNe = s(() => {});
var dNe,
  mNe = s(() => {
    (function (e) {
      (e.HEADER = "header"), (e.QUERY = "query");
    })(dNe || (dNe = {}));
  });
var lNe,
  fNe = s(() => {
    (function (e) {
      (e.HEADER = "header"), (e.QUERY = "query");
    })(lNe || (lNe = {}));
  });
var uNe = s(() => {});
var pNe = s(() => {});
var hNe = s(() => {});
var gNe = s(() => {});
var yNe = s(() => {
  mNe();
  fNe();
  uNe();
  pNe();
  hNe();
  gNe();
});
var xNe = s(() => {});
var ENe = s(() => {});
var SNe = s(() => {});
var CNe = s(() => {});
var bNe = s(() => {});
var _Ne = s(() => {});
var wNe = s(() => {});
var TNe = s(() => {
  bNe();
  _Ne();
  wNe();
});
var ANe = s(() => {});
var RNe = s(() => {});
var INe,
  PNe = s(() => {
    (function (e) {
      (e.HTTP = "http"), (e.HTTPS = "https");
    })(INe || (INe = {}));
  });
var vNe = s(() => {});
var ONe = s(() => {});
var kNe = s(() => {});
var DNe = s(() => {});
var NNe = s(() => {});
var BNe = s(() => {
  vNe();
  ONe();
  kNe();
  DNe();
  NNe();
});
var MNe = s(() => {});
var V1,
  W1 = s(() => {
    (function (e) {
      (e.MD5 = "md5"),
        (e.CRC32 = "crc32"),
        (e.CRC32C = "crc32c"),
        (e.SHA1 = "sha1"),
        (e.SHA256 = "sha256");
    })(V1 || (V1 = {}));
  });
var LNe = s(() => {
  W1();
});
var FNe = s(() => {});
var UNe = s(() => {
  LNe();
  FNe();
  W1();
});
var $Ne = s(() => {});
var K1,
  HNe = s(() => {
    (function (e) {
      (e[(e.HEADER = 0)] = "HEADER"), (e[(e.TRAILER = 1)] = "TRAILER");
    })(K1 || (K1 = {}));
  });
var zNe = s(() => {});
var qNe = s(() => {});
var jNe = s(() => {});
var GNe = s(() => {});
var VNe = s(() => {});
var WNe = s(() => {
  qNe();
  jNe();
  GNe();
  VNe();
});
var KNe = s(() => {});
var YNe = s(() => {});
var QNe = s(() => {});
var XNe,
  JNe = s(() => {
    (function (e) {
      (e.PROFILE = "profile"),
        (e.SSO_SESSION = "sso-session"),
        (e.SERVICES = "services");
    })(XNe || (XNe = {}));
  });
var ZNe = s(() => {});
var eBe = s(() => {});
var tBe = s(() => {});
var rBe = s(() => {});
var oBe = s(() => {});
var nBe = s(() => {});
var sBe = s(() => {});
var iBe = s(() => {});
var aBe = s(() => {});
var cBe = s(() => {});
var dBe = s(() => {});
var mBe,
  lBe = s(() => {
    (function (e) {
      (e.HTTP_0_9 = "http/0.9"),
        (e.HTTP_1_0 = "http/1.0"),
        (e.TDS_8_0 = "tds/8.0");
    })(mBe || (mBe = {}));
  });
var fBe = s(() => {});
var uBe = s(() => {});
var pBe = s(() => {});
var hBe = s(() => {});
var gBe = s(() => {});
var yBe = s(() => {});
var xBe = s(() => {});
var EBe = s(() => {
  cNe();
  yNe();
  xNe();
  ENe();
  SNe();
  CNe();
  TNe();
  ANe();
  RNe();
  PNe();
  BNe();
  MNe();
  UNe();
  $Ne();
  HNe();
  zNe();
  WNe();
  KNe();
  YNe();
  QNe();
  JNe();
  ZNe();
  eBe();
  tBe();
  rBe();
  oBe();
  nBe();
  sBe();
  iBe();
  aBe();
  cBe();
  dBe();
  lBe();
  fBe();
  uBe();
  pBe();
  hBe();
  gBe();
  yBe();
  xBe();
});
var SBe = s(() => {
  EBe();
});
var CBe = s(() => {});
var bBe = s(() => {});
function Fpt(e) {
  return Object.keys(e).reduce((t, r) => {
    let o = e[r];
    return { ...t, [r]: Array.isArray(o) ? [...o] : o };
  }, {});
}
var gu,
  _Be = s(() => {
    gu = class e {
      constructor(t) {
        (this.method = t.method || "GET"),
          (this.hostname = t.hostname || "localhost"),
          (this.port = t.port),
          (this.query = t.query || {}),
          (this.headers = t.headers || {}),
          (this.body = t.body),
          (this.protocol = t.protocol
            ? t.protocol.slice(-1) !== ":"
              ? `${t.protocol}:`
              : t.protocol
            : "https:"),
          (this.path = t.path
            ? t.path.charAt(0) !== "/"
              ? `/${t.path}`
              : t.path
            : "/"),
          (this.username = t.username),
          (this.password = t.password),
          (this.fragment = t.fragment);
      }
      static clone(t) {
        let r = new e({ ...t, headers: { ...t.headers } });
        return r.query && (r.query = Fpt(r.query)), r;
      }
      static isInstance(t) {
        if (!t) return !1;
        let r = t;
        return (
          "method" in r &&
          "protocol" in r &&
          "hostname" in r &&
          "path" in r &&
          typeof r.query == "object" &&
          typeof r.headers == "object"
        );
      }
      clone() {
        return e.clone(this);
      }
    };
  });
var wBe = s(() => {});
var TBe = s(() => {});
var ABe = s(() => {});
var yu = s(() => {
  aNe();
  SBe();
  CBe();
  bBe();
  _Be();
  wBe();
  TBe();
  ABe();
});
import { Buffer as Upt } from "buffer";
var RBe,
  Y1 = s(() => {
    cr();
    RBe = (e, t = 0, r = e.byteLength - t) => {
      if (!Ke(e))
        throw new TypeError(
          `The "input" argument must be ArrayBuffer. Received type ${typeof e} (${e})`
        );
      return Upt.from(e, t, r);
    };
  });
var IBe = s(() => {
  Y1();
});
import { Buffer as PBe } from "buffer";
var vBe,
  Q1 = s(() => {
    cr();
    vBe = (e, t) => {
      if (typeof e != "string")
        throw new TypeError(
          `The "input" argument must be of type string. Received type ${typeof e} (${e})`
        );
      return t ? PBe.from(e, t) : PBe.from(e);
    };
  });
var by,
  X1 = s(() => {
    Q1();
    by = (e) => {
      let t = vBe(e, "utf8");
      return new Uint8Array(
        t.buffer,
        t.byteOffset,
        t.byteLength / Uint8Array.BYTES_PER_ELEMENT
      );
    };
  });
var OBe,
  kBe = s(() => {
    X1();
    OBe = (e) =>
      typeof e == "string"
        ? by(e)
        : ArrayBuffer.isView(e)
          ? new Uint8Array(
              e.buffer,
              e.byteOffset,
              e.byteLength / Uint8Array.BYTES_PER_ELEMENT
            )
          : new Uint8Array(e);
  });
var DBe = s(() => {
  Q1();
});
var _y = s(() => {
  X1();
  kBe();
  DBe();
});
var xu,
  NBe = s(() => {
    Y1();
    _y();
    xu = (e) => {
      let t;
      if (
        (typeof e == "string" ? (t = by(e)) : (t = e),
        typeof t != "object" ||
          typeof t.byteOffset != "number" ||
          typeof t.byteLength != "number")
      )
        throw new Error(
          "@smithy/util-base64: toBase64 encoder function only accepts string | Uint8Array."
        );
      return RBe(t.buffer, t.byteOffset, t.byteLength).toString("base64");
    };
  });
var Eu = s(() => {
  IBe();
  NBe();
});
var BBe = s(() => {
  Eu();
  _y();
  J1();
});
var J1 = s(() => {
  BBe();
});
import { Duplex as zpt } from "stream";
var MA,
  Z1 = s(() => {
    Eu();
    MA = class extends zpt {
      constructor({
        expectedChecksum: t,
        checksum: r,
        source: o,
        checksumSourceLocation: n,
        base64Encoder: i,
      }) {
        if ((super(), typeof o.pipe == "function")) this.source = o;
        else
          throw new Error(
            `@smithy/util-stream: unsupported source type ${o?.constructor?.name ?? o} in ChecksumStream.`
          );
        (this.base64Encoder = i ?? xu),
          (this.expectedChecksum = t),
          (this.checksum = r),
          (this.checksumSourceLocation = n),
          this.source.pipe(this);
      }
      _read(t) {}
      _write(t, r, o) {
        try {
          this.checksum.update(t), this.push(t);
        } catch (n) {
          return o(n);
        }
        return o();
      }
      async _final(t) {
        try {
          let r = await this.checksum.digest(),
            o = this.base64Encoder(r);
          if (this.expectedChecksum !== o)
            return t(
              new Error(
                `Checksum mismatch: expected "${this.expectedChecksum}" but received "${o}" in response header "${this.checksumSourceLocation}".`
              )
            );
        } catch (r) {
          return t(r);
        }
        return this.push(null), t();
      }
    };
  });
var aa,
  hc = s(() => {
    aa = (e) =>
      typeof ReadableStream == "function" &&
      (e?.constructor?.name === ReadableStream.name ||
        e instanceof ReadableStream);
  });
var qpt,
  LA,
  MBe = s(() => {
    (qpt =
      typeof ReadableStream == "function" ? ReadableStream : function () {}),
      (LA = class extends qpt {});
  });
var LBe,
  FBe = s(() => {
    Eu();
    hc();
    MBe();
    LBe = ({
      expectedChecksum: e,
      checksum: t,
      source: r,
      checksumSourceLocation: o,
      base64Encoder: n,
    }) => {
      if (!aa(r))
        throw new Error(
          `@smithy/util-stream: unsupported source type ${r?.constructor?.name ?? r} in ChecksumStream.`
        );
      let i = n ?? xu;
      if (typeof TransformStream != "function")
        throw new Error(
          "@smithy/util-stream: unable to instantiate ChecksumStream because API unavailable: ReadableStream/TransformStream."
        );
      let a = new TransformStream({
        start() {},
        async transform(d, m) {
          t.update(d), m.enqueue(d);
        },
        async flush(d) {
          let m = await t.digest(),
            f = i(m);
          if (e !== f) {
            let l = new Error(
              `Checksum mismatch: expected "${e}" but received "${f}" in response header "${o}".`
            );
            d.error(l);
          } else d.terminate();
        },
      });
      r.pipeThrough(a);
      let c = a.readable;
      return Object.setPrototypeOf(c, LA.prototype), c;
    };
  });
function UBe(e) {
  return typeof ReadableStream == "function" && aa(e.source)
    ? LBe(e)
    : new MA(e);
}
var $Be = s(() => {
  hc();
  Z1();
  FBe();
});
var Ld,
  eH = s(() => {
    Ld = class {
      constructor(t) {
        (this.allocByteArray = t),
          (this.byteLength = 0),
          (this.byteArrays = []);
      }
      push(t) {
        this.byteArrays.push(t), (this.byteLength += t.byteLength);
      }
      flush() {
        if (this.byteArrays.length === 1) {
          let o = this.byteArrays[0];
          return this.reset(), o;
        }
        let t = this.allocByteArray(this.byteLength),
          r = 0;
        for (let o = 0; o < this.byteArrays.length; ++o) {
          let n = this.byteArrays[o];
          t.set(n, r), (r += n.byteLength);
        }
        return this.reset(), t;
      }
      reset() {
        (this.byteArrays = []), (this.byteLength = 0);
      }
    };
  });
function HBe(e, t, r) {
  let o = e.getReader(),
    n = !1,
    i = 0,
    a = ["", new Ld((m) => new Uint8Array(m))],
    c = -1,
    d = async (m) => {
      let { value: f, done: l } = await o.read(),
        u = f;
      if (l) {
        if (c !== -1) {
          let h = Fd(a, c);
          ca(h) > 0 && m.enqueue(h);
        }
        m.close();
      } else {
        let h = rH(u, !1);
        if ((c !== h && (c >= 0 && m.enqueue(Fd(a, c)), (c = h)), c === -1)) {
          m.enqueue(u);
          return;
        }
        let y = ca(u);
        i += y;
        let S = ca(a[c]);
        if (y >= t && S === 0) m.enqueue(u);
        else {
          let E = tH(a, c, u);
          !n &&
            i > t * 2 &&
            ((n = !0),
            r?.warn(
              `@smithy/util-stream - stream chunk size ${y} is below threshold of ${t}, automatically buffering.`
            )),
            E >= t ? m.enqueue(Fd(a, c)) : await d(m);
        }
      }
    };
  return new ReadableStream({ pull: d });
}
function tH(e, t, r) {
  switch (t) {
    case 0:
      return (e[0] += r), ca(e[0]);
    case 1:
    case 2:
      return e[t].push(r), ca(e[t]);
  }
}
function Fd(e, t) {
  switch (t) {
    case 0:
      let r = e[0];
      return (e[0] = ""), r;
    case 1:
    case 2:
      return e[t].flush();
  }
  throw new Error(`@smithy/util-stream - invalid index ${t} given to flush()`);
}
function ca(e) {
  return e?.byteLength ?? e?.length ?? 0;
}
function rH(e, t = !0) {
  return t && typeof Buffer < "u" && e instanceof Buffer
    ? 2
    : e instanceof Uint8Array
      ? 1
      : typeof e == "string"
        ? 0
        : -1;
}
var zBe = s(() => {
  eH();
});
import { Readable as jpt } from "node:stream";
function qBe(e, t, r) {
  if (aa(e)) return HBe(e, t, r);
  let o = new jpt({ read() {} }),
    n = !1,
    i = 0,
    a = [
      "",
      new Ld((d) => new Uint8Array(d)),
      new Ld((d) => Buffer.from(new Uint8Array(d))),
    ],
    c = -1;
  return (
    e.on("data", (d) => {
      let m = rH(d, !0);
      if ((c !== m && (c >= 0 && o.push(Fd(a, c)), (c = m)), c === -1)) {
        o.push(d);
        return;
      }
      let f = ca(d);
      i += f;
      let l = ca(a[c]);
      if (f >= t && l === 0) o.push(d);
      else {
        let u = tH(a, c, d);
        !n &&
          i > t * 2 &&
          ((n = !0),
          r?.warn(
            `@smithy/util-stream - stream chunk size ${f} is below threshold of ${t}, automatically buffering.`
          )),
          u >= t && o.push(Fd(a, c));
      }
    }),
    e.on("end", () => {
      if (c !== -1) {
        let d = Fd(a, c);
        ca(d) > 0 && o.push(d);
      }
      o.push(null);
    }),
    o
  );
}
var jBe = s(() => {
  eH();
  zBe();
  hc();
});
var GBe = s(() => {});
var VBe = s(() => {});
var WBe = s(() => {
  VBe();
  hc();
});
var oH = s(() => {});
var KBe = s(() => {
  oH();
});
var YBe = s(() => {
  oH();
  KBe();
});
var FA = s(() => {
  YBe();
});
var QBe = s(() => {});
var nH = s(() => {});
var Su = s(() => {});
var XBe = s(() => {
  Su();
});
var JBe = s(() => {
  Su();
});
var ZBe = s(() => {
  sH();
  Su();
});
var iH = s(() => {
  Su();
});
var sH = s(() => {
  yu();
  FA();
  QBe();
  nH();
  XBe();
  JBe();
  ZBe();
  Su();
  iH();
});
var rMe = s(() => {});
var oMe = s(() => {
  rMe();
});
var nMe = s(() => {
  yu();
  FA();
  nH();
  oMe();
  iH();
});
var sMe = s(() => {});
var iMe = s(() => {
  sMe();
});
var aMe = s(() => {
  sH();
  nMe();
  iMe();
});
var cMe = s(() => {
  cr();
});
var dMe = s(() => {});
var mMe = s(() => {});
var lMe = s(() => {
  yu();
  FA();
  dMe();
  mMe();
});
var fMe = s(() => {
  Eu();
});
var uMe = s(() => {
  lMe();
  fMe();
});
var pMe = s(() => {
  uMe();
  Eu();
  Fo();
  _y();
  hc();
});
var hMe = s(() => {
  aMe();
  cMe();
  pMe();
});
var gMe = s(() => {});
var yMe = s(() => {
  gMe();
  hc();
});
var aH = s(() => {
  J1();
  Z1();
  $Be();
  jBe();
  GBe();
  WBe();
  hMe();
  yMe();
  hc();
});
var wy,
  xMe,
  cH = s(() => {
    fs();
    (wy = [kt.CRC32, kt.CRC32C, kt.CRC64NVME, kt.SHA1, kt.SHA256]),
      (xMe = [kt.SHA256, kt.SHA1, kt.CRC32, kt.CRC32C, kt.CRC64NVME]);
  });
var EMe,
  SMe = s(() => {
    fs();
    cH();
    EMe = (
      e,
      {
        requestChecksumRequired: t,
        requestAlgorithmMember: r,
        requestChecksumCalculation: o,
      }
    ) => {
      if (!r) return o === ls.WHEN_SUPPORTED || t ? Cy : void 0;
      if (!e[r]) return;
      let n = e[r];
      if (!wy.includes(n))
        throw new Error(
          `The checksum algorithm "${n}" is not supported by the client. Select one of ${wy}.`
        );
      return n;
    };
  });
var Cu,
  $A = s(() => {
    fs();
    Cu = (e) =>
      e === kt.MD5 ? "content-md5" : `x-amz-checksum-${e.toLowerCase()}`;
  });
var CMe,
  bMe = s(() => {
    CMe = (e, t) => {
      let r = e.toLowerCase();
      for (let o of Object.keys(t)) if (r === o.toLowerCase()) return !0;
      return !1;
    };
  });
var _Me,
  wMe = s(() => {
    _Me = (e, t) => {
      let r = e.toLowerCase();
      for (let o of Object.keys(t))
        if (o.toLowerCase().startsWith(r)) return !0;
      return !1;
    };
  });
var HA,
  dH = s(() => {
    cr();
    HA = (e) =>
      e !== void 0 && typeof e != "string" && !ArrayBuffer.isView(e) && !Ke(e);
  });
function zA(e, t, r, o) {
  function n(i) {
    return i instanceof r
      ? i
      : new r(function (a) {
          a(i);
        });
  }
  return new (r || (r = Promise))(function (i, a) {
    function c(f) {
      try {
        m(o.next(f));
      } catch (l) {
        a(l);
      }
    }
    function d(f) {
      try {
        m(o.throw(f));
      } catch (l) {
        a(l);
      }
    }
    function m(f) {
      f.done ? i(f.value) : n(f.value).then(c, d);
    }
    m((o = o.apply(e, t || [])).next());
  });
}
function qA(e, t) {
  var r = {
      label: 0,
      sent: function () {
        if (i[0] & 1) throw i[1];
        return i[1];
      },
      trys: [],
      ops: [],
    },
    o,
    n,
    i,
    a = Object.create(
      (typeof Iterator == "function" ? Iterator : Object).prototype
    );
  return (
    (a.next = c(0)),
    (a.throw = c(1)),
    (a.return = c(2)),
    typeof Symbol == "function" &&
      (a[Symbol.iterator] = function () {
        return this;
      }),
    a
  );
  function c(m) {
    return function (f) {
      return d([m, f]);
    };
  }
  function d(m) {
    if (o) throw new TypeError("Generator is already executing.");
    for (; a && ((a = 0), m[0] && (r = 0)), r; )
      try {
        if (
          ((o = 1),
          n &&
            (i =
              m[0] & 2
                ? n.return
                : m[0]
                  ? n.throw || ((i = n.return) && i.call(n), 0)
                  : n.next) &&
            !(i = i.call(n, m[1])).done)
        )
          return i;
        switch (((n = 0), i && (m = [m[0] & 2, i.value]), m[0])) {
          case 0:
          case 1:
            i = m;
            break;
          case 4:
            return r.label++, { value: m[1], done: !1 };
          case 5:
            r.label++, (n = m[1]), (m = [0]);
            continue;
          case 7:
            (m = r.ops.pop()), r.trys.pop();
            continue;
          default:
            if (
              ((i = r.trys),
              !(i = i.length > 0 && i[i.length - 1]) &&
                (m[0] === 6 || m[0] === 2))
            ) {
              r = 0;
              continue;
            }
            if (m[0] === 3 && (!i || (m[1] > i[0] && m[1] < i[3]))) {
              r.label = m[1];
              break;
            }
            if (m[0] === 6 && r.label < i[1]) {
              (r.label = i[1]), (i = m);
              break;
            }
            if (i && r.label < i[2]) {
              (r.label = i[2]), r.ops.push(m);
              break;
            }
            i[2] && r.ops.pop(), r.trys.pop();
            continue;
        }
        m = t.call(e, r);
      } catch (f) {
        (m = [6, f]), (n = 0);
      } finally {
        o = i = 0;
      }
    if (m[0] & 5) throw m[1];
    return { value: m[0] ? m[1] : void 0, done: !0 };
  }
}
function jA(e) {
  var t = typeof Symbol == "function" && Symbol.iterator,
    r = t && e[t],
    o = 0;
  if (r) return r.call(e);
  if (e && typeof e.length == "number")
    return {
      next: function () {
        return (
          e && o >= e.length && (e = void 0), { value: e && e[o++], done: !e }
        );
      },
    };
  throw new TypeError(
    t ? "Object is not iterable." : "Symbol.iterator is not defined."
  );
}
var Ty = s(() => {});
var TMe = s(() => {});
import { Buffer as AMe } from "buffer";
var GA,
  Ay = s(() => {
    TMe();
    GA = (e, t) => {
      if (typeof e != "string")
        throw new TypeError(
          `The "input" argument must be of type string. Received type ${typeof e} (${e})`
        );
      return t ? AMe.from(e, t) : AMe.from(e);
    };
  });
var Ry,
  mH = s(() => {
    Ay();
    Ry = (e) => {
      let t = GA(e, "utf8");
      return new Uint8Array(
        t.buffer,
        t.byteOffset,
        t.byteLength / Uint8Array.BYTES_PER_ELEMENT
      );
    };
  });
var RMe = s(() => {
  mH();
});
var IMe = s(() => {
  Ay();
});
var lH = s(() => {
  mH();
  RMe();
  IMe();
});
function fH(e) {
  return e instanceof Uint8Array
    ? e
    : typeof e == "string"
      ? Ypt(e)
      : ArrayBuffer.isView(e)
        ? new Uint8Array(
            e.buffer,
            e.byteOffset,
            e.byteLength / Uint8Array.BYTES_PER_ELEMENT
          )
        : new Uint8Array(e);
}
var Ypt,
  PMe = s(() => {
    lH();
    Ypt =
      typeof Buffer < "u" && Buffer.from
        ? function (e) {
            return Buffer.from(e, "utf8");
          }
        : Ry;
  });
function uH(e) {
  return typeof e == "string" ? e.length === 0 : e.byteLength === 0;
}
var vMe = s(() => {});
function pH(e) {
  return new Uint8Array([
    (e & 4278190080) >> 24,
    (e & 16711680) >> 16,
    (e & 65280) >> 8,
    e & 255,
  ]);
}
var OMe = s(() => {});
function hH(e) {
  if (!Uint32Array.from) {
    for (var t = new Uint32Array(e.length), r = 0; r < e.length; )
      (t[r] = e[r]), (r += 1);
    return t;
  }
  return Uint32Array.from(e);
}
var kMe = s(() => {});
var gH = s(() => {
  PMe();
  vMe();
  OMe();
  kMe();
});
var xH,
  DMe = s(() => {
    Ty();
    gH();
    EH();
    xH = (function () {
      function e() {
        this.crc32c = new yH();
      }
      return (
        (e.prototype.update = function (t) {
          uH(t) || this.crc32c.update(fH(t));
        }),
        (e.prototype.digest = function () {
          return zA(this, void 0, void 0, function () {
            return qA(this, function (t) {
              return [2, pH(this.crc32c.digest())];
            });
          });
        }),
        (e.prototype.reset = function () {
          this.crc32c = new yH();
        }),
        e
      );
    })();
  });
var yH,
  Qpt,
  Xpt,
  EH = s(() => {
    Ty();
    gH();
    DMe();
    (yH = (function () {
      function e() {
        this.checksum = 4294967295;
      }
      return (
        (e.prototype.update = function (t) {
          var r, o;
          try {
            for (var n = jA(t), i = n.next(); !i.done; i = n.next()) {
              var a = i.value;
              this.checksum =
                (this.checksum >>> 8) ^ Xpt[(this.checksum ^ a) & 255];
            }
          } catch (c) {
            r = { error: c };
          } finally {
            try {
              i && !i.done && (o = n.return) && o.call(n);
            } finally {
              if (r) throw r.error;
            }
          }
          return this;
        }),
        (e.prototype.digest = function () {
          return (this.checksum ^ 4294967295) >>> 0;
        }),
        e
      );
    })()),
      (Qpt = [
        0, 4067132163, 3778769143, 324072436, 3348797215, 904991772, 648144872,
        3570033899, 2329499855, 2024987596, 1809983544, 2575936315, 1296289744,
        3207089363, 2893594407, 1578318884, 274646895, 3795141740, 4049975192,
        51262619, 3619967088, 632279923, 922689671, 3298075524, 2592579488,
        1760304291, 2075979607, 2312596564, 1562183871, 2943781820, 3156637768,
        1313733451, 549293790, 3537243613, 3246849577, 871202090, 3878099393,
        357341890, 102525238, 4101499445, 2858735121, 1477399826, 1264559846,
        3107202533, 1845379342, 2677391885, 2361733625, 2125378298, 820201905,
        3263744690, 3520608582, 598981189, 4151959214, 85089709, 373468761,
        3827903834, 3124367742, 1213305469, 1526817161, 2842354314, 2107672161,
        2412447074, 2627466902, 1861252501, 1098587580, 3004210879, 2688576843,
        1378610760, 2262928035, 1955203488, 1742404180, 2511436119, 3416409459,
        969524848, 714683780, 3639785095, 205050476, 4266873199, 3976438427,
        526918040, 1361435347, 2739821008, 2954799652, 1114974503, 2529119692,
        1691668175, 2005155131, 2247081528, 3690758684, 697762079, 986182379,
        3366744552, 476452099, 3993867776, 4250756596, 255256311, 1640403810,
        2477592673, 2164122517, 1922457750, 2791048317, 1412925310, 1197962378,
        3037525897, 3944729517, 427051182, 170179418, 4165941337, 746937522,
        3740196785, 3451792453, 1070968646, 1905808397, 2213795598, 2426610938,
        1657317369, 3053634322, 1147748369, 1463399397, 2773627110, 4215344322,
        153784257, 444234805, 3893493558, 1021025245, 3467647198, 3722505002,
        797665321, 2197175160, 1889384571, 1674398607, 2443626636, 1164749927,
        3070701412, 2757221520, 1446797203, 137323447, 4198817972, 3910406976,
        461344835, 3484808360, 1037989803, 781091935, 3705997148, 2460548119,
        1623424788, 1939049696, 2180517859, 1429367560, 2807687179, 3020495871,
        1180866812, 410100952, 3927582683, 4182430767, 186734380, 3756733383,
        763408580, 1053836080, 3434856499, 2722870694, 1344288421, 1131464017,
        2971354706, 1708204729, 2545590714, 2229949006, 1988219213, 680717673,
        3673779818, 3383336350, 1002577565, 4010310262, 493091189, 238226049,
        4233660802, 2987750089, 1082061258, 1395524158, 2705686845, 1972364758,
        2279892693, 2494862625, 1725896226, 952904198, 3399985413, 3656866545,
        731699698, 4283874585, 222117402, 510512622, 3959836397, 3280807620,
        837199303, 582374963, 3504198960, 68661723, 4135334616, 3844915500,
        390545967, 1230274059, 3141532936, 2825850620, 1510247935, 2395924756,
        2091215383, 1878366691, 2644384480, 3553878443, 565732008, 854102364,
        3229815391, 340358836, 3861050807, 4117890627, 119113024, 1493875044,
        2875275879, 3090270611, 1247431312, 2660249211, 1828433272, 2141937292,
        2378227087, 3811616794, 291187481, 34330861, 4032846830, 615137029,
        3603020806, 3314634738, 939183345, 1776939221, 2609017814, 2295496738,
        2058945313, 2926798794, 1545135305, 1330124605, 3173225534, 4084100981,
        17165430, 307568514, 3762199681, 888469610, 3332340585, 3587147933,
        665062302, 2042050490, 2346497209, 2559330125, 1793573966, 3190661285,
        1279665062, 1595330642, 2910671697,
      ]),
      (Xpt = hH(Qpt));
  });
function SH(e) {
  return e instanceof Uint8Array
    ? e
    : typeof e == "string"
      ? Jpt(e)
      : ArrayBuffer.isView(e)
        ? new Uint8Array(
            e.buffer,
            e.byteOffset,
            e.byteLength / Uint8Array.BYTES_PER_ELEMENT
          )
        : new Uint8Array(e);
}
var Jpt,
  NMe = s(() => {
    lH();
    Jpt =
      typeof Buffer < "u" && Buffer.from
        ? function (e) {
            return Buffer.from(e, "utf8");
          }
        : Ry;
  });
function CH(e) {
  return typeof e == "string" ? e.length === 0 : e.byteLength === 0;
}
var BMe = s(() => {});
function bH(e) {
  return new Uint8Array([
    (e & 4278190080) >> 24,
    (e & 16711680) >> 16,
    (e & 65280) >> 8,
    e & 255,
  ]);
}
var MMe = s(() => {});
function _H(e) {
  if (!Uint32Array.from) {
    for (var t = new Uint32Array(e.length), r = 0; r < e.length; )
      (t[r] = e[r]), (r += 1);
    return t;
  }
  return Uint32Array.from(e);
}
var LMe = s(() => {});
var wH = s(() => {
  NMe();
  BMe();
  MMe();
  LMe();
});
var TH,
  FMe = s(() => {
    Ty();
    wH();
    Iy();
    TH = (function () {
      function e() {
        this.crc32 = new Ud();
      }
      return (
        (e.prototype.update = function (t) {
          CH(t) || this.crc32.update(SH(t));
        }),
        (e.prototype.digest = function () {
          return zA(this, void 0, void 0, function () {
            return qA(this, function (t) {
              return [2, bH(this.crc32.digest())];
            });
          });
        }),
        (e.prototype.reset = function () {
          this.crc32 = new Ud();
        }),
        e
      );
    })();
  });
var Ud,
  Zpt,
  eht,
  Iy = s(() => {
    Ty();
    wH();
    FMe();
    (Ud = (function () {
      function e() {
        this.checksum = 4294967295;
      }
      return (
        (e.prototype.update = function (t) {
          var r, o;
          try {
            for (var n = jA(t), i = n.next(); !i.done; i = n.next()) {
              var a = i.value;
              this.checksum =
                (this.checksum >>> 8) ^ eht[(this.checksum ^ a) & 255];
            }
          } catch (c) {
            r = { error: c };
          } finally {
            try {
              i && !i.done && (o = n.return) && o.call(n);
            } finally {
              if (r) throw r.error;
            }
          }
          return this;
        }),
        (e.prototype.digest = function () {
          return (this.checksum ^ 4294967295) >>> 0;
        }),
        e
      );
    })()),
      (Zpt = [
        0, 1996959894, 3993919788, 2567524794, 124634137, 1886057615,
        3915621685, 2657392035, 249268274, 2044508324, 3772115230, 2547177864,
        162941995, 2125561021, 3887607047, 2428444049, 498536548, 1789927666,
        4089016648, 2227061214, 450548861, 1843258603, 4107580753, 2211677639,
        325883990, 1684777152, 4251122042, 2321926636, 335633487, 1661365465,
        4195302755, 2366115317, 997073096, 1281953886, 3579855332, 2724688242,
        1006888145, 1258607687, 3524101629, 2768942443, 901097722, 1119000684,
        3686517206, 2898065728, 853044451, 1172266101, 3705015759, 2882616665,
        651767980, 1373503546, 3369554304, 3218104598, 565507253, 1454621731,
        3485111705, 3099436303, 671266974, 1594198024, 3322730930, 2970347812,
        795835527, 1483230225, 3244367275, 3060149565, 1994146192, 31158534,
        2563907772, 4023717930, 1907459465, 112637215, 2680153253, 3904427059,
        2013776290, 251722036, 2517215374, 3775830040, 2137656763, 141376813,
        2439277719, 3865271297, 1802195444, 476864866, 2238001368, 4066508878,
        1812370925, 453092731, 2181625025, 4111451223, 1706088902, 314042704,
        2344532202, 4240017532, 1658658271, 366619977, 2362670323, 4224994405,
        1303535960, 984961486, 2747007092, 3569037538, 1256170817, 1037604311,
        2765210733, 3554079995, 1131014506, 879679996, 2909243462, 3663771856,
        1141124467, 855842277, 2852801631, 3708648649, 1342533948, 654459306,
        3188396048, 3373015174, 1466479909, 544179635, 3110523913, 3462522015,
        1591671054, 702138776, 2966460450, 3352799412, 1504918807, 783551873,
        3082640443, 3233442989, 3988292384, 2596254646, 62317068, 1957810842,
        3939845945, 2647816111, 81470997, 1943803523, 3814918930, 2489596804,
        225274430, 2053790376, 3826175755, 2466906013, 167816743, 2097651377,
        4027552580, 2265490386, 503444072, 1762050814, 4150417245, 2154129355,
        426522225, 1852507879, 4275313526, 2312317920, 282753626, 1742555852,
        4189708143, 2394877945, 397917763, 1622183637, 3604390888, 2714866558,
        953729732, 1340076626, 3518719985, 2797360999, 1068828381, 1219638859,
        3624741850, 2936675148, 906185462, 1090812512, 3747672003, 2825379669,
        829329135, 1181335161, 3412177804, 3160834842, 628085408, 1382605366,
        3423369109, 3138078467, 570562233, 1426400815, 3317316542, 2998733608,
        733239954, 1555261956, 3268935591, 3050360625, 752459403, 1541320221,
        2607071920, 3965973030, 1969922972, 40735498, 2617837225, 3943577151,
        1913087877, 83908371, 2512341634, 3803740692, 2075208622, 213261112,
        2463272603, 3855990285, 2094854071, 198958881, 2262029012, 4057260610,
        1759359992, 534414190, 2176718541, 4139329115, 1873836001, 414664567,
        2282248934, 4279200368, 1711684554, 285281116, 2405801727, 4167216745,
        1634467795, 376229701, 2685067896, 3608007406, 1308918612, 956543938,
        2808555105, 3495958263, 1231636301, 1047427035, 2932959818, 3654703836,
        1088359270, 936918e3, 2847714899, 3736837829, 1202900863, 817233897,
        3183342108, 3401237130, 1404277552, 615818150, 3134207493, 3453421203,
        1423857449, 601450431, 3009837614, 3294710456, 1567103746, 711928724,
        3020668471, 3272380065, 1510334235, 755167117,
      ]),
      (eht = _H(Zpt));
  });
var AH,
  RH = s(() => {
    Ay();
    AH = (e) => {
      let t = GA(e, "utf8");
      return new Uint8Array(
        t.buffer,
        t.byteOffset,
        t.byteLength / Uint8Array.BYTES_PER_ELEMENT
      );
    };
  });
var UMe = s(() => {
  RH();
});
var $Me = s(() => {
  Ay();
});
var HMe = s(() => {
  RH();
  UMe();
  $Me();
});
var Tdo,
  zMe = s(() => {
    HMe();
    Tdo =
      typeof Buffer < "u" && Buffer.from
        ? function (e) {
            return Buffer.from(e, "utf8");
          }
        : AH;
  });
var qMe = s(() => {});
function IH(e) {
  return new Uint8Array([
    (e & 4278190080) >> 24,
    (e & 16711680) >> 16,
    (e & 65280) >> 8,
    e & 255,
  ]);
}
var jMe = s(() => {});
var GMe = s(() => {});
var VMe = s(() => {
  zMe();
  qMe();
  jMe();
  GMe();
});
import * as vH from "zlib";
var PH,
  WMe,
  KMe = s(() => {
    Iy();
    VMe();
    (PH = class {
      checksum = 0;
      update(t) {
        this.checksum = vH.crc32(t, this.checksum);
      }
      async digest() {
        return IH(this.checksum);
      }
      reset() {
        this.checksum = 0;
      }
    }),
      (WMe = () => (typeof vH.crc32 > "u" ? TH : PH));
  });
var VA,
  OH = s(() => {
    EH();
    fs();
    G1();
    KMe();
    VA = (e, t) => {
      switch (e) {
        case kt.MD5:
          return t.md5;
        case kt.CRC32:
          return WMe();
        case kt.CRC32C:
          return xH;
        case kt.CRC64NVME:
          if (typeof j1.CrtCrc64Nvme != "function")
            throw new Error(`Please check whether you have installed the "@aws-sdk/crc64-nvme-crt" package explicitly. 
You must also register the package by calling [require("@aws-sdk/crc64-nvme-crt");] or an ESM equivalent such as [import "@aws-sdk/crc64-nvme-crt";]. 
For more information please go to https://github.com/aws/aws-sdk-js-v3#functionality-requiring-aws-common-runtime-crt`);
          return j1.CrtCrc64Nvme;
        case kt.SHA1:
          return t.sha1;
        case kt.SHA256:
          return t.sha256;
        default:
          throw new Error(`Unsupported checksum algorithm: ${e}`);
      }
    };
  });
var WA,
  kH = s(() => {
    _y();
    WA = (e, t) => {
      let r = new e();
      return r.update(OBe(t || "")), r.digest();
    };
  });
var YMe,
  QMe,
  DH = s(() => {
    rt();
    yu();
    aH();
    fs();
    SMe();
    $A();
    bMe();
    wMe();
    dH();
    OH();
    kH();
    (YMe = {
      name: "flexibleChecksumsMiddleware",
      step: "build",
      tags: ["BODY_CHECKSUM"],
      override: !0,
    }),
      (QMe = (e, t) => (r, o) => async (n) => {
        if (
          !gu.isInstance(n.request) ||
          _Me("x-amz-checksum-", n.request.headers)
        )
          return r(n);
        let { request: i, input: a } = n,
          { body: c, headers: d } = i,
          { base64Encoder: m, streamHasher: f } = e,
          { requestChecksumRequired: l, requestAlgorithmMember: u } = t,
          h = await e.requestChecksumCalculation(),
          y = u?.name,
          S = u?.httpHeader;
        y &&
          !a[y] &&
          (h === ls.WHEN_SUPPORTED || l) &&
          ((a[y] = Cy), S && (d[S] = Cy));
        let E = EMe(a, {
            requestChecksumRequired: l,
            requestAlgorithmMember: u?.name,
            requestChecksumCalculation: h,
          }),
          b = c,
          v = d;
        if (E) {
          switch (E) {
            case kt.CRC32:
              _e(o, "FLEXIBLE_CHECKSUMS_REQ_CRC32", "U");
              break;
            case kt.CRC32C:
              _e(o, "FLEXIBLE_CHECKSUMS_REQ_CRC32C", "V");
              break;
            case kt.CRC64NVME:
              _e(o, "FLEXIBLE_CHECKSUMS_REQ_CRC64", "W");
              break;
            case kt.SHA1:
              _e(o, "FLEXIBLE_CHECKSUMS_REQ_SHA1", "X");
              break;
            case kt.SHA256:
              _e(o, "FLEXIBLE_CHECKSUMS_REQ_SHA256", "Y");
              break;
          }
          let O = Cu(E),
            ge = VA(E, e);
          if (HA(c)) {
            let { getAwsChunkedEncodingStream: Fe, bodyLengthChecker: Vt } = e;
            (b = Fe(
              typeof e.requestStreamBufferSize == "number" &&
                e.requestStreamBufferSize >= 8 * 1024
                ? qBe(c, e.requestStreamBufferSize, o.logger)
                : c,
              {
                base64Encoder: m,
                bodyLengthChecker: Vt,
                checksumLocationName: O,
                checksumAlgorithmFn: ge,
                streamHasher: f,
              }
            )),
              (v = {
                ...d,
                "content-encoding": d["content-encoding"]
                  ? `${d["content-encoding"]},aws-chunked`
                  : "aws-chunked",
                "transfer-encoding": "chunked",
                "x-amz-decoded-content-length": d["content-length"],
                "x-amz-content-sha256": "STREAMING-UNSIGNED-PAYLOAD-TRAILER",
                "x-amz-trailer": O,
              }),
              delete v["content-length"];
          } else if (!CMe(O, d)) {
            let Fe = await WA(ge, c);
            v = { ...d, [O]: m(Fe) };
          }
        }
        return await r({ ...n, request: { ...i, headers: v, body: b } });
      });
  });
var XMe,
  JMe,
  ZMe = s(() => {
    rt();
    fs();
    (XMe = {
      name: "flexibleChecksumsInputMiddleware",
      toMiddleware: "serializerMiddleware",
      relation: "before",
      tags: ["BODY_CHECKSUM"],
      override: !0,
    }),
      (JMe = (e, t) => (r, o) => async (n) => {
        let i = n.input,
          { requestValidationModeMember: a } = t,
          c = await e.requestChecksumCalculation(),
          d = await e.responseChecksumValidation();
        switch (c) {
          case ls.WHEN_REQUIRED:
            _e(o, "FLEXIBLE_CHECKSUMS_REQ_WHEN_REQUIRED", "a");
            break;
          case ls.WHEN_SUPPORTED:
            _e(o, "FLEXIBLE_CHECKSUMS_REQ_WHEN_SUPPORTED", "Z");
            break;
        }
        switch (d) {
          case Md.WHEN_REQUIRED:
            _e(o, "FLEXIBLE_CHECKSUMS_RES_WHEN_REQUIRED", "c");
            break;
          case Md.WHEN_SUPPORTED:
            _e(o, "FLEXIBLE_CHECKSUMS_RES_WHEN_SUPPORTED", "b");
            break;
        }
        return (
          a && !i[a] && d === Md.WHEN_SUPPORTED && (i[a] = "ENABLED"), r(n)
        );
      });
  });
var KA,
  NH = s(() => {
    cH();
    KA = (e = []) => {
      let t = [];
      for (let r of xMe) !e.includes(r) || !wy.includes(r) || t.push(r);
      return t;
    };
  });
var eLe,
  tLe = s(() => {
    eLe = (e) => {
      let t = e.lastIndexOf("-");
      if (t !== -1) {
        let r = e.slice(t + 1);
        if (!r.startsWith("0")) {
          let o = parseInt(r, 10);
          if (!isNaN(o) && o >= 1 && o <= 1e4) return !0;
        }
      }
      return !1;
    };
  });
var rLe,
  oLe = s(() => {
    kH();
    rLe = async (e, { checksumAlgorithmFn: t, base64Encoder: r }) =>
      r(await WA(t, e));
  });
var nLe,
  sLe = s(() => {
    aH();
    fs();
    oLe();
    NH();
    $A();
    dH();
    OH();
    nLe = async (e, { config: t, responseAlgorithms: r, logger: o }) => {
      let n = KA(r),
        { body: i, headers: a } = e;
      for (let c of n) {
        let d = Cu(c),
          m = a[d];
        if (m) {
          let f;
          try {
            f = VA(c, t);
          } catch (h) {
            if (c === kt.CRC64NVME) {
              o?.warn(
                `Skipping ${kt.CRC64NVME} checksum validation: ${h.message}`
              );
              continue;
            }
            throw h;
          }
          let { base64Encoder: l } = t;
          if (HA(i)) {
            e.body = UBe({
              expectedChecksum: m,
              checksumSourceLocation: d,
              checksum: new f(),
              source: i,
              base64Encoder: l,
            });
            return;
          }
          let u = await rLe(i, { checksumAlgorithmFn: f, base64Encoder: l });
          if (u === m) break;
          throw new Error(
            `Checksum mismatch: expected "${u}" but received "${m}" in response header "${d}".`
          );
        }
      }
    };
  });
var iLe,
  aLe,
  cLe = s(() => {
    yu();
    NH();
    $A();
    tLe();
    sLe();
    (iLe = {
      name: "flexibleChecksumsResponseMiddleware",
      toMiddleware: "deserializerMiddleware",
      relation: "after",
      tags: ["BODY_CHECKSUM"],
      override: !0,
    }),
      (aLe = (e, t) => (r, o) => async (n) => {
        if (!gu.isInstance(n.request)) return r(n);
        let i = n.input,
          a = await r(n),
          c = a.response,
          { requestValidationModeMember: d, responseAlgorithms: m } = t;
        if (d && i[d] === "ENABLED") {
          let { clientName: f, commandName: l } = o;
          if (
            f === "S3Client" &&
            l === "GetObjectCommand" &&
            KA(m).every((h) => {
              let y = Cu(h),
                S = c.headers[y];
              return !S || eLe(S);
            })
          )
            return a;
          await nLe(c, { config: e, responseAlgorithms: m, logger: o.logger });
        }
        return a;
      });
  });
var Le,
  dLe = s(() => {
    ZMe();
    DH();
    cLe();
    Le = (e, t) => ({
      applyToStack: (r) => {
        r.add(QMe(e, t), YMe),
          r.addRelativeTo(JMe(e, t), XMe),
          r.addRelativeTo(aLe(e, t), iLe);
      },
    });
  });
var mLe,
  lLe = s(() => {
    ct();
    fs();
    mLe = (e) => {
      let {
        requestChecksumCalculation: t,
        responseChecksumValidation: r,
        requestStreamBufferSize: o,
      } = e;
      return Object.assign(e, {
        requestChecksumCalculation: pe(t ?? NA),
        responseChecksumValidation: pe(r ?? BA),
        requestStreamBufferSize: Number(o ?? 0),
      });
    };
  });
var Kt = s(() => {
  oNe();
  sNe();
  fs();
  G1();
  DH();
  dLe();
  lLe();
});
var YA,
  QA,
  fLe = s(() => {
    (YA = (e) => ({
      setHttpHandler(t) {
        e.httpHandler = t;
      },
      httpHandler() {
        return e.httpHandler;
      },
      updateHttpClientConfig(t, r) {
        e.httpHandler?.updateHttpClientConfig(t, r);
      },
      httpHandlerConfigs() {
        return e.httpHandler.httpHandlerConfigs();
      },
    })),
      (QA = (e) => ({ httpHandler: e.httpHandler() }));
  });
var uLe = s(() => {
  fLe();
});
var pLe = s(() => {});
var hLe,
  gLe = s(() => {
    (function (e) {
      (e.HEADER = "header"), (e.QUERY = "query");
    })(hLe || (hLe = {}));
  });
var yLe,
  xLe = s(() => {
    (function (e) {
      (e.HEADER = "header"), (e.QUERY = "query");
    })(yLe || (yLe = {}));
  });
var ELe = s(() => {});
var SLe = s(() => {});
var CLe = s(() => {});
var bLe = s(() => {});
var _Le = s(() => {
  gLe();
  xLe();
  ELe();
  SLe();
  CLe();
  bLe();
});
var wLe = s(() => {});
var TLe = s(() => {});
var ALe = s(() => {});
var RLe = s(() => {});
var ILe = s(() => {});
var PLe = s(() => {});
var vLe = s(() => {});
var OLe = s(() => {
  ILe();
  PLe();
  vLe();
});
var kLe = s(() => {});
var DLe = s(() => {});
var NLe,
  BLe = s(() => {
    (function (e) {
      (e.HTTP = "http"), (e.HTTPS = "https");
    })(NLe || (NLe = {}));
  });
var MLe = s(() => {});
var LLe = s(() => {});
var FLe = s(() => {});
var ULe = s(() => {});
var $Le = s(() => {});
var HLe = s(() => {
  MLe();
  LLe();
  FLe();
  ULe();
  $Le();
});
var zLe = s(() => {});
var bu,
  BH = s(() => {
    (function (e) {
      (e.MD5 = "md5"),
        (e.CRC32 = "crc32"),
        (e.CRC32C = "crc32c"),
        (e.SHA1 = "sha1"),
        (e.SHA256 = "sha256");
    })(bu || (bu = {}));
  });
var qLe = s(() => {
  BH();
});
var jLe = s(() => {});
var GLe = s(() => {
  qLe();
  jLe();
  BH();
});
var VLe = s(() => {});
var MH,
  WLe = s(() => {
    (function (e) {
      (e[(e.HEADER = 0)] = "HEADER"), (e[(e.TRAILER = 1)] = "TRAILER");
    })(MH || (MH = {}));
  });
var KLe = s(() => {});
var YLe = s(() => {});
var QLe = s(() => {});
var XLe = s(() => {});
var JLe = s(() => {});
var ZLe = s(() => {
  YLe();
  QLe();
  XLe();
  JLe();
});
var eFe = s(() => {});
var tFe,
  rFe = s(() => {
    tFe = "__smithy_context";
  });
var oFe = s(() => {});
var da,
  nFe = s(() => {
    (function (e) {
      (e.PROFILE = "profile"),
        (e.SSO_SESSION = "sso-session"),
        (e.SERVICES = "services");
    })(da || (da = {}));
  });
var sFe = s(() => {});
var iFe = s(() => {});
var aFe = s(() => {});
var cFe = s(() => {});
var dFe = s(() => {});
var mFe = s(() => {});
var lFe = s(() => {});
var fFe = s(() => {});
var uFe = s(() => {});
var pFe = s(() => {});
var hFe = s(() => {});
var gFe,
  yFe = s(() => {
    (function (e) {
      (e.HTTP_0_9 = "http/0.9"),
        (e.HTTP_1_0 = "http/1.0"),
        (e.TDS_8_0 = "tds/8.0");
    })(gFe || (gFe = {}));
  });
var xFe = s(() => {});
var EFe = s(() => {});
var SFe = s(() => {});
var CFe = s(() => {});
var bFe = s(() => {});
var _Fe = s(() => {});
var wFe = s(() => {});
var $d = s(() => {
  pLe();
  _Le();
  wLe();
  TLe();
  ALe();
  RLe();
  OLe();
  kLe();
  DLe();
  BLe();
  HLe();
  zLe();
  GLe();
  VLe();
  WLe();
  KLe();
  ZLe();
  eFe();
  rFe();
  oFe();
  nFe();
  sFe();
  iFe();
  aFe();
  cFe();
  dFe();
  mFe();
  lFe();
  fFe();
  uFe();
  pFe();
  hFe();
  yFe();
  xFe();
  EFe();
  SFe();
  CFe();
  bFe();
  _Fe();
  wFe();
});
var TFe = s(() => {
  $d();
});
var AFe = s(() => {});
var RFe = s(() => {});
function tht(e) {
  return Object.keys(e).reduce((t, r) => {
    let o = e[r];
    return { ...t, [r]: Array.isArray(o) ? [...o] : o };
  }, {});
}
var bn,
  IFe = s(() => {
    bn = class e {
      constructor(t) {
        (this.method = t.method || "GET"),
          (this.hostname = t.hostname || "localhost"),
          (this.port = t.port),
          (this.query = t.query || {}),
          (this.headers = t.headers || {}),
          (this.body = t.body),
          (this.protocol = t.protocol
            ? t.protocol.slice(-1) !== ":"
              ? `${t.protocol}:`
              : t.protocol
            : "https:"),
          (this.path = t.path
            ? t.path.charAt(0) !== "/"
              ? `/${t.path}`
              : t.path
            : "/"),
          (this.username = t.username),
          (this.password = t.password),
          (this.fragment = t.fragment);
      }
      static clone(t) {
        let r = new e({ ...t, headers: { ...t.headers } });
        return r.query && (r.query = tht(r.query)), r;
      }
      static isInstance(t) {
        if (!t) return !1;
        let r = t;
        return (
          "method" in r &&
          "protocol" in r &&
          "hostname" in r &&
          "path" in r &&
          typeof r.query == "object" &&
          typeof r.headers == "object"
        );
      }
      clone() {
        return e.clone(this);
      }
    };
  });
var Gs,
  PFe = s(() => {
    Gs = class {
      constructor(t) {
        (this.statusCode = t.statusCode),
          (this.reason = t.reason),
          (this.headers = t.headers || {}),
          (this.body = t.body);
      }
      static isInstance(t) {
        if (!t) return !1;
        let r = t;
        return typeof r.statusCode == "number" && typeof r.headers == "object";
      }
    };
  });
function vFe(e) {
  return /^[a-z0-9][a-z0-9\.\-]*[a-z0-9]$/.test(e);
}
var OFe = s(() => {});
var kFe = s(() => {});
var an = s(() => {
  uLe();
  TFe();
  AFe();
  RFe();
  IFe();
  PFe();
  OFe();
  kFe();
});
var rht,
  oht,
  XA,
  LH = s(() => {
    an();
    (rht = (e) => (t) => async (r) => {
      if (!bn.isInstance(r.request)) return t(r);
      let { request: o } = r,
        { handlerProtocol: n = "" } = e.requestHandler.metadata || {};
      if (n.indexOf("h2") >= 0 && !o.headers[":authority"])
        delete o.headers.host,
          (o.headers[":authority"] = o.hostname + (o.port ? ":" + o.port : ""));
      else if (!o.headers.host) {
        let i = o.hostname;
        o.port != null && (i += `:${o.port}`), (o.headers.host = i);
      }
      return t(r);
    }),
      (oht = {
        name: "hostHeaderMiddleware",
        step: "build",
        priority: "low",
        tags: ["HOST"],
        override: !0,
      }),
      (XA = (e) => ({
        applyToStack: (t) => {
          t.add(rht(e), oht);
        },
      }));
  });
var nht,
  sht,
  JA,
  DFe = s(() => {
    (nht = () => (e, t) => async (r) => {
      try {
        let o = await e(r),
          {
            clientName: n,
            commandName: i,
            logger: a,
            dynamoDbDocumentClientOptions: c = {},
          } = t,
          {
            overrideInputFilterSensitiveLog: d,
            overrideOutputFilterSensitiveLog: m,
          } = c,
          f = d ?? t.inputFilterSensitiveLog,
          l = m ?? t.outputFilterSensitiveLog,
          { $metadata: u, ...h } = o.output;
        return (
          a?.info?.({
            clientName: n,
            commandName: i,
            input: f(r.input),
            output: l(h),
            metadata: u,
          }),
          o
        );
      } catch (o) {
        let {
            clientName: n,
            commandName: i,
            logger: a,
            dynamoDbDocumentClientOptions: c = {},
          } = t,
          { overrideInputFilterSensitiveLog: d } = c,
          m = d ?? t.inputFilterSensitiveLog;
        throw (
          (a?.error?.({
            clientName: n,
            commandName: i,
            input: m(r.input),
            error: o,
            metadata: o.$metadata,
          }),
          o)
        );
      }
    }),
      (sht = {
        name: "loggerMiddleware",
        tags: ["LOGGER"],
        step: "initialize",
        override: !0,
      }),
      (JA = (e) => ({
        applyToStack: (t) => {
          t.add(nht(), sht);
        },
      }));
  });
var FH = s(() => {
  DFe();
});
var UH,
  iht,
  aht,
  cht,
  dht,
  ZA,
  $H = s(() => {
    an();
    (UH = "X-Amzn-Trace-Id"),
      (iht = "AWS_LAMBDA_FUNCTION_NAME"),
      (aht = "_X_AMZN_TRACE_ID"),
      (cht = (e) => (t) => async (r) => {
        let { request: o } = r;
        if (!bn.isInstance(o) || e.runtime !== "node") return t(r);
        let n =
          Object.keys(o.headers ?? {}).find(
            (d) => d.toLowerCase() === UH.toLowerCase()
          ) ?? UH;
        if (o.headers.hasOwnProperty(n)) return t(r);
        let i = process.env[iht],
          a = process.env[aht],
          c = (d) => typeof d == "string" && d.length > 0;
        return c(i) && c(a) && (o.headers[UH] = a), t({ ...r, request: o });
      }),
      (dht = {
        step: "build",
        tags: ["RECURSION_DETECTION"],
        name: "recursionDetectionMiddleware",
        override: !0,
        priority: "low",
      }),
      (ZA = (e) => ({
        applyToStack: (t) => {
          t.add(cht(e), dht);
        },
      }));
  });
var NFe = s(() => {});
var BFe = s(() => {
  NFe();
});
var MFe = s(() => {});
var LFe,
  FFe = s(() => {
    (function (e) {
      (e.HEADER = "header"), (e.QUERY = "query");
    })(LFe || (LFe = {}));
  });
var UFe,
  $Fe = s(() => {
    (function (e) {
      (e.HEADER = "header"), (e.QUERY = "query");
    })(UFe || (UFe = {}));
  });
var HFe = s(() => {});
var zFe = s(() => {});
var qFe = s(() => {});
var jFe = s(() => {});
var GFe = s(() => {
  FFe();
  $Fe();
  HFe();
  zFe();
  qFe();
  jFe();
});
var VFe = s(() => {});
var WFe = s(() => {});
var KFe = s(() => {});
var YFe = s(() => {});
var QFe = s(() => {});
var XFe = s(() => {});
var JFe = s(() => {});
var ZFe = s(() => {
  QFe();
  XFe();
  JFe();
});
var eUe = s(() => {});
var tUe = s(() => {});
var rUe,
  oUe = s(() => {
    (function (e) {
      (e.HTTP = "http"), (e.HTTPS = "https");
    })(rUe || (rUe = {}));
  });
var nUe = s(() => {});
var sUe = s(() => {});
var iUe = s(() => {});
var aUe = s(() => {});
var cUe = s(() => {});
var dUe = s(() => {
  nUe();
  sUe();
  iUe();
  aUe();
  cUe();
});
var mUe = s(() => {});
var eR,
  HH = s(() => {
    (function (e) {
      (e.MD5 = "md5"),
        (e.CRC32 = "crc32"),
        (e.CRC32C = "crc32c"),
        (e.SHA1 = "sha1"),
        (e.SHA256 = "sha256");
    })(eR || (eR = {}));
  });
var lUe = s(() => {
  HH();
});
var fUe = s(() => {});
var uUe = s(() => {
  lUe();
  fUe();
  HH();
});
var pUe = s(() => {});
var zH,
  hUe = s(() => {
    (function (e) {
      (e[(e.HEADER = 0)] = "HEADER"), (e[(e.TRAILER = 1)] = "TRAILER");
    })(zH || (zH = {}));
  });
var gUe = s(() => {});
var yUe = s(() => {});
var xUe = s(() => {});
var EUe = s(() => {});
var SUe = s(() => {});
var CUe = s(() => {
  yUe();
  xUe();
  EUe();
  SUe();
});
var bUe = s(() => {});
var _Ue = s(() => {});
var wUe = s(() => {});
var TUe,
  AUe = s(() => {
    (function (e) {
      (e.PROFILE = "profile"),
        (e.SSO_SESSION = "sso-session"),
        (e.SERVICES = "services");
    })(TUe || (TUe = {}));
  });
var RUe = s(() => {});
var IUe = s(() => {});
var PUe = s(() => {});
var vUe = s(() => {});
var OUe = s(() => {});
var kUe = s(() => {});
var DUe = s(() => {});
var NUe = s(() => {});
var BUe = s(() => {});
var MUe = s(() => {});
var LUe = s(() => {});
var FUe,
  UUe = s(() => {
    (function (e) {
      (e.HTTP_0_9 = "http/0.9"),
        (e.HTTP_1_0 = "http/1.0"),
        (e.TDS_8_0 = "tds/8.0");
    })(FUe || (FUe = {}));
  });
var $Ue = s(() => {});
var HUe = s(() => {});
var zUe = s(() => {});
var qUe = s(() => {});
var jUe = s(() => {});
var GUe = s(() => {});
var VUe = s(() => {});
var Py = s(() => {
  MFe();
  GFe();
  VFe();
  WFe();
  KFe();
  YFe();
  ZFe();
  eUe();
  tUe();
  oUe();
  dUe();
  mUe();
  uUe();
  pUe();
  hUe();
  gUe();
  CUe();
  bUe();
  _Ue();
  wUe();
  AUe();
  RUe();
  IUe();
  PUe();
  vUe();
  OUe();
  kUe();
  DUe();
  NUe();
  BUe();
  MUe();
  LUe();
  UUe();
  $Ue();
  HUe();
  zUe();
  qUe();
  jUe();
  GUe();
  VUe();
});
var WUe = s(() => {
  Py();
});
var KUe = s(() => {});
var YUe = s(() => {});
function mht(e) {
  return Object.keys(e).reduce((t, r) => {
    let o = e[r];
    return { ...t, [r]: Array.isArray(o) ? [...o] : o };
  }, {});
}
var gc,
  QUe = s(() => {
    gc = class e {
      constructor(t) {
        (this.method = t.method || "GET"),
          (this.hostname = t.hostname || "localhost"),
          (this.port = t.port),
          (this.query = t.query || {}),
          (this.headers = t.headers || {}),
          (this.body = t.body),
          (this.protocol = t.protocol
            ? t.protocol.slice(-1) !== ":"
              ? `${t.protocol}:`
              : t.protocol
            : "https:"),
          (this.path = t.path
            ? t.path.charAt(0) !== "/"
              ? `/${t.path}`
              : t.path
            : "/"),
          (this.username = t.username),
          (this.password = t.password),
          (this.fragment = t.fragment);
      }
      static clone(t) {
        let r = new e({ ...t, headers: { ...t.headers } });
        return r.query && (r.query = mht(r.query)), r;
      }
      static isInstance(t) {
        if (!t) return !1;
        let r = t;
        return (
          "method" in r &&
          "protocol" in r &&
          "hostname" in r &&
          "path" in r &&
          typeof r.query == "object" &&
          typeof r.headers == "object"
        );
      }
      clone() {
        return e.clone(this);
      }
    };
  });
var ma,
  XUe = s(() => {
    ma = class {
      constructor(t) {
        (this.statusCode = t.statusCode),
          (this.reason = t.reason),
          (this.headers = t.headers || {}),
          (this.body = t.body);
      }
      static isInstance(t) {
        if (!t) return !1;
        let r = t;
        return typeof r.statusCode == "number" && typeof r.headers == "object";
      }
    };
  });
var JUe = s(() => {});
var ZUe = s(() => {});
var la = s(() => {
  BFe();
  WUe();
  KUe();
  YUe();
  QUe();
  XUe();
  JUe();
  ZUe();
});
var e$e = s(() => {});
var qH = s(() => {
  e$e();
});
var t$e = s(() => {
  qH();
});
var r$e = s(() => {
  Dt();
});
var o$e = s(() => {
  qH();
  Py();
});
var n$e = s(() => {});
var s$e = s(() => {});
var jH = s(() => {});
var i$e = s(() => {
  jH();
});
var a$e = s(() => {});
var c$e = s(() => {});
var d$e = s(() => {
  Dt();
});
var m$e = s(() => {
  Py();
});
var l$e = s(() => {});
var f$e = s(() => {
  m$e();
  l$e();
});
var u$e = s(() => {
  f$e();
});
var p$e = s(() => {});
var h$e = s(() => {});
var g$e = s(() => {});
var tR,
  y$e = s(() => {
    tR = class {
      trace() {}
      debug() {}
      info() {}
      warn() {}
      error() {}
    };
  });
var x$e = s(() => {});
var E$e = s(() => {
  Dt();
});
var S$e = s(() => {});
var C$e = s(() => {});
var GH = s(() => {
  t$e();
  r$e();
  o$e();
  n$e();
  s$e();
  i$e();
  a$e();
  c$e();
  jH();
  d$e();
  u$e();
  p$e();
  h$e();
  g$e();
  y$e();
  x$e();
  E$e();
  S$e();
  C$e();
  Uo();
});
function pht() {
  return (e, t) => async (r) => {
    let { request: o } = r;
    if (gc.isInstance(o) && !(fht in o.headers) && !(uht in o.headers)) {
      let n =
        "Are you using a Stream of unknown length as the Body of a PutObject request? Consider using Upload instead from @aws-sdk/lib-storage.";
      typeof t?.logger?.warn == "function" && !(t.logger instanceof tR)
        ? t.logger.warn(n)
        : console.warn(n);
    }
    return e({ ...r });
  };
}
var fht,
  uht,
  hht,
  b$e,
  _$e = s(() => {
    la();
    GH();
    (fht = "content-length"), (uht = "x-amz-decoded-content-length");
    (hht = {
      step: "finalizeRequest",
      tags: ["CHECK_CONTENT_LENGTH_HEADER"],
      name: "getCheckContentLengthHeaderPlugin",
      override: !0,
    }),
      (b$e = (e) => ({
        applyToStack: (t) => {
          t.add(pht(), hht);
        },
      }));
  });
var w$e,
  T$e,
  VH = s(() => {
    (w$e = (e) => (t, r) => async (o) => {
      let n = await e.region(),
        i = e.region,
        a = () => {};
      r.__s3RegionRedirect &&
        (Object.defineProperty(e, "region", {
          writable: !1,
          value: async () => r.__s3RegionRedirect,
        }),
        (a = () =>
          Object.defineProperty(e, "region", { writable: !0, value: i })));
      try {
        let c = await t(o);
        if (r.__s3RegionRedirect) {
          a();
          let d = await e.region();
          if (n !== d)
            throw new Error(
              "Region was not restored following S3 region redirect."
            );
        }
        return c;
      } catch (c) {
        throw (a(), c);
      }
    }),
      (T$e = {
        tags: ["REGION_REDIRECT", "S3"],
        name: "regionRedirectEndpointMiddleware",
        override: !0,
        relation: "before",
        toMiddleware: "endpointV2Middleware",
      });
  });
function ght(e) {
  return (t, r) => async (o) => {
    try {
      return await t(o);
    } catch (n) {
      if (
        e.followRegionRedirects &&
        (n?.$metadata?.httpStatusCode === 301 ||
          (n?.$metadata?.httpStatusCode === 400 &&
            n?.name === "IllegalLocationConstraintException"))
      ) {
        try {
          let i = n.$response.headers["x-amz-bucket-region"];
          r.logger?.debug(`Redirecting from ${await e.region()} to ${i}`),
            (r.__s3RegionRedirect = i);
        } catch (i) {
          throw new Error("Region redirect failed: " + i);
        }
        return t(o);
      }
      throw n;
    }
  };
}
var yht,
  A$e,
  R$e = s(() => {
    VH();
    (yht = {
      step: "initialize",
      tags: ["REGION_REDIRECT", "S3"],
      name: "regionRedirectMiddleware",
      override: !0,
    }),
      (A$e = (e) => ({
        applyToStack: (t) => {
          t.add(ght(e), yht), t.addRelativeTo(w$e(e), T$e);
        },
      }));
  });
var xht,
  Eht,
  rR,
  I$e = s(() => {
    la();
    GH();
    (xht = (e) => (t, r) => async (o) => {
      let n = await t(o),
        { response: i } = n;
      if (ma.isInstance(i) && i.headers.expires) {
        i.headers.expiresstring = i.headers.expires;
        try {
          Hn(i.headers.expires);
        } catch (a) {
          r.logger?.warn(
            `AWS SDK Warning for ${r.clientName}::${r.commandName} response parsing (${i.headers.expires}): ${a}`
          ),
            delete i.headers.expires;
        }
      }
      return n;
    }),
      (Eht = {
        tags: ["S3"],
        name: "s3ExpiresMiddleware",
        override: !0,
        relation: "after",
        toMiddleware: "deserializerMiddleware",
      }),
      (rR = (e) => ({
        applyToStack: (t) => {
          t.addRelativeTo(xht(e), Eht);
        },
      }));
  });
var vy,
  WH = s(() => {
    vy = class e {
      data;
      lastPurgeTime = Date.now();
      static EXPIRED_CREDENTIAL_PURGE_INTERVAL_MS = 3e4;
      constructor(t = {}) {
        this.data = t;
      }
      get(t) {
        let r = this.data[t];
        if (r) return r;
      }
      set(t, r) {
        return (this.data[t] = r), r;
      }
      delete(t) {
        delete this.data[t];
      }
      async purgeExpired() {
        let t = Date.now();
        if (!(this.lastPurgeTime + e.EXPIRED_CREDENTIAL_PURGE_INTERVAL_MS > t))
          for (let r in this.data) {
            let o = this.data[r];
            if (!o.isRefreshing) {
              let n = await o.identity;
              n.expiration && n.expiration.getTime() < t && delete this.data[r];
            }
          }
      }
    };
  });
var Hd,
  KH = s(() => {
    Hd = class {
      _identity;
      isRefreshing;
      accessed;
      constructor(t, r = !1, o = Date.now()) {
        (this._identity = t), (this.isRefreshing = r), (this.accessed = o);
      }
      get identity() {
        return (this.accessed = Date.now()), this._identity;
      }
    };
  });
var Oy,
  P$e = s(() => {
    WH();
    KH();
    Oy = class e {
      createSessionFn;
      cache;
      static REFRESH_WINDOW_MS = 6e4;
      constructor(t, r = new vy()) {
        (this.createSessionFn = t), (this.cache = r);
      }
      async getS3ExpressIdentity(t, r) {
        let o = r.Bucket,
          { cache: n } = this,
          i = n.get(o);
        return i
          ? i.identity.then((a) =>
              (a.expiration?.getTime() ?? 0) < Date.now()
                ? n.set(o, new Hd(this.getIdentity(o))).identity
                : ((a.expiration?.getTime() ?? 0) <
                    Date.now() + e.REFRESH_WINDOW_MS &&
                    !i.isRefreshing &&
                    ((i.isRefreshing = !0),
                    this.getIdentity(o).then((m) => {
                      n.set(o, new Hd(Promise.resolve(m)));
                    })),
                  a)
            )
          : n.set(o, new Hd(this.getIdentity(o))).identity;
      }
      async getIdentity(t) {
        await this.cache.purgeExpired().catch((n) => {
          console.warn(
            `Error while clearing expired entries in S3ExpressIdentityCache: 
` + n
          );
        });
        let r = await this.createSessionFn(t);
        if (!r.Credentials?.AccessKeyId || !r.Credentials?.SecretAccessKey)
          throw new Error(
            "s3#createSession response credential missing AccessKeyId or SecretAccessKey."
          );
        return {
          accessKeyId: r.Credentials.AccessKeyId,
          secretAccessKey: r.Credentials.SecretAccessKey,
          sessionToken: r.Credentials.SessionToken,
          expiration: r.Credentials.Expiration
            ? new Date(r.Credentials.Expiration)
            : void 0,
        };
      }
    };
  });
var v$e,
  O$e,
  k$e,
  oR,
  ky,
  Sht,
  Cht,
  YH,
  nR = s(() => {
    Wn();
    (v$e = "Directory"),
      (O$e = "S3Express"),
      (k$e = "sigv4-s3express"),
      (oR = "X-Amz-S3session-Token"),
      (ky = oR.toLowerCase()),
      (Sht = "AWS_S3_DISABLE_EXPRESS_SESSION_AUTH"),
      (Cht = "s3_disable_express_session_auth"),
      (YH = {
        environmentVariableSelector: (e) => Nt(e, Sht, Tt.ENV),
        configFileSelector: (e) => Nt(e, Cht, Tt.CONFIG),
        default: !1,
      });
  });
function D$e(e) {
  return {
    accessKeyId: e.accessKeyId,
    secretAccessKey: e.secretAccessKey,
    expiration: e.expiration,
  };
}
function N$e(e, t) {
  let r = setTimeout(() => {
      throw new Error(
        "SignatureV4S3Express credential override was created but not called."
      );
    }, 10),
    o = e.credentialProvider,
    n = () => (clearTimeout(r), (e.credentialProvider = o), Promise.resolve(t));
  e.credentialProvider = n;
}
var Dy,
  B$e = s(() => {
    AE();
    nR();
    Dy = class extends ed {
      async signWithCredentials(t, r, o) {
        let n = D$e(r);
        t.headers[ky] = r.sessionToken;
        let i = this;
        return N$e(i, n), i.signRequest(t, o ?? {});
      }
      async presignWithCredentials(t, r, o) {
        let n = D$e(r);
        return (
          delete t.headers[ky],
          (t.headers[oR] = r.sessionToken),
          (t.query = t.query ?? {}),
          (t.query[oR] = r.sessionToken),
          N$e(this, n),
          this.presign(t, o)
        );
      }
    };
  });
var M$e,
  L$e,
  QH,
  F$e = s(() => {
    rt();
    la();
    nR();
    (M$e = (e) => (t, r) => async (o) => {
      if (r.endpointV2) {
        let n = r.endpointV2,
          i = n.properties?.authSchemes?.[0]?.name === k$e;
        if (
          ((n.properties?.backend === O$e ||
            n.properties?.bucketType === v$e) &&
            (_e(r, "S3_EXPRESS_BUCKET", "J"), (r.isS3ExpressBucket = !0)),
          i)
        ) {
          let c = o.input.Bucket;
          if (c) {
            let d = await e.s3ExpressIdentityProvider.getS3ExpressIdentity(
              await e.credentials(),
              { Bucket: c }
            );
            (r.s3ExpressIdentity = d),
              gc.isInstance(o.request) &&
                d.sessionToken &&
                (o.request.headers[ky] = d.sessionToken);
          }
        }
      }
      return t(o);
    }),
      (L$e = {
        name: "s3ExpressMiddleware",
        step: "build",
        tags: ["S3", "S3_EXPRESS"],
        override: !0,
      }),
      (QH = (e) => ({
        applyToStack: (t) => {
          t.add(M$e(e), L$e);
        },
      }));
  });
var U$e,
  $$e = s(() => {
    U$e = async (e, t, r, o) => {
      let n = await o.signWithCredentials(r, e, {});
      if (
        n.headers["X-Amz-Security-Token"] ||
        n.headers["x-amz-security-token"]
      )
        throw new Error(
          "X-Amz-Security-Token must not be set for s3-express requests."
        );
      return n;
    };
  });
var bht,
  _ht,
  H$e,
  XH,
  z$e = s(() => {
    Ue();
    la();
    Py();
    ct();
    $$e();
    (bht = (e) => (t) => {
      throw t;
    }),
      (_ht = (e, t) => {}),
      (H$e = (e) => (t, r) => async (o) => {
        if (!gc.isInstance(o.request)) return t(o);
        let i = bt(r).selectedHttpAuthScheme;
        if (!i)
          throw new Error(
            "No HttpAuthScheme was selected: unable to sign request"
          );
        let {
            httpAuthOption: { signingProperties: a = {} },
            identity: c,
            signer: d,
          } = i,
          m;
        r.s3ExpressIdentity
          ? (m = await U$e(r.s3ExpressIdentity, a, o.request, await e.signer()))
          : (m = await d.sign(o.request, c, a));
        let f = await t({ ...o, request: m }).catch((d.errorHandler || bht)(a));
        return (d.successHandler || _ht)(f.response, a), f;
      }),
      (XH = (e) => ({
        applyToStack: (t) => {
          t.addRelativeTo(H$e(e), YO);
        },
      }));
  });
var JH = s(() => {
  WH();
  KH();
  P$e();
  B$e();
  nR();
  F$e();
  z$e();
});
var q$e,
  j$e = s(() => {
    JH();
    q$e = (e, { session: t }) => {
      let [r, o] = t,
        {
          forcePathStyle: n,
          useAccelerateEndpoint: i,
          disableMultiregionAccessPoints: a,
          followRegionRedirects: c,
          s3ExpressIdentityProvider: d,
          bucketEndpoint: m,
        } = e;
      return Object.assign(e, {
        forcePathStyle: n ?? !1,
        useAccelerateEndpoint: i ?? !1,
        disableMultiregionAccessPoints: a ?? !1,
        followRegionRedirects: c ?? !1,
        s3ExpressIdentityProvider:
          d ?? new Oy(async (f) => r().send(new o({ Bucket: f }))),
        bucketEndpoint: m ?? !1,
      });
    };
  });
var _u = s(() => {
  cr();
});
var G$e = s(() => {
  _u();
});
var ZH = s(() => {
  _u();
});
var W$e = s(() => {
  ZH();
});
var Y$e = s(() => {
  _u();
});
var sR = s(() => {
  ZH();
  W$e();
  Y$e();
});
var Q$e = s(() => {
  _u();
  sR();
});
var wu = s(() => {
  G$e();
  Q$e();
});
var X$e = s(() => {
  wu();
  sR();
  t3();
});
var t3 = s(() => {
  X$e();
});
var r3 = s(() => {
  wu();
});
var yc,
  J$e,
  xc = s(() => {
    (yc = (e) =>
      typeof ReadableStream == "function" &&
      (e?.constructor?.name === ReadableStream.name ||
        e instanceof ReadableStream)),
      (J$e = (e) =>
        typeof Blob == "function" &&
        (e?.constructor?.name === Blob.name || e instanceof Blob));
  });
var Z$e = s(() => {});
var e1e = s(() => {
  wu();
  xc();
  Z$e();
});
var t1e = s(() => {
  xc();
  r3();
  e1e();
});
var o3 = s(() => {});
var r1e = s(() => {
  o3();
});
var o1e = s(() => {
  o3();
  r1e();
  xc();
});
var n1e = s(() => {});
async function s1e(e, t) {
  let r = 0,
    o = [],
    n = e.getReader(),
    i = !1;
  for (; !i; ) {
    let { done: d, value: m } = await n.read();
    if ((m && (o.push(m), (r += m?.byteLength ?? 0)), r >= t)) break;
    i = d;
  }
  n.releaseLock();
  let a = new Uint8Array(Math.min(t, r)),
    c = 0;
  for (let d of o) {
    if (d.byteLength > a.byteLength - c) {
      a.set(d.subarray(0, a.byteLength - c), c);
      break;
    } else a.set(d, c);
    c += d.length;
  }
  return a;
}
var i1e = s(() => {});
import { Writable as Iht } from "stream";
var a1e,
  n3,
  c1e = s(() => {
    i1e();
    xc();
    (a1e = (e, t) =>
      yc(e)
        ? s1e(e, t)
        : new Promise((r, o) => {
            let n = new n3();
            (n.limit = t),
              e.pipe(n),
              e.on("error", (i) => {
                n.end(), o(i);
              }),
              n.on("error", o),
              n.on("finish", function () {
                let i = new Uint8Array(Buffer.concat(this.buffers));
                r(i);
              });
          })),
      (n3 = class extends Iht {
        constructor() {
          super(...arguments),
            (this.buffers = []),
            (this.limit = 1 / 0),
            (this.bytesBuffered = 0);
        }
        _write(t, r, o) {
          if (
            (this.buffers.push(t),
            (this.bytesBuffered += t.byteLength ?? 0),
            this.bytesBuffered >= this.limit)
          ) {
            let n = this.bytesBuffered - this.limit,
              i = this.buffers[this.buffers.length - 1];
            (this.buffers[this.buffers.length - 1] = i.subarray(
              0,
              i.byteLength - n
            )),
              this.emit("finish");
          }
          o();
        }
      });
  });
var s3 = s(() => {});
var d1e = s(() => {
  s3();
});
var m1e = s(() => {
  s3();
  d1e();
});
var iR = s(() => {
  m1e();
});
var l1e = s(() => {});
var i3 = s(() => {});
var Tu = s(() => {});
var f1e = s(() => {
  Tu();
});
var u1e = s(() => {
  Tu();
});
var p1e = s(() => {
  a3();
  Tu();
});
var c3 = s(() => {
  Tu();
});
var a3 = s(() => {
  la();
  iR();
  l1e();
  i3();
  f1e();
  u1e();
  p1e();
  Tu();
  c3();
});
var g1e = s(() => {});
var y1e = s(() => {
  g1e();
});
var x1e = s(() => {
  la();
  iR();
  i3();
  y1e();
  c3();
});
var E1e = s(() => {});
var S1e = s(() => {
  E1e();
});
var C1e = s(() => {
  a3();
  x1e();
  S1e();
});
var b1e = s(() => {});
var _1e = s(() => {});
var w1e = s(() => {
  la();
  iR();
  b1e();
  _1e();
});
var T1e = s(() => {
  wu();
});
var A1e = s(() => {
  w1e();
  T1e();
});
var R1e = s(() => {
  A1e();
  wu();
  Fo();
  sR();
  xc();
});
var I1e = s(() => {
  C1e();
  _u();
  R1e();
});
async function P1e(e) {
  return typeof e.stream == "function" && (e = e.stream()), e.tee();
}
var v1e = s(() => {});
import { PassThrough as O1e } from "stream";
async function k1e(e) {
  if (yc(e) || J$e(e)) return P1e(e);
  let t = new O1e(),
    r = new O1e();
  return e.pipe(t), e.pipe(r), [t, r];
}
var D1e = s(() => {
  v1e();
  xc();
});
var N1e = s(() => {
  t3();
  r3();
  t1e();
  o1e();
  n1e();
  c1e();
  I1e();
  D1e();
  xc();
});
var kht,
  Dht,
  Nht,
  Bht,
  Mht,
  U,
  B1e = s(() => {
    la();
    N1e();
    (kht = {
      CopyObjectCommand: !0,
      UploadPartCopyCommand: !0,
      CompleteMultipartUploadCommand: !0,
    }),
      (Dht = 3e3),
      (Nht = (e) => (t, r) => async (o) => {
        let n = await t(o),
          { response: i } = n;
        if (!ma.isInstance(i)) return n;
        let { statusCode: a, body: c } = i;
        if (
          a < 200 ||
          a >= 300 ||
          !(
            typeof c?.stream == "function" ||
            typeof c?.pipe == "function" ||
            typeof c?.tee == "function"
          )
        )
          return n;
        let m = c,
          f = c;
        c &&
          typeof c == "object" &&
          !(c instanceof Uint8Array) &&
          ([m, f] = await k1e(c)),
          (i.body = f);
        let l = await Bht(m, { streamCollector: async (h) => a1e(h, Dht) });
        typeof m?.destroy == "function" && m.destroy();
        let u = e.utf8Encoder(l.subarray(l.length - 16));
        if (l.length === 0 && kht[r.commandName]) {
          let h = new Error("S3 aborted request");
          throw ((h.name = "InternalError"), h);
        }
        return u && u.endsWith("</Error>") && (i.statusCode = 400), n;
      }),
      (Bht = (e = new Uint8Array(), t) =>
        e instanceof Uint8Array
          ? Promise.resolve(e)
          : t.streamCollector(e) || Promise.resolve(new Uint8Array())),
      (Mht = {
        relation: "after",
        toMiddleware: "deserializerMiddleware",
        tags: ["THROW_200_EXCEPTIONS", "S3"],
        name: "throw200ExceptionsMiddleware",
        override: !0,
      }),
      (U = (e) => ({
        applyToStack: (t) => {
          t.addRelativeTo(Nht(e), Mht);
        },
      }));
  });
var d3,
  m3 = s(() => {
    d3 = (e) =>
      typeof e == "string" &&
      e.indexOf("arn:") === 0 &&
      e.split(":").length >= 6;
  });
function M1e(e) {
  return (t, r) => async (o) => {
    if (e.bucketEndpoint) {
      let n = r.endpointV2;
      if (n) {
        let i = o.input.Bucket;
        if (typeof i == "string")
          try {
            let a = new URL(i);
            r.endpointV2 = { ...n, url: a };
          } catch (a) {
            let c = `@aws-sdk/middleware-sdk-s3: bucketEndpoint=true was set but Bucket=${i} could not be parsed as URL.`;
            throw (
              (r.logger?.constructor?.name === "NoOpLogger"
                ? console.warn(c)
                : r.logger?.warn?.(c),
              a)
            );
          }
      }
    }
    return t(o);
  };
}
var L1e,
  F1e = s(() => {
    L1e = {
      name: "bucketEndpointMiddleware",
      override: !0,
      relation: "after",
      toMiddleware: "endpointV2Middleware",
    };
  });
function Lht({ bucketEndpoint: e }) {
  return (t) => async (r) => {
    let {
      input: { Bucket: o },
    } = r;
    if (!e && typeof o == "string" && !d3(o) && o.indexOf("/") >= 0) {
      let n = new Error(`Bucket name shouldn't contain '/', received '${o}'`);
      throw ((n.name = "InvalidBucketName"), n);
    }
    return t({ ...r });
  };
}
var Fht,
  U1e,
  $1e = s(() => {
    m3();
    F1e();
    (Fht = {
      step: "initialize",
      tags: ["VALIDATE_BUCKET_NAME"],
      name: "validateBucketNameMiddleware",
      override: !0,
    }),
      (U1e = (e) => ({
        applyToStack: (t) => {
          t.add(Lht(e), Fht), t.addRelativeTo(M1e(e), L1e);
        },
      }));
  });
var he = s(() => {
  _$e();
  VH();
  R$e();
  I$e();
  JH();
  j$e();
  B1e();
  $1e();
});
function Uht(e) {
  return e === void 0 ? !0 : typeof e == "string" && e.length <= 50;
}
function cR(e) {
  let t = rn(e.userAgentAppId ?? l3),
    { customUserAgent: r } = e;
  return Object.assign(e, {
    customUserAgent: typeof r == "string" ? [[r]] : r,
    userAgentAppId: async () => {
      let o = await t();
      if (!Uht(o)) {
        let n =
          e.logger?.constructor?.name === "NoOpLogger" || !e.logger
            ? console
            : e.logger;
        typeof o != "string"
          ? n?.warn("userAgentAppId must be a string or undefined.")
          : o.length > 50 &&
            n?.warn(
              "The provided userAgentAppId exceeds the maximum length of 50 characters."
            );
      }
      return o;
    },
  });
}
var l3,
  H1e = s(() => {
    Ue();
    l3 = void 0;
  });
var f3 = s(() => {
  $t();
});
var u3,
  z1e = s(() => {
    $t();
    f3();
    u3 = (e, t = !1) => {
      if (t) {
        for (let r of e.split(".")) if (!u3(r)) return !1;
        return !0;
      }
      return !(
        !Ms(e) ||
        e.length < 3 ||
        e.length > 63 ||
        e !== e.toLowerCase() ||
        gn(e)
      );
    };
  });
var q1e,
  $ht,
  j1e,
  G1e = s(() => {
    (q1e = ":"),
      ($ht = "/"),
      (j1e = (e) => {
        let t = e.split(q1e);
        if (t.length < 6) return null;
        let [r, o, n, i, a, ...c] = t;
        if (r !== "arn" || o === "" || n === "" || c.join(q1e) === "")
          return null;
        let d = c.map((m) => m.split($ht)).flat();
        return {
          partition: o,
          service: n,
          region: i,
          accountId: a,
          resourceId: d,
        };
      });
  });
var W1e,
  V1e = s(() => {
    W1e = {
      partitions: [
        {
          id: "aws",
          outputs: {
            dnsSuffix: "amazonaws.com",
            dualStackDnsSuffix: "api.aws",
            implicitGlobalRegion: "us-east-1",
            name: "aws",
            supportsDualStack: !0,
            supportsFIPS: !0,
          },
          regionRegex: "^(us|eu|ap|sa|ca|me|af|il|mx)\\-\\w+\\-\\d+$",
          regions: {
            "af-south-1": { description: "Africa (Cape Town)" },
            "ap-east-1": { description: "Asia Pacific (Hong Kong)" },
            "ap-east-2": { description: "Asia Pacific (Taipei)" },
            "ap-northeast-1": { description: "Asia Pacific (Tokyo)" },
            "ap-northeast-2": { description: "Asia Pacific (Seoul)" },
            "ap-northeast-3": { description: "Asia Pacific (Osaka)" },
            "ap-south-1": { description: "Asia Pacific (Mumbai)" },
            "ap-south-2": { description: "Asia Pacific (Hyderabad)" },
            "ap-southeast-1": { description: "Asia Pacific (Singapore)" },
            "ap-southeast-2": { description: "Asia Pacific (Sydney)" },
            "ap-southeast-3": { description: "Asia Pacific (Jakarta)" },
            "ap-southeast-4": { description: "Asia Pacific (Melbourne)" },
            "ap-southeast-5": { description: "Asia Pacific (Malaysia)" },
            "ap-southeast-7": { description: "Asia Pacific (Thailand)" },
            "aws-global": { description: "AWS Standard global region" },
            "ca-central-1": { description: "Canada (Central)" },
            "ca-west-1": { description: "Canada West (Calgary)" },
            "eu-central-1": { description: "Europe (Frankfurt)" },
            "eu-central-2": { description: "Europe (Zurich)" },
            "eu-north-1": { description: "Europe (Stockholm)" },
            "eu-south-1": { description: "Europe (Milan)" },
            "eu-south-2": { description: "Europe (Spain)" },
            "eu-west-1": { description: "Europe (Ireland)" },
            "eu-west-2": { description: "Europe (London)" },
            "eu-west-3": { description: "Europe (Paris)" },
            "il-central-1": { description: "Israel (Tel Aviv)" },
            "me-central-1": { description: "Middle East (UAE)" },
            "me-south-1": { description: "Middle East (Bahrain)" },
            "mx-central-1": { description: "Mexico (Central)" },
            "sa-east-1": { description: "South America (Sao Paulo)" },
            "us-east-1": { description: "US East (N. Virginia)" },
            "us-east-2": { description: "US East (Ohio)" },
            "us-west-1": { description: "US West (N. California)" },
            "us-west-2": { description: "US West (Oregon)" },
          },
        },
        {
          id: "aws-cn",
          outputs: {
            dnsSuffix: "amazonaws.com.cn",
            dualStackDnsSuffix: "api.amazonwebservices.com.cn",
            implicitGlobalRegion: "cn-northwest-1",
            name: "aws-cn",
            supportsDualStack: !0,
            supportsFIPS: !0,
          },
          regionRegex: "^cn\\-\\w+\\-\\d+$",
          regions: {
            "aws-cn-global": { description: "AWS China global region" },
            "cn-north-1": { description: "China (Beijing)" },
            "cn-northwest-1": { description: "China (Ningxia)" },
          },
        },
        {
          id: "aws-us-gov",
          outputs: {
            dnsSuffix: "amazonaws.com",
            dualStackDnsSuffix: "api.aws",
            implicitGlobalRegion: "us-gov-west-1",
            name: "aws-us-gov",
            supportsDualStack: !0,
            supportsFIPS: !0,
          },
          regionRegex: "^us\\-gov\\-\\w+\\-\\d+$",
          regions: {
            "aws-us-gov-global": {
              description: "AWS GovCloud (US) global region",
            },
            "us-gov-east-1": { description: "AWS GovCloud (US-East)" },
            "us-gov-west-1": { description: "AWS GovCloud (US-West)" },
          },
        },
        {
          id: "aws-iso",
          outputs: {
            dnsSuffix: "c2s.ic.gov",
            dualStackDnsSuffix: "c2s.ic.gov",
            implicitGlobalRegion: "us-iso-east-1",
            name: "aws-iso",
            supportsDualStack: !1,
            supportsFIPS: !0,
          },
          regionRegex: "^us\\-iso\\-\\w+\\-\\d+$",
          regions: {
            "aws-iso-global": { description: "AWS ISO (US) global region" },
            "us-iso-east-1": { description: "US ISO East" },
            "us-iso-west-1": { description: "US ISO WEST" },
          },
        },
        {
          id: "aws-iso-b",
          outputs: {
            dnsSuffix: "sc2s.sgov.gov",
            dualStackDnsSuffix: "sc2s.sgov.gov",
            implicitGlobalRegion: "us-isob-east-1",
            name: "aws-iso-b",
            supportsDualStack: !1,
            supportsFIPS: !0,
          },
          regionRegex: "^us\\-isob\\-\\w+\\-\\d+$",
          regions: {
            "aws-iso-b-global": { description: "AWS ISOB (US) global region" },
            "us-isob-east-1": { description: "US ISOB East (Ohio)" },
          },
        },
        {
          id: "aws-iso-e",
          outputs: {
            dnsSuffix: "cloud.adc-e.uk",
            dualStackDnsSuffix: "cloud.adc-e.uk",
            implicitGlobalRegion: "eu-isoe-west-1",
            name: "aws-iso-e",
            supportsDualStack: !1,
            supportsFIPS: !0,
          },
          regionRegex: "^eu\\-isoe\\-\\w+\\-\\d+$",
          regions: {
            "aws-iso-e-global": {
              description: "AWS ISOE (Europe) global region",
            },
            "eu-isoe-west-1": { description: "EU ISOE West" },
          },
        },
        {
          id: "aws-iso-f",
          outputs: {
            dnsSuffix: "csp.hci.ic.gov",
            dualStackDnsSuffix: "csp.hci.ic.gov",
            implicitGlobalRegion: "us-isof-south-1",
            name: "aws-iso-f",
            supportsDualStack: !1,
            supportsFIPS: !0,
          },
          regionRegex: "^us\\-isof\\-\\w+\\-\\d+$",
          regions: {
            "aws-iso-f-global": { description: "AWS ISOF global region" },
            "us-isof-east-1": { description: "US ISOF EAST" },
            "us-isof-south-1": { description: "US ISOF SOUTH" },
          },
        },
        {
          id: "aws-eusc",
          outputs: {
            dnsSuffix: "amazonaws.eu",
            dualStackDnsSuffix: "amazonaws.eu",
            implicitGlobalRegion: "eusc-de-east-1",
            name: "aws-eusc",
            supportsDualStack: !1,
            supportsFIPS: !0,
          },
          regionRegex: "^eusc\\-(de)\\-\\w+\\-\\d+$",
          regions: { "eusc-de-east-1": { description: "EU (Germany)" } },
        },
      ],
      version: "1.1",
    };
  });
var zht,
  qht,
  K1e,
  Y1e,
  p3 = s(() => {
    V1e();
    (zht = W1e),
      (qht = ""),
      (K1e = (e) => {
        let { partitions: t } = zht;
        for (let o of t) {
          let { regions: n, outputs: i } = o;
          for (let [a, c] of Object.entries(n))
            if (a === e) return { ...i, ...c };
        }
        for (let o of t) {
          let { regionRegex: n, outputs: i } = o;
          if (new RegExp(n).test(e)) return { ...i };
        }
        let r = t.find((o) => o.id === "aws");
        if (!r)
          throw new Error(
            "Provided region was not found in the partition array or regex, and default partition with id 'aws' doesn't exist."
          );
        return { ...r.outputs };
      }),
      (Y1e = () => qht);
  });
var Ny,
  Q1e = s(() => {
    $t();
    z1e();
    G1e();
    p3();
    Ny = { isVirtualHostableS3Bucket: u3, parseArn: j1e, partition: K1e };
    Jt.aws = Ny;
  });
var X1e = s(() => {
  $t();
});
var J1e = s(() => {
  $t();
});
var Z1e = s(() => {});
var eHe = s(() => {});
var tHe = s(() => {});
var rHe = s(() => {});
var oHe = s(() => {});
var nHe = s(() => {
  J1e();
  Z1e();
  eHe();
  tHe();
  rHe();
  oHe();
});
var dR = s(() => {
  Q1e();
  p3();
  f3();
  X1e();
  nHe();
});
async function sHe(e, t, r) {
  if (
    (r.request?.headers?.["smithy-protocol"] === "rpc-v2-cbor" &&
      _e(e, "PROTOCOL_RPC_V2_CBOR", "M"),
    typeof t.retryStrategy == "function")
  ) {
    let i = await t.retryStrategy();
    typeof i.acquireInitialRetryToken == "function"
      ? i.constructor?.name?.includes("Adaptive")
        ? _e(e, "RETRY_MODE_ADAPTIVE", "F")
        : _e(e, "RETRY_MODE_STANDARD", "E")
      : _e(e, "RETRY_MODE_LEGACY", "D");
  }
  if (typeof t.accountIdEndpointMode == "function") {
    let i = e.endpointV2;
    switch (
      (String(i?.url?.hostname).match(jht) && _e(e, "ACCOUNT_ID_ENDPOINT", "O"),
      await t.accountIdEndpointMode?.())
    ) {
      case "disabled":
        _e(e, "ACCOUNT_ID_MODE_DISABLED", "Q");
        break;
      case "preferred":
        _e(e, "ACCOUNT_ID_MODE_PREFERRED", "P");
        break;
      case "required":
        _e(e, "ACCOUNT_ID_MODE_REQUIRED", "R");
        break;
    }
  }
  let n = e.__smithy_context?.selectedHttpAuthScheme?.identity;
  if (n?.$source) {
    let i = n;
    i.accountId && _e(e, "RESOLVED_ACCOUNT_ID", "T");
    for (let [a, c] of Object.entries(i.$source ?? {})) _e(e, a, c);
  }
}
var jht,
  iHe = s(() => {
    rt();
    jht = /\d{12}\.ddb/;
  });
var h3,
  mR,
  g3,
  lR,
  aHe,
  cHe,
  y3,
  dHe = s(() => {
    (h3 = "user-agent"),
      (mR = "x-amz-user-agent"),
      (g3 = " "),
      (lR = "/"),
      (aHe = /[^\!\$\%\&\'\*\+\-\.\^\_\`\|\~\d\w]/g),
      (cHe = /[^\!\$\%\&\'\*\+\-\.\^\_\`\|\~\d\w\#]/g),
      (y3 = "-");
  });
function mHe(e) {
  let t = "";
  for (let r in e) {
    let o = e[r];
    if (t.length + o.length + 1 <= 1024) {
      t.length ? (t += "," + o) : (t += o);
      continue;
    }
    break;
  }
  return t;
}
var lHe = s(() => {});
var Ght,
  fR,
  Vht,
  uR,
  fHe = s(() => {
    dR();
    an();
    iHe();
    dHe();
    lHe();
    (Ght = (e) => (t, r) => async (o) => {
      let { request: n } = o;
      if (!bn.isInstance(n)) return t(o);
      let { headers: i } = n,
        a = r?.userAgent?.map(fR) || [],
        c = (await e.defaultUserAgentProvider()).map(fR);
      await sHe(r, e, o);
      let d = r;
      c.push(
        `m/${mHe(Object.assign({}, r.__smithy_context?.features, d.__aws_sdk_context?.features))}`
      );
      let m = e?.customUserAgent?.map(fR) || [],
        f = await e.userAgentAppId();
      f && c.push(fR([`app/${f}`]));
      let l = Y1e(),
        u = (l ? [l] : []).concat([...c, ...a, ...m]).join(g3),
        h = [...c.filter((y) => y.startsWith("aws-sdk-")), ...m].join(g3);
      return (
        e.runtime !== "browser"
          ? (h && (i[mR] = i[mR] ? `${i[h3]} ${h}` : h), (i[h3] = u))
          : (i[mR] = u),
        t({ ...o, request: n })
      );
    }),
      (fR = (e) => {
        let t = e[0]
            .split(lR)
            .map((a) => a.replace(aHe, y3))
            .join(lR),
          r = e[1]?.replace(cHe, y3),
          o = t.indexOf(lR),
          n = t.substring(0, o),
          i = t.substring(o + 1);
        return (
          n === "api" && (i = i.toLowerCase()),
          [n, i, r]
            .filter((a) => a && a.length > 0)
            .reduce((a, c, d) => {
              switch (d) {
                case 0:
                  return c;
                case 1:
                  return `${a}/${c}`;
                default:
                  return `${a}#${c}`;
              }
            }, "")
        );
      }),
      (Vht = {
        name: "getUserAgentMiddleware",
        step: "build",
        priority: "low",
        tags: ["SET_USER_AGENT", "USER_AGENT"],
        override: !0,
      }),
      (uR = (e) => ({
        applyToStack: (t) => {
          t.add(Ght(e), Vht);
        },
      }));
  });
var pR = s(() => {
  H1e();
  fHe();
});
var Wht,
  Kht,
  hR,
  uHe = s(() => {
    Wn();
    (Wht = "AWS_USE_DUALSTACK_ENDPOINT"),
      (Kht = "use_dualstack_endpoint"),
      (hR = {
        environmentVariableSelector: (e) => Nt(e, Wht, Tt.ENV),
        configFileSelector: (e) => Nt(e, Kht, Tt.CONFIG),
        default: !1,
      });
  });
var Yht,
  Qht,
  gR,
  pHe = s(() => {
    Wn();
    (Yht = "AWS_USE_FIPS_ENDPOINT"),
      (Qht = "use_fips_endpoint"),
      (gR = {
        environmentVariableSelector: (e) => Nt(e, Yht, Tt.ENV),
        configFileSelector: (e) => Nt(e, Qht, Tt.CONFIG),
        default: !1,
      });
  });
var hHe = s(() => {
  ct();
});
var gHe = s(() => {});
var yHe = s(() => {
  ct();
  gHe();
});
var xHe = s(() => {
  uHe();
  pHe();
  hHe();
  yHe();
});
var Xht,
  Jht,
  Au,
  yR,
  EHe = s(() => {
    (Xht = "AWS_REGION"),
      (Jht = "region"),
      (Au = {
        environmentVariableSelector: (e) => e[Xht],
        configFileSelector: (e) => e[Jht],
        default: () => {
          throw new Error("Region is missing");
        },
      }),
      (yR = { preferredFile: "credentials" });
  });
var xR,
  x3 = s(() => {
    xR = (e) =>
      typeof e == "string" && (e.startsWith("fips-") || e.endsWith("-fips"));
  });
var E3,
  SHe = s(() => {
    x3();
    E3 = (e) =>
      xR(e)
        ? ["fips-aws-global", "aws-fips"].includes(e)
          ? "us-east-1"
          : e.replace(/fips-(dkr-|prod-)?|-fips/, "")
        : e;
  });
var ER,
  CHe = s(() => {
    SHe();
    x3();
    ER = (e) => {
      let { region: t, useFipsEndpoint: r } = e;
      if (!t) throw new Error("Region is missing");
      return Object.assign(e, {
        region: async () => {
          if (typeof t == "string") return E3(t);
          let o = await t();
          return E3(o);
        },
        useFipsEndpoint: async () => {
          let o = typeof t == "string" ? t : await t();
          return xR(o)
            ? !0
            : typeof r != "function"
              ? Promise.resolve(!!r)
              : r();
        },
      });
    };
  });
var bHe = s(() => {
  EHe();
  CHe();
});
var _He = s(() => {});
var wHe = s(() => {});
var THe = s(() => {});
var AHe = s(() => {});
var RHe = s(() => {});
var IHe = s(() => {});
var PHe = s(() => {
  THe();
  AHe();
  RHe();
  IHe();
});
var vHe = s(() => {
  _He();
  wHe();
  PHe();
});
var Ru = s(() => {
  xHe();
  bHe();
  vHe();
});
var OHe,
  kHe = s(() => {
    OHe = (e) =>
      Object.assign(e, {
        eventStreamMarshaller: e.eventStreamSerdeProvider(e),
      });
  });
var DHe = s(() => {
  kHe();
});
function Zht(e) {
  return (t) => async (r) => {
    let o = r.request;
    if (bn.isInstance(o)) {
      let { body: n, headers: i } = o;
      if (
        n &&
        Object.keys(i)
          .map((a) => a.toLowerCase())
          .indexOf(NHe) === -1
      )
        try {
          let a = e(n);
          o.headers = { ...o.headers, [NHe]: String(a) };
        } catch {}
    }
    return t({ ...r, request: o });
  };
}
var NHe,
  egt,
  SR,
  S3 = s(() => {
    an();
    NHe = "content-length";
    (egt = {
      step: "build",
      tags: ["SET_CONTENT_LENGTH", "CONTENT_LENGTH"],
      name: "contentLengthMiddleware",
      override: !0,
    }),
      (SR = (e) => ({
        applyToStack: (t) => {
          t.add(Zht(e.bodyLengthChecker), egt);
        },
      }));
  });
var BHe,
  tgt,
  rgt,
  ogt,
  ngt,
  sgt,
  MHe = s(() => {
    (BHe = async (e) => {
      let t = e?.Bucket || "";
      if (
        (typeof e.Bucket == "string" &&
          (e.Bucket = t
            .replace(/#/g, encodeURIComponent("#"))
            .replace(/\?/g, encodeURIComponent("?"))),
        sgt(t))
      ) {
        if (e.ForcePathStyle === !0)
          throw new Error(
            "Path-style addressing cannot be used with ARN buckets"
          );
      } else
        (!ngt(t) ||
          (t.indexOf(".") !== -1 && !String(e.Endpoint).startsWith("http:")) ||
          t.toLowerCase() !== t ||
          t.length < 3) &&
          (e.ForcePathStyle = !0);
      return (
        e.DisableMultiRegionAccessPoints &&
          ((e.disableMultiRegionAccessPoints = !0), (e.DisableMRAP = !0)),
        e
      );
    }),
      (tgt = /^[a-z0-9][a-z0-9\.\-]{1,61}[a-z0-9]$/),
      (rgt = /(\d+\.){3}\d+/),
      (ogt = /\.\./),
      (ngt = (e) => tgt.test(e) && !rgt.test(e) && !ogt.test(e)),
      (sgt = (e) => {
        let [t, r, o, , , n] = e.split(":"),
          i = t === "arn" && e.split(":").length >= 6,
          a = !!(i && r && o && n);
        if (i && !a) throw new Error(`Invalid ARN: ${e} was an invalid ARN.`);
        return a;
      });
  });
var LHe = s(() => {
  MHe();
});
var FHe,
  UHe = s(() => {
    FHe = (e, t, r) => {
      let o = async () => {
        let n = r[e] ?? r[t];
        return typeof n == "function" ? n() : n;
      };
      return e === "credentialScope" || t === "CredentialScope"
        ? async () => {
            let n =
              typeof r.credentials == "function"
                ? await r.credentials()
                : r.credentials;
            return n?.credentialScope ?? n?.CredentialScope;
          }
        : e === "accountId" || t === "AccountId"
          ? async () => {
              let n =
                typeof r.credentials == "function"
                  ? await r.credentials()
                  : r.credentials;
              return n?.accountId ?? n?.AccountId;
            }
          : e === "endpoint" || t === "endpoint"
            ? async () => {
                let n = await o();
                if (n && typeof n == "object") {
                  if ("url" in n) return n.url.href;
                  if ("hostname" in n) {
                    let { protocol: i, hostname: a, port: c, path: d } = n;
                    return `${i}//${a}${c ? ":" + c : ""}${d}`;
                  }
                }
                return n;
              }
            : o;
    };
  });
function CR(e) {
  try {
    let t = new Set(Array.from(e.match(/([A-Z_]){3,}/g) ?? []));
    return (
      t.delete("CONFIG"),
      t.delete("CONFIG_PREFIX_SEPARATOR"),
      t.delete("ENV"),
      [...t].join(", ")
    );
  } catch {
    return e;
  }
}
var C3 = s(() => {});
var $He,
  HHe = s(() => {
    re();
    C3();
    $He = (e, t) => async () => {
      try {
        let r = e(process.env, t);
        if (r === void 0) throw new Error();
        return r;
      } catch (r) {
        throw new P(r.message || `Not found in ENV: ${CR(e.toString())}`, {
          logger: t?.logger,
        });
      }
    };
  });
import { homedir as igt } from "os";
import { sep as agt } from "path";
var b3,
  cgt,
  Ec,
  Iu = s(() => {
    (b3 = {}),
      (cgt = () =>
        process && process.geteuid ? `${process.geteuid()}` : "DEFAULT"),
      (Ec = () => {
        let {
          HOME: e,
          USERPROFILE: t,
          HOMEPATH: r,
          HOMEDRIVE: o = `C:${agt}`,
        } = process.env;
        if (e) return e;
        if (t) return t;
        if (r) return `${o}${r}`;
        let n = cgt();
        return b3[n] || (b3[n] = igt()), b3[n];
      });
  });
var _3,
  dgt,
  us,
  zHe = s(() => {
    (_3 = "AWS_PROFILE"),
      (dgt = "default"),
      (us = (e) => e.profile || process.env[_3] || dgt);
  });
import { createHash as mgt } from "crypto";
import { join as lgt } from "path";
var bR,
  w3 = s(() => {
    Iu();
    bR = (e) => {
      let r = mgt("sha1").update(e).digest("hex");
      return lgt(Ec(), ".aws", "sso", "cache", `${r}.json`);
    };
  });
import { promises as fgt } from "fs";
var ugt,
  _R,
  qHe = s(() => {
    w3();
    ({ readFile: ugt } = fgt),
      (_R = async (e) => {
        let t = bR(e),
          r = await ugt(t, "utf8");
        return JSON.parse(r);
      });
  });
var jHe,
  GHe = s(() => {
    $d();
    Pu();
    jHe = (e) =>
      Object.entries(e)
        .filter(([t]) => {
          let r = t.indexOf(ps);
          return r === -1 ? !1 : Object.values(da).includes(t.substring(0, r));
        })
        .reduce(
          (t, [r, o]) => {
            let n = r.indexOf(ps),
              i = r.substring(0, n) === da.PROFILE ? r.substring(n + 1) : r;
            return (t[i] = o), t;
          },
          { ...(e.default && { default: e.default }) }
        );
  });
import { join as pgt } from "path";
var hgt,
  wR,
  T3 = s(() => {
    Iu();
    (hgt = "AWS_CONFIG_FILE"),
      (wR = () => process.env[hgt] || pgt(Ec(), ".aws", "config"));
  });
import { join as ggt } from "path";
var ygt,
  VHe,
  WHe = s(() => {
    Iu();
    (ygt = "AWS_SHARED_CREDENTIALS_FILE"),
      (VHe = () => process.env[ygt] || ggt(Ec(), ".aws", "credentials"));
  });
var xgt,
  Egt,
  By,
  A3 = s(() => {
    $d();
    Pu();
    (xgt = /^([\w-]+)\s(["'])?([\w-@\+\.%:/]+)\2$/),
      (Egt = ["__proto__", "profile __proto__"]),
      (By = (e) => {
        let t = {},
          r,
          o;
        for (let n of e.split(/\r?\n/)) {
          let i = n.split(/(^|\s)[;#]/)[0].trim();
          if (i[0] === "[" && i[i.length - 1] === "]") {
            (r = void 0), (o = void 0);
            let c = i.substring(1, i.length - 1),
              d = xgt.exec(c);
            if (d) {
              let [, m, , f] = d;
              Object.values(da).includes(m) && (r = [m, f].join(ps));
            } else r = c;
            if (Egt.includes(c))
              throw new Error(`Found invalid profile name "${c}"`);
          } else if (r) {
            let c = i.indexOf("=");
            if (![0, -1].includes(c)) {
              let [d, m] = [
                i.substring(0, c).trim(),
                i.substring(c + 1).trim(),
              ];
              if (m === "") o = d;
              else {
                o && n.trimStart() === n && (o = void 0), (t[r] = t[r] || {});
                let f = o ? [o, d].join(ps) : d;
                t[r][f] = m;
              }
            }
          }
        }
        return t;
      });
  });
import { promises as Sgt } from "fs";
var Cgt,
  R3,
  My,
  I3 = s(() => {
    ({ readFile: Cgt } = Sgt),
      (R3 = {}),
      (My = (e, t) => (
        (!R3[e] || t?.ignoreCache) && (R3[e] = Cgt(e, "utf8")), R3[e]
      ));
  });
import { join as KHe } from "path";
var YHe,
  ps,
  TR,
  Pu = s(() => {
    GHe();
    T3();
    WHe();
    Iu();
    A3();
    I3();
    (YHe = () => ({})),
      (ps = "."),
      (TR = async (e = {}) => {
        let { filepath: t = VHe(), configFilepath: r = wR() } = e,
          o = Ec(),
          n = "~/",
          i = t;
        t.startsWith(n) && (i = KHe(o, t.slice(2)));
        let a = r;
        r.startsWith(n) && (a = KHe(o, r.slice(2)));
        let c = await Promise.all([
          My(a, { ignoreCache: e.ignoreCache }).then(By).then(jHe).catch(YHe),
          My(i, { ignoreCache: e.ignoreCache }).then(By).catch(YHe),
        ]);
        return { configFile: c[0], credentialsFile: c[1] };
      });
  });
var QHe,
  XHe = s(() => {
    $d();
    Pu();
    QHe = (e) =>
      Object.entries(e)
        .filter(([t]) => t.startsWith(da.SSO_SESSION + ps))
        .reduce(
          (t, [r, o]) => ({ ...t, [r.substring(r.indexOf(ps) + 1)]: o }),
          {}
        );
  });
var bgt,
  AR,
  JHe = s(() => {
    T3();
    XHe();
    A3();
    I3();
    (bgt = () => ({})),
      (AR = async (e = {}) =>
        My(e.configFilepath ?? wR())
          .then(By)
          .then(QHe)
          .catch(bgt));
  });
var ZHe,
  e3e = s(() => {
    ZHe = (...e) => {
      let t = {};
      for (let r of e)
        for (let [o, n] of Object.entries(r))
          t[o] !== void 0 ? Object.assign(t[o], n) : (t[o] = n);
      return t;
    };
  });
var Sc,
  t3e = s(() => {
    Pu();
    e3e();
    Sc = async (e) => {
      let t = await TR(e);
      return ZHe(t.configFile, t.credentialsFile);
    };
  });
var r3e = s(() => {});
var Vs = s(() => {
  Iu();
  zHe();
  w3();
  qHe();
  Pu();
  JHe();
  t3e();
  r3e();
});
var o3e,
  n3e = s(() => {
    re();
    Vs();
    C3();
    o3e =
      (e, { preferredFile: t = "config", ...r } = {}) =>
      async () => {
        let o = us(r),
          { configFile: n, credentialsFile: i } = await TR(r),
          a = i[o] || {},
          c = n[o] || {},
          d = t === "config" ? { ...a, ...c } : { ...c, ...a };
        try {
          let f = e(d, t === "config" ? n : i);
          if (f === void 0) throw new Error();
          return f;
        } catch (m) {
          throw new P(
            m.message ||
              `Not found in config files w/ profile [${o}]: ${CR(e.toString())}`,
            { logger: r.logger }
          );
        }
      };
  });
var _gt,
  s3e,
  i3e = s(() => {
    re();
    (_gt = (e) => typeof e == "function"),
      (s3e = (e) => (_gt(e) ? async () => await e() : Ra(e)));
  });
var Bt,
  a3e = s(() => {
    re();
    HHe();
    n3e();
    i3e();
    Bt = (
      { environmentVariableSelector: e, configFileSelector: t, default: r },
      o = {}
    ) => {
      let { signingName: n, logger: i } = o;
      return gr(Ht($He(e, { signingName: n, logger: i }), o3e(t, o), s3e(r)));
    };
  });
var zd = s(() => {
  a3e();
});
var c3e,
  d3e,
  m3e,
  l3e = s(() => {
    Vs();
    (c3e = "AWS_ENDPOINT_URL"),
      (d3e = "endpoint_url"),
      (m3e = (e) => ({
        environmentVariableSelector: (t) => {
          let r = e.split(" ").map((i) => i.toUpperCase()),
            o = t[[c3e, ...r].join("_")];
          if (o) return o;
          let n = t[c3e];
          if (n) return n;
        },
        configFileSelector: (t, r) => {
          if (r && t.services) {
            let n = r[["services", t.services].join(ps)];
            if (n) {
              let i = e.split(" ").map((c) => c.toLowerCase()),
                a = n[[i.join("_"), d3e].join(ps)];
              if (a) return a;
            }
          }
          let o = t[d3e];
          if (o) return o;
        },
        default: void 0,
      }));
  });
var RR,
  P3 = s(() => {
    zd();
    l3e();
    RR = async (e) => Bt(m3e(e ?? ""))();
  });
function f3e(e) {
  let t = {};
  if (((e = e.replace(/^\?/, "")), e))
    for (let r of e.split("&")) {
      let [o, n = null] = r.split("=");
      (o = decodeURIComponent(o)),
        n && (n = decodeURIComponent(n)),
        o in t
          ? Array.isArray(t[o])
            ? t[o].push(n)
            : (t[o] = [t[o], n])
          : (t[o] = n);
    }
  return t;
}
var u3e = s(() => {});
var wi,
  Ly = s(() => {
    u3e();
    wi = (e) => {
      if (typeof e == "string") return wi(new URL(e));
      let { hostname: t, pathname: r, port: o, protocol: n, search: i } = e,
        a;
      return (
        i && (a = f3e(i)),
        {
          hostname: t,
          port: o ? parseInt(o) : void 0,
          protocol: n,
          path: r,
          query: a,
        }
      );
    };
  });
var IR,
  PR = s(() => {
    Ly();
    IR = (e) => (typeof e == "object" ? ("url" in e ? wi(e.url) : e) : wi(e));
  });
var p3e,
  v3,
  O3 = s(() => {
    LHe();
    UHe();
    P3();
    PR();
    (p3e = async (e, t, r, o) => {
      if (!r.endpoint) {
        let a;
        r.serviceConfiguredEndpoint
          ? (a = await r.serviceConfiguredEndpoint())
          : (a = await RR(r.serviceId)),
          a && (r.endpoint = () => Promise.resolve(IR(a)));
      }
      let n = await v3(e, t, r);
      if (typeof r.endpointProvider != "function")
        throw new Error("config.endpointProvider is not set.");
      return r.endpointProvider(n, o);
    }),
      (v3 = async (e, t, r) => {
        let o = {},
          n = t?.getEndpointParameterInstructions?.() || {};
        for (let [i, a] of Object.entries(n))
          switch (a.type) {
            case "staticContextParams":
              o[i] = a.value;
              break;
            case "contextParams":
              o[i] = e[a.name];
              break;
            case "clientContextParams":
            case "builtInParams":
              o[i] = await FHe(a.name, i, r)();
              break;
            case "operationContextParams":
              o[i] = a.get(e);
              break;
            default:
              throw new Error(
                "Unrecognized endpoint parameter instruction: " +
                  JSON.stringify(a)
              );
          }
        return (
          Object.keys(n).length === 0 && Object.assign(o, r),
          String(r.serviceId).toLowerCase() === "s3" && (await BHe(o)),
          o
        );
      });
  });
var h3e = s(() => {
  O3();
  PR();
});
var g3e,
  k3 = s(() => {
    Ue();
    ct();
    O3();
    g3e =
      ({ config: e, instructions: t }) =>
      (r, o) =>
      async (n) => {
        e.endpoint && Ta(o, "ENDPOINT_OVERRIDE", "N");
        let i = await p3e(
          n.input,
          {
            getEndpointParameterInstructions() {
              return t;
            },
          },
          { ...e },
          o
        );
        (o.endpointV2 = i), (o.authSchemes = i.properties?.authSchemes);
        let a = o.authSchemes?.[0];
        if (a) {
          (o.signing_region = a.signingRegion),
            (o.signing_service = a.signingName);
          let d = bt(o)?.selectedHttpAuthScheme?.httpAuthOption;
          d &&
            (d.signingProperties = Object.assign(
              d.signingProperties || {},
              {
                signing_region: a.signingRegion,
                signingRegion: a.signingRegion,
                signing_service: a.signingName,
                signingName: a.signingName,
                signingRegionSet: a.signingRegionSet,
              },
              a.properties
            ));
        }
        return r({ ...n });
      };
  });
var y3e,
  D3,
  N3 = s(() => {
    an();
    (y3e = (e, t) => (r, o) => async (n) => {
      let { response: i } = await r(n);
      try {
        let a = await t(i, e);
        return { response: i, output: a };
      } catch (a) {
        if (
          (Object.defineProperty(a, "$response", { value: i }),
          !("$metadata" in a))
        ) {
          let c =
            "Deserialization error: to see the raw response, inspect the hidden field {error}.$response on this object.";
          try {
            a.message +=
              `
  ` + c;
          } catch {
            !o.logger || o.logger?.constructor?.name === "NoOpLogger"
              ? console.warn(c)
              : o.logger?.warn?.(c);
          }
          typeof a.$responseBodyText < "u" &&
            a.$response &&
            (a.$response.body = a.$responseBodyText);
          try {
            if (Gs.isInstance(i)) {
              let { headers: d = {} } = i,
                m = Object.entries(d);
              a.$metadata = {
                httpStatusCode: i.statusCode,
                requestId: D3(/^x-[\w-]+-request-?id$/, m),
                extendedRequestId: D3(/^x-[\w-]+-id-2$/, m),
                cfId: D3(/^x-[\w-]+-cf-id$/, m),
              };
            }
          } catch {}
        }
        throw a;
      }
    }),
      (D3 = (e, t) => (t.find(([r]) => r.match(e)) || [void 0, void 0])[1]);
  });
var x3e,
  B3 = s(() => {
    x3e = (e, t) => (r, o) => async (n) => {
      let i = e,
        a =
          o.endpointV2?.url && i.urlParser
            ? async () => i.urlParser(o.endpointV2.url)
            : i.endpoint;
      if (!a) throw new Error("No valid endpoint provider available.");
      let c = await t(n.input, { ...e, endpoint: a });
      return r({ ...n, request: c });
    };
  });
function T(e, t, r) {
  return {
    applyToStack: (o) => {
      o.add(y3e(e, r), wgt), o.add(x3e(e, t), M3);
    },
  };
}
var wgt,
  M3,
  E3e = s(() => {
    N3();
    B3();
    (wgt = {
      name: "deserializerMiddleware",
      step: "deserialize",
      tags: ["DESERIALIZER"],
      override: !0,
    }),
      (M3 = {
        name: "serializerMiddleware",
        step: "serialize",
        tags: ["SERIALIZER"],
        override: !0,
      });
  });
var Y = s(() => {
  N3();
  E3e();
  B3();
});
var Tgt,
  A,
  S3e = s(() => {
    Y();
    k3();
    (Tgt = {
      step: "serialize",
      tags: ["ENDPOINT_PARAMETERS", "ENDPOINT_V2", "ENDPOINT"],
      name: "endpointV2Middleware",
      override: !0,
      relation: "before",
      toMiddleware: M3.name,
    }),
      (A = (e, t) => ({
        applyToStack: (r) => {
          r.addRelativeTo(g3e({ config: e, instructions: t }), Tgt);
        },
      }));
  });
var vR,
  C3e = s(() => {
    ct();
    P3();
    PR();
    vR = (e) => {
      let t = e.tls ?? !0,
        { endpoint: r, useDualstackEndpoint: o, useFipsEndpoint: n } = e,
        i = r != null ? async () => IR(await pe(r)()) : void 0,
        c = Object.assign(e, {
          endpoint: i,
          tls: t,
          isCustomEndpoint: !!r,
          useDualstackEndpoint: pe(o ?? !1),
          useFipsEndpoint: pe(n ?? !1),
        }),
        d;
      return (
        (c.serviceConfiguredEndpoint = async () => (
          e.serviceId && !d && (d = RR(e.serviceId)), d
        )),
        c
      );
    };
  });
var b3e = s(() => {});
var _3e = s(() => {});
var K = s(() => {
  h3e();
  k3();
  S3e();
  C3e();
  b3e();
  _3e();
});
var Ws,
  qd,
  vu,
  OR = s(() => {
    (function (e) {
      (e.STANDARD = "standard"), (e.ADAPTIVE = "adaptive");
    })(Ws || (Ws = {}));
    (qd = 3), (vu = Ws.STANDARD);
  });
var w3e,
  T3e,
  A3e,
  R3e,
  I3e,
  P3e = s(() => {
    (w3e = [
      "BandwidthLimitExceeded",
      "EC2ThrottledException",
      "LimitExceededException",
      "PriorRequestNotComplete",
      "ProvisionedThroughputExceededException",
      "RequestLimitExceeded",
      "RequestThrottled",
      "RequestThrottledException",
      "SlowDown",
      "ThrottledException",
      "Throttling",
      "ThrottlingException",
      "TooManyRequestsException",
      "TransactionInProgressException",
    ]),
      (T3e = ["TimeoutError", "RequestTimeout", "RequestTimeoutException"]),
      (A3e = [500, 502, 503, 504]),
      (R3e = ["ECONNRESET", "ECONNREFUSED", "EPIPE", "ETIMEDOUT"]),
      (I3e = ["EHOSTUNREACH", "ENETUNREACH", "ENOTFOUND"]);
  });
var Agt,
  Rgt,
  Ou,
  Fy,
  v3e,
  Uy = s(() => {
    P3e();
    (Agt = (e) => e.$metadata?.clockSkewCorrected),
      (Rgt = (e) => {
        let t = new Set([
          "Failed to fetch",
          "NetworkError when attempting to fetch resource",
          "The Internet connection appears to be offline",
          "Load failed",
          "Network request failed",
        ]);
        return e && e instanceof TypeError ? t.has(e.message) : !1;
      }),
      (Ou = (e) =>
        e.$metadata?.httpStatusCode === 429 ||
        w3e.includes(e.name) ||
        e.$retryable?.throttling == !0),
      (Fy = (e, t = 0) =>
        Agt(e) ||
        T3e.includes(e.name) ||
        R3e.includes(e?.code || "") ||
        I3e.includes(e?.code || "") ||
        A3e.includes(e.$metadata?.httpStatusCode || 0) ||
        Rgt(e) ||
        (e.cause !== void 0 && t <= 10 && Fy(e.cause, t + 1))),
      (v3e = (e) => {
        if (e.$metadata?.httpStatusCode !== void 0) {
          let t = e.$metadata.httpStatusCode;
          return 500 <= t && t <= 599 && !Fy(e);
        }
        return !1;
      });
  });
var ku,
  L3 = s(() => {
    Uy();
    ku = class e {
      constructor(t) {
        (this.currentCapacity = 0),
          (this.enabled = !1),
          (this.lastMaxRate = 0),
          (this.measuredTxRate = 0),
          (this.requestCount = 0),
          (this.lastTimestamp = 0),
          (this.timeWindow = 0),
          (this.beta = t?.beta ?? 0.7),
          (this.minCapacity = t?.minCapacity ?? 1),
          (this.minFillRate = t?.minFillRate ?? 0.5),
          (this.scaleConstant = t?.scaleConstant ?? 0.4),
          (this.smooth = t?.smooth ?? 0.8);
        let r = this.getCurrentTimeInSeconds();
        (this.lastThrottleTime = r),
          (this.lastTxRateBucket = Math.floor(this.getCurrentTimeInSeconds())),
          (this.fillRate = this.minFillRate),
          (this.maxCapacity = this.minCapacity);
      }
      getCurrentTimeInSeconds() {
        return Date.now() / 1e3;
      }
      async getSendToken() {
        return this.acquireTokenBucket(1);
      }
      async acquireTokenBucket(t) {
        if (this.enabled) {
          if ((this.refillTokenBucket(), t > this.currentCapacity)) {
            let r = ((t - this.currentCapacity) / this.fillRate) * 1e3;
            await new Promise((o) => e.setTimeoutFn(o, r));
          }
          this.currentCapacity = this.currentCapacity - t;
        }
      }
      refillTokenBucket() {
        let t = this.getCurrentTimeInSeconds();
        if (!this.lastTimestamp) {
          this.lastTimestamp = t;
          return;
        }
        let r = (t - this.lastTimestamp) * this.fillRate;
        (this.currentCapacity = Math.min(
          this.maxCapacity,
          this.currentCapacity + r
        )),
          (this.lastTimestamp = t);
      }
      updateClientSendingRate(t) {
        let r;
        if ((this.updateMeasuredRate(), Ou(t))) {
          let n = this.enabled
            ? Math.min(this.measuredTxRate, this.fillRate)
            : this.measuredTxRate;
          (this.lastMaxRate = n),
            this.calculateTimeWindow(),
            (this.lastThrottleTime = this.getCurrentTimeInSeconds()),
            (r = this.cubicThrottle(n)),
            this.enableTokenBucket();
        } else
          this.calculateTimeWindow(),
            (r = this.cubicSuccess(this.getCurrentTimeInSeconds()));
        let o = Math.min(r, 2 * this.measuredTxRate);
        this.updateTokenBucketRate(o);
      }
      calculateTimeWindow() {
        this.timeWindow = this.getPrecise(
          Math.pow(
            (this.lastMaxRate * (1 - this.beta)) / this.scaleConstant,
            1 / 3
          )
        );
      }
      cubicThrottle(t) {
        return this.getPrecise(t * this.beta);
      }
      cubicSuccess(t) {
        return this.getPrecise(
          this.scaleConstant *
            Math.pow(t - this.lastThrottleTime - this.timeWindow, 3) +
            this.lastMaxRate
        );
      }
      enableTokenBucket() {
        this.enabled = !0;
      }
      updateTokenBucketRate(t) {
        this.refillTokenBucket(),
          (this.fillRate = Math.max(t, this.minFillRate)),
          (this.maxCapacity = Math.max(t, this.minCapacity)),
          (this.currentCapacity = Math.min(
            this.currentCapacity,
            this.maxCapacity
          ));
      }
      updateMeasuredRate() {
        let t = this.getCurrentTimeInSeconds(),
          r = Math.floor(t * 2) / 2;
        if ((this.requestCount++, r > this.lastTxRateBucket)) {
          let o = this.requestCount / (r - this.lastTxRateBucket);
          (this.measuredTxRate = this.getPrecise(
            o * this.smooth + this.measuredTxRate * (1 - this.smooth)
          )),
            (this.requestCount = 0),
            (this.lastTxRateBucket = r);
        }
      }
      getPrecise(t) {
        return parseFloat(t.toFixed(8));
      }
    };
    ku.setTimeoutFn = setTimeout;
  });
var kR,
  DR,
  Du = s(() => {
    (kR = "amz-sdk-invocation-id"), (DR = "amz-sdk-request");
  });
var O3e,
  k3e = s(() => {
    Du();
    O3e = () => {
      let e = 100;
      return {
        computeNextBackoffDelay: (o) =>
          Math.floor(Math.min(2e4, Math.random() * 2 ** o * e)),
        setDelayBase: (o) => {
          e = o;
        },
      };
    };
  });
var F3,
  D3e = s(() => {
    Du();
    F3 = ({ retryDelay: e, retryCount: t, retryCost: r }) => ({
      getRetryCount: () => t,
      getRetryDelay: () => Math.min(2e4, e),
      getRetryCost: () => r,
    });
  });
var jd,
  BR = s(() => {
    OR();
    Du();
    k3e();
    D3e();
    jd = class {
      constructor(t) {
        (this.maxAttempts = t),
          (this.mode = Ws.STANDARD),
          (this.capacity = 500),
          (this.retryBackoffStrategy = O3e()),
          (this.maxAttemptsProvider =
            typeof t == "function" ? t : async () => t);
      }
      async acquireInitialRetryToken(t) {
        return F3({ retryDelay: 100, retryCount: 0 });
      }
      async refreshRetryTokenForRetry(t, r) {
        let o = await this.getMaxAttempts();
        if (this.shouldRetry(t, r, o)) {
          let n = r.errorType;
          this.retryBackoffStrategy.setDelayBase(
            n === "THROTTLING" ? 500 : 100
          );
          let i = this.retryBackoffStrategy.computeNextBackoffDelay(
              t.getRetryCount()
            ),
            a = r.retryAfterHint
              ? Math.max(r.retryAfterHint.getTime() - Date.now() || 0, i)
              : i,
            c = this.getCapacityCost(n);
          return (
            (this.capacity -= c),
            F3({
              retryDelay: a,
              retryCount: t.getRetryCount() + 1,
              retryCost: c,
            })
          );
        }
        throw new Error("No retry token available");
      }
      recordSuccess(t) {
        this.capacity = Math.max(500, this.capacity + (t.getRetryCost() ?? 1));
      }
      getCapacity() {
        return this.capacity;
      }
      async getMaxAttempts() {
        try {
          return await this.maxAttemptsProvider();
        } catch {
          return (
            console.warn(
              `Max attempts provider could not resolve. Using default of ${qd}`
            ),
            qd
          );
        }
      }
      shouldRetry(t, r, o) {
        return (
          t.getRetryCount() + 1 < o &&
          this.capacity >= this.getCapacityCost(r.errorType) &&
          this.isRetryableError(r.errorType)
        );
      }
      getCapacityCost(t) {
        return t === "TRANSIENT" ? 10 : 5;
      }
      isRetryableError(t) {
        return t === "THROTTLING" || t === "TRANSIENT";
      }
    };
  });
var MR,
  F3e = s(() => {
    OR();
    L3();
    BR();
    MR = class {
      constructor(t, r) {
        (this.maxAttemptsProvider = t), (this.mode = Ws.ADAPTIVE);
        let { rateLimiter: o } = r ?? {};
        (this.rateLimiter = o ?? new ku()),
          (this.standardRetryStrategy = new jd(t));
      }
      async acquireInitialRetryToken(t) {
        return (
          await this.rateLimiter.getSendToken(),
          this.standardRetryStrategy.acquireInitialRetryToken(t)
        );
      }
      async refreshRetryTokenForRetry(t, r) {
        return (
          this.rateLimiter.updateClientSendingRate(r),
          this.standardRetryStrategy.refreshRetryTokenForRetry(t, r)
        );
      }
      recordSuccess(t) {
        this.rateLimiter.updateClientSendingRate({}),
          this.standardRetryStrategy.recordSuccess(t);
      }
    };
  });
var U3e = s(() => {
  Du();
  BR();
});
var $3e = s(() => {});
var Ti = s(() => {
  F3e();
  U3e();
  L3();
  BR();
  OR();
  Du();
  $3e();
});
var H3e = s(() => {
  Ti();
});
var $3 = s(() => {
  Ti();
});
var H3 = s(() => {
  Uy();
});
var z3,
  q3 = s(() => {
    z3 = (e) =>
      e instanceof Error
        ? e
        : e instanceof Object
          ? Object.assign(new Error(), e)
          : typeof e == "string"
            ? new Error(e)
            : new Error(`AWS SDK error wrapper for ${e}`);
  });
var j3 = s(() => {
  an();
  Uy();
  Ti();
  H3e();
  $3();
  H3();
  q3();
});
var z3e = s(() => {
  Ti();
  j3();
});
var q3e,
  j3e,
  LR,
  FR,
  Igt,
  Pgt,
  UR,
  G3e = s(() => {
    ct();
    Ti();
    (q3e = "AWS_MAX_ATTEMPTS"),
      (j3e = "max_attempts"),
      (LR = {
        environmentVariableSelector: (e) => {
          let t = e[q3e];
          if (!t) return;
          let r = parseInt(t);
          if (Number.isNaN(r))
            throw new Error(
              `Environment variable ${q3e} mast be a number, got "${t}"`
            );
          return r;
        },
        configFileSelector: (e) => {
          let t = e[j3e];
          if (!t) return;
          let r = parseInt(t);
          if (Number.isNaN(r))
            throw new Error(
              `Shared config file entry ${j3e} mast be a number, got "${t}"`
            );
          return r;
        },
        default: qd,
      }),
      (FR = (e) => {
        let { retryStrategy: t, retryMode: r, maxAttempts: o } = e,
          n = pe(o ?? qd);
        return Object.assign(e, {
          maxAttempts: n,
          retryStrategy: async () =>
            t || ((await pe(r)()) === Ws.ADAPTIVE ? new MR(n) : new jd(n)),
        });
      }),
      (Igt = "AWS_RETRY_MODE"),
      (Pgt = "retry_mode"),
      (UR = {
        environmentVariableSelector: (e) => e[Igt],
        configFileSelector: (e) => e[Pgt],
        default: vu,
      });
  });
var V3e = s(() => {
  an();
  Ti();
});
var Gd,
  Cc,
  Bu,
  W3e,
  K3e,
  Y3e = s(() => {
    (Gd = (e, t) => {
      let r = [];
      if ((e && r.push(e), t)) for (let o of t) r.push(o);
      return r;
    }),
      (Cc = (e, t) =>
        `${e || "anonymous"}${t && t.length > 0 ? ` (a.k.a. ${t.join(",")})` : ""}`),
      (Bu = () => {
        let e = [],
          t = [],
          r = !1,
          o = new Set(),
          n = (l) =>
            l.sort(
              (u, h) =>
                W3e[h.step] - W3e[u.step] ||
                K3e[h.priority || "normal"] - K3e[u.priority || "normal"]
            ),
          i = (l) => {
            let u = !1,
              h = (y) => {
                let S = Gd(y.name, y.aliases);
                if (S.includes(l)) {
                  u = !0;
                  for (let E of S) o.delete(E);
                  return !1;
                }
                return !0;
              };
            return (e = e.filter(h)), (t = t.filter(h)), u;
          },
          a = (l) => {
            let u = !1,
              h = (y) => {
                if (y.middleware === l) {
                  u = !0;
                  for (let S of Gd(y.name, y.aliases)) o.delete(S);
                  return !1;
                }
                return !0;
              };
            return (e = e.filter(h)), (t = t.filter(h)), u;
          },
          c = (l) => (
            e.forEach((u) => {
              l.add(u.middleware, { ...u });
            }),
            t.forEach((u) => {
              l.addRelativeTo(u.middleware, { ...u });
            }),
            l.identifyOnResolve?.(f.identifyOnResolve()),
            l
          ),
          d = (l) => {
            let u = [];
            return (
              l.before.forEach((h) => {
                h.before.length === 0 && h.after.length === 0
                  ? u.push(h)
                  : u.push(...d(h));
              }),
              u.push(l),
              l.after.reverse().forEach((h) => {
                h.before.length === 0 && h.after.length === 0
                  ? u.push(h)
                  : u.push(...d(h));
              }),
              u
            );
          },
          m = (l = !1) => {
            let u = [],
              h = [],
              y = {};
            return (
              e.forEach((E) => {
                let b = { ...E, before: [], after: [] };
                for (let v of Gd(b.name, b.aliases)) y[v] = b;
                u.push(b);
              }),
              t.forEach((E) => {
                let b = { ...E, before: [], after: [] };
                for (let v of Gd(b.name, b.aliases)) y[v] = b;
                h.push(b);
              }),
              h.forEach((E) => {
                if (E.toMiddleware) {
                  let b = y[E.toMiddleware];
                  if (b === void 0) {
                    if (l) return;
                    throw new Error(
                      `${E.toMiddleware} is not found when adding ${Cc(E.name, E.aliases)} middleware ${E.relation} ${E.toMiddleware}`
                    );
                  }
                  E.relation === "after" && b.after.push(E),
                    E.relation === "before" && b.before.push(E);
                }
              }),
              n(u)
                .map(d)
                .reduce((E, b) => (E.push(...b), E), [])
            );
          },
          f = {
            add: (l, u = {}) => {
              let { name: h, override: y, aliases: S } = u,
                E = {
                  step: "initialize",
                  priority: "normal",
                  middleware: l,
                  ...u,
                },
                b = Gd(h, S);
              if (b.length > 0) {
                if (b.some((v) => o.has(v))) {
                  if (!y)
                    throw new Error(`Duplicate middleware name '${Cc(h, S)}'`);
                  for (let v of b) {
                    let I = e.findIndex(
                      (ge) =>
                        ge.name === v || ge.aliases?.some((Fe) => Fe === v)
                    );
                    if (I === -1) continue;
                    let O = e[I];
                    if (O.step !== E.step || E.priority !== O.priority)
                      throw new Error(
                        `"${Cc(O.name, O.aliases)}" middleware with ${O.priority} priority in ${O.step} step cannot be overridden by "${Cc(h, S)}" middleware with ${E.priority} priority in ${E.step} step.`
                      );
                    e.splice(I, 1);
                  }
                }
                for (let v of b) o.add(v);
              }
              e.push(E);
            },
            addRelativeTo: (l, u) => {
              let { name: h, override: y, aliases: S } = u,
                E = { middleware: l, ...u },
                b = Gd(h, S);
              if (b.length > 0) {
                if (b.some((v) => o.has(v))) {
                  if (!y)
                    throw new Error(`Duplicate middleware name '${Cc(h, S)}'`);
                  for (let v of b) {
                    let I = t.findIndex(
                      (ge) =>
                        ge.name === v || ge.aliases?.some((Fe) => Fe === v)
                    );
                    if (I === -1) continue;
                    let O = t[I];
                    if (
                      O.toMiddleware !== E.toMiddleware ||
                      O.relation !== E.relation
                    )
                      throw new Error(
                        `"${Cc(O.name, O.aliases)}" middleware ${O.relation} "${O.toMiddleware}" middleware cannot be overridden by "${Cc(h, S)}" middleware ${E.relation} "${E.toMiddleware}" middleware.`
                      );
                    t.splice(I, 1);
                  }
                }
                for (let v of b) o.add(v);
              }
              t.push(E);
            },
            clone: () => c(Bu()),
            use: (l) => {
              l.applyToStack(f);
            },
            remove: (l) => (typeof l == "string" ? i(l) : a(l)),
            removeByTag: (l) => {
              let u = !1,
                h = (y) => {
                  let { tags: S, name: E, aliases: b } = y;
                  if (S && S.includes(l)) {
                    let v = Gd(E, b);
                    for (let I of v) o.delete(I);
                    return (u = !0), !1;
                  }
                  return !0;
                };
              return (e = e.filter(h)), (t = t.filter(h)), u;
            },
            concat: (l) => {
              let u = c(Bu());
              return (
                u.use(l),
                u.identifyOnResolve(
                  r || u.identifyOnResolve() || (l.identifyOnResolve?.() ?? !1)
                ),
                u
              );
            },
            applyToStack: c,
            identify: () =>
              m(!0).map((l) => {
                let u = l.step ?? l.relation + " " + l.toMiddleware;
                return Cc(l.name, l.aliases) + " - " + u;
              }),
            identifyOnResolve(l) {
              return typeof l == "boolean" && (r = l), r;
            },
            resolve: (l, u) => {
              for (let h of m()
                .map((y) => y.middleware)
                .reverse())
                l = h(l, u);
              return r && console.log(f.identify()), l;
            },
          };
        return f;
      }),
      (W3e = {
        initialize: 5,
        serialize: 4,
        build: 3,
        finalizeRequest: 2,
        deserialize: 1,
      }),
      (K3e = { high: 3, normal: 2, low: 1 });
  });
var G3 = s(() => {
  Y3e();
});
var Mu,
  Q3e = s(() => {
    G3();
    Mu = class {
      constructor(t) {
        (this.config = t), (this.middlewareStack = Bu());
      }
      send(t, r, o) {
        let n = typeof r != "function" ? r : void 0,
          i = typeof r == "function" ? r : o,
          a = n === void 0 && this.config.cacheMiddleware === !0,
          c;
        if (a) {
          this.handlers || (this.handlers = new WeakMap());
          let d = this.handlers;
          d.has(t.constructor)
            ? (c = d.get(t.constructor))
            : ((c = t.resolveMiddleware(this.middlewareStack, this.config, n)),
              d.set(t.constructor, c));
        } else
          delete this.handlers,
            (c = t.resolveMiddleware(this.middlewareStack, this.config, n));
        if (i)
          c(t)
            .then(
              (d) => i(null, d.output),
              (d) => i(d)
            )
            .catch(() => {});
        else return c(t).then((d) => d.output);
      }
      destroy() {
        this.config?.requestHandler?.destroy?.(), delete this.handlers;
      }
    };
  });
var X3e = s(() => {
  Dt();
});
var _,
  V3,
  J3e = s(() => {
    G3();
    $d();
    (_ = class {
      constructor() {
        this.middlewareStack = Bu();
      }
      static classBuilder() {
        return new V3();
      }
      resolveMiddlewareWithContext(
        t,
        r,
        o,
        {
          middlewareFn: n,
          clientName: i,
          commandName: a,
          inputFilterSensitiveLog: c,
          outputFilterSensitiveLog: d,
          smithyContext: m,
          additionalContext: f,
          CommandCtor: l,
        }
      ) {
        for (let E of n.bind(this)(l, t, r, o)) this.middlewareStack.use(E);
        let u = t.concat(this.middlewareStack),
          { logger: h } = r,
          y = {
            logger: h,
            clientName: i,
            commandName: a,
            inputFilterSensitiveLog: c,
            outputFilterSensitiveLog: d,
            [tFe]: { commandInstance: this, ...m },
            ...f,
          },
          { requestHandler: S } = r;
        return u.resolve((E) => S.handle(E.request, o || {}), y);
      }
    }),
      (V3 = class {
        constructor() {
          (this._init = () => {}),
            (this._ep = {}),
            (this._middlewareFn = () => []),
            (this._commandName = ""),
            (this._clientName = ""),
            (this._additionalContext = {}),
            (this._smithyContext = {}),
            (this._inputFilterSensitiveLog = (t) => t),
            (this._outputFilterSensitiveLog = (t) => t),
            (this._serializer = null),
            (this._deserializer = null);
        }
        init(t) {
          this._init = t;
        }
        ep(t) {
          return (this._ep = t), this;
        }
        m(t) {
          return (this._middlewareFn = t), this;
        }
        s(t, r, o = {}) {
          return (
            (this._smithyContext = { service: t, operation: r, ...o }), this
          );
        }
        c(t = {}) {
          return (this._additionalContext = t), this;
        }
        n(t, r) {
          return (this._clientName = t), (this._commandName = r), this;
        }
        f(t = (o) => o, r = (o) => o) {
          return (
            (this._inputFilterSensitiveLog = t),
            (this._outputFilterSensitiveLog = r),
            this
          );
        }
        ser(t) {
          return (this._serializer = t), this;
        }
        de(t) {
          return (this._deserializer = t), this;
        }
        sc(t) {
          return (
            (this._operationSchema = t),
            (this._smithyContext.operationSchema = t),
            this
          );
        }
        build() {
          let t = this,
            r;
          return (r = class extends _ {
            static getEndpointParameterInstructions() {
              return t._ep;
            }
            constructor(...[o]) {
              super(),
                (this.serialize = t._serializer),
                (this.deserialize = t._deserializer),
                (this.input = o ?? {}),
                t._init(this),
                (this.schema = t._operationSchema);
            }
            resolveMiddleware(o, n, i) {
              return this.resolveMiddlewareWithContext(o, n, i, {
                CommandCtor: r,
                middlewareFn: t._middlewareFn,
                clientName: t._clientName,
                commandName: t._commandName,
                inputFilterSensitiveLog: t._inputFilterSensitiveLog,
                outputFilterSensitiveLog: t._outputFilterSensitiveLog,
                smithyContext: t._smithyContext,
                additionalContext: t._additionalContext,
              });
            }
          });
        }
      });
  });
var $e,
  Z3e = s(() => {
    $e = "***SensitiveInformation***";
  });
var $R,
  eze = s(() => {
    $R = (e, t) => {
      for (let r of Object.keys(e)) {
        let o = e[r],
          n = async function (a, c, d) {
            let m = new o(a);
            if (typeof c == "function") this.send(m, c);
            else if (typeof d == "function") {
              if (typeof c != "object")
                throw new Error(`Expected http options but got ${typeof c}`);
              this.send(m, c || {}, d);
            } else return this.send(m, c);
          },
          i = (r[0].toLowerCase() + r.slice(1)).replace(/Command$/, "");
        t.prototype[i] = n;
      }
    };
  });
var Lu,
  Nr,
  W3 = s(() => {
    (Lu = class e extends Error {
      constructor(t) {
        super(t.message),
          Object.setPrototypeOf(
            this,
            Object.getPrototypeOf(this).constructor.prototype
          ),
          (this.name = t.name),
          (this.$fault = t.$fault),
          (this.$metadata = t.$metadata);
      }
      static isInstance(t) {
        if (!t) return !1;
        let r = t;
        return (
          e.prototype.isPrototypeOf(r) ||
          (!!r.$fault &&
            !!r.$metadata &&
            (r.$fault === "client" || r.$fault === "server"))
        );
      }
      static [Symbol.hasInstance](t) {
        if (!t) return !1;
        let r = t;
        return this === e
          ? e.isInstance(t)
          : e.isInstance(t)
            ? r.name && this.name
              ? this.prototype.isPrototypeOf(t) || r.name === this.name
              : this.prototype.isPrototypeOf(t)
            : !1;
      }
    }),
      (Nr = (e, t = {}) => {
        Object.entries(t)
          .filter(([, o]) => o !== void 0)
          .forEach(([o, n]) => {
            (e[o] == null || e[o] === "") && (e[o] = n);
          });
        let r = e.message || e.Message || "UnknownError";
        return (e.message = r), delete e.Message, e;
      });
  });
var vgt,
  HR,
  Ogt,
  tze = s(() => {
    W3();
    (vgt = ({ output: e, parsedBody: t, exceptionCtor: r, errorCode: o }) => {
      let n = Ogt(e),
        i = n.httpStatusCode ? n.httpStatusCode + "" : void 0,
        a = new r({
          name: t?.code || t?.Code || o || i || "UnknownError",
          $fault: "client",
          $metadata: n,
        });
      throw Nr(a, t);
    }),
      (HR =
        (e) =>
        ({ output: t, parsedBody: r, errorCode: o }) => {
          vgt({ output: t, parsedBody: r, exceptionCtor: e, errorCode: o });
        }),
      (Ogt = (e) => ({
        httpStatusCode: e.statusCode,
        requestId:
          e.headers["x-amzn-requestid"] ??
          e.headers["x-amzn-request-id"] ??
          e.headers["x-amz-request-id"],
        extendedRequestId: e.headers["x-amz-id-2"],
        cfId: e.headers["x-amz-cf-id"],
      }));
  });
var zR,
  rze = s(() => {
    zR = (e) => {
      switch (e) {
        case "standard":
          return { retryMode: "standard", connectionTimeout: 3100 };
        case "in-region":
          return { retryMode: "standard", connectionTimeout: 1100 };
        case "cross-region":
          return { retryMode: "standard", connectionTimeout: 3100 };
        case "mobile":
          return { retryMode: "standard", connectionTimeout: 3e4 };
        default:
          return {};
      }
    };
  });
var oze,
  qR,
  nze = s(() => {
    (oze = !1),
      (qR = (e) => {
        e &&
          !oze &&
          parseInt(e.substring(1, e.indexOf("."))) < 16 &&
          (oze = !0);
      });
  });
var sze = s(() => {
  Dt();
});
var ize,
  aze,
  cze = s(() => {
    $d();
    (ize = (e) => {
      let t = [];
      for (let r in bu) {
        let o = bu[r];
        e[o] !== void 0 &&
          t.push({ algorithmId: () => o, checksumConstructor: () => e[o] });
      }
      return {
        addChecksumAlgorithm(r) {
          t.push(r);
        },
        checksumAlgorithms() {
          return t;
        },
      };
    }),
      (aze = (e) => {
        let t = {};
        return (
          e.checksumAlgorithms().forEach((r) => {
            t[r.algorithmId()] = r.checksumConstructor();
          }),
          t
        );
      });
  });
var dze,
  mze,
  lze = s(() => {
    (dze = (e) => ({
      setRetryStrategy(t) {
        e.retryStrategy = t;
      },
      retryStrategy() {
        return e.retryStrategy;
      },
    })),
      (mze = (e) => {
        let t = {};
        return (t.retryStrategy = e.retryStrategy()), t;
      });
  });
var jR,
  GR,
  fze = s(() => {
    cze();
    lze();
    (jR = (e) => Object.assign(ize(e), dze(e))),
      (GR = (e) => Object.assign(aze(e), mze(e)));
  });
var uze = s(() => {
  fze();
});
var Ne,
  pze = s(() => {
    Ne = (e) => (Array.isArray(e) ? e : [e]);
  });
var hze = s(() => {});
var k,
  gze = s(() => {
    k = (e) => e != null;
  });
var bc,
  yze = s(() => {
    bc = class {
      trace() {}
      debug() {}
      info() {}
      warn() {}
      error() {}
    };
  });
function g(e, t, r) {
  let o, n, i;
  if (typeof t > "u" && typeof r > "u") (o = {}), (i = e);
  else {
    if (((o = e), typeof t == "function"))
      return (n = t), (i = r), kgt(o, n, i);
    i = t;
  }
  for (let a of Object.keys(i)) {
    if (!Array.isArray(i[a])) {
      o[a] = i[a];
      continue;
    }
    xze(o, null, i, a);
  }
  return o;
}
var _c,
  kgt,
  xze,
  Dgt,
  Ngt,
  Eze = s(() => {
    (_c = (e, t) => {
      let r = {};
      for (let o in t) xze(r, e, t, o);
      return r;
    }),
      (kgt = (e, t, r) =>
        g(
          e,
          Object.entries(r).reduce(
            (o, [n, i]) => (
              Array.isArray(i)
                ? (o[n] = i)
                : typeof i == "function"
                  ? (o[n] = [t, i()])
                  : (o[n] = [t, i]),
              o
            ),
            {}
          )
        )),
      (xze = (e, t, r, o) => {
        if (t !== null) {
          let a = r[o];
          typeof a == "function" && (a = [, a]);
          let [c = Dgt, d = Ngt, m = o] = a;
          ((typeof c == "function" && c(t[m])) ||
            (typeof c != "function" && c)) &&
            (e[o] = d(t[m]));
          return;
        }
        let [n, i] = r[o];
        if (typeof i == "function") {
          let a,
            c = n === void 0 && (a = i()) != null,
            d =
              (typeof n == "function" && !!n(void 0)) ||
              (typeof n != "function" && !!n);
          c ? (e[o] = a) : d && (e[o] = i());
        } else {
          let a = n === void 0 && i != null,
            c =
              (typeof n == "function" && !!n(i)) ||
              (typeof n != "function" && !!n);
          (a || c) && (e[o] = i);
        }
      }),
      (Dgt = (e) => e != null),
      (Ngt = (e) => e);
  });
var Sze = s(() => {
  Dt();
});
var wc,
  Cze = s(() => {
    wc = (e) => e.toISOString().replace(".000Z", "Z");
  });
var Fu,
  bze = s(() => {
    Fu = (e) => {
      if (e == null) return {};
      if (Array.isArray(e)) return e.filter((t) => t != null).map(Fu);
      if (typeof e == "object") {
        let t = {};
        for (let r of Object.keys(e)) e[r] != null && (t[r] = Fu(e[r]));
        return t;
      }
      return e;
    };
  });
var $ = s(() => {
  Q3e();
  X3e();
  J3e();
  Z3e();
  eze();
  tze();
  rze();
  nze();
  W3();
  sze();
  uze();
  pze();
  hze();
  gze();
  yze();
  Eze();
  Sze();
  Cze();
  bze();
  Uo();
});
import { Readable as Bgt } from "stream";
var _ze,
  wze = s(() => {
    _ze = (e) =>
      e?.body instanceof Bgt ||
      (typeof ReadableStream < "u" && e?.body instanceof ReadableStream);
  });
var Mgt,
  Lgt,
  Fgt,
  Ugt,
  $gt,
  VR,
  Hgt,
  Tze = s(() => {
    an();
    Uy();
    $();
    Ti();
    id();
    wze();
    q3();
    (Mgt = (e) => (t, r) => async (o) => {
      let n = await e.retryStrategy(),
        i = await e.maxAttempts();
      if (Lgt(n)) {
        n = n;
        let a = await n.acquireInitialRetryToken(r.partition_id),
          c = new Error(),
          d = 0,
          m = 0,
          { request: f } = o,
          l = bn.isInstance(f);
        for (l && (f.headers[kR] = qo()); ; )
          try {
            l && (f.headers[DR] = `attempt=${d + 1}; max=${i}`);
            let { response: u, output: h } = await t(o);
            return (
              n.recordSuccess(a),
              (h.$metadata.attempts = d + 1),
              (h.$metadata.totalRetryDelay = m),
              { response: u, output: h }
            );
          } catch (u) {
            let h = Fgt(u);
            if (((c = z3(u)), l && _ze(f)))
              throw (
                ((r.logger instanceof bc ? console : r.logger)?.warn(
                  "An error was encountered in a non-retryable streaming request."
                ),
                c)
              );
            try {
              a = await n.refreshRetryTokenForRetry(a, h);
            } catch {
              throw (
                (c.$metadata || (c.$metadata = {}),
                (c.$metadata.attempts = d + 1),
                (c.$metadata.totalRetryDelay = m),
                c)
              );
            }
            d = a.getRetryCount();
            let y = a.getRetryDelay();
            (m += y), await new Promise((S) => setTimeout(S, y));
          }
      } else
        return (
          (n = n),
          n?.mode &&
            (r.userAgent = [
              ...(r.userAgent || []),
              ["cfg/retry-mode", n.mode],
            ]),
          n.retry(t, o)
        );
    }),
      (Lgt = (e) =>
        typeof e.acquireInitialRetryToken < "u" &&
        typeof e.refreshRetryTokenForRetry < "u" &&
        typeof e.recordSuccess < "u"),
      (Fgt = (e) => {
        let t = { error: e, errorType: Ugt(e) },
          r = Hgt(e.$response);
        return r && (t.retryAfterHint = r), t;
      }),
      (Ugt = (e) =>
        Ou(e)
          ? "THROTTLING"
          : Fy(e)
            ? "TRANSIENT"
            : v3e(e)
              ? "SERVER_ERROR"
              : "CLIENT_ERROR"),
      ($gt = {
        name: "retryMiddleware",
        tags: ["RETRY"],
        step: "finalizeRequest",
        priority: "high",
        override: !0,
      }),
      (VR = (e) => ({
        applyToStack: (t) => {
          t.add(Mgt(e), $gt);
        },
      })),
      (Hgt = (e) => {
        if (!Gs.isInstance(e)) return;
        let t = Object.keys(e.headers).find(
          (i) => i.toLowerCase() === "retry-after"
        );
        if (!t) return;
        let r = e.headers[t],
          o = Number(r);
        return Number.isNaN(o) ? new Date(r) : new Date(o * 1e3);
      });
  });
var $y = s(() => {
  z3e();
  j3();
  G3e();
  $3();
  V3e();
  H3();
  Tze();
});
var Hy,
  K3 = s(() => {
    Hy = { CrtSignerV4: null };
  });
var Uu,
  Aze = s(() => {
    he();
    AE();
    K3();
    Uu = class {
      sigv4aSigner;
      sigv4Signer;
      signerOptions;
      static sigv4aDependency() {
        return typeof Hy.CrtSignerV4 == "function"
          ? "crt"
          : typeof ED.SignatureV4a == "function"
            ? "js"
            : "none";
      }
      constructor(t) {
        (this.sigv4Signer = new Dy(t)), (this.signerOptions = t);
      }
      async sign(t, r = {}) {
        return r.signingRegion === "*"
          ? this.getSigv4aSigner().sign(t, r)
          : this.sigv4Signer.sign(t, r);
      }
      async signWithCredentials(t, r, o = {}) {
        if (o.signingRegion === "*") {
          let n = this.getSigv4aSigner(),
            i = Hy.CrtSignerV4;
          if (i && n instanceof i) return n.signWithCredentials(t, r, o);
          throw new Error(
            `signWithCredentials with signingRegion '*' is only supported when using the CRT dependency @aws-sdk/signature-v4-crt. Please check whether you have installed the "@aws-sdk/signature-v4-crt" package explicitly. You must also register the package by calling [require("@aws-sdk/signature-v4-crt");] or an ESM equivalent such as [import "@aws-sdk/signature-v4-crt";]. For more information please go to https://github.com/aws/aws-sdk-js-v3#functionality-requiring-aws-common-runtime-crt`
          );
        }
        return this.sigv4Signer.signWithCredentials(t, r, o);
      }
      async presign(t, r = {}) {
        if (r.signingRegion === "*") {
          let o = this.getSigv4aSigner(),
            n = Hy.CrtSignerV4;
          if (n && o instanceof n) return o.presign(t, r);
          throw new Error(
            `presign with signingRegion '*' is only supported when using the CRT dependency @aws-sdk/signature-v4-crt. Please check whether you have installed the "@aws-sdk/signature-v4-crt" package explicitly. You must also register the package by calling [require("@aws-sdk/signature-v4-crt");] or an ESM equivalent such as [import "@aws-sdk/signature-v4-crt";]. For more information please go to https://github.com/aws/aws-sdk-js-v3#functionality-requiring-aws-common-runtime-crt`
          );
        }
        return this.sigv4Signer.presign(t, r);
      }
      async presignWithCredentials(t, r, o = {}) {
        if (o.signingRegion === "*")
          throw new Error(
            "Method presignWithCredentials is not supported for [signingRegion=*]."
          );
        return this.sigv4Signer.presignWithCredentials(t, r, o);
      }
      getSigv4aSigner() {
        if (!this.sigv4aSigner) {
          let t = Hy.CrtSignerV4,
            r = ED.SignatureV4a;
          if (this.signerOptions.runtime === "node") {
            if (!t && !r)
              throw new Error(
                "Neither CRT nor JS SigV4a implementation is available. Please load either @aws-sdk/signature-v4-crt or @aws-sdk/signature-v4a. For more information please go to https://github.com/aws/aws-sdk-js-v3#functionality-requiring-aws-common-runtime-crt"
              );
            if (t && typeof t == "function")
              this.sigv4aSigner = new t({
                ...this.signerOptions,
                signingAlgorithm: 1,
              });
            else if (r && typeof r == "function")
              this.sigv4aSigner = new r({ ...this.signerOptions });
            else
              throw new Error(
                "Available SigV4a implementation is not a valid constructor. Please ensure you've properly imported @aws-sdk/signature-v4-crt or @aws-sdk/signature-v4a.For more information please go to https://github.com/aws/aws-sdk-js-v3#functionality-requiring-aws-common-runtime-crt"
              );
          } else {
            if (!r || typeof r != "function")
              throw new Error(
                "JS SigV4a implementation is not available or not a valid constructor. Please check whether you have installed the @aws-sdk/signature-v4a package explicitly. The CRT implementation is not available for browsers. You must also register the package by calling [require('@aws-sdk/signature-v4a');] or an ESM equivalent such as [import '@aws-sdk/signature-v4a';]. For more information please go to https://github.com/aws/aws-sdk-js-v3#using-javascript-non-crt-implementation-of-sigv4a"
              );
            this.sigv4aSigner = new r({ ...this.signerOptions });
          }
        }
        return this.sigv4aSigner;
      }
    };
  });
var Y3 = s(() => {
  Aze();
  K3();
});
var Ez,
  x,
  H,
  w,
  N,
  B,
  Ee,
  Qe,
  le,
  fe,
  Wd,
  Yo,
  Eo,
  So,
  dn,
  ue,
  Sz,
  Bn,
  Hr,
  me,
  XR,
  St,
  Pr,
  $r,
  tr,
  Rze,
  Cz,
  Q,
  j,
  JR,
  ZR,
  Ii,
  Ize,
  QR,
  F2e,
  U2e,
  Pze,
  yz,
  Kd,
  bz,
  Gy,
  ju,
  $2e,
  H2e,
  vze,
  z2e,
  q2e,
  j2e,
  eI,
  _z,
  G2e,
  wz,
  Oze,
  kze,
  Dze,
  Nze,
  V2e,
  Bze,
  Mze,
  $u,
  Hu,
  zy,
  gs,
  fr,
  er,
  Ur,
  W2e,
  Lze,
  jy,
  Et,
  Fze,
  Uze,
  $ze,
  cn,
  Q3,
  K2e,
  Y2e,
  Vd,
  Ve,
  Q2e,
  Hze,
  zze,
  qze,
  We,
  WR,
  jze,
  Gze,
  Vze,
  KR,
  X3,
  zgt,
  Wr,
  oo,
  go,
  gt,
  yo,
  Wze,
  Kr,
  xo,
  lt,
  Kze,
  nt,
  Yze,
  Qze,
  J3,
  Z3,
  xz,
  Xze,
  ez,
  Jze,
  YR,
  _n,
  X2e,
  tz,
  Tz,
  Zze,
  e2e,
  t2e,
  rz,
  J2e,
  Z2e,
  oz,
  r2e,
  nz,
  sz,
  iz,
  o2e,
  n2e,
  qy,
  s2e,
  i2e,
  a2e,
  c2e,
  d2e,
  az,
  m2e,
  l2e,
  cz,
  f2e,
  u2e,
  p2e,
  dz,
  h2e,
  mz,
  qgt,
  jgt,
  g2e,
  lz,
  zu,
  y2e,
  Ggt,
  x2e,
  hs,
  qu,
  E2e,
  Ai,
  S2e,
  C2e,
  b2e,
  _2e,
  Ri,
  w2e,
  T2e,
  A2e,
  R2e,
  I2e,
  P2e,
  Vgt,
  v2e,
  O2e,
  Wgt,
  k2e,
  Tc,
  fz,
  D2e,
  Kgt,
  uz,
  N2e,
  Ygt,
  pz,
  B2e,
  hz,
  gz,
  M2e,
  L2e,
  Qgt,
  eqe,
  tqe = s(() => {
    (Ez = "required"),
      (x = "type"),
      (H = "rules"),
      (w = "conditions"),
      (N = "fn"),
      (B = "argv"),
      (Ee = "ref"),
      (Qe = "assign"),
      (le = "url"),
      (fe = "properties"),
      (Wd = "backend"),
      (Yo = "authSchemes"),
      (Eo = "disableDoubleEncoding"),
      (So = "signingName"),
      (dn = "signingRegion"),
      (ue = "headers"),
      (Sz = "signingRegionSet"),
      (Bn = "isSet"),
      (Hr = "booleanEquals"),
      (me = "error"),
      (XR = "aws.partition"),
      (St = "stringEquals"),
      (Pr = "getAttr"),
      ($r = "name"),
      (tr = "substring"),
      (Rze = "bucketSuffix"),
      (Cz = "parseURL"),
      (Q = "endpoint"),
      (j = "tree"),
      (JR = "aws.isVirtualHostableS3Bucket"),
      (ZR = "{url#scheme}://{Bucket}.{url#authority}{url#path}"),
      (Ii = "not"),
      (Ize = "accessPointSuffix"),
      (QR = "{url#scheme}://{url#authority}{url#path}"),
      (F2e = "hardwareType"),
      (U2e = "regionPrefix"),
      (Pze = "bucketAliasSuffix"),
      (yz = "outpostId"),
      (Kd = "isValidHostLabel"),
      (bz = "sigv4a"),
      (Gy = "s3-outposts"),
      (ju = "s3"),
      ($2e = "{url#scheme}://{url#authority}{url#normalizedPath}{Bucket}"),
      (H2e = "https://{Bucket}.s3-accelerate.{partitionResult#dnsSuffix}"),
      (vze = "https://{Bucket}.s3.{partitionResult#dnsSuffix}"),
      (z2e = "aws.parseArn"),
      (q2e = "bucketArn"),
      (j2e = "arnType"),
      (eI = ""),
      (_z = "s3-object-lambda"),
      (G2e = "accesspoint"),
      (wz = "accessPointName"),
      (Oze =
        "{url#scheme}://{accessPointName}-{bucketArn#accountId}.{url#authority}{url#path}"),
      (kze = "mrapPartition"),
      (Dze = "outpostType"),
      (Nze = "arnPrefix"),
      (V2e =
        "{url#scheme}://{url#authority}{url#normalizedPath}{uri_encoded_bucket}"),
      (Bze = "https://s3.{partitionResult#dnsSuffix}/{uri_encoded_bucket}"),
      (Mze = "https://s3.{partitionResult#dnsSuffix}"),
      ($u = { [Ez]: !1, [x]: "String" }),
      (Hu = { [Ez]: !0, default: !1, [x]: "Boolean" }),
      (zy = { [Ez]: !1, [x]: "Boolean" }),
      (gs = { [N]: Hr, [B]: [{ [Ee]: "Accelerate" }, !0] }),
      (fr = { [N]: Hr, [B]: [{ [Ee]: "UseFIPS" }, !0] }),
      (er = { [N]: Hr, [B]: [{ [Ee]: "UseDualStack" }, !0] }),
      (Ur = { [N]: Bn, [B]: [{ [Ee]: "Endpoint" }] }),
      (W2e = { [N]: XR, [B]: [{ [Ee]: "Region" }], [Qe]: "partitionResult" }),
      (Lze = {
        [N]: St,
        [B]: [{ [N]: Pr, [B]: [{ [Ee]: "partitionResult" }, $r] }, "aws-cn"],
      }),
      (jy = { [N]: Bn, [B]: [{ [Ee]: "Bucket" }] }),
      (Et = { [Ee]: "Bucket" }),
      (Fze = {
        [w]: [er],
        [me]: "S3Express does not support Dual-stack.",
        [x]: me,
      }),
      (Uze = {
        [w]: [gs],
        [me]: "S3Express does not support S3 Accelerate.",
        [x]: me,
      }),
      ($ze = {
        [w]: [Ur, { [N]: Cz, [B]: [{ [Ee]: "Endpoint" }], [Qe]: "url" }],
        [H]: [
          {
            [w]: [
              { [N]: Bn, [B]: [{ [Ee]: "DisableS3ExpressSessionAuth" }] },
              { [N]: Hr, [B]: [{ [Ee]: "DisableS3ExpressSessionAuth" }, !0] },
            ],
            [H]: [
              {
                [w]: [
                  {
                    [N]: Hr,
                    [B]: [{ [N]: Pr, [B]: [{ [Ee]: "url" }, "isIp"] }, !0],
                  },
                ],
                [H]: [
                  {
                    [w]: [
                      {
                        [N]: "uriEncode",
                        [B]: [Et],
                        [Qe]: "uri_encoded_bucket",
                      },
                    ],
                    [H]: [
                      {
                        [Q]: {
                          [le]: "{url#scheme}://{url#authority}/{uri_encoded_bucket}{url#path}",
                          [fe]: {
                            [Wd]: "S3Express",
                            [Yo]: [
                              {
                                [Eo]: !0,
                                [$r]: "sigv4",
                                [So]: "s3express",
                                [dn]: "{Region}",
                              },
                            ],
                          },
                          [ue]: {},
                        },
                        [x]: Q,
                      },
                    ],
                    [x]: j,
                  },
                ],
                [x]: j,
              },
              {
                [w]: [{ [N]: JR, [B]: [Et, !1] }],
                [H]: [
                  {
                    [Q]: {
                      [le]: ZR,
                      [fe]: {
                        [Wd]: "S3Express",
                        [Yo]: [
                          {
                            [Eo]: !0,
                            [$r]: "sigv4",
                            [So]: "s3express",
                            [dn]: "{Region}",
                          },
                        ],
                      },
                      [ue]: {},
                    },
                    [x]: Q,
                  },
                ],
                [x]: j,
              },
              {
                [me]: "S3Express bucket name is not a valid virtual hostable name.",
                [x]: me,
              },
            ],
            [x]: j,
          },
          {
            [w]: [
              {
                [N]: Hr,
                [B]: [{ [N]: Pr, [B]: [{ [Ee]: "url" }, "isIp"] }, !0],
              },
            ],
            [H]: [
              {
                [w]: [
                  { [N]: "uriEncode", [B]: [Et], [Qe]: "uri_encoded_bucket" },
                ],
                [H]: [
                  {
                    [Q]: {
                      [le]: "{url#scheme}://{url#authority}/{uri_encoded_bucket}{url#path}",
                      [fe]: {
                        [Wd]: "S3Express",
                        [Yo]: [
                          {
                            [Eo]: !0,
                            [$r]: "sigv4-s3express",
                            [So]: "s3express",
                            [dn]: "{Region}",
                          },
                        ],
                      },
                      [ue]: {},
                    },
                    [x]: Q,
                  },
                ],
                [x]: j,
              },
            ],
            [x]: j,
          },
          {
            [w]: [{ [N]: JR, [B]: [Et, !1] }],
            [H]: [
              {
                [Q]: {
                  [le]: ZR,
                  [fe]: {
                    [Wd]: "S3Express",
                    [Yo]: [
                      {
                        [Eo]: !0,
                        [$r]: "sigv4-s3express",
                        [So]: "s3express",
                        [dn]: "{Region}",
                      },
                    ],
                  },
                  [ue]: {},
                },
                [x]: Q,
              },
            ],
            [x]: j,
          },
          {
            [me]: "S3Express bucket name is not a valid virtual hostable name.",
            [x]: me,
          },
        ],
        [x]: j,
      }),
      (cn = { [N]: Cz, [B]: [{ [Ee]: "Endpoint" }], [Qe]: "url" }),
      (Q3 = {
        [N]: Hr,
        [B]: [{ [N]: Pr, [B]: [{ [Ee]: "url" }, "isIp"] }, !0],
      }),
      (K2e = { [Ee]: "url" }),
      (Y2e = { [N]: "uriEncode", [B]: [Et], [Qe]: "uri_encoded_bucket" }),
      (Vd = {
        [Wd]: "S3Express",
        [Yo]: [
          { [Eo]: !0, [$r]: "sigv4", [So]: "s3express", [dn]: "{Region}" },
        ],
      }),
      (Ve = {}),
      (Q2e = { [N]: JR, [B]: [Et, !1] }),
      (Hze = {
        [me]: "S3Express bucket name is not a valid virtual hostable name.",
        [x]: me,
      }),
      (zze = { [N]: Bn, [B]: [{ [Ee]: "UseS3ExpressControlEndpoint" }] }),
      (qze = { [N]: Hr, [B]: [{ [Ee]: "UseS3ExpressControlEndpoint" }, !0] }),
      (We = { [N]: Ii, [B]: [Ur] }),
      (WR = { [me]: "Unrecognized S3Express bucket name format.", [x]: me }),
      (jze = { [N]: Ii, [B]: [jy] }),
      (Gze = { [Ee]: F2e }),
      (Vze = {
        [w]: [We],
        [me]: "Expected a endpoint to be specified but no endpoint was found",
        [x]: me,
      }),
      (KR = {
        [Yo]: [
          { [Eo]: !0, [$r]: bz, [So]: Gy, [Sz]: ["*"] },
          { [Eo]: !0, [$r]: "sigv4", [So]: Gy, [dn]: "{Region}" },
        ],
      }),
      (X3 = { [N]: Hr, [B]: [{ [Ee]: "ForcePathStyle" }, !1] }),
      (zgt = { [Ee]: "ForcePathStyle" }),
      (Wr = { [N]: Hr, [B]: [{ [Ee]: "Accelerate" }, !1] }),
      (oo = { [N]: St, [B]: [{ [Ee]: "Region" }, "aws-global"] }),
      (go = {
        [Yo]: [{ [Eo]: !0, [$r]: "sigv4", [So]: ju, [dn]: "us-east-1" }],
      }),
      (gt = { [N]: Ii, [B]: [oo] }),
      (yo = { [N]: Hr, [B]: [{ [Ee]: "UseGlobalEndpoint" }, !0] }),
      (Wze = {
        [le]: "https://{Bucket}.s3-fips.dualstack.{Region}.{partitionResult#dnsSuffix}",
        [fe]: {
          [Yo]: [{ [Eo]: !0, [$r]: "sigv4", [So]: ju, [dn]: "{Region}" }],
        },
        [ue]: {},
      }),
      (Kr = {
        [Yo]: [{ [Eo]: !0, [$r]: "sigv4", [So]: ju, [dn]: "{Region}" }],
      }),
      (xo = { [N]: Hr, [B]: [{ [Ee]: "UseGlobalEndpoint" }, !1] }),
      (lt = { [N]: Hr, [B]: [{ [Ee]: "UseDualStack" }, !1] }),
      (Kze = {
        [le]: "https://{Bucket}.s3-fips.{Region}.{partitionResult#dnsSuffix}",
        [fe]: Kr,
        [ue]: {},
      }),
      (nt = { [N]: Hr, [B]: [{ [Ee]: "UseFIPS" }, !1] }),
      (Yze = {
        [le]: "https://{Bucket}.s3-accelerate.dualstack.{partitionResult#dnsSuffix}",
        [fe]: Kr,
        [ue]: {},
      }),
      (Qze = {
        [le]: "https://{Bucket}.s3.dualstack.{Region}.{partitionResult#dnsSuffix}",
        [fe]: Kr,
        [ue]: {},
      }),
      (J3 = { [N]: Hr, [B]: [{ [N]: Pr, [B]: [K2e, "isIp"] }, !1] }),
      (Z3 = { [le]: $2e, [fe]: Kr, [ue]: {} }),
      (xz = { [le]: ZR, [fe]: Kr, [ue]: {} }),
      (Xze = { [Q]: xz, [x]: Q }),
      (ez = { [le]: H2e, [fe]: Kr, [ue]: {} }),
      (Jze = {
        [le]: "https://{Bucket}.s3.{Region}.{partitionResult#dnsSuffix}",
        [fe]: Kr,
        [ue]: {},
      }),
      (YR = {
        [me]: "Invalid region: region was not a valid DNS name.",
        [x]: me,
      }),
      (_n = { [Ee]: q2e }),
      (X2e = { [Ee]: j2e }),
      (tz = { [N]: Pr, [B]: [_n, "service"] }),
      (Tz = { [Ee]: wz }),
      (Zze = {
        [w]: [er],
        [me]: "S3 Object Lambda does not support Dual-stack",
        [x]: me,
      }),
      (e2e = {
        [w]: [gs],
        [me]: "S3 Object Lambda does not support S3 Accelerate",
        [x]: me,
      }),
      (t2e = {
        [w]: [
          { [N]: Bn, [B]: [{ [Ee]: "DisableAccessPoints" }] },
          { [N]: Hr, [B]: [{ [Ee]: "DisableAccessPoints" }, !0] },
        ],
        [me]: "Access points are not supported for this operation",
        [x]: me,
      }),
      (rz = {
        [w]: [
          { [N]: Bn, [B]: [{ [Ee]: "UseArnRegion" }] },
          { [N]: Hr, [B]: [{ [Ee]: "UseArnRegion" }, !1] },
          {
            [N]: Ii,
            [B]: [
              { [N]: St, [B]: [{ [N]: Pr, [B]: [_n, "region"] }, "{Region}"] },
            ],
          },
        ],
        [me]: "Invalid configuration: region from ARN `{bucketArn#region}` does not match client region `{Region}` and UseArnRegion is `false`",
        [x]: me,
      }),
      (J2e = { [N]: Pr, [B]: [{ [Ee]: "bucketPartition" }, $r] }),
      (Z2e = { [N]: Pr, [B]: [_n, "accountId"] }),
      (oz = {
        [Yo]: [
          { [Eo]: !0, [$r]: "sigv4", [So]: _z, [dn]: "{bucketArn#region}" },
        ],
      }),
      (r2e = {
        [me]: "Invalid ARN: The access point name may only contain a-z, A-Z, 0-9 and `-`. Found: `{accessPointName}`",
        [x]: me,
      }),
      (nz = {
        [me]: "Invalid ARN: The account id may only contain a-z, A-Z, 0-9 and `-`. Found: `{bucketArn#accountId}`",
        [x]: me,
      }),
      (sz = {
        [me]: "Invalid region in ARN: `{bucketArn#region}` (invalid DNS name)",
        [x]: me,
      }),
      (iz = {
        [me]: "Client was configured for partition `{partitionResult#name}` but ARN (`{Bucket}`) has `{bucketPartition#name}`",
        [x]: me,
      }),
      (o2e = {
        [me]: "Invalid ARN: The ARN may only contain a single resource component after `accesspoint`.",
        [x]: me,
      }),
      (n2e = {
        [me]: "Invalid ARN: Expected a resource of the format `accesspoint:<accesspoint name>` but no name was provided",
        [x]: me,
      }),
      (qy = {
        [Yo]: [
          { [Eo]: !0, [$r]: "sigv4", [So]: ju, [dn]: "{bucketArn#region}" },
        ],
      }),
      (s2e = {
        [Yo]: [
          { [Eo]: !0, [$r]: bz, [So]: Gy, [Sz]: ["*"] },
          { [Eo]: !0, [$r]: "sigv4", [So]: Gy, [dn]: "{bucketArn#region}" },
        ],
      }),
      (i2e = { [N]: z2e, [B]: [Et] }),
      (a2e = {
        [le]: "https://s3-fips.dualstack.{Region}.{partitionResult#dnsSuffix}/{uri_encoded_bucket}",
        [fe]: Kr,
        [ue]: {},
      }),
      (c2e = {
        [le]: "https://s3-fips.{Region}.{partitionResult#dnsSuffix}/{uri_encoded_bucket}",
        [fe]: Kr,
        [ue]: {},
      }),
      (d2e = {
        [le]: "https://s3.dualstack.{Region}.{partitionResult#dnsSuffix}/{uri_encoded_bucket}",
        [fe]: Kr,
        [ue]: {},
      }),
      (az = { [le]: V2e, [fe]: Kr, [ue]: {} }),
      (m2e = {
        [le]: "https://s3.{Region}.{partitionResult#dnsSuffix}/{uri_encoded_bucket}",
        [fe]: Kr,
        [ue]: {},
      }),
      (l2e = { [Ee]: "UseObjectLambdaEndpoint" }),
      (cz = {
        [Yo]: [{ [Eo]: !0, [$r]: "sigv4", [So]: _z, [dn]: "{Region}" }],
      }),
      (f2e = {
        [le]: "https://s3-fips.dualstack.{Region}.{partitionResult#dnsSuffix}",
        [fe]: Kr,
        [ue]: {},
      }),
      (u2e = {
        [le]: "https://s3-fips.{Region}.{partitionResult#dnsSuffix}",
        [fe]: Kr,
        [ue]: {},
      }),
      (p2e = {
        [le]: "https://s3.dualstack.{Region}.{partitionResult#dnsSuffix}",
        [fe]: Kr,
        [ue]: {},
      }),
      (dz = { [le]: QR, [fe]: Kr, [ue]: {} }),
      (h2e = {
        [le]: "https://s3.{Region}.{partitionResult#dnsSuffix}",
        [fe]: Kr,
        [ue]: {},
      }),
      (mz = [{ [Ee]: "Region" }]),
      (qgt = [{ [Ee]: "Endpoint" }]),
      (jgt = [Et]),
      (g2e = [er]),
      (lz = [gs]),
      (zu = [Ur, cn]),
      (y2e = [
        { [N]: Bn, [B]: [{ [Ee]: "DisableS3ExpressSessionAuth" }] },
        { [N]: Hr, [B]: [{ [Ee]: "DisableS3ExpressSessionAuth" }, !0] },
      ]),
      (Ggt = [Y2e]),
      (x2e = [Q2e]),
      (hs = [W2e]),
      (qu = [fr]),
      (E2e = [
        { [N]: tr, [B]: [Et, 6, 14, !0], [Qe]: "s3expressAvailabilityZoneId" },
        {
          [N]: tr,
          [B]: [Et, 14, 16, !0],
          [Qe]: "s3expressAvailabilityZoneDelim",
        },
        { [N]: St, [B]: [{ [Ee]: "s3expressAvailabilityZoneDelim" }, "--"] },
      ]),
      (Ai = [
        {
          [w]: [fr],
          [Q]: {
            [le]: "https://{Bucket}.s3express-fips-{s3expressAvailabilityZoneId}.{Region}.{partitionResult#dnsSuffix}",
            [fe]: Vd,
            [ue]: {},
          },
          [x]: Q,
        },
        {
          [Q]: {
            [le]: "https://{Bucket}.s3express-{s3expressAvailabilityZoneId}.{Region}.{partitionResult#dnsSuffix}",
            [fe]: Vd,
            [ue]: {},
          },
          [x]: Q,
        },
      ]),
      (S2e = [
        { [N]: tr, [B]: [Et, 6, 15, !0], [Qe]: "s3expressAvailabilityZoneId" },
        {
          [N]: tr,
          [B]: [Et, 15, 17, !0],
          [Qe]: "s3expressAvailabilityZoneDelim",
        },
        { [N]: St, [B]: [{ [Ee]: "s3expressAvailabilityZoneDelim" }, "--"] },
      ]),
      (C2e = [
        { [N]: tr, [B]: [Et, 6, 19, !0], [Qe]: "s3expressAvailabilityZoneId" },
        {
          [N]: tr,
          [B]: [Et, 19, 21, !0],
          [Qe]: "s3expressAvailabilityZoneDelim",
        },
        { [N]: St, [B]: [{ [Ee]: "s3expressAvailabilityZoneDelim" }, "--"] },
      ]),
      (b2e = [
        { [N]: tr, [B]: [Et, 6, 20, !0], [Qe]: "s3expressAvailabilityZoneId" },
        {
          [N]: tr,
          [B]: [Et, 20, 22, !0],
          [Qe]: "s3expressAvailabilityZoneDelim",
        },
        { [N]: St, [B]: [{ [Ee]: "s3expressAvailabilityZoneDelim" }, "--"] },
      ]),
      (_2e = [
        { [N]: tr, [B]: [Et, 6, 26, !0], [Qe]: "s3expressAvailabilityZoneId" },
        {
          [N]: tr,
          [B]: [Et, 26, 28, !0],
          [Qe]: "s3expressAvailabilityZoneDelim",
        },
        { [N]: St, [B]: [{ [Ee]: "s3expressAvailabilityZoneDelim" }, "--"] },
      ]),
      (Ri = [
        {
          [w]: [fr],
          [Q]: {
            [le]: "https://{Bucket}.s3express-fips-{s3expressAvailabilityZoneId}.{Region}.{partitionResult#dnsSuffix}",
            [fe]: {
              [Wd]: "S3Express",
              [Yo]: [
                {
                  [Eo]: !0,
                  [$r]: "sigv4-s3express",
                  [So]: "s3express",
                  [dn]: "{Region}",
                },
              ],
            },
            [ue]: {},
          },
          [x]: Q,
        },
        {
          [Q]: {
            [le]: "https://{Bucket}.s3express-{s3expressAvailabilityZoneId}.{Region}.{partitionResult#dnsSuffix}",
            [fe]: {
              [Wd]: "S3Express",
              [Yo]: [
                {
                  [Eo]: !0,
                  [$r]: "sigv4-s3express",
                  [So]: "s3express",
                  [dn]: "{Region}",
                },
              ],
            },
            [ue]: {},
          },
          [x]: Q,
        },
      ]),
      (w2e = [Et, 0, 7, !0]),
      (T2e = [
        { [N]: tr, [B]: [Et, 7, 15, !0], [Qe]: "s3expressAvailabilityZoneId" },
        {
          [N]: tr,
          [B]: [Et, 15, 17, !0],
          [Qe]: "s3expressAvailabilityZoneDelim",
        },
        { [N]: St, [B]: [{ [Ee]: "s3expressAvailabilityZoneDelim" }, "--"] },
      ]),
      (A2e = [
        { [N]: tr, [B]: [Et, 7, 16, !0], [Qe]: "s3expressAvailabilityZoneId" },
        {
          [N]: tr,
          [B]: [Et, 16, 18, !0],
          [Qe]: "s3expressAvailabilityZoneDelim",
        },
        { [N]: St, [B]: [{ [Ee]: "s3expressAvailabilityZoneDelim" }, "--"] },
      ]),
      (R2e = [
        { [N]: tr, [B]: [Et, 7, 20, !0], [Qe]: "s3expressAvailabilityZoneId" },
        {
          [N]: tr,
          [B]: [Et, 20, 22, !0],
          [Qe]: "s3expressAvailabilityZoneDelim",
        },
        { [N]: St, [B]: [{ [Ee]: "s3expressAvailabilityZoneDelim" }, "--"] },
      ]),
      (I2e = [
        { [N]: tr, [B]: [Et, 7, 21, !0], [Qe]: "s3expressAvailabilityZoneId" },
        {
          [N]: tr,
          [B]: [Et, 21, 23, !0],
          [Qe]: "s3expressAvailabilityZoneDelim",
        },
        { [N]: St, [B]: [{ [Ee]: "s3expressAvailabilityZoneDelim" }, "--"] },
      ]),
      (P2e = [
        { [N]: tr, [B]: [Et, 7, 27, !0], [Qe]: "s3expressAvailabilityZoneId" },
        {
          [N]: tr,
          [B]: [Et, 27, 29, !0],
          [Qe]: "s3expressAvailabilityZoneDelim",
        },
        { [N]: St, [B]: [{ [Ee]: "s3expressAvailabilityZoneDelim" }, "--"] },
      ]),
      (Vgt = [jy]),
      (v2e = [{ [N]: Kd, [B]: [{ [Ee]: yz }, !1] }]),
      (O2e = [{ [N]: St, [B]: [{ [Ee]: U2e }, "beta"] }]),
      (Wgt = ["*"]),
      (k2e = [{ [N]: Kd, [B]: [{ [Ee]: "Region" }, !1] }]),
      (Tc = [{ [N]: St, [B]: [{ [Ee]: "Region" }, "us-east-1"] }]),
      (fz = [{ [N]: St, [B]: [X2e, G2e] }]),
      (D2e = [
        { [N]: Pr, [B]: [_n, "resourceId[1]"], [Qe]: wz },
        { [N]: Ii, [B]: [{ [N]: St, [B]: [Tz, eI] }] },
      ]),
      (Kgt = [_n, "resourceId[1]"]),
      (uz = [
        {
          [N]: Ii,
          [B]: [{ [N]: St, [B]: [{ [N]: Pr, [B]: [_n, "region"] }, eI] }],
        },
      ]),
      (N2e = [
        {
          [N]: Ii,
          [B]: [{ [N]: Bn, [B]: [{ [N]: Pr, [B]: [_n, "resourceId[2]"] }] }],
        },
      ]),
      (Ygt = [_n, "resourceId[2]"]),
      (pz = [
        {
          [N]: XR,
          [B]: [{ [N]: Pr, [B]: [_n, "region"] }],
          [Qe]: "bucketPartition",
        },
      ]),
      (B2e = [
        {
          [N]: St,
          [B]: [J2e, { [N]: Pr, [B]: [{ [Ee]: "partitionResult" }, $r] }],
        },
      ]),
      (hz = [{ [N]: Kd, [B]: [{ [N]: Pr, [B]: [_n, "region"] }, !0] }]),
      (gz = [{ [N]: Kd, [B]: [Z2e, !1] }]),
      (M2e = [{ [N]: Kd, [B]: [Tz, !1] }]),
      (L2e = [{ [N]: Kd, [B]: [{ [Ee]: "Region" }, !0] }]),
      (Qgt = {
        version: "1.0",
        parameters: {
          Bucket: $u,
          Region: $u,
          UseFIPS: Hu,
          UseDualStack: Hu,
          Endpoint: $u,
          ForcePathStyle: Hu,
          Accelerate: Hu,
          UseGlobalEndpoint: Hu,
          UseObjectLambdaEndpoint: zy,
          Key: $u,
          Prefix: $u,
          CopySource: $u,
          DisableAccessPoints: zy,
          DisableMultiRegionAccessPoints: Hu,
          UseArnRegion: zy,
          UseS3ExpressControlEndpoint: zy,
          DisableS3ExpressSessionAuth: zy,
        },
        [H]: [
          {
            [w]: [{ [N]: Bn, [B]: mz }],
            [H]: [
              {
                [w]: [gs, fr],
                error: "Accelerate cannot be used with FIPS",
                [x]: me,
              },
              {
                [w]: [er, Ur],
                error:
                  "Cannot set dual-stack in combination with a custom endpoint.",
                [x]: me,
              },
              {
                [w]: [Ur, fr],
                error: "A custom endpoint cannot be combined with FIPS",
                [x]: me,
              },
              {
                [w]: [Ur, gs],
                error:
                  "A custom endpoint cannot be combined with S3 Accelerate",
                [x]: me,
              },
              {
                [w]: [fr, W2e, Lze],
                error: "Partition does not support FIPS",
                [x]: me,
              },
              {
                [w]: [
                  jy,
                  { [N]: tr, [B]: [Et, 0, 6, !0], [Qe]: Rze },
                  { [N]: St, [B]: [{ [Ee]: Rze }, "--x-s3"] },
                ],
                [H]: [
                  Fze,
                  Uze,
                  $ze,
                  {
                    [w]: [zze, qze],
                    [H]: [
                      {
                        [w]: hs,
                        [H]: [
                          {
                            [w]: [Y2e, We],
                            [H]: [
                              {
                                [w]: qu,
                                endpoint: {
                                  [le]: "https://s3express-control-fips.{Region}.{partitionResult#dnsSuffix}/{uri_encoded_bucket}",
                                  [fe]: Vd,
                                  [ue]: Ve,
                                },
                                [x]: Q,
                              },
                              {
                                endpoint: {
                                  [le]: "https://s3express-control.{Region}.{partitionResult#dnsSuffix}/{uri_encoded_bucket}",
                                  [fe]: Vd,
                                  [ue]: Ve,
                                },
                                [x]: Q,
                              },
                            ],
                            [x]: j,
                          },
                        ],
                        [x]: j,
                      },
                    ],
                    [x]: j,
                  },
                  {
                    [w]: x2e,
                    [H]: [
                      {
                        [w]: hs,
                        [H]: [
                          {
                            [w]: y2e,
                            [H]: [
                              { [w]: E2e, [H]: Ai, [x]: j },
                              { [w]: S2e, [H]: Ai, [x]: j },
                              { [w]: C2e, [H]: Ai, [x]: j },
                              { [w]: b2e, [H]: Ai, [x]: j },
                              { [w]: _2e, [H]: Ai, [x]: j },
                              WR,
                            ],
                            [x]: j,
                          },
                          { [w]: E2e, [H]: Ri, [x]: j },
                          { [w]: S2e, [H]: Ri, [x]: j },
                          { [w]: C2e, [H]: Ri, [x]: j },
                          { [w]: b2e, [H]: Ri, [x]: j },
                          { [w]: _2e, [H]: Ri, [x]: j },
                          WR,
                        ],
                        [x]: j,
                      },
                    ],
                    [x]: j,
                  },
                  Hze,
                ],
                [x]: j,
              },
              {
                [w]: [
                  jy,
                  { [N]: tr, [B]: w2e, [Qe]: Ize },
                  { [N]: St, [B]: [{ [Ee]: Ize }, "--xa-s3"] },
                ],
                [H]: [
                  Fze,
                  Uze,
                  $ze,
                  {
                    [w]: x2e,
                    [H]: [
                      {
                        [w]: hs,
                        [H]: [
                          {
                            [w]: y2e,
                            [H]: [
                              { [w]: T2e, [H]: Ai, [x]: j },
                              { [w]: A2e, [H]: Ai, [x]: j },
                              { [w]: R2e, [H]: Ai, [x]: j },
                              { [w]: I2e, [H]: Ai, [x]: j },
                              { [w]: P2e, [H]: Ai, [x]: j },
                              WR,
                            ],
                            [x]: j,
                          },
                          { [w]: T2e, [H]: Ri, [x]: j },
                          { [w]: A2e, [H]: Ri, [x]: j },
                          { [w]: R2e, [H]: Ri, [x]: j },
                          { [w]: I2e, [H]: Ri, [x]: j },
                          { [w]: P2e, [H]: Ri, [x]: j },
                          WR,
                        ],
                        [x]: j,
                      },
                    ],
                    [x]: j,
                  },
                  Hze,
                ],
                [x]: j,
              },
              {
                [w]: [jze, zze, qze],
                [H]: [
                  {
                    [w]: hs,
                    [H]: [
                      {
                        [w]: zu,
                        endpoint: { [le]: QR, [fe]: Vd, [ue]: Ve },
                        [x]: Q,
                      },
                      {
                        [w]: qu,
                        endpoint: {
                          [le]: "https://s3express-control-fips.{Region}.{partitionResult#dnsSuffix}",
                          [fe]: Vd,
                          [ue]: Ve,
                        },
                        [x]: Q,
                      },
                      {
                        endpoint: {
                          [le]: "https://s3express-control.{Region}.{partitionResult#dnsSuffix}",
                          [fe]: Vd,
                          [ue]: Ve,
                        },
                        [x]: Q,
                      },
                    ],
                    [x]: j,
                  },
                ],
                [x]: j,
              },
              {
                [w]: [
                  jy,
                  { [N]: tr, [B]: [Et, 49, 50, !0], [Qe]: F2e },
                  { [N]: tr, [B]: [Et, 8, 12, !0], [Qe]: U2e },
                  { [N]: tr, [B]: w2e, [Qe]: Pze },
                  { [N]: tr, [B]: [Et, 32, 49, !0], [Qe]: yz },
                  { [N]: XR, [B]: mz, [Qe]: "regionPartition" },
                  { [N]: St, [B]: [{ [Ee]: Pze }, "--op-s3"] },
                ],
                [H]: [
                  {
                    [w]: v2e,
                    [H]: [
                      {
                        [w]: [{ [N]: St, [B]: [Gze, "e"] }],
                        [H]: [
                          {
                            [w]: O2e,
                            [H]: [
                              Vze,
                              {
                                [w]: zu,
                                endpoint: {
                                  [le]: "https://{Bucket}.ec2.{url#authority}",
                                  [fe]: KR,
                                  [ue]: Ve,
                                },
                                [x]: Q,
                              },
                            ],
                            [x]: j,
                          },
                          {
                            endpoint: {
                              [le]: "https://{Bucket}.ec2.s3-outposts.{Region}.{regionPartition#dnsSuffix}",
                              [fe]: KR,
                              [ue]: Ve,
                            },
                            [x]: Q,
                          },
                        ],
                        [x]: j,
                      },
                      {
                        [w]: [{ [N]: St, [B]: [Gze, "o"] }],
                        [H]: [
                          {
                            [w]: O2e,
                            [H]: [
                              Vze,
                              {
                                [w]: zu,
                                endpoint: {
                                  [le]: "https://{Bucket}.op-{outpostId}.{url#authority}",
                                  [fe]: KR,
                                  [ue]: Ve,
                                },
                                [x]: Q,
                              },
                            ],
                            [x]: j,
                          },
                          {
                            endpoint: {
                              [le]: "https://{Bucket}.op-{outpostId}.s3-outposts.{Region}.{regionPartition#dnsSuffix}",
                              [fe]: KR,
                              [ue]: Ve,
                            },
                            [x]: Q,
                          },
                        ],
                        [x]: j,
                      },
                      {
                        error:
                          'Unrecognized hardware type: "Expected hardware type o or e but got {hardwareType}"',
                        [x]: me,
                      },
                    ],
                    [x]: j,
                  },
                  {
                    error:
                      "Invalid ARN: The outpost Id must only contain a-z, A-Z, 0-9 and `-`.",
                    [x]: me,
                  },
                ],
                [x]: j,
              },
              {
                [w]: Vgt,
                [H]: [
                  {
                    [w]: [
                      Ur,
                      {
                        [N]: Ii,
                        [B]: [{ [N]: Bn, [B]: [{ [N]: Cz, [B]: qgt }] }],
                      },
                    ],
                    error: "Custom endpoint `{Endpoint}` was not a valid URI",
                    [x]: me,
                  },
                  {
                    [w]: [X3, Q2e],
                    [H]: [
                      {
                        [w]: hs,
                        [H]: [
                          {
                            [w]: k2e,
                            [H]: [
                              {
                                [w]: [gs, Lze],
                                error:
                                  "S3 Accelerate cannot be used in this region",
                                [x]: me,
                              },
                              {
                                [w]: [er, fr, Wr, We, oo],
                                endpoint: {
                                  [le]: "https://{Bucket}.s3-fips.dualstack.us-east-1.{partitionResult#dnsSuffix}",
                                  [fe]: go,
                                  [ue]: Ve,
                                },
                                [x]: Q,
                              },
                              {
                                [w]: [er, fr, Wr, We, gt, yo],
                                [H]: [{ endpoint: Wze, [x]: Q }],
                                [x]: j,
                              },
                              {
                                [w]: [er, fr, Wr, We, gt, xo],
                                endpoint: Wze,
                                [x]: Q,
                              },
                              {
                                [w]: [lt, fr, Wr, We, oo],
                                endpoint: {
                                  [le]: "https://{Bucket}.s3-fips.us-east-1.{partitionResult#dnsSuffix}",
                                  [fe]: go,
                                  [ue]: Ve,
                                },
                                [x]: Q,
                              },
                              {
                                [w]: [lt, fr, Wr, We, gt, yo],
                                [H]: [{ endpoint: Kze, [x]: Q }],
                                [x]: j,
                              },
                              {
                                [w]: [lt, fr, Wr, We, gt, xo],
                                endpoint: Kze,
                                [x]: Q,
                              },
                              {
                                [w]: [er, nt, gs, We, oo],
                                endpoint: {
                                  [le]: "https://{Bucket}.s3-accelerate.dualstack.us-east-1.{partitionResult#dnsSuffix}",
                                  [fe]: go,
                                  [ue]: Ve,
                                },
                                [x]: Q,
                              },
                              {
                                [w]: [er, nt, gs, We, gt, yo],
                                [H]: [{ endpoint: Yze, [x]: Q }],
                                [x]: j,
                              },
                              {
                                [w]: [er, nt, gs, We, gt, xo],
                                endpoint: Yze,
                                [x]: Q,
                              },
                              {
                                [w]: [er, nt, Wr, We, oo],
                                endpoint: {
                                  [le]: "https://{Bucket}.s3.dualstack.us-east-1.{partitionResult#dnsSuffix}",
                                  [fe]: go,
                                  [ue]: Ve,
                                },
                                [x]: Q,
                              },
                              {
                                [w]: [er, nt, Wr, We, gt, yo],
                                [H]: [{ endpoint: Qze, [x]: Q }],
                                [x]: j,
                              },
                              {
                                [w]: [er, nt, Wr, We, gt, xo],
                                endpoint: Qze,
                                [x]: Q,
                              },
                              {
                                [w]: [lt, nt, Wr, Ur, cn, Q3, oo],
                                endpoint: { [le]: $2e, [fe]: go, [ue]: Ve },
                                [x]: Q,
                              },
                              {
                                [w]: [lt, nt, Wr, Ur, cn, J3, oo],
                                endpoint: { [le]: ZR, [fe]: go, [ue]: Ve },
                                [x]: Q,
                              },
                              {
                                [w]: [lt, nt, Wr, Ur, cn, Q3, gt, yo],
                                [H]: [
                                  { [w]: Tc, endpoint: Z3, [x]: Q },
                                  { endpoint: Z3, [x]: Q },
                                ],
                                [x]: j,
                              },
                              {
                                [w]: [lt, nt, Wr, Ur, cn, J3, gt, yo],
                                [H]: [{ [w]: Tc, endpoint: xz, [x]: Q }, Xze],
                                [x]: j,
                              },
                              {
                                [w]: [lt, nt, Wr, Ur, cn, Q3, gt, xo],
                                endpoint: Z3,
                                [x]: Q,
                              },
                              {
                                [w]: [lt, nt, Wr, Ur, cn, J3, gt, xo],
                                endpoint: xz,
                                [x]: Q,
                              },
                              {
                                [w]: [lt, nt, gs, We, oo],
                                endpoint: { [le]: H2e, [fe]: go, [ue]: Ve },
                                [x]: Q,
                              },
                              {
                                [w]: [lt, nt, gs, We, gt, yo],
                                [H]: [
                                  { [w]: Tc, endpoint: ez, [x]: Q },
                                  { endpoint: ez, [x]: Q },
                                ],
                                [x]: j,
                              },
                              {
                                [w]: [lt, nt, gs, We, gt, xo],
                                endpoint: ez,
                                [x]: Q,
                              },
                              {
                                [w]: [lt, nt, Wr, We, oo],
                                endpoint: { [le]: vze, [fe]: go, [ue]: Ve },
                                [x]: Q,
                              },
                              {
                                [w]: [lt, nt, Wr, We, gt, yo],
                                [H]: [
                                  {
                                    [w]: Tc,
                                    endpoint: { [le]: vze, [fe]: Kr, [ue]: Ve },
                                    [x]: Q,
                                  },
                                  { endpoint: Jze, [x]: Q },
                                ],
                                [x]: j,
                              },
                              {
                                [w]: [lt, nt, Wr, We, gt, xo],
                                endpoint: Jze,
                                [x]: Q,
                              },
                            ],
                            [x]: j,
                          },
                          YR,
                        ],
                        [x]: j,
                      },
                    ],
                    [x]: j,
                  },
                  {
                    [w]: [
                      Ur,
                      cn,
                      {
                        [N]: St,
                        [B]: [{ [N]: Pr, [B]: [K2e, "scheme"] }, "http"],
                      },
                      { [N]: JR, [B]: [Et, !0] },
                      X3,
                      nt,
                      lt,
                      Wr,
                    ],
                    [H]: [
                      {
                        [w]: hs,
                        [H]: [{ [w]: k2e, [H]: [Xze], [x]: j }, YR],
                        [x]: j,
                      },
                    ],
                    [x]: j,
                  },
                  {
                    [w]: [X3, { [N]: z2e, [B]: jgt, [Qe]: q2e }],
                    [H]: [
                      {
                        [w]: [
                          { [N]: Pr, [B]: [_n, "resourceId[0]"], [Qe]: j2e },
                          { [N]: Ii, [B]: [{ [N]: St, [B]: [X2e, eI] }] },
                        ],
                        [H]: [
                          {
                            [w]: [{ [N]: St, [B]: [tz, _z] }],
                            [H]: [
                              {
                                [w]: fz,
                                [H]: [
                                  {
                                    [w]: D2e,
                                    [H]: [
                                      Zze,
                                      e2e,
                                      {
                                        [w]: uz,
                                        [H]: [
                                          t2e,
                                          {
                                            [w]: N2e,
                                            [H]: [
                                              rz,
                                              {
                                                [w]: pz,
                                                [H]: [
                                                  {
                                                    [w]: hs,
                                                    [H]: [
                                                      {
                                                        [w]: B2e,
                                                        [H]: [
                                                          {
                                                            [w]: hz,
                                                            [H]: [
                                                              {
                                                                [w]: [
                                                                  {
                                                                    [N]: St,
                                                                    [B]: [
                                                                      Z2e,
                                                                      eI,
                                                                    ],
                                                                  },
                                                                ],
                                                                error:
                                                                  "Invalid ARN: Missing account id",
                                                                [x]: me,
                                                              },
                                                              {
                                                                [w]: gz,
                                                                [H]: [
                                                                  {
                                                                    [w]: M2e,
                                                                    [H]: [
                                                                      {
                                                                        [w]: zu,
                                                                        endpoint:
                                                                          {
                                                                            [le]: Oze,
                                                                            [fe]: oz,
                                                                            [ue]: Ve,
                                                                          },
                                                                        [x]: Q,
                                                                      },
                                                                      {
                                                                        [w]: qu,
                                                                        endpoint:
                                                                          {
                                                                            [le]: "https://{accessPointName}-{bucketArn#accountId}.s3-object-lambda-fips.{bucketArn#region}.{bucketPartition#dnsSuffix}",
                                                                            [fe]: oz,
                                                                            [ue]: Ve,
                                                                          },
                                                                        [x]: Q,
                                                                      },
                                                                      {
                                                                        endpoint:
                                                                          {
                                                                            [le]: "https://{accessPointName}-{bucketArn#accountId}.s3-object-lambda.{bucketArn#region}.{bucketPartition#dnsSuffix}",
                                                                            [fe]: oz,
                                                                            [ue]: Ve,
                                                                          },
                                                                        [x]: Q,
                                                                      },
                                                                    ],
                                                                    [x]: j,
                                                                  },
                                                                  r2e,
                                                                ],
                                                                [x]: j,
                                                              },
                                                              nz,
                                                            ],
                                                            [x]: j,
                                                          },
                                                          sz,
                                                        ],
                                                        [x]: j,
                                                      },
                                                      iz,
                                                    ],
                                                    [x]: j,
                                                  },
                                                ],
                                                [x]: j,
                                              },
                                            ],
                                            [x]: j,
                                          },
                                          o2e,
                                        ],
                                        [x]: j,
                                      },
                                      {
                                        error:
                                          "Invalid ARN: bucket ARN is missing a region",
                                        [x]: me,
                                      },
                                    ],
                                    [x]: j,
                                  },
                                  n2e,
                                ],
                                [x]: j,
                              },
                              {
                                error:
                                  "Invalid ARN: Object Lambda ARNs only support `accesspoint` arn types, but found: `{arnType}`",
                                [x]: me,
                              },
                            ],
                            [x]: j,
                          },
                          {
                            [w]: fz,
                            [H]: [
                              {
                                [w]: D2e,
                                [H]: [
                                  {
                                    [w]: uz,
                                    [H]: [
                                      {
                                        [w]: fz,
                                        [H]: [
                                          {
                                            [w]: uz,
                                            [H]: [
                                              t2e,
                                              {
                                                [w]: N2e,
                                                [H]: [
                                                  rz,
                                                  {
                                                    [w]: pz,
                                                    [H]: [
                                                      {
                                                        [w]: hs,
                                                        [H]: [
                                                          {
                                                            [w]: [
                                                              {
                                                                [N]: St,
                                                                [B]: [
                                                                  J2e,
                                                                  "{partitionResult#name}",
                                                                ],
                                                              },
                                                            ],
                                                            [H]: [
                                                              {
                                                                [w]: hz,
                                                                [H]: [
                                                                  {
                                                                    [w]: [
                                                                      {
                                                                        [N]: St,
                                                                        [B]: [
                                                                          tz,
                                                                          ju,
                                                                        ],
                                                                      },
                                                                    ],
                                                                    [H]: [
                                                                      {
                                                                        [w]: gz,
                                                                        [H]: [
                                                                          {
                                                                            [w]: M2e,
                                                                            [H]: [
                                                                              {
                                                                                [w]: lz,
                                                                                error:
                                                                                  "Access Points do not support S3 Accelerate",
                                                                                [x]: me,
                                                                              },
                                                                              {
                                                                                [w]: [
                                                                                  fr,
                                                                                  er,
                                                                                ],
                                                                                endpoint:
                                                                                  {
                                                                                    [le]: "https://{accessPointName}-{bucketArn#accountId}.s3-accesspoint-fips.dualstack.{bucketArn#region}.{bucketPartition#dnsSuffix}",
                                                                                    [fe]: qy,
                                                                                    [ue]: Ve,
                                                                                  },
                                                                                [x]: Q,
                                                                              },
                                                                              {
                                                                                [w]: [
                                                                                  fr,
                                                                                  lt,
                                                                                ],
                                                                                endpoint:
                                                                                  {
                                                                                    [le]: "https://{accessPointName}-{bucketArn#accountId}.s3-accesspoint-fips.{bucketArn#region}.{bucketPartition#dnsSuffix}",
                                                                                    [fe]: qy,
                                                                                    [ue]: Ve,
                                                                                  },
                                                                                [x]: Q,
                                                                              },
                                                                              {
                                                                                [w]: [
                                                                                  nt,
                                                                                  er,
                                                                                ],
                                                                                endpoint:
                                                                                  {
                                                                                    [le]: "https://{accessPointName}-{bucketArn#accountId}.s3-accesspoint.dualstack.{bucketArn#region}.{bucketPartition#dnsSuffix}",
                                                                                    [fe]: qy,
                                                                                    [ue]: Ve,
                                                                                  },
                                                                                [x]: Q,
                                                                              },
                                                                              {
                                                                                [w]: [
                                                                                  nt,
                                                                                  lt,
                                                                                  Ur,
                                                                                  cn,
                                                                                ],
                                                                                endpoint:
                                                                                  {
                                                                                    [le]: Oze,
                                                                                    [fe]: qy,
                                                                                    [ue]: Ve,
                                                                                  },
                                                                                [x]: Q,
                                                                              },
                                                                              {
                                                                                [w]: [
                                                                                  nt,
                                                                                  lt,
                                                                                ],
                                                                                endpoint:
                                                                                  {
                                                                                    [le]: "https://{accessPointName}-{bucketArn#accountId}.s3-accesspoint.{bucketArn#region}.{bucketPartition#dnsSuffix}",
                                                                                    [fe]: qy,
                                                                                    [ue]: Ve,
                                                                                  },
                                                                                [x]: Q,
                                                                              },
                                                                            ],
                                                                            [x]: j,
                                                                          },
                                                                          r2e,
                                                                        ],
                                                                        [x]: j,
                                                                      },
                                                                      nz,
                                                                    ],
                                                                    [x]: j,
                                                                  },
                                                                  {
                                                                    error:
                                                                      "Invalid ARN: The ARN was not for the S3 service, found: {bucketArn#service}",
                                                                    [x]: me,
                                                                  },
                                                                ],
                                                                [x]: j,
                                                              },
                                                              sz,
                                                            ],
                                                            [x]: j,
                                                          },
                                                          iz,
                                                        ],
                                                        [x]: j,
                                                      },
                                                    ],
                                                    [x]: j,
                                                  },
                                                ],
                                                [x]: j,
                                              },
                                              o2e,
                                            ],
                                            [x]: j,
                                          },
                                        ],
                                        [x]: j,
                                      },
                                    ],
                                    [x]: j,
                                  },
                                  {
                                    [w]: [{ [N]: Kd, [B]: [Tz, !0] }],
                                    [H]: [
                                      {
                                        [w]: g2e,
                                        error:
                                          "S3 MRAP does not support dual-stack",
                                        [x]: me,
                                      },
                                      {
                                        [w]: qu,
                                        error: "S3 MRAP does not support FIPS",
                                        [x]: me,
                                      },
                                      {
                                        [w]: lz,
                                        error:
                                          "S3 MRAP does not support S3 Accelerate",
                                        [x]: me,
                                      },
                                      {
                                        [w]: [
                                          {
                                            [N]: Hr,
                                            [B]: [
                                              {
                                                [Ee]: "DisableMultiRegionAccessPoints",
                                              },
                                              !0,
                                            ],
                                          },
                                        ],
                                        error:
                                          "Invalid configuration: Multi-Region Access Point ARNs are disabled.",
                                        [x]: me,
                                      },
                                      {
                                        [w]: [{ [N]: XR, [B]: mz, [Qe]: kze }],
                                        [H]: [
                                          {
                                            [w]: [
                                              {
                                                [N]: St,
                                                [B]: [
                                                  {
                                                    [N]: Pr,
                                                    [B]: [{ [Ee]: kze }, $r],
                                                  },
                                                  {
                                                    [N]: Pr,
                                                    [B]: [_n, "partition"],
                                                  },
                                                ],
                                              },
                                            ],
                                            [H]: [
                                              {
                                                endpoint: {
                                                  [le]: "https://{accessPointName}.accesspoint.s3-global.{mrapPartition#dnsSuffix}",
                                                  [fe]: {
                                                    [Yo]: [
                                                      {
                                                        [Eo]: !0,
                                                        name: bz,
                                                        [So]: ju,
                                                        [Sz]: Wgt,
                                                      },
                                                    ],
                                                  },
                                                  [ue]: Ve,
                                                },
                                                [x]: Q,
                                              },
                                            ],
                                            [x]: j,
                                          },
                                          {
                                            error:
                                              "Client was configured for partition `{mrapPartition#name}` but bucket referred to partition `{bucketArn#partition}`",
                                            [x]: me,
                                          },
                                        ],
                                        [x]: j,
                                      },
                                    ],
                                    [x]: j,
                                  },
                                  {
                                    error: "Invalid Access Point Name",
                                    [x]: me,
                                  },
                                ],
                                [x]: j,
                              },
                              n2e,
                            ],
                            [x]: j,
                          },
                          {
                            [w]: [{ [N]: St, [B]: [tz, Gy] }],
                            [H]: [
                              {
                                [w]: g2e,
                                error:
                                  "S3 Outposts does not support Dual-stack",
                                [x]: me,
                              },
                              {
                                [w]: qu,
                                error: "S3 Outposts does not support FIPS",
                                [x]: me,
                              },
                              {
                                [w]: lz,
                                error:
                                  "S3 Outposts does not support S3 Accelerate",
                                [x]: me,
                              },
                              {
                                [w]: [
                                  {
                                    [N]: Bn,
                                    [B]: [
                                      { [N]: Pr, [B]: [_n, "resourceId[4]"] },
                                    ],
                                  },
                                ],
                                error:
                                  "Invalid Arn: Outpost Access Point ARN contains sub resources",
                                [x]: me,
                              },
                              {
                                [w]: [{ [N]: Pr, [B]: Kgt, [Qe]: yz }],
                                [H]: [
                                  {
                                    [w]: v2e,
                                    [H]: [
                                      rz,
                                      {
                                        [w]: pz,
                                        [H]: [
                                          {
                                            [w]: hs,
                                            [H]: [
                                              {
                                                [w]: B2e,
                                                [H]: [
                                                  {
                                                    [w]: hz,
                                                    [H]: [
                                                      {
                                                        [w]: gz,
                                                        [H]: [
                                                          {
                                                            [w]: [
                                                              {
                                                                [N]: Pr,
                                                                [B]: Ygt,
                                                                [Qe]: Dze,
                                                              },
                                                            ],
                                                            [H]: [
                                                              {
                                                                [w]: [
                                                                  {
                                                                    [N]: Pr,
                                                                    [B]: [
                                                                      _n,
                                                                      "resourceId[3]",
                                                                    ],
                                                                    [Qe]: wz,
                                                                  },
                                                                ],
                                                                [H]: [
                                                                  {
                                                                    [w]: [
                                                                      {
                                                                        [N]: St,
                                                                        [B]: [
                                                                          {
                                                                            [Ee]: Dze,
                                                                          },
                                                                          G2e,
                                                                        ],
                                                                      },
                                                                    ],
                                                                    [H]: [
                                                                      {
                                                                        [w]: zu,
                                                                        endpoint:
                                                                          {
                                                                            [le]: "https://{accessPointName}-{bucketArn#accountId}.{outpostId}.{url#authority}",
                                                                            [fe]: s2e,
                                                                            [ue]: Ve,
                                                                          },
                                                                        [x]: Q,
                                                                      },
                                                                      {
                                                                        endpoint:
                                                                          {
                                                                            [le]: "https://{accessPointName}-{bucketArn#accountId}.{outpostId}.s3-outposts.{bucketArn#region}.{bucketPartition#dnsSuffix}",
                                                                            [fe]: s2e,
                                                                            [ue]: Ve,
                                                                          },
                                                                        [x]: Q,
                                                                      },
                                                                    ],
                                                                    [x]: j,
                                                                  },
                                                                  {
                                                                    error:
                                                                      "Expected an outpost type `accesspoint`, found {outpostType}",
                                                                    [x]: me,
                                                                  },
                                                                ],
                                                                [x]: j,
                                                              },
                                                              {
                                                                error:
                                                                  "Invalid ARN: expected an access point name",
                                                                [x]: me,
                                                              },
                                                            ],
                                                            [x]: j,
                                                          },
                                                          {
                                                            error:
                                                              "Invalid ARN: Expected a 4-component resource",
                                                            [x]: me,
                                                          },
                                                        ],
                                                        [x]: j,
                                                      },
                                                      nz,
                                                    ],
                                                    [x]: j,
                                                  },
                                                  sz,
                                                ],
                                                [x]: j,
                                              },
                                              iz,
                                            ],
                                            [x]: j,
                                          },
                                        ],
                                        [x]: j,
                                      },
                                    ],
                                    [x]: j,
                                  },
                                  {
                                    error:
                                      "Invalid ARN: The outpost Id may only contain a-z, A-Z, 0-9 and `-`. Found: `{outpostId}`",
                                    [x]: me,
                                  },
                                ],
                                [x]: j,
                              },
                              {
                                error:
                                  "Invalid ARN: The Outpost Id was not set",
                                [x]: me,
                              },
                            ],
                            [x]: j,
                          },
                          {
                            error:
                              "Invalid ARN: Unrecognized format: {Bucket} (type: {arnType})",
                            [x]: me,
                          },
                        ],
                        [x]: j,
                      },
                      { error: "Invalid ARN: No ARN type specified", [x]: me },
                    ],
                    [x]: j,
                  },
                  {
                    [w]: [
                      { [N]: tr, [B]: [Et, 0, 4, !1], [Qe]: Nze },
                      { [N]: St, [B]: [{ [Ee]: Nze }, "arn:"] },
                      { [N]: Ii, [B]: [{ [N]: Bn, [B]: [i2e] }] },
                    ],
                    error: "Invalid ARN: `{Bucket}` was not a valid ARN",
                    [x]: me,
                  },
                  {
                    [w]: [{ [N]: Hr, [B]: [zgt, !0] }, i2e],
                    error:
                      "Path-style addressing cannot be used with ARN buckets",
                    [x]: me,
                  },
                  {
                    [w]: Ggt,
                    [H]: [
                      {
                        [w]: hs,
                        [H]: [
                          {
                            [w]: [Wr],
                            [H]: [
                              {
                                [w]: [er, We, fr, oo],
                                endpoint: {
                                  [le]: "https://s3-fips.dualstack.us-east-1.{partitionResult#dnsSuffix}/{uri_encoded_bucket}",
                                  [fe]: go,
                                  [ue]: Ve,
                                },
                                [x]: Q,
                              },
                              {
                                [w]: [er, We, fr, gt, yo],
                                [H]: [{ endpoint: a2e, [x]: Q }],
                                [x]: j,
                              },
                              {
                                [w]: [er, We, fr, gt, xo],
                                endpoint: a2e,
                                [x]: Q,
                              },
                              {
                                [w]: [lt, We, fr, oo],
                                endpoint: {
                                  [le]: "https://s3-fips.us-east-1.{partitionResult#dnsSuffix}/{uri_encoded_bucket}",
                                  [fe]: go,
                                  [ue]: Ve,
                                },
                                [x]: Q,
                              },
                              {
                                [w]: [lt, We, fr, gt, yo],
                                [H]: [{ endpoint: c2e, [x]: Q }],
                                [x]: j,
                              },
                              {
                                [w]: [lt, We, fr, gt, xo],
                                endpoint: c2e,
                                [x]: Q,
                              },
                              {
                                [w]: [er, We, nt, oo],
                                endpoint: {
                                  [le]: "https://s3.dualstack.us-east-1.{partitionResult#dnsSuffix}/{uri_encoded_bucket}",
                                  [fe]: go,
                                  [ue]: Ve,
                                },
                                [x]: Q,
                              },
                              {
                                [w]: [er, We, nt, gt, yo],
                                [H]: [{ endpoint: d2e, [x]: Q }],
                                [x]: j,
                              },
                              {
                                [w]: [er, We, nt, gt, xo],
                                endpoint: d2e,
                                [x]: Q,
                              },
                              {
                                [w]: [lt, Ur, cn, nt, oo],
                                endpoint: { [le]: V2e, [fe]: go, [ue]: Ve },
                                [x]: Q,
                              },
                              {
                                [w]: [lt, Ur, cn, nt, gt, yo],
                                [H]: [
                                  { [w]: Tc, endpoint: az, [x]: Q },
                                  { endpoint: az, [x]: Q },
                                ],
                                [x]: j,
                              },
                              {
                                [w]: [lt, Ur, cn, nt, gt, xo],
                                endpoint: az,
                                [x]: Q,
                              },
                              {
                                [w]: [lt, We, nt, oo],
                                endpoint: { [le]: Bze, [fe]: go, [ue]: Ve },
                                [x]: Q,
                              },
                              {
                                [w]: [lt, We, nt, gt, yo],
                                [H]: [
                                  {
                                    [w]: Tc,
                                    endpoint: { [le]: Bze, [fe]: Kr, [ue]: Ve },
                                    [x]: Q,
                                  },
                                  { endpoint: m2e, [x]: Q },
                                ],
                                [x]: j,
                              },
                              {
                                [w]: [lt, We, nt, gt, xo],
                                endpoint: m2e,
                                [x]: Q,
                              },
                            ],
                            [x]: j,
                          },
                          {
                            error:
                              "Path-style addressing cannot be used with S3 Accelerate",
                            [x]: me,
                          },
                        ],
                        [x]: j,
                      },
                    ],
                    [x]: j,
                  },
                ],
                [x]: j,
              },
              {
                [w]: [
                  { [N]: Bn, [B]: [l2e] },
                  { [N]: Hr, [B]: [l2e, !0] },
                ],
                [H]: [
                  {
                    [w]: hs,
                    [H]: [
                      {
                        [w]: L2e,
                        [H]: [
                          Zze,
                          e2e,
                          {
                            [w]: zu,
                            endpoint: { [le]: QR, [fe]: cz, [ue]: Ve },
                            [x]: Q,
                          },
                          {
                            [w]: qu,
                            endpoint: {
                              [le]: "https://s3-object-lambda-fips.{Region}.{partitionResult#dnsSuffix}",
                              [fe]: cz,
                              [ue]: Ve,
                            },
                            [x]: Q,
                          },
                          {
                            endpoint: {
                              [le]: "https://s3-object-lambda.{Region}.{partitionResult#dnsSuffix}",
                              [fe]: cz,
                              [ue]: Ve,
                            },
                            [x]: Q,
                          },
                        ],
                        [x]: j,
                      },
                      YR,
                    ],
                    [x]: j,
                  },
                ],
                [x]: j,
              },
              {
                [w]: [jze],
                [H]: [
                  {
                    [w]: hs,
                    [H]: [
                      {
                        [w]: L2e,
                        [H]: [
                          {
                            [w]: [fr, er, We, oo],
                            endpoint: {
                              [le]: "https://s3-fips.dualstack.us-east-1.{partitionResult#dnsSuffix}",
                              [fe]: go,
                              [ue]: Ve,
                            },
                            [x]: Q,
                          },
                          {
                            [w]: [fr, er, We, gt, yo],
                            [H]: [{ endpoint: f2e, [x]: Q }],
                            [x]: j,
                          },
                          { [w]: [fr, er, We, gt, xo], endpoint: f2e, [x]: Q },
                          {
                            [w]: [fr, lt, We, oo],
                            endpoint: {
                              [le]: "https://s3-fips.us-east-1.{partitionResult#dnsSuffix}",
                              [fe]: go,
                              [ue]: Ve,
                            },
                            [x]: Q,
                          },
                          {
                            [w]: [fr, lt, We, gt, yo],
                            [H]: [{ endpoint: u2e, [x]: Q }],
                            [x]: j,
                          },
                          { [w]: [fr, lt, We, gt, xo], endpoint: u2e, [x]: Q },
                          {
                            [w]: [nt, er, We, oo],
                            endpoint: {
                              [le]: "https://s3.dualstack.us-east-1.{partitionResult#dnsSuffix}",
                              [fe]: go,
                              [ue]: Ve,
                            },
                            [x]: Q,
                          },
                          {
                            [w]: [nt, er, We, gt, yo],
                            [H]: [{ endpoint: p2e, [x]: Q }],
                            [x]: j,
                          },
                          { [w]: [nt, er, We, gt, xo], endpoint: p2e, [x]: Q },
                          {
                            [w]: [nt, lt, Ur, cn, oo],
                            endpoint: { [le]: QR, [fe]: go, [ue]: Ve },
                            [x]: Q,
                          },
                          {
                            [w]: [nt, lt, Ur, cn, gt, yo],
                            [H]: [
                              { [w]: Tc, endpoint: dz, [x]: Q },
                              { endpoint: dz, [x]: Q },
                            ],
                            [x]: j,
                          },
                          {
                            [w]: [nt, lt, Ur, cn, gt, xo],
                            endpoint: dz,
                            [x]: Q,
                          },
                          {
                            [w]: [nt, lt, We, oo],
                            endpoint: { [le]: Mze, [fe]: go, [ue]: Ve },
                            [x]: Q,
                          },
                          {
                            [w]: [nt, lt, We, gt, yo],
                            [H]: [
                              {
                                [w]: Tc,
                                endpoint: { [le]: Mze, [fe]: Kr, [ue]: Ve },
                                [x]: Q,
                              },
                              { endpoint: h2e, [x]: Q },
                            ],
                            [x]: j,
                          },
                          { [w]: [nt, lt, We, gt, xo], endpoint: h2e, [x]: Q },
                        ],
                        [x]: j,
                      },
                      YR,
                    ],
                    [x]: j,
                  },
                ],
                [x]: j,
              },
            ],
            [x]: j,
          },
          {
            error: "A region must be set when sending requests to S3.",
            [x]: me,
          },
        ],
      }),
      (eqe = Qgt);
  });
var Xgt,
  tI,
  Az = s(() => {
    dR();
    $t();
    tqe();
    (Xgt = new uo({
      size: 50,
      params: [
        "Accelerate",
        "Bucket",
        "DisableAccessPoints",
        "DisableMultiRegionAccessPoints",
        "DisableS3ExpressSessionAuth",
        "Endpoint",
        "ForcePathStyle",
        "Region",
        "UseArnRegion",
        "UseDualStack",
        "UseFIPS",
        "UseGlobalEndpoint",
        "UseObjectLambdaEndpoint",
        "UseS3ExpressControlEndpoint",
      ],
    })),
      (tI = (e, t = {}) =>
        Xgt.get(e, () => jr(eqe, { endpointParams: e, logger: t.logger })));
    Jt.aws = Ny;
  });
function oqe(e) {
  return {
    schemeId: "aws.auth#sigv4",
    signingProperties: { name: "s3", region: e.region },
    propertiesExtractor: (t, r) => ({
      signingProperties: { config: t, context: r },
    }),
  };
}
function nqe(e) {
  return {
    schemeId: "aws.auth#sigv4a",
    signingProperties: { name: "s3", region: e.region },
    propertiesExtractor: (t, r) => ({
      signingProperties: { config: t, context: r },
    }),
  };
}
var Jgt,
  Zgt,
  rqe,
  eyt,
  tyt,
  sqe,
  iqe,
  Rz = s(() => {
    rt();
    Y3();
    K();
    ct();
    Az();
    (Jgt = (e) => async (t, r, o) => {
      if (!o)
        throw new Error(
          "Could not find `input` for `defaultEndpointRuleSetHttpAuthSchemeParametersProvider`"
        );
      let n = await e(t, r, o),
        i =
          bt(r)?.commandInstance?.constructor?.getEndpointParameterInstructions;
      if (!i)
        throw new Error(
          `getEndpointParameterInstructions() is not defined on \`${r.commandName}\``
        );
      let a = await v3(o, { getEndpointParameterInstructions: i }, t);
      return Object.assign(n, a);
    }),
      (Zgt = async (e, t, r) => ({
        operation: bt(t).operation,
        region:
          (await pe(e.region)()) ||
          (() => {
            throw new Error(
              "expected `region` to be configured for `aws.auth#sigv4`"
            );
          })(),
      })),
      (rqe = Jgt(Zgt));
    (eyt = (e, t, r) => (n) => {
      let a = e(n).properties?.authSchemes;
      if (!a) return t(n);
      let c = [];
      for (let d of a) {
        let { name: m, properties: f = {}, ...l } = d,
          u = m.toLowerCase();
        m !== u &&
          console.warn(
            `HttpAuthScheme has been normalized with lowercasing: \`${m}\` to \`${u}\``
          );
        let h;
        if (u === "sigv4a") {
          h = "aws.auth#sigv4a";
          let E = a.find((b) => {
            let v = b.name.toLowerCase();
            return v !== "sigv4a" && v.startsWith("sigv4");
          });
          if (Uu.sigv4aDependency() === "none" && E) continue;
        } else if (u.startsWith("sigv4")) h = "aws.auth#sigv4";
        else
          throw new Error(
            `Unknown HttpAuthScheme found in \`@smithy.rules#endpointRuleSet\`: \`${u}\``
          );
        let y = r[h];
        if (!y)
          throw new Error(
            `Could not find HttpAuthOption create function for \`${h}\``
          );
        let S = y(n);
        (S.schemeId = h),
          (S.signingProperties = {
            ...(S.signingProperties || {}),
            ...l,
            ...f,
          }),
          c.push(S);
      }
      return c;
    }),
      (tyt = (e) => {
        let t = [];
        switch (e.operation) {
          default:
            t.push(oqe(e)), t.push(nqe(e));
        }
        return t;
      }),
      (sqe = eyt(tI, tyt, { "aws.auth#sigv4": oqe, "aws.auth#sigv4a": nqe })),
      (iqe = (e) => {
        let t = zo(e),
          r = TZ(t);
        return Object.assign(r, {
          authSchemePreference: pe(e.authSchemePreference ?? []),
        });
      });
  });
var aqe,
  R,
  X = s(() => {
    (aqe = (e) =>
      Object.assign(e, {
        useFipsEndpoint: e.useFipsEndpoint ?? !1,
        useDualstackEndpoint: e.useDualstackEndpoint ?? !1,
        forcePathStyle: e.forcePathStyle ?? !1,
        useAccelerateEndpoint: e.useAccelerateEndpoint ?? !1,
        useGlobalEndpoint: e.useGlobalEndpoint ?? !1,
        disableMultiregionAccessPoints: e.disableMultiregionAccessPoints ?? !1,
        defaultSigningName: "s3",
      })),
      (R = {
        ForcePathStyle: { type: "clientContextParams", name: "forcePathStyle" },
        UseArnRegion: { type: "clientContextParams", name: "useArnRegion" },
        DisableMultiRegionAccessPoints: {
          type: "clientContextParams",
          name: "disableMultiregionAccessPoints",
        },
        Accelerate: {
          type: "clientContextParams",
          name: "useAccelerateEndpoint",
        },
        DisableS3ExpressSessionAuth: {
          type: "clientContextParams",
          name: "disableS3ExpressSessionAuth",
        },
        UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
        UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
        Endpoint: { type: "builtInParams", name: "endpoint" },
        Region: { type: "builtInParams", name: "region" },
        UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
      });
  });
var Yr,
  rI = s(() => {
    $();
    Yr = class e extends Lu {
      constructor(t) {
        super(t), Object.setPrototypeOf(this, e.prototype);
      }
    };
  });
var oI,
  nI,
  sI,
  iI,
  aI,
  cI,
  dI,
  mI,
  lI,
  fI,
  cqe,
  dqe,
  mqe,
  lqe,
  fqe,
  uqe,
  ryt,
  pqe,
  hqe,
  oyt,
  nyt,
  Iz,
  gqe,
  syt,
  iyt,
  ayt,
  cyt,
  uI,
  yqe,
  xqe,
  Eqe,
  Sqe,
  Cqe,
  bqe,
  _qe,
  wqe,
  Tqe,
  Qo = s(() => {
    $();
    rI();
    (oI = class e extends Yr {
      name = "NoSuchUpload";
      $fault = "client";
      constructor(t) {
        super({ name: "NoSuchUpload", $fault: "client", ...t }),
          Object.setPrototypeOf(this, e.prototype);
      }
    }),
      (nI = class e extends Yr {
        name = "ObjectNotInActiveTierError";
        $fault = "client";
        constructor(t) {
          super({ name: "ObjectNotInActiveTierError", $fault: "client", ...t }),
            Object.setPrototypeOf(this, e.prototype);
        }
      }),
      (sI = class e extends Yr {
        name = "BucketAlreadyExists";
        $fault = "client";
        constructor(t) {
          super({ name: "BucketAlreadyExists", $fault: "client", ...t }),
            Object.setPrototypeOf(this, e.prototype);
        }
      }),
      (iI = class e extends Yr {
        name = "BucketAlreadyOwnedByYou";
        $fault = "client";
        constructor(t) {
          super({ name: "BucketAlreadyOwnedByYou", $fault: "client", ...t }),
            Object.setPrototypeOf(this, e.prototype);
        }
      }),
      (aI = class e extends Yr {
        name = "NoSuchBucket";
        $fault = "client";
        constructor(t) {
          super({ name: "NoSuchBucket", $fault: "client", ...t }),
            Object.setPrototypeOf(this, e.prototype);
        }
      });
    (function (e) {
      e.visit = (t, r) =>
        t.Prefix !== void 0
          ? r.Prefix(t.Prefix)
          : t.Tag !== void 0
            ? r.Tag(t.Tag)
            : t.And !== void 0
              ? r.And(t.And)
              : r._(t.$unknown[0], t.$unknown[1]);
    })(cI || (cI = {}));
    (function (e) {
      e.visit = (t, r) =>
        t.Prefix !== void 0
          ? r.Prefix(t.Prefix)
          : t.Tag !== void 0
            ? r.Tag(t.Tag)
            : t.AccessPointArn !== void 0
              ? r.AccessPointArn(t.AccessPointArn)
              : t.And !== void 0
                ? r.And(t.And)
                : r._(t.$unknown[0], t.$unknown[1]);
    })(dI || (dI = {}));
    (mI = class e extends Yr {
      name = "InvalidObjectState";
      $fault = "client";
      StorageClass;
      AccessTier;
      constructor(t) {
        super({ name: "InvalidObjectState", $fault: "client", ...t }),
          Object.setPrototypeOf(this, e.prototype),
          (this.StorageClass = t.StorageClass),
          (this.AccessTier = t.AccessTier);
      }
    }),
      (lI = class e extends Yr {
        name = "NoSuchKey";
        $fault = "client";
        constructor(t) {
          super({ name: "NoSuchKey", $fault: "client", ...t }),
            Object.setPrototypeOf(this, e.prototype);
        }
      }),
      (fI = class e extends Yr {
        name = "NotFound";
        $fault = "client";
        constructor(t) {
          super({ name: "NotFound", $fault: "client", ...t }),
            Object.setPrototypeOf(this, e.prototype);
        }
      }),
      (cqe = (e) => ({ ...e, ...(e.SSEKMSKeyId && { SSEKMSKeyId: $e }) })),
      (dqe = (e) => ({
        ...e,
        ...(e.SSECustomerKey && { SSECustomerKey: $e }),
      })),
      (mqe = (e) => ({
        ...e,
        ...(e.SSEKMSKeyId && { SSEKMSKeyId: $e }),
        ...(e.SSEKMSEncryptionContext && { SSEKMSEncryptionContext: $e }),
      })),
      (lqe = (e) => ({
        ...e,
        ...(e.SSECustomerKey && { SSECustomerKey: $e }),
        ...(e.SSEKMSKeyId && { SSEKMSKeyId: $e }),
        ...(e.SSEKMSEncryptionContext && { SSEKMSEncryptionContext: $e }),
        ...(e.CopySourceSSECustomerKey && { CopySourceSSECustomerKey: $e }),
      })),
      (fqe = (e) => ({
        ...e,
        ...(e.SSEKMSKeyId && { SSEKMSKeyId: $e }),
        ...(e.SSEKMSEncryptionContext && { SSEKMSEncryptionContext: $e }),
      })),
      (uqe = (e) => ({
        ...e,
        ...(e.SSECustomerKey && { SSECustomerKey: $e }),
        ...(e.SSEKMSKeyId && { SSEKMSKeyId: $e }),
        ...(e.SSEKMSEncryptionContext && { SSEKMSEncryptionContext: $e }),
      })),
      (ryt = (e) => ({
        ...e,
        ...(e.SecretAccessKey && { SecretAccessKey: $e }),
        ...(e.SessionToken && { SessionToken: $e }),
      })),
      (pqe = (e) => ({
        ...e,
        ...(e.SSEKMSKeyId && { SSEKMSKeyId: $e }),
        ...(e.SSEKMSEncryptionContext && { SSEKMSEncryptionContext: $e }),
        ...(e.Credentials && { Credentials: ryt(e.Credentials) }),
      })),
      (hqe = (e) => ({
        ...e,
        ...(e.SSEKMSKeyId && { SSEKMSKeyId: $e }),
        ...(e.SSEKMSEncryptionContext && { SSEKMSEncryptionContext: $e }),
      })),
      (oyt = (e) => ({
        ...e,
        ...(e.KMSMasterKeyID && { KMSMasterKeyID: $e }),
      })),
      (nyt = (e) => ({
        ...e,
        ...(e.ApplyServerSideEncryptionByDefault && {
          ApplyServerSideEncryptionByDefault: oyt(
            e.ApplyServerSideEncryptionByDefault
          ),
        }),
      })),
      (Iz = (e) => ({
        ...e,
        ...(e.Rules && { Rules: e.Rules.map((t) => nyt(t)) }),
      })),
      (gqe = (e) => ({
        ...e,
        ...(e.ServerSideEncryptionConfiguration && {
          ServerSideEncryptionConfiguration: Iz(
            e.ServerSideEncryptionConfiguration
          ),
        }),
      })),
      (syt = (e) => ({ ...e, ...(e.KeyId && { KeyId: $e }) })),
      (iyt = (e) => ({ ...e, ...(e.SSEKMS && { SSEKMS: syt(e.SSEKMS) }) })),
      (ayt = (e) => ({
        ...e,
        ...(e.Encryption && { Encryption: iyt(e.Encryption) }),
      })),
      (cyt = (e) => ({
        ...e,
        ...(e.S3BucketDestination && {
          S3BucketDestination: ayt(e.S3BucketDestination),
        }),
      })),
      (uI = (e) => ({
        ...e,
        ...(e.Destination && { Destination: cyt(e.Destination) }),
      })),
      (yqe = (e) => ({
        ...e,
        ...(e.InventoryConfiguration && {
          InventoryConfiguration: uI(e.InventoryConfiguration),
        }),
      })),
      (xqe = (e) => ({ ...e, ...(e.SSEKMSKeyId && { SSEKMSKeyId: $e }) })),
      (Eqe = (e) => ({
        ...e,
        ...(e.SSECustomerKey && { SSECustomerKey: $e }),
      })),
      (Sqe = (e) => ({
        ...e,
        ...(e.SSECustomerKey && { SSECustomerKey: $e }),
      })),
      (Cqe = (e) => ({ ...e })),
      (bqe = (e) => ({ ...e, ...(e.SSEKMSKeyId && { SSEKMSKeyId: $e }) })),
      (_qe = (e) => ({
        ...e,
        ...(e.SSECustomerKey && { SSECustomerKey: $e }),
      })),
      (wqe = (e) => ({
        ...e,
        ...(e.InventoryConfigurationList && {
          InventoryConfigurationList: e.InventoryConfigurationList.map((t) =>
            uI(t)
          ),
        }),
      })),
      (Tqe = (e) => ({
        ...e,
        ...(e.SSECustomerKey && { SSECustomerKey: $e }),
      }));
  });
function Aqe(e) {
  return e
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;");
}
var Rqe = s(() => {});
function Iqe(e) {
  return e
    .replace(/&/g, "&amp;")
    .replace(/"/g, "&quot;")
    .replace(/'/g, "&apos;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/\r/g, "&#x0D;")
    .replace(/\n/g, "&#x0A;")
    .replace(/\u0085/g, "&#x85;")
    .replace(/\u2028/, "&#x2028;");
}
var Pqe = s(() => {});
var Yd,
  Pz = s(() => {
    Pqe();
    Yd = class {
      value;
      constructor(t) {
        this.value = t;
      }
      toString() {
        return Iqe("" + this.value);
      }
    };
  });
var C,
  vqe = s(() => {
    Rqe();
    Pz();
    C = class e {
      name;
      children;
      attributes = {};
      static of(t, r, o) {
        let n = new e(t);
        return (
          r !== void 0 && n.addChildNode(new Yd(r)),
          o !== void 0 && n.withName(o),
          n
        );
      }
      constructor(t, r = []) {
        (this.name = t), (this.children = r);
      }
      withName(t) {
        return (this.name = t), this;
      }
      addAttribute(t, r) {
        return (this.attributes[t] = r), this;
      }
      addChildNode(t) {
        return this.children.push(t), this;
      }
      removeAttribute(t) {
        return delete this.attributes[t], this;
      }
      n(t) {
        return (this.name = t), this;
      }
      c(t) {
        return this.children.push(t), this;
      }
      a(t, r) {
        return r != null && (this.attributes[t] = r), this;
      }
      cc(t, r, o = r) {
        if (t[r] != null) {
          let n = e.of(r, t[r]).withName(o);
          this.c(n);
        }
      }
      l(t, r, o, n) {
        t[r] != null &&
          n().map((a) => {
            a.withName(o), this.c(a);
          });
      }
      lc(t, r, o, n) {
        if (t[r] != null) {
          let i = n(),
            a = new e(o);
          i.map((c) => {
            a.c(c);
          }),
            this.c(a);
        }
      }
      toString() {
        let t = !!this.children.length,
          r = `<${this.name}`,
          o = this.attributes;
        for (let n of Object.keys(o)) {
          let i = o[n];
          i != null && (r += ` ${n}="${Aqe("" + i)}"`);
        }
        return (r += t
          ? `>${this.children.map((n) => n.toString()).join("")}</${this.name}>`
          : "/>");
      }
    };
  });
var Oqe = s(() => {
  vqe();
  Pz();
});
var pI,
  hI,
  gI,
  yI,
  xI,
  EI,
  kqe,
  Dqe,
  Nqe,
  Bqe,
  Mqe,
  dyt,
  myt,
  lyt,
  fyt,
  Lqe,
  Fqe,
  Uqe,
  $qe,
  Hqe,
  zqe,
  qqe,
  jqe,
  Ks = s(() => {
    $();
    Qo();
    rI();
    (pI = class e extends Yr {
      name = "EncryptionTypeMismatch";
      $fault = "client";
      constructor(t) {
        super({ name: "EncryptionTypeMismatch", $fault: "client", ...t }),
          Object.setPrototypeOf(this, e.prototype);
      }
    }),
      (hI = class e extends Yr {
        name = "InvalidRequest";
        $fault = "client";
        constructor(t) {
          super({ name: "InvalidRequest", $fault: "client", ...t }),
            Object.setPrototypeOf(this, e.prototype);
        }
      }),
      (gI = class e extends Yr {
        name = "InvalidWriteOffset";
        $fault = "client";
        constructor(t) {
          super({ name: "InvalidWriteOffset", $fault: "client", ...t }),
            Object.setPrototypeOf(this, e.prototype);
        }
      }),
      (yI = class e extends Yr {
        name = "TooManyParts";
        $fault = "client";
        constructor(t) {
          super({ name: "TooManyParts", $fault: "client", ...t }),
            Object.setPrototypeOf(this, e.prototype);
        }
      }),
      (xI = class e extends Yr {
        name = "IdempotencyParameterMismatch";
        $fault = "client";
        constructor(t) {
          super({
            name: "IdempotencyParameterMismatch",
            $fault: "client",
            ...t,
          }),
            Object.setPrototypeOf(this, e.prototype);
        }
      }),
      (EI = class e extends Yr {
        name = "ObjectAlreadyInActiveTierError";
        $fault = "client";
        constructor(t) {
          super({
            name: "ObjectAlreadyInActiveTierError",
            $fault: "client",
            ...t,
          }),
            Object.setPrototypeOf(this, e.prototype);
        }
      });
    (function (e) {
      e.visit = (t, r) =>
        t.Records !== void 0
          ? r.Records(t.Records)
          : t.Stats !== void 0
            ? r.Stats(t.Stats)
            : t.Progress !== void 0
              ? r.Progress(t.Progress)
              : t.Cont !== void 0
                ? r.Cont(t.Cont)
                : t.End !== void 0
                  ? r.End(t.End)
                  : r._(t.$unknown[0], t.$unknown[1]);
    })(kqe || (kqe = {}));
    (Dqe = (e) => ({
      ...e,
      ...(e.ServerSideEncryptionConfiguration && {
        ServerSideEncryptionConfiguration: Iz(
          e.ServerSideEncryptionConfiguration
        ),
      }),
    })),
      (Nqe = (e) => ({
        ...e,
        ...(e.InventoryConfiguration && {
          InventoryConfiguration: uI(e.InventoryConfiguration),
        }),
      })),
      (Bqe = (e) => ({
        ...e,
        ...(e.SSEKMSKeyId && { SSEKMSKeyId: $e }),
        ...(e.SSEKMSEncryptionContext && { SSEKMSEncryptionContext: $e }),
      })),
      (Mqe = (e) => ({
        ...e,
        ...(e.SSECustomerKey && { SSECustomerKey: $e }),
        ...(e.SSEKMSKeyId && { SSEKMSKeyId: $e }),
        ...(e.SSEKMSEncryptionContext && { SSEKMSEncryptionContext: $e }),
      })),
      (dyt = (e) => ({ ...e, ...(e.KMSKeyId && { KMSKeyId: $e }) })),
      (myt = (e) => ({
        ...e,
        ...(e.Encryption && { Encryption: dyt(e.Encryption) }),
      })),
      (lyt = (e) => ({ ...e, ...(e.S3 && { S3: myt(e.S3) }) })),
      (fyt = (e) => ({
        ...e,
        ...(e.OutputLocation && { OutputLocation: lyt(e.OutputLocation) }),
      })),
      (Lqe = (e) => ({
        ...e,
        ...(e.RestoreRequest && { RestoreRequest: fyt(e.RestoreRequest) }),
      })),
      (Fqe = (e) => ({
        ...e,
        ...(e.Payload && { Payload: "STREAMING_CONTENT" }),
      })),
      (Uqe = (e) => ({
        ...e,
        ...(e.SSECustomerKey && { SSECustomerKey: $e }),
      })),
      ($qe = (e) => ({ ...e, ...(e.SSEKMSKeyId && { SSEKMSKeyId: $e }) })),
      (Hqe = (e) => ({
        ...e,
        ...(e.SSECustomerKey && { SSECustomerKey: $e }),
      })),
      (zqe = (e) => ({ ...e, ...(e.SSEKMSKeyId && { SSEKMSKeyId: $e }) })),
      (qqe = (e) => ({
        ...e,
        ...(e.SSECustomerKey && { SSECustomerKey: $e }),
        ...(e.CopySourceSSECustomerKey && { CopySourceSSECustomerKey: $e }),
      })),
      (jqe = (e) => ({ ...e, ...(e.SSEKMSKeyId && { SSEKMSKeyId: $e }) }));
  });
var Eje,
  Sje,
  Cje,
  bje,
  _je,
  wje,
  Tje,
  Aje,
  Rje,
  Ije,
  Pje,
  vje,
  Oje,
  kje,
  Dje,
  Nje,
  Bje,
  Mje,
  Lje,
  Fje,
  Uje,
  $je,
  Hje,
  zje,
  qje,
  jje,
  Gje,
  Vje,
  Wje,
  Kje,
  Yje,
  Qje,
  Xje,
  Jje,
  Zje,
  eGe,
  tGe,
  rGe,
  oGe,
  nGe,
  sGe,
  iGe,
  aGe,
  cGe,
  dGe,
  mGe,
  lGe,
  fGe,
  uGe,
  pGe,
  hGe,
  gGe,
  yGe,
  xGe,
  EGe,
  SGe,
  CGe,
  bGe,
  _Ge,
  wGe,
  TGe,
  AGe,
  RGe,
  IGe,
  PGe,
  vGe,
  OGe,
  kGe,
  DGe,
  NGe,
  BGe,
  MGe,
  LGe,
  FGe,
  UGe,
  $Ge,
  HGe,
  zGe,
  qGe,
  jGe,
  GGe,
  VGe,
  WGe,
  KGe,
  YGe,
  QGe,
  XGe,
  JGe,
  ZGe,
  e4e,
  t4e,
  r4e,
  o4e,
  n4e,
  s4e,
  i4e,
  a4e,
  c4e,
  d4e,
  m4e,
  l4e,
  f4e,
  u4e,
  p4e,
  h4e,
  g4e,
  y4e,
  x4e,
  E4e,
  S4e,
  C4e,
  b4e,
  _4e,
  w4e,
  T4e,
  A4e,
  R4e,
  I4e,
  P4e,
  v4e,
  O4e,
  k4e,
  D4e,
  N4e,
  B4e,
  M4e,
  L4e,
  F4e,
  U4e,
  $4e,
  H4e,
  z4e,
  q4e,
  j4e,
  G4e,
  V4e,
  W4e,
  K4e,
  Y4e,
  Q4e,
  X4e,
  J4e,
  Z4e,
  eVe,
  tVe,
  rVe,
  oVe,
  nVe,
  sVe,
  iVe,
  aVe,
  cVe,
  dVe,
  mVe,
  lVe,
  fVe,
  uVe,
  pVe,
  hVe,
  gVe,
  yVe,
  xVe,
  EVe,
  SVe,
  CVe,
  bVe,
  _Ve,
  wVe,
  TVe,
  AVe,
  RVe,
  IVe,
  PVe,
  vVe,
  OVe,
  kVe,
  DVe,
  NVe,
  BVe,
  MVe,
  LVe,
  FVe,
  UVe,
  $Ve,
  HVe,
  zVe,
  qVe,
  jVe,
  GVe,
  VVe,
  WVe,
  KVe,
  YVe,
  QVe,
  XVe,
  JVe,
  ZVe,
  e8e,
  Z,
  uyt,
  pyt,
  hyt,
  gyt,
  yyt,
  xyt,
  Eyt,
  Syt,
  Cyt,
  byt,
  _yt,
  wyt,
  Tyt,
  Ayt,
  Ryt,
  Iyt,
  Pyt,
  vyt,
  Oyt,
  kyt,
  Dyt,
  Nyt,
  Byt,
  t8e,
  Myt,
  Lyt,
  Fyt,
  Uyt,
  $yt,
  Hyt,
  zyt,
  qyt,
  jyt,
  Gyt,
  Vyt,
  Wyt,
  Kyt,
  Yyt,
  Qyt,
  Xyt,
  Jyt,
  Zyt,
  ext,
  txt,
  rxt,
  oxt,
  nxt,
  sxt,
  ixt,
  axt,
  cxt,
  dxt,
  mxt,
  lxt,
  $2,
  fxt,
  uxt,
  pxt,
  hxt,
  gxt,
  yxt,
  r8e,
  o8e,
  xxt,
  n8e,
  Ext,
  Sxt,
  Cxt,
  bxt,
  _xt,
  wxt,
  Txt,
  Axt,
  Rxt,
  Ixt,
  Pxt,
  vxt,
  Oxt,
  kxt,
  Dxt,
  Nxt,
  Bxt,
  Mxt,
  Lxt,
  Fxt,
  Uxt,
  $xt,
  Hxt,
  zxt,
  qxt,
  jxt,
  Gxt,
  Vxt,
  Wxt,
  Kxt,
  Yxt,
  H2,
  Qxt,
  Xxt,
  Jxt,
  Zxt,
  eEt,
  tEt,
  rEt,
  s8e,
  oEt,
  nEt,
  sEt,
  iEt,
  aEt,
  cEt,
  dEt,
  mEt,
  lEt,
  fEt,
  uEt,
  pEt,
  hEt,
  gEt,
  yEt,
  xEt,
  EEt,
  SEt,
  i8e,
  CEt,
  bEt,
  _Et,
  wEt,
  TEt,
  AEt,
  REt,
  IEt,
  PEt,
  vEt,
  OEt,
  kEt,
  DEt,
  NEt,
  BEt,
  MEt,
  LEt,
  FEt,
  UEt,
  $Et,
  HEt,
  vp,
  z2,
  Op,
  zEt,
  qEt,
  jEt,
  GEt,
  VEt,
  WEt,
  KEt,
  YEt,
  QEt,
  XEt,
  JEt,
  ZEt,
  eSt,
  tSt,
  rSt,
  oSt,
  nSt,
  sSt,
  a8e,
  iSt,
  aSt,
  cSt,
  dSt,
  mSt,
  c8e,
  lSt,
  d8e,
  fSt,
  EP,
  uSt,
  pSt,
  hSt,
  gSt,
  ySt,
  xSt,
  ESt,
  SSt,
  CSt,
  bSt,
  _St,
  wSt,
  TSt,
  ASt,
  RSt,
  ISt,
  PSt,
  vSt,
  OSt,
  kSt,
  q2,
  DSt,
  NSt,
  BSt,
  MSt,
  LSt,
  FSt,
  USt,
  m8e,
  l8e,
  $St,
  f8e,
  HSt,
  u8e,
  zSt,
  qSt,
  p8e,
  jSt,
  GSt,
  VSt,
  WSt,
  KSt,
  YSt,
  QSt,
  XSt,
  JSt,
  ZSt,
  eCt,
  tCt,
  rCt,
  oCt,
  nCt,
  sCt,
  iCt,
  aCt,
  h8e,
  cCt,
  dCt,
  mCt,
  lCt,
  fCt,
  uCt,
  pCt,
  j2,
  hCt,
  g8e,
  gCt,
  yCt,
  xCt,
  ECt,
  SCt,
  CCt,
  bCt,
  Dc,
  _Ct,
  wCt,
  TCt,
  ACt,
  RCt,
  ICt,
  PCt,
  vCt,
  OCt,
  kCt,
  DCt,
  NCt,
  BCt,
  MCt,
  LCt,
  FCt,
  UCt,
  $Ct,
  HCt,
  zCt,
  qCt,
  y8e,
  x8e,
  jCt,
  GCt,
  VCt,
  WCt,
  KCt,
  YCt,
  QCt,
  XCt,
  JCt,
  ZCt,
  ebt,
  tbt,
  rbt,
  obt,
  nbt,
  sbt,
  ibt,
  kp,
  Bm,
  abt,
  cbt,
  dbt,
  mbt,
  lbt,
  fbt,
  ubt,
  pbt,
  hbt,
  W,
  gbt,
  pr,
  ybt,
  s2,
  Dp,
  om,
  Gqe,
  xbt,
  nm,
  Ebt,
  E8e,
  Sbt,
  Cbt,
  i2,
  a2,
  bbt,
  sm,
  Ku,
  vz,
  c2,
  d2,
  m2,
  l2,
  _bt,
  fa,
  SI,
  G2,
  S8e,
  wbt,
  Tbt,
  Abt,
  Yu,
  ua,
  Qu,
  ft,
  Xu,
  Rbt,
  Ap,
  Ibt,
  ur,
  Pbt,
  vbt,
  Obt,
  kbt,
  Dbt,
  Nbt,
  SP,
  Ju,
  Zu,
  ep,
  Vy,
  tp,
  rp,
  Bbt,
  Mbt,
  Pi,
  Oz,
  et,
  kz,
  Lbt,
  Np,
  rr,
  or,
  nr,
  Bp,
  Dz,
  Mp,
  f2,
  Vqe,
  Lp,
  Oc,
  C8e,
  Qr,
  Fbt,
  Ubt,
  u2,
  p2,
  Xo,
  $bt,
  V2,
  Wqe,
  b8e,
  sr,
  ir,
  _8e,
  sP,
  w8e,
  iP,
  Hbt,
  T8e,
  A8e,
  R8e,
  op,
  I8e,
  zbt,
  qbt,
  ar,
  jbt,
  Fp,
  Gbt,
  Yt,
  Nz,
  Ac,
  Bz,
  Vbt,
  im,
  Jo,
  Qd,
  np,
  Wbt,
  Kqe,
  Kbt,
  Yqe,
  Qs,
  am,
  Ybt,
  Mz,
  Qqe,
  Xs,
  Qbt,
  cm,
  Rt,
  mn,
  CI,
  Xbt,
  no,
  Jbt,
  ki,
  RI,
  dm,
  ee,
  II,
  mm,
  lm,
  h2,
  g2,
  PI,
  Xd,
  fm,
  Zbt,
  e_t,
  P8e,
  v8e,
  t_t,
  Zo,
  Qt,
  Lz,
  sp,
  O8e,
  vi,
  Fz,
  bI,
  Wy,
  Xqe,
  Om,
  ha,
  k8e,
  ln,
  Oe,
  D8e,
  r_t,
  o_t,
  y2,
  n_t,
  s_t,
  x2,
  E2,
  ys,
  ip,
  ga,
  Up,
  vI,
  $p,
  Hp,
  W2,
  zp,
  Yy,
  Mn,
  OI,
  Rc,
  kI,
  ke,
  S2,
  Jqe,
  um,
  vr,
  i_t,
  Jd,
  a_t,
  c_t,
  d_t,
  m_t,
  l_t,
  f_t,
  ap,
  Xy,
  Zqe,
  eje,
  tje,
  aP,
  CP,
  u_t,
  cp,
  Uz,
  dp,
  $z,
  pm,
  p_t,
  h_t,
  Ft,
  g_t,
  y_t,
  C2,
  rje,
  x_t,
  E_t,
  S_t,
  C_t,
  cP,
  mp,
  Hz,
  lp,
  b_t,
  __t,
  w_t,
  Ge,
  zz,
  fp,
  Ic,
  T_t,
  qz,
  up,
  DI,
  hm,
  pp,
  gm,
  A_t,
  NI,
  b2,
  R_t,
  I_t,
  Or,
  _I,
  P_t,
  v_t,
  O_t,
  k_t,
  D_t,
  N_t,
  BI,
  B_t,
  Zd,
  M_t,
  _2,
  oje,
  L_t,
  F_t,
  w2,
  N8e,
  U_t,
  K2,
  MI,
  $_t,
  xs,
  H_t,
  dP,
  nje,
  pa,
  z_t,
  q_t,
  jz,
  LI,
  j_t,
  ym,
  Gz,
  em,
  Es,
  Cr,
  G_t,
  V_t,
  fn,
  Ss,
  Y2,
  hp,
  Vz,
  Cs,
  gp,
  Wz,
  xm,
  Kz,
  T2,
  A2,
  Ct,
  sje,
  W_t,
  K_t,
  Y_t,
  Gu,
  Q_t,
  Q2,
  FI,
  X_t,
  UI,
  ije,
  J_t,
  Mm,
  qp,
  Z_t,
  B8e,
  Di,
  ewt,
  Ky,
  Rp,
  twt,
  Yz,
  Em,
  bs,
  M8e,
  _s,
  L8e,
  yp,
  Qz,
  rwt,
  owt,
  se,
  nwt,
  Ip,
  $I,
  swt,
  wn,
  Pc,
  Sm,
  HI,
  mP,
  Xz,
  Qy,
  Oi,
  vc,
  tm,
  wI,
  zI,
  R2,
  I2,
  F8e,
  U8e,
  iwt,
  P2,
  $8e,
  Cm,
  hr,
  H8e,
  z8e,
  q8e,
  j8e,
  G8e,
  awt,
  X2,
  V8e,
  Jz,
  qI,
  jI,
  GI,
  bm,
  cwt,
  dwt,
  qt,
  xp,
  mwt,
  VI,
  lwt,
  fwt,
  uwt,
  pwt,
  hwt,
  gwt,
  ywt,
  Vu,
  lP,
  xwt,
  J2,
  Ep,
  Ewt,
  Swt,
  Cwt,
  _m,
  Sp,
  Z2,
  wm,
  WI,
  Tn,
  Ts,
  de,
  KI,
  Zz,
  ws,
  tt,
  Tm,
  bwt,
  _wt,
  aje,
  cje,
  wwt,
  dje,
  Twt,
  mje,
  fP,
  Am,
  Awt,
  Rwt,
  v2,
  Iwt,
  Pwt,
  vwt,
  YI,
  Rm,
  QI,
  uP,
  Im,
  en,
  Cp,
  Owt,
  kwt,
  so,
  Js,
  io,
  O2,
  Nc,
  Do,
  Dwt,
  k2,
  e2,
  Nwt,
  XI,
  t2,
  Bwt,
  r2,
  bp,
  TI,
  ko,
  AI,
  JI,
  Pm,
  ZI,
  o2,
  eP,
  _p,
  pP,
  D2,
  N2,
  Mwt,
  eq,
  Wu,
  Lwt,
  wp,
  n2,
  vm,
  tP,
  Fwt,
  Ys,
  W8e,
  Xe,
  un,
  K8e,
  B2,
  M2,
  Tp,
  Y8e,
  L2,
  F2,
  U2,
  An,
  lje,
  Rn,
  rP,
  Uwt,
  oP,
  fje,
  uje,
  Q8e,
  $wt,
  st,
  nP,
  Ln,
  pje,
  Hwt,
  hje,
  Jy,
  rm,
  bP,
  X8e,
  _P,
  J8e,
  zwt,
  qwt,
  tq,
  Zy,
  ex,
  tx,
  rx,
  km,
  Xr,
  Z8e,
  ox,
  Lm,
  jwt,
  wP,
  Dm,
  rq,
  TP,
  AP,
  eWe,
  Gwt,
  As,
  jp,
  oq,
  RP,
  nx,
  IP,
  nq,
  tWe,
  sq,
  rWe,
  Pp,
  oWe,
  nWe,
  Vwt,
  PP,
  iq,
  Wwt,
  Kwt,
  Ywt,
  ao,
  aq,
  Qwt,
  Xwt,
  sWe,
  cq,
  iWe,
  dq,
  mq,
  vP,
  Jwt,
  Zwt,
  sx,
  lq,
  eTt,
  aWe,
  cWe,
  dWe,
  mWe,
  lWe,
  fWe,
  uWe,
  pWe,
  tTt,
  hWe,
  rTt,
  oTt,
  nTt,
  sTt,
  Gp,
  iTt,
  gWe,
  ix,
  aTt,
  yWe,
  In,
  jt,
  cTt,
  dTt,
  fq,
  gje,
  Vp,
  hP,
  yje,
  xWe,
  mTt,
  uq,
  lTt,
  fTt,
  uTt,
  EWe,
  pTt,
  pq,
  Fm,
  Um,
  $m,
  SWe,
  hTt,
  Hm,
  zm,
  CWe,
  bWe,
  _We,
  wWe,
  TWe,
  gTt,
  yTt,
  AWe,
  RWe,
  IWe,
  PWe,
  Wp,
  xTt,
  kc,
  ax,
  te,
  ETt,
  STt,
  CTt,
  bTt,
  _Tt,
  wTt,
  TTt,
  ATt,
  RTt,
  ITt,
  PTt,
  vTt,
  OTt,
  kTt,
  DTt,
  NTt,
  BTt,
  MTt,
  LTt,
  FTt,
  UTt,
  $Tt,
  HTt,
  zTt,
  qTt,
  jTt,
  GTt,
  VTt,
  WTt,
  KTt,
  YTt,
  QTt,
  XTt,
  JTt,
  ZTt,
  eAt,
  Kp,
  Yp,
  Qp,
  hq,
  Xp,
  tAt,
  rAt,
  oAt,
  gq,
  nAt,
  gP,
  sAt,
  iAt,
  yP,
  aAt,
  cx,
  dx,
  Nm,
  cAt,
  yq,
  xje,
  dAt,
  vWe,
  xr,
  mAt,
  Gt,
  lAt,
  fAt,
  OWe,
  uAt,
  pAt,
  hAt,
  gAt,
  yAt,
  mx,
  br,
  xAt,
  kWe,
  Fn,
  Un,
  Br,
  Bc,
  Co,
  Zs,
  bo,
  xq,
  xP,
  EAt,
  Eq,
  Ni,
  SAt,
  lx,
  _o,
  J = s(() => {
    rt();
    Oqe();
    Ue();
    an();
    $();
    id();
    Qo();
    Ks();
    rI();
    (Eje = async (e, t) => {
      let r = G(e, t),
        o = g({}, k, {
          [Gt]: e[qt],
          [te]: e[ee],
          [tAt]: [() => k(e[Zqe]), () => dr(e[Zqe]).toString()],
        });
      r.bp("/{Key+}"),
        r.p("Bucket", () => e.Bucket, "{Bucket}", !1),
        r.p("Key", () => e.Key, "{Key+}", !0);
      let n = g({
        [_o]: [, "AbortMultipartUpload"],
        [ix]: [, F(e[Rn], "UploadId")],
      });
      return (
        r
          .m("DELETE")
          .h(o)
          .q(n)
          .b(void 0),
        r.build()
      );
    }),
      (Sje = async (e, t) => {
        let r = G(e, t),
          o = g({}, k, {
            "content-type": "application/xml",
            [Fm]: e[rr],
            [Um]: e[or],
            [$m]: e[nr],
            [Hm]: e[sr],
            [zm]: e[ir],
            [Wp]: e[ar],
            [sAt]: [() => k(e[nje]), () => e[nje].toString()],
            [Gt]: e[qt],
            [te]: e[ee],
            [jp]: e[Xy],
            [nx]: e[CP],
            [Co]: e[so],
            [Zs]: e[Js],
            [bo]: e[io],
          });
        r.bp("/{Key+}"),
          r.p("Bucket", () => e.Bucket, "{Bucket}", !1),
          r.p("Key", () => e.Key, "{Key+}", !0);
        let n = g({ [ix]: [, F(e[Rn], "UploadId")] }),
          i,
          a;
        return (
          e.MultipartUpload !== void 0 &&
            ((a = Kyt(e.MultipartUpload, t)),
            (a = a.n("CompleteMultipartUpload")),
            (i = jt),
            a.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/"),
            (i += a.toString())),
          r.m("POST").h(o).q(n).b(i),
          r.build()
        );
      }),
      (Cje = async (e, t) => {
        let r = G(e, t),
          o = g({}, k, {
            ...(e.Metadata !== void 0 &&
              Object.keys(e.Metadata).reduce(
                (a, c) => (
                  (a[`x-amz-meta-${c.toLowerCase()}`] = e.Metadata[c]), a
                ),
                {}
              )),
            [Vp]: e[Dp],
            [Zy]: e[Np],
            [pq]: e[et],
            [ex]: e[Bp],
            [tx]: e[Mp],
            [rx]: e[Lp],
            [ox]: e[Fp],
            [CWe]: e[b8e],
            [bWe]: e[_8e],
            [_We]: [() => k(e[sP]), () => dr(e[sP]).toString()],
            [wWe]: e[w8e],
            [TWe]: [() => k(e[iP]), () => dr(e[iP]).toString()],
            [Dm]: [() => k(e[ki]), () => dr(e[ki]).toString()],
            [Kp]: e[Up],
            [Yp]: e[$p],
            [Qp]: e[Hp],
            [Xp]: e[zp],
            [nAt]: e[L_t],
            [EAt]: e[Mwt],
            [Fn]: e[en],
            [mx]: e[tt],
            [lx]: e[Jy],
            [Co]: e[so],
            [Zs]: e[Js],
            [bo]: e[io],
            [Un]: e[Do],
            [Bc]: e[Nc],
            [Br]: [() => k(e[ur]), () => e[ur].toString()],
            [AWe]: e[T8e],
            [RWe]: e[A8e],
            [IWe]: e[R8e],
            [Gt]: e[qt],
            [xq]: e[Pm],
            [dx]: e[qp],
            [Nm]: [() => k(e[Di]), () => wc(e[Di]).toString()],
            [cx]: e[Mm],
            [te]: e[ee],
            [kWe]: e[v8e],
          });
        r.bp("/{Key+}"),
          r.p("Bucket", () => e.Bucket, "{Bucket}", !1),
          r.p("Key", () => e.Key, "{Key+}", !0);
        let n = g({ [_o]: [, "CopyObject"] });
        return (
          r
            .m("PUT")
            .h(o)
            .q(n)
            .b(void 0),
          r.build()
        );
      }),
      (bje = async (e, t) => {
        let r = G(e, t),
          o = g({}, k, {
            "content-type": "application/xml",
            [Vp]: e[Dp],
            [Kp]: e[Up],
            [Yp]: e[$p],
            [Qp]: e[Hp],
            [hq]: e[W2],
            [Xp]: e[zp],
            [uTt]: [() => k(e[ije]), () => e[ije].toString()],
            [cAt]: e[Ky],
          });
        r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
        let n, i;
        return (
          e.CreateBucketConfiguration !== void 0 &&
            ((i = txt(e.CreateBucketConfiguration, t)),
            (n = jt),
            i.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/"),
            (n += i.toString())),
          r.m("PUT").h(o).b(n),
          r.build()
        );
      }),
      (_je = async (e, t) => {
        let r = G(e, t),
          o = g({}, k, {
            "content-type": "application/xml",
            [Xr]: e[Qr],
            [br]: e[et],
            [te]: e[ee],
          });
        r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
        let n = g({ [iq]: [, ""] }),
          i,
          a;
        return (
          e.MetadataTableConfiguration !== void 0 &&
            ((a = Hxt(e.MetadataTableConfiguration, t)),
            (i = jt),
            a.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/"),
            (i += a.toString())),
          r.m("POST").h(o).q(n).b(i),
          r.build()
        );
      }),
      (wje = async (e, t) => {
        let r = G(e, t),
          o = g({}, k, {
            ...(e.Metadata !== void 0 &&
              Object.keys(e.Metadata).reduce(
                (a, c) => (
                  (a[`x-amz-meta-${c.toLowerCase()}`] = e.Metadata[c]), a
                ),
                {}
              )),
            [Vp]: e[Dp],
            [Zy]: e[Np],
            [ex]: e[Bp],
            [tx]: e[Mp],
            [rx]: e[Lp],
            [ox]: e[Fp],
            [Dm]: [() => k(e[ki]), () => dr(e[ki]).toString()],
            [Kp]: e[Up],
            [Yp]: e[$p],
            [Qp]: e[Hp],
            [Xp]: e[zp],
            [Fn]: e[en],
            [mx]: e[tt],
            [lx]: e[Jy],
            [Co]: e[so],
            [Zs]: e[Js],
            [bo]: e[io],
            [Un]: e[Do],
            [Bc]: e[Nc],
            [Br]: [() => k(e[ur]), () => e[ur].toString()],
            [Gt]: e[qt],
            [xq]: e[Pm],
            [dx]: e[qp],
            [Nm]: [() => k(e[Di]), () => wc(e[Di]).toString()],
            [cx]: e[Mm],
            [te]: e[ee],
            [pq]: e[et],
            [Wp]: e[ar],
          });
        r.bp("/{Key+}"),
          r.p("Bucket", () => e.Bucket, "{Bucket}", !1),
          r.p("Key", () => e.Key, "{Key+}", !0);
        let n = g({ [gWe]: [, ""] });
        return (
          r
            .m("POST")
            .h(o)
            .q(n)
            .b(void 0),
          r.build()
        );
      }),
      (Tje = async (e, t) => {
        let r = G(e, t),
          o = g({}, k, {
            [gTt]: e[Pwt],
            [Fn]: e[en],
            [Un]: e[Do],
            [Bc]: e[Nc],
            [Br]: [() => k(e[ur]), () => e[ur].toString()],
          });
        r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
        let n = g({ [rTt]: [, ""] });
        return (
          r
            .m("GET")
            .h(o)
            .q(n)
            .b(void 0),
          r.build()
        );
      }),
      (Aje = async (e, t) => {
        let r = G(e, t),
          o = g({}, k, { [te]: e[ee] });
        return (
          r.bp("/"),
          r.p("Bucket", () => e.Bucket, "{Bucket}", !1),
          r
            .m("DELETE")
            .h(o)
            .b(void 0),
          r.build()
        );
      }),
      (Rje = async (e, t) => {
        let r = G(e, t),
          o = g({}, k, { [te]: e[ee] });
        r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
        let n = g({ [bP]: [, ""], [As]: [, F(e[ke], "Id")] });
        return (
          r
            .m("DELETE")
            .h(o)
            .q(n)
            .b(void 0),
          r.build()
        );
      }),
      (Ije = async (e, t) => {
        let r = G(e, t),
          o = g({}, k, { [te]: e[ee] });
        r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
        let n = g({ [tq]: [, ""] });
        return (
          r
            .m("DELETE")
            .h(o)
            .q(n)
            .b(void 0),
          r.build()
        );
      }),
      (Pje = async (e, t) => {
        let r = G(e, t),
          o = g({}, k, { [te]: e[ee] });
        r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
        let n = g({ [rq]: [, ""] });
        return (
          r
            .m("DELETE")
            .h(o)
            .q(n)
            .b(void 0),
          r.build()
        );
      }),
      (vje = async (e, t) => {
        let r = G(e, t),
          o = g({}, k, { [te]: e[ee] });
        r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
        let n = g({ [IP]: [, ""], [As]: [, F(e[ke], "Id")] });
        return (
          r
            .m("DELETE")
            .h(o)
            .q(n)
            .b(void 0),
          r.build()
        );
      }),
      (Oje = async (e, t) => {
        let r = G(e, t),
          o = g({}, k, { [te]: e[ee] });
        r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
        let n = g({ [RP]: [, ""], [As]: [, F(e[ke], "Id")] });
        return (
          r
            .m("DELETE")
            .h(o)
            .q(n)
            .b(void 0),
          r.build()
        );
      }),
      (kje = async (e, t) => {
        let r = G(e, t),
          o = g({}, k, { [te]: e[ee] });
        r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
        let n = g({ [sq]: [, ""] });
        return (
          r
            .m("DELETE")
            .h(o)
            .q(n)
            .b(void 0),
          r.build()
        );
      }),
      (Dje = async (e, t) => {
        let r = G(e, t),
          o = g({}, k, { [te]: e[ee] });
        r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
        let n = g({ [iq]: [, ""] });
        return (
          r
            .m("DELETE")
            .h(o)
            .q(n)
            .b(void 0),
          r.build()
        );
      }),
      (Nje = async (e, t) => {
        let r = G(e, t),
          o = g({}, k, { [te]: e[ee] });
        r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
        let n = g({ [PP]: [, ""], [As]: [, F(e[ke], "Id")] });
        return (
          r
            .m("DELETE")
            .h(o)
            .q(n)
            .b(void 0),
          r.build()
        );
      }),
      (Bje = async (e, t) => {
        let r = G(e, t),
          o = g({}, k, { [te]: e[ee] });
        r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
        let n = g({ [cq]: [, ""] });
        return (
          r
            .m("DELETE")
            .h(o)
            .q(n)
            .b(void 0),
          r.build()
        );
      }),
      (Mje = async (e, t) => {
        let r = G(e, t),
          o = g({}, k, { [te]: e[ee] });
        r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
        let n = g({ [dq]: [, ""] });
        return (
          r
            .m("DELETE")
            .h(o)
            .q(n)
            .b(void 0),
          r.build()
        );
      }),
      (Lje = async (e, t) => {
        let r = G(e, t),
          o = g({}, k, { [te]: e[ee] });
        r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
        let n = g({ [lq]: [, ""] });
        return (
          r
            .m("DELETE")
            .h(o)
            .q(n)
            .b(void 0),
          r.build()
        );
      }),
      (Fje = async (e, t) => {
        let r = G(e, t),
          o = g({}, k, { [te]: e[ee] });
        r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
        let n = g({ [Gp]: [, ""] });
        return (
          r
            .m("DELETE")
            .h(o)
            .q(n)
            .b(void 0),
          r.build()
        );
      }),
      (Uje = async (e, t) => {
        let r = G(e, t),
          o = g({}, k, { [te]: e[ee] });
        r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
        let n = g({ [fq]: [, ""] });
        return (
          r
            .m("DELETE")
            .h(o)
            .q(n)
            .b(void 0),
          r.build()
        );
      }),
      ($je = async (e, t) => {
        let r = G(e, t),
          o = g({}, k, {
            [gq]: e[K2],
            [Gt]: e[qt],
            [uq]: [() => k(e[Ap]), () => e[Ap].toString()],
            [te]: e[ee],
            [jp]: e[Xy],
            [rAt]: [() => k(e[eje]), () => dr(e[eje]).toString()],
            [oAt]: [() => k(e[tje]), () => e[tje].toString()],
          });
        r.bp("/{Key+}"),
          r.p("Bucket", () => e.Bucket, "{Bucket}", !1),
          r.p("Key", () => e.Key, "{Key+}", !0);
        let n = g({ [_o]: [, "DeleteObject"], [In]: [, e[st]] });
        return (
          r
            .m("DELETE")
            .h(o)
            .q(n)
            .b(void 0),
          r.build()
        );
      }),
      (Hje = async (e, t) => {
        let r = G(e, t),
          o = g({}, k, {
            "content-type": "application/xml",
            [gq]: e[K2],
            [Gt]: e[qt],
            [uq]: [() => k(e[Ap]), () => e[Ap].toString()],
            [te]: e[ee],
            [br]: e[et],
          });
        r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
        let n = g({ [jwt]: [, ""] }),
          i,
          a;
        return (
          e.Delete !== void 0 &&
            ((a = sxt(e.Delete, t)),
            (i = jt),
            a.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/"),
            (i += a.toString())),
          r.m("POST").h(o).q(n).b(i),
          r.build()
        );
      }),
      (zje = async (e, t) => {
        let r = G(e, t),
          o = g({}, k, { [te]: e[ee] });
        r.bp("/{Key+}"),
          r.p("Bucket", () => e.Bucket, "{Bucket}", !1),
          r.p("Key", () => e.Key, "{Key+}", !0);
        let n = g({ [Gp]: [, ""], [In]: [, e[st]] });
        return (
          r
            .m("DELETE")
            .h(o)
            .q(n)
            .b(void 0),
          r.build()
        );
      }),
      (qje = async (e, t) => {
        let r = G(e, t),
          o = g({}, k, { [te]: e[ee] });
        r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
        let n = g({ [mq]: [, ""] });
        return (
          r
            .m("DELETE")
            .h(o)
            .q(n)
            .b(void 0),
          r.build()
        );
      }),
      (jje = async (e, t) => {
        let r = G(e, t),
          o = g({}, k, { [te]: e[ee], [Gt]: e[qt] });
        r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
        let n = g({ [X8e]: [, ""] });
        return (
          r
            .m("GET")
            .h(o)
            .q(n)
            .b(void 0),
          r.build()
        );
      }),
      (Gje = async (e, t) => {
        let r = G(e, t),
          o = g({}, k, { [te]: e[ee] });
        r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
        let n = g({ [_P]: [, ""] });
        return (
          r
            .m("GET")
            .h(o)
            .q(n)
            .b(void 0),
          r.build()
        );
      }),
      (Vje = async (e, t) => {
        let r = G(e, t),
          o = g({}, k, { [te]: e[ee] });
        r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
        let n = g({
          [bP]: [, ""],
          [_o]: [, "GetBucketAnalyticsConfiguration"],
          [As]: [, F(e[ke], "Id")],
        });
        return (
          r
            .m("GET")
            .h(o)
            .q(n)
            .b(void 0),
          r.build()
        );
      }),
      (Wje = async (e, t) => {
        let r = G(e, t),
          o = g({}, k, { [te]: e[ee] });
        r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
        let n = g({ [tq]: [, ""] });
        return (
          r
            .m("GET")
            .h(o)
            .q(n)
            .b(void 0),
          r.build()
        );
      }),
      (Kje = async (e, t) => {
        let r = G(e, t),
          o = g({}, k, { [te]: e[ee] });
        r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
        let n = g({ [rq]: [, ""] });
        return (
          r
            .m("GET")
            .h(o)
            .q(n)
            .b(void 0),
          r.build()
        );
      }),
      (Yje = async (e, t) => {
        let r = G(e, t),
          o = g({}, k, { [te]: e[ee] });
        r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
        let n = g({
          [IP]: [, ""],
          [_o]: [, "GetBucketIntelligentTieringConfiguration"],
          [As]: [, F(e[ke], "Id")],
        });
        return (
          r
            .m("GET")
            .h(o)
            .q(n)
            .b(void 0),
          r.build()
        );
      }),
      (Qje = async (e, t) => {
        let r = G(e, t),
          o = g({}, k, { [te]: e[ee] });
        r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
        let n = g({
          [RP]: [, ""],
          [_o]: [, "GetBucketInventoryConfiguration"],
          [As]: [, F(e[ke], "Id")],
        });
        return (
          r
            .m("GET")
            .h(o)
            .q(n)
            .b(void 0),
          r.build()
        );
      }),
      (Xje = async (e, t) => {
        let r = G(e, t),
          o = g({}, k, { [te]: e[ee] });
        r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
        let n = g({ [sq]: [, ""] });
        return (
          r
            .m("GET")
            .h(o)
            .q(n)
            .b(void 0),
          r.build()
        );
      }),
      (Jje = async (e, t) => {
        let r = G(e, t),
          o = g({}, k, { [te]: e[ee] });
        r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
        let n = g({ [oWe]: [, ""] });
        return (
          r
            .m("GET")
            .h(o)
            .q(n)
            .b(void 0),
          r.build()
        );
      }),
      (Zje = async (e, t) => {
        let r = G(e, t),
          o = g({}, k, { [te]: e[ee] });
        r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
        let n = g({ [nWe]: [, ""] });
        return (
          r
            .m("GET")
            .h(o)
            .q(n)
            .b(void 0),
          r.build()
        );
      }),
      (eGe = async (e, t) => {
        let r = G(e, t),
          o = g({}, k, { [te]: e[ee] });
        r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
        let n = g({ [iq]: [, ""] });
        return (
          r
            .m("GET")
            .h(o)
            .q(n)
            .b(void 0),
          r.build()
        );
      }),
      (tGe = async (e, t) => {
        let r = G(e, t),
          o = g({}, k, { [te]: e[ee] });
        r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
        let n = g({
          [PP]: [, ""],
          [_o]: [, "GetBucketMetricsConfiguration"],
          [As]: [, F(e[ke], "Id")],
        });
        return (
          r
            .m("GET")
            .h(o)
            .q(n)
            .b(void 0),
          r.build()
        );
      }),
      (rGe = async (e, t) => {
        let r = G(e, t),
          o = g({}, k, { [te]: e[ee] });
        r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
        let n = g({ [sWe]: [, ""] });
        return (
          r
            .m("GET")
            .h(o)
            .q(n)
            .b(void 0),
          r.build()
        );
      }),
      (oGe = async (e, t) => {
        let r = G(e, t),
          o = g({}, k, { [te]: e[ee] });
        r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
        let n = g({ [cq]: [, ""] });
        return (
          r
            .m("GET")
            .h(o)
            .q(n)
            .b(void 0),
          r.build()
        );
      }),
      (nGe = async (e, t) => {
        let r = G(e, t),
          o = g({}, k, { [te]: e[ee] });
        r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
        let n = g({ [dq]: [, ""] });
        return (
          r
            .m("GET")
            .h(o)
            .q(n)
            .b(void 0),
          r.build()
        );
      }),
      (sGe = async (e, t) => {
        let r = G(e, t),
          o = g({}, k, { [te]: e[ee] });
        r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
        let n = g({ [Jwt]: [, ""] });
        return (
          r
            .m("GET")
            .h(o)
            .q(n)
            .b(void 0),
          r.build()
        );
      }),
      (iGe = async (e, t) => {
        let r = G(e, t),
          o = g({}, k, { [te]: e[ee] });
        r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
        let n = g({ [lq]: [, ""] });
        return (
          r
            .m("GET")
            .h(o)
            .q(n)
            .b(void 0),
          r.build()
        );
      }),
      (aGe = async (e, t) => {
        let r = G(e, t),
          o = g({}, k, { [te]: e[ee] });
        r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
        let n = g({ [aWe]: [, ""] });
        return (
          r
            .m("GET")
            .h(o)
            .q(n)
            .b(void 0),
          r.build()
        );
      }),
      (cGe = async (e, t) => {
        let r = G(e, t),
          o = g({}, k, { [te]: e[ee] });
        r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
        let n = g({ [Gp]: [, ""] });
        return (
          r
            .m("GET")
            .h(o)
            .q(n)
            .b(void 0),
          r.build()
        );
      }),
      (dGe = async (e, t) => {
        let r = G(e, t),
          o = g({}, k, { [te]: e[ee] });
        r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
        let n = g({ [yWe]: [, ""] });
        return (
          r
            .m("GET")
            .h(o)
            .q(n)
            .b(void 0),
          r.build()
        );
      }),
      (mGe = async (e, t) => {
        let r = G(e, t),
          o = g({}, k, { [te]: e[ee] });
        r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
        let n = g({ [fq]: [, ""] });
        return (
          r
            .m("GET")
            .h(o)
            .q(n)
            .b(void 0),
          r.build()
        );
      }),
      (lGe = async (e, t) => {
        let r = G(e, t),
          o = g({}, k, {
            [jp]: e[Xy],
            [oq]: [() => k(e[aP]), () => dr(e[aP]).toString()],
            [nx]: e[CP],
            [nq]: [() => k(e[cP]), () => dr(e[cP]).toString()],
            [cWe]: e[$8e],
            [Co]: e[so],
            [Zs]: e[Js],
            [bo]: e[io],
            [Gt]: e[qt],
            [te]: e[ee],
            [SWe]: e[C8e],
          });
        r.bp("/{Key+}"),
          r.p("Bucket", () => e.Bucket, "{Bucket}", !1),
          r.p("Key", () => e.Key, "{Key+}", !0);
        let n = g({
          [_o]: [, "GetObject"],
          [dWe]: [, e[H8e]],
          [mWe]: [, e[z8e]],
          [lWe]: [, e[q8e]],
          [fWe]: [, e[j8e]],
          [uWe]: [, e[G8e]],
          [pWe]: [
            () => e.ResponseExpires !== void 0,
            () => dr(e[V8e]).toString(),
          ],
          [In]: [, e[st]],
          [vP]: [() => e.PartNumber !== void 0, () => e[wn].toString()],
        });
        return (
          r
            .m("GET")
            .h(o)
            .q(n)
            .b(void 0),
          r.build()
        );
      }),
      (fGe = async (e, t) => {
        let r = G(e, t),
          o = g({}, k, { [Gt]: e[qt], [te]: e[ee] });
        r.bp("/{Key+}"),
          r.p("Bucket", () => e.Bucket, "{Bucket}", !1),
          r.p("Key", () => e.Key, "{Key+}", !0);
        let n = g({ [_P]: [, ""], [In]: [, e[st]] });
        return (
          r
            .m("GET")
            .h(o)
            .q(n)
            .b(void 0),
          r.build()
        );
      }),
      (uGe = async (e, t) => {
        let r = G(e, t),
          o = g({}, k, {
            [iAt]: [() => k(e[pa]), () => e[pa].toString()],
            [dAt]: e[Pc],
            [Co]: e[so],
            [Zs]: e[Js],
            [bo]: e[io],
            [Gt]: e[qt],
            [te]: e[ee],
            [aAt]: [() => k(e[sje]), () => (e[sje] || []).map(pl).join(", ")],
          });
        r.bp("/{Key+}"),
          r.p("Bucket", () => e.Bucket, "{Bucket}", !1),
          r.p("Key", () => e.Key, "{Key+}", !0);
        let n = g({ [zwt]: [, ""], [In]: [, e[st]] });
        return (
          r
            .m("GET")
            .h(o)
            .q(n)
            .b(void 0),
          r.build()
        );
      }),
      (pGe = async (e, t) => {
        let r = G(e, t),
          o = g({}, k, { [Gt]: e[qt], [te]: e[ee] });
        r.bp("/{Key+}"),
          r.p("Bucket", () => e.Bucket, "{Bucket}", !1),
          r.p("Key", () => e.Key, "{Key+}", !0);
        let n = g({ [rWe]: [, ""], [In]: [, e[st]] });
        return (
          r
            .m("GET")
            .h(o)
            .q(n)
            .b(void 0),
          r.build()
        );
      }),
      (hGe = async (e, t) => {
        let r = G(e, t),
          o = g({}, k, { [te]: e[ee] });
        r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
        let n = g({ [iWe]: [, ""] });
        return (
          r
            .m("GET")
            .h(o)
            .q(n)
            .b(void 0),
          r.build()
        );
      }),
      (gGe = async (e, t) => {
        let r = G(e, t),
          o = g({}, k, { [Gt]: e[qt], [te]: e[ee] });
        r.bp("/{Key+}"),
          r.p("Bucket", () => e.Bucket, "{Bucket}", !1),
          r.p("Key", () => e.Key, "{Key+}", !0);
        let n = g({ [hWe]: [, ""], [In]: [, e[st]] });
        return (
          r
            .m("GET")
            .h(o)
            .q(n)
            .b(void 0),
          r.build()
        );
      }),
      (yGe = async (e, t) => {
        let r = G(e, t),
          o = g({}, k, { [te]: e[ee], [Gt]: e[qt] });
        r.bp("/{Key+}"),
          r.p("Bucket", () => e.Bucket, "{Bucket}", !1),
          r.p("Key", () => e.Key, "{Key+}", !0);
        let n = g({ [Gp]: [, ""], [In]: [, e[st]] });
        return (
          r
            .m("GET")
            .h(o)
            .q(n)
            .b(void 0),
          r.build()
        );
      }),
      (xGe = async (e, t) => {
        let r = G(e, t),
          o = g({}, k, { [Gt]: e[qt], [te]: e[ee] });
        r.bp("/{Key+}"),
          r.p("Bucket", () => e.Bucket, "{Bucket}", !1),
          r.p("Key", () => e.Key, "{Key+}", !0);
        let n = g({ [iTt]: [, ""] });
        return (
          r
            .m("GET")
            .h(o)
            .q(n)
            .b(void 0),
          r.build()
        );
      }),
      (EGe = async (e, t) => {
        let r = G(e, t),
          o = g({}, k, { [te]: e[ee] });
        r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
        let n = g({ [mq]: [, ""] });
        return (
          r
            .m("GET")
            .h(o)
            .q(n)
            .b(void 0),
          r.build()
        );
      }),
      (SGe = async (e, t) => {
        let r = G(e, t),
          o = g({}, k, { [te]: e[ee] });
        return (
          r.bp("/"),
          r.p("Bucket", () => e.Bucket, "{Bucket}", !1),
          r
            .m("HEAD")
            .h(o)
            .b(void 0),
          r.build()
        );
      }),
      (CGe = async (e, t) => {
        let r = G(e, t),
          o = g({}, k, {
            [jp]: e[Xy],
            [oq]: [() => k(e[aP]), () => dr(e[aP]).toString()],
            [nx]: e[CP],
            [nq]: [() => k(e[cP]), () => dr(e[cP]).toString()],
            [cWe]: e[$8e],
            [Co]: e[so],
            [Zs]: e[Js],
            [bo]: e[io],
            [Gt]: e[qt],
            [te]: e[ee],
            [SWe]: e[C8e],
          });
        r.bp("/{Key+}"),
          r.p("Bucket", () => e.Bucket, "{Bucket}", !1),
          r.p("Key", () => e.Key, "{Key+}", !0);
        let n = g({
          [dWe]: [, e[H8e]],
          [mWe]: [, e[z8e]],
          [lWe]: [, e[q8e]],
          [fWe]: [, e[j8e]],
          [uWe]: [, e[G8e]],
          [pWe]: [
            () => e.ResponseExpires !== void 0,
            () => dr(e[V8e]).toString(),
          ],
          [In]: [, e[st]],
          [vP]: [() => e.PartNumber !== void 0, () => e[wn].toString()],
        });
        return (
          r
            .m("HEAD")
            .h(o)
            .q(n)
            .b(void 0),
          r.build()
        );
      }),
      (bGe = async (e, t) => {
        let r = G(e, t),
          o = g({}, k, { [te]: e[ee] });
        r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
        let n = g({
          [bP]: [, ""],
          [_o]: [, "ListBucketAnalyticsConfigurations"],
          [Lm]: [, e[Yt]],
        });
        return (
          r
            .m("GET")
            .h(o)
            .q(n)
            .b(void 0),
          r.build()
        );
      }),
      (_Ge = async (e, t) => {
        let r = G(e, t),
          o = g({}, k, { [te]: e[ee] });
        r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
        let n = g({
          [IP]: [, ""],
          [_o]: [, "ListBucketIntelligentTieringConfigurations"],
          [Lm]: [, e[Yt]],
        });
        return (
          r
            .m("GET")
            .h(o)
            .q(n)
            .b(void 0),
          r.build()
        );
      }),
      (wGe = async (e, t) => {
        let r = G(e, t),
          o = g({}, k, { [te]: e[ee] });
        r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
        let n = g({
          [RP]: [, ""],
          [_o]: [, "ListBucketInventoryConfigurations"],
          [Lm]: [, e[Yt]],
        });
        return (
          r
            .m("GET")
            .h(o)
            .q(n)
            .b(void 0),
          r.build()
        );
      }),
      (TGe = async (e, t) => {
        let r = G(e, t),
          o = g({}, k, { [te]: e[ee] });
        r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
        let n = g({
          [PP]: [, ""],
          [_o]: [, "ListBucketMetricsConfigurations"],
          [Lm]: [, e[Yt]],
        });
        return (
          r
            .m("GET")
            .h(o)
            .q(n)
            .b(void 0),
          r.build()
        );
      }),
      (AGe = async (e, t) => {
        let r = G(e, t),
          o = {};
        r.bp("/");
        let n = g({
          [_o]: [, "ListBuckets"],
          [Kwt]: [() => e.MaxBuckets !== void 0, () => e[M_t].toString()],
          [Lm]: [, e[Yt]],
          [sx]: [, e[se]],
          [qwt]: [, e[Vy]],
        });
        return (
          r
            .m("GET")
            .h(o)
            .q(n)
            .b(void 0),
          r.build()
        );
      }),
      (RGe = async (e, t) => {
        let r = G(e, t),
          o = {};
        r.bp("/");
        let n = g({
          [_o]: [, "ListDirectoryBuckets"],
          [Lm]: [, e[Yt]],
          [Ywt]: [
            () => e.MaxDirectoryBuckets !== void 0,
            () => e[F_t].toString(),
          ],
        });
        return (
          r
            .m("GET")
            .h(o)
            .q(n)
            .b(void 0),
          r.build()
        );
      }),
      (IGe = async (e, t) => {
        let r = G(e, t),
          o = g({}, k, { [te]: e[ee], [Gt]: e[qt] });
        r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
        let n = g({
          [gWe]: [, ""],
          [wP]: [, e[Jo]],
          [TP]: [, e[Zo]],
          [tWe]: [, e[Ic]],
          [Xwt]: [() => e.MaxUploads !== void 0, () => e[LI].toString()],
          [sx]: [, e[se]],
          [aTt]: [, e[rP]],
        });
        return (
          r
            .m("GET")
            .h(o)
            .q(n)
            .b(void 0),
          r.build()
        );
      }),
      (PGe = async (e, t) => {
        let r = G(e, t),
          o = g({}, k, {
            [Gt]: e[qt],
            [te]: e[ee],
            [yq]: [() => k(e[Rp]), () => (e[Rp] || []).map(pl).join(", ")],
          });
        r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
        let n = g({
          [wP]: [, e[Jo]],
          [TP]: [, e[Zo]],
          [Wwt]: [, e[BI]],
          [aq]: [() => e.MaxKeys !== void 0, () => e[xs].toString()],
          [sx]: [, e[se]],
        });
        return (
          r
            .m("GET")
            .h(o)
            .q(n)
            .b(void 0),
          r.build()
        );
      }),
      (vGe = async (e, t) => {
        let r = G(e, t),
          o = g({}, k, {
            [Gt]: e[qt],
            [te]: e[ee],
            [yq]: [() => k(e[Rp]), () => (e[Rp] || []).map(pl).join(", ")],
          });
        r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
        let n = g({
          [Vwt]: [, "2"],
          [wP]: [, e[Jo]],
          [TP]: [, e[Zo]],
          [aq]: [() => e.MaxKeys !== void 0, () => e[xs].toString()],
          [sx]: [, e[se]],
          [Lm]: [, e[Yt]],
          [Gwt]: [() => e.FetchOwner !== void 0, () => e[o_t].toString()],
          [oTt]: [, e[KI]],
        });
        return (
          r
            .m("GET")
            .h(o)
            .q(n)
            .b(void 0),
          r.build()
        );
      }),
      (OGe = async (e, t) => {
        let r = G(e, t),
          o = g({}, k, {
            [te]: e[ee],
            [Gt]: e[qt],
            [yq]: [() => k(e[Rp]), () => (e[Rp] || []).map(pl).join(", ")],
          });
        r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
        let n = g({
          [cTt]: [, ""],
          [wP]: [, e[Jo]],
          [TP]: [, e[Zo]],
          [tWe]: [, e[Ic]],
          [aq]: [() => e.MaxKeys !== void 0, () => e[xs].toString()],
          [sx]: [, e[se]],
          [dTt]: [, e[nP]],
        });
        return (
          r
            .m("GET")
            .h(o)
            .q(n)
            .b(void 0),
          r.build()
        );
      }),
      (kGe = async (e, t) => {
        let r = G(e, t),
          o = g({}, k, {
            [Gt]: e[qt],
            [te]: e[ee],
            [Co]: e[so],
            [Zs]: e[Js],
            [bo]: e[io],
          });
        r.bp("/{Key+}"),
          r.p("Bucket", () => e.Bucket, "{Bucket}", !1),
          r.p("Key", () => e.Key, "{Key+}", !0);
        let n = g({
          [_o]: [, "ListParts"],
          [Qwt]: [() => e.MaxParts !== void 0, () => e[pa].toString()],
          [Zwt]: [, e[Pc]],
          [ix]: [, F(e[Rn], "UploadId")],
        });
        return (
          r
            .m("GET")
            .h(o)
            .q(n)
            .b(void 0),
          r.build()
        );
      }),
      (DGe = async (e, t) => {
        let r = G(e, t),
          o = g({}, k, {
            "content-type": "application/xml",
            [te]: e[ee],
            [br]: e[et],
          });
        r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
        let n = g({ [X8e]: [, ""] }),
          i,
          a;
        return (
          e.AccelerateConfiguration !== void 0 &&
            ((a = Byt(e.AccelerateConfiguration, t)),
            (i = jt),
            a.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/"),
            (i += a.toString())),
          r.m("PUT").h(o).q(n).b(i),
          r.build()
        );
      }),
      (NGe = async (e, t) => {
        let r = G(e, t),
          o = g({}, k, {
            "content-type": "application/xml",
            [Vp]: e[Dp],
            [Xr]: e[Qr],
            [br]: e[et],
            [Kp]: e[Up],
            [Yp]: e[$p],
            [Qp]: e[Hp],
            [hq]: e[W2],
            [Xp]: e[zp],
            [te]: e[ee],
          });
        r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
        let n = g({ [_P]: [, ""] }),
          i,
          a;
        return (
          e.AccessControlPolicy !== void 0 &&
            ((a = t8e(e.AccessControlPolicy, t)),
            (i = jt),
            a.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/"),
            (i += a.toString())),
          r.m("PUT").h(o).q(n).b(i),
          r.build()
        );
      }),
      (BGe = async (e, t) => {
        let r = G(e, t),
          o = g({}, k, { "content-type": "application/xml", [te]: e[ee] });
        r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
        let n = g({ [bP]: [, ""], [As]: [, F(e[ke], "Id")] }),
          i,
          a;
        return (
          e.AnalyticsConfiguration !== void 0 &&
            ((a = Hyt(e.AnalyticsConfiguration, t)),
            (i = jt),
            a.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/"),
            (i += a.toString())),
          r.m("PUT").h(o).q(n).b(i),
          r.build()
        );
      }),
      (MGe = async (e, t) => {
        let r = G(e, t),
          o = g({}, k, {
            "content-type": "application/xml",
            [Xr]: e[Qr],
            [br]: e[et],
            [te]: e[ee],
          });
        r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
        let n = g({ [tq]: [, ""] }),
          i,
          a;
        return (
          e.CORSConfiguration !== void 0 &&
            ((a = Jyt(e.CORSConfiguration, t)),
            (i = jt),
            a.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/"),
            (i += a.toString())),
          r.m("PUT").h(o).q(n).b(i),
          r.build()
        );
      }),
      (LGe = async (e, t) => {
        let r = G(e, t),
          o = g({}, k, {
            "content-type": "application/xml",
            [Xr]: e[Qr],
            [br]: e[et],
            [te]: e[ee],
          });
        r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
        let n = g({ [rq]: [, ""] }),
          i,
          a;
        return (
          e.ServerSideEncryptionConfiguration !== void 0 &&
            ((a = kEt(e.ServerSideEncryptionConfiguration, t)),
            (i = jt),
            a.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/"),
            (i += a.toString())),
          r.m("PUT").h(o).q(n).b(i),
          r.build()
        );
      }),
      (FGe = async (e, t) => {
        let r = G(e, t),
          o = g({}, k, { "content-type": "application/xml", [te]: e[ee] });
        r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
        let n = g({ [IP]: [, ""], [As]: [, F(e[ke], "Id")] }),
          i,
          a;
        return (
          e.IntelligentTieringConfiguration !== void 0 &&
            ((a = Sxt(e.IntelligentTieringConfiguration, t)),
            (i = jt),
            a.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/"),
            (i += a.toString())),
          r.m("PUT").h(o).q(n).b(i),
          r.build()
        );
      }),
      (UGe = async (e, t) => {
        let r = G(e, t),
          o = g({}, k, { "content-type": "application/xml", [te]: e[ee] });
        r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
        let n = g({ [RP]: [, ""], [As]: [, F(e[ke], "Id")] }),
          i,
          a;
        return (
          e.InventoryConfiguration !== void 0 &&
            ((a = bxt(e.InventoryConfiguration, t)),
            (i = jt),
            a.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/"),
            (i += a.toString())),
          r.m("PUT").h(o).q(n).b(i),
          r.build()
        );
      }),
      ($Ge = async (e, t) => {
        let r = G(e, t),
          o = g({}, k, {
            "content-type": "application/xml",
            [br]: e[et],
            [te]: e[ee],
            [Eq]: e[eq],
          });
        r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
        let n = g({ [sq]: [, ""] }),
          i,
          a;
        return (
          e.LifecycleConfiguration !== void 0 &&
            ((a = Vyt(e.LifecycleConfiguration, t)),
            (a = a.n("LifecycleConfiguration")),
            (i = jt),
            a.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/"),
            (i += a.toString())),
          r.m("PUT").h(o).q(n).b(i),
          r.build()
        );
      }),
      (HGe = async (e, t) => {
        let r = G(e, t),
          o = g({}, k, {
            "content-type": "application/xml",
            [Xr]: e[Qr],
            [br]: e[et],
            [te]: e[ee],
          });
        r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
        let n = g({ [nWe]: [, ""] }),
          i,
          a;
        return (
          e.BucketLoggingStatus !== void 0 &&
            ((a = Wyt(e.BucketLoggingStatus, t)),
            (i = jt),
            a.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/"),
            (i += a.toString())),
          r.m("PUT").h(o).q(n).b(i),
          r.build()
        );
      }),
      (zGe = async (e, t) => {
        let r = G(e, t),
          o = g({}, k, { "content-type": "application/xml", [te]: e[ee] });
        r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
        let n = g({ [PP]: [, ""], [As]: [, F(e[ke], "Id")] }),
          i,
          a;
        return (
          e.MetricsConfiguration !== void 0 &&
            ((a = jxt(e.MetricsConfiguration, t)),
            (i = jt),
            a.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/"),
            (i += a.toString())),
          r.m("PUT").h(o).q(n).b(i),
          r.build()
        );
      }),
      (qGe = async (e, t) => {
        let r = G(e, t),
          o = g({}, k, {
            "content-type": "application/xml",
            [te]: e[ee],
            [xAt]: [() => k(e[cje]), () => e[cje].toString()],
          });
        r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
        let n = g({ [sWe]: [, ""] }),
          i,
          a;
        return (
          e.NotificationConfiguration !== void 0 &&
            ((a = Yxt(e.NotificationConfiguration, t)),
            (i = jt),
            a.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/"),
            (i += a.toString())),
          r.m("PUT").h(o).q(n).b(i),
          r.build()
        );
      }),
      (jGe = async (e, t) => {
        let r = G(e, t),
          o = g({}, k, {
            "content-type": "application/xml",
            [Xr]: e[Qr],
            [te]: e[ee],
            [br]: e[et],
          });
        r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
        let n = g({ [cq]: [, ""] }),
          i,
          a;
        return (
          e.OwnershipControls !== void 0 &&
            ((a = nEt(e.OwnershipControls, t)),
            (i = jt),
            a.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/"),
            (i += a.toString())),
          r.m("PUT").h(o).q(n).b(i),
          r.build()
        );
      }),
      (GGe = async (e, t) => {
        let r = G(e, t),
          o = g({}, k, {
            "content-type": "text/plain",
            [Xr]: e[Qr],
            [br]: e[et],
            [hTt]: [() => k(e[Wqe]), () => e[Wqe].toString()],
            [te]: e[ee],
          });
        r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
        let n = g({ [dq]: [, ""] }),
          i,
          a;
        return (
          e.Policy !== void 0 && ((a = e.Policy), (i = a)),
          r.m("PUT").h(o).q(n).b(i),
          r.build()
        );
      }),
      (VGe = async (e, t) => {
        let r = G(e, t),
          o = g({}, k, {
            "content-type": "application/xml",
            [Xr]: e[Qr],
            [br]: e[et],
            [EWe]: e[Y8e],
            [te]: e[ee],
          });
        r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
        let n = g({ [lq]: [, ""] }),
          i,
          a;
        return (
          e.ReplicationConfiguration !== void 0 &&
            ((a = hEt(e.ReplicationConfiguration, t)),
            (i = jt),
            a.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/"),
            (i += a.toString())),
          r.m("PUT").h(o).q(n).b(i),
          r.build()
        );
      }),
      (WGe = async (e, t) => {
        let r = G(e, t),
          o = g({}, k, {
            "content-type": "application/xml",
            [Xr]: e[Qr],
            [br]: e[et],
            [te]: e[ee],
          });
        r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
        let n = g({ [aWe]: [, ""] }),
          i,
          a;
        return (
          e.RequestPaymentConfiguration !== void 0 &&
            ((a = CEt(e.RequestPaymentConfiguration, t)),
            (i = jt),
            a.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/"),
            (i += a.toString())),
          r.m("PUT").h(o).q(n).b(i),
          r.build()
        );
      }),
      (KGe = async (e, t) => {
        let r = G(e, t),
          o = g({}, k, {
            "content-type": "application/xml",
            [Xr]: e[Qr],
            [br]: e[et],
            [te]: e[ee],
          });
        r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
        let n = g({ [Gp]: [, ""] }),
          i,
          a;
        return (
          e.Tagging !== void 0 &&
            ((a = z2(e.Tagging, t)),
            (i = jt),
            a.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/"),
            (i += a.toString())),
          r.m("PUT").h(o).q(n).b(i),
          r.build()
        );
      }),
      (YGe = async (e, t) => {
        let r = G(e, t),
          o = g({}, k, {
            "content-type": "application/xml",
            [Xr]: e[Qr],
            [br]: e[et],
            [gq]: e[K2],
            [te]: e[ee],
          });
        r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
        let n = g({ [yWe]: [, ""] }),
          i,
          a;
        return (
          e.VersioningConfiguration !== void 0 &&
            ((a = JEt(e.VersioningConfiguration, t)),
            (i = jt),
            a.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/"),
            (i += a.toString())),
          r.m("PUT").h(o).q(n).b(i),
          r.build()
        );
      }),
      (QGe = async (e, t) => {
        let r = G(e, t),
          o = g({}, k, {
            "content-type": "application/xml",
            [Xr]: e[Qr],
            [br]: e[et],
            [te]: e[ee],
          });
        r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
        let n = g({ [fq]: [, ""] }),
          i,
          a;
        return (
          e.WebsiteConfiguration !== void 0 &&
            ((a = ZEt(e.WebsiteConfiguration, t)),
            (i = jt),
            a.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/"),
            (i += a.toString())),
          r.m("PUT").h(o).q(n).b(i),
          r.build()
        );
      }),
      (XGe = async (e, t) => {
        let r = G(e, t),
          o = g({}, k, {
            ...(e.Metadata !== void 0 &&
              Object.keys(e.Metadata).reduce(
                (c, d) => (
                  (c[`x-amz-meta-${d.toLowerCase()}`] = e.Metadata[d]), c
                ),
                {}
              )),
            [ox]: e[Fp] || "application/octet-stream",
            [Vp]: e[Dp],
            [Zy]: e[Np],
            [ex]: e[Bp],
            [tx]: e[Mp],
            [rx]: e[Lp],
            [km]: [() => k(e[Oc]), () => e[Oc].toString()],
            [Xr]: e[Qr],
            [br]: e[et],
            [Fm]: e[rr],
            [Um]: e[or],
            [$m]: e[nr],
            [Hm]: e[sr],
            [zm]: e[ir],
            [Dm]: [() => k(e[ki]), () => dr(e[ki]).toString()],
            [jp]: e[Xy],
            [nx]: e[CP],
            [Kp]: e[Up],
            [Yp]: e[$p],
            [Qp]: e[Hp],
            [Xp]: e[zp],
            [SAt]: [() => k(e[hje]), () => e[hje].toString()],
            [Fn]: e[en],
            [mx]: e[tt],
            [lx]: e[Jy],
            [Co]: e[so],
            [Zs]: e[Js],
            [bo]: e[io],
            [Un]: e[Do],
            [Bc]: e[Nc],
            [Br]: [() => k(e[ur]), () => e[ur].toString()],
            [Gt]: e[qt],
            [xq]: e[Pm],
            [dx]: e[qp],
            [Nm]: [() => k(e[Di]), () => wc(e[Di]).toString()],
            [cx]: e[Mm],
            [te]: e[ee],
          });
        r.bp("/{Key+}"),
          r.p("Bucket", () => e.Bucket, "{Bucket}", !1),
          r.p("Key", () => e.Key, "{Key+}", !0);
        let n = g({ [_o]: [, "PutObject"] }),
          i,
          a;
        return (
          e.Body !== void 0 && ((a = e.Body), (i = a)),
          r.m("PUT").h(o).q(n).b(i),
          r.build()
        );
      }),
      (JGe = async (e, t) => {
        let r = G(e, t),
          o = g({}, k, {
            "content-type": "application/xml",
            [Vp]: e[Dp],
            [Xr]: e[Qr],
            [br]: e[et],
            [Kp]: e[Up],
            [Yp]: e[$p],
            [Qp]: e[Hp],
            [hq]: e[W2],
            [Xp]: e[zp],
            [Gt]: e[qt],
            [te]: e[ee],
          });
        r.bp("/{Key+}"),
          r.p("Bucket", () => e.Bucket, "{Bucket}", !1),
          r.p("Key", () => e.Key, "{Key+}", !0);
        let n = g({ [_P]: [, ""], [In]: [, e[st]] }),
          i,
          a;
        return (
          e.AccessControlPolicy !== void 0 &&
            ((a = t8e(e.AccessControlPolicy, t)),
            (i = jt),
            a.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/"),
            (i += a.toString())),
          r.m("PUT").h(o).q(n).b(i),
          r.build()
        );
      }),
      (ZGe = async (e, t) => {
        let r = G(e, t),
          o = g({}, k, {
            "content-type": "application/xml",
            [Gt]: e[qt],
            [Xr]: e[Qr],
            [br]: e[et],
            [te]: e[ee],
          });
        r.bp("/{Key+}"),
          r.p("Bucket", () => e.Bucket, "{Bucket}", !1),
          r.p("Key", () => e.Key, "{Key+}", !0);
        let n = g({ [rWe]: [, ""], [In]: [, e[st]] }),
          i,
          a;
        return (
          e.LegalHold !== void 0 &&
            ((a = Zxt(e.LegalHold, t)),
            (a = a.n("LegalHold")),
            (i = jt),
            a.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/"),
            (i += a.toString())),
          r.m("PUT").h(o).q(n).b(i),
          r.build()
        );
      }),
      (e4e = async (e, t) => {
        let r = G(e, t),
          o = g({}, k, {
            "content-type": "application/xml",
            [Gt]: e[qt],
            [EWe]: e[Y8e],
            [Xr]: e[Qr],
            [br]: e[et],
            [te]: e[ee],
          });
        r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
        let n = g({ [iWe]: [, ""] }),
          i,
          a;
        return (
          e.ObjectLockConfiguration !== void 0 &&
            ((a = Jxt(e.ObjectLockConfiguration, t)),
            (i = jt),
            a.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/"),
            (i += a.toString())),
          r.m("PUT").h(o).q(n).b(i),
          r.build()
        );
      }),
      (t4e = async (e, t) => {
        let r = G(e, t),
          o = g({}, k, {
            "content-type": "application/xml",
            [Gt]: e[qt],
            [uq]: [() => k(e[Ap]), () => e[Ap].toString()],
            [Xr]: e[Qr],
            [br]: e[et],
            [te]: e[ee],
          });
        r.bp("/{Key+}"),
          r.p("Bucket", () => e.Bucket, "{Bucket}", !1),
          r.p("Key", () => e.Key, "{Key+}", !0);
        let n = g({ [hWe]: [, ""], [In]: [, e[st]] }),
          i,
          a;
        return (
          e.Retention !== void 0 &&
            ((a = eEt(e.Retention, t)),
            (a = a.n("Retention")),
            (i = jt),
            a.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/"),
            (i += a.toString())),
          r.m("PUT").h(o).q(n).b(i),
          r.build()
        );
      }),
      (r4e = async (e, t) => {
        let r = G(e, t),
          o = g({}, k, {
            "content-type": "application/xml",
            [Xr]: e[Qr],
            [br]: e[et],
            [te]: e[ee],
            [Gt]: e[qt],
          });
        r.bp("/{Key+}"),
          r.p("Bucket", () => e.Bucket, "{Bucket}", !1),
          r.p("Key", () => e.Key, "{Key+}", !0);
        let n = g({ [Gp]: [, ""], [In]: [, e[st]] }),
          i,
          a;
        return (
          e.Tagging !== void 0 &&
            ((a = z2(e.Tagging, t)),
            (i = jt),
            a.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/"),
            (i += a.toString())),
          r.m("PUT").h(o).q(n).b(i),
          r.build()
        );
      }),
      (o4e = async (e, t) => {
        let r = G(e, t),
          o = g({}, k, {
            "content-type": "application/xml",
            [Xr]: e[Qr],
            [br]: e[et],
            [te]: e[ee],
          });
        r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
        let n = g({ [mq]: [, ""] }),
          i,
          a;
        return (
          e.PublicAccessBlockConfiguration !== void 0 &&
            ((a = dEt(e.PublicAccessBlockConfiguration, t)),
            (i = jt),
            a.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/"),
            (i += a.toString())),
          r.m("PUT").h(o).q(n).b(i),
          r.build()
        );
      }),
      (n4e = async (e, t) => {
        let r = G(e, t),
          o = g({}, k, {
            [fAt]: e[xwt],
            [jp]: e[Wbt],
            [nx]: e[Kbt],
            [oq]: [() => k(e[Kqe]), () => dr(e[Kqe]).toString()],
            [nq]: [() => k(e[Yqe]), () => dr(e[Yqe]).toString()],
            [uAt]: e[wwt],
            [hAt]: e[Twt],
            [pAt]: [() => k(e[dje]), () => dr(e[dje]).toString()],
            [gAt]: [() => k(e[mje]), () => dr(e[mje]).toString()],
            [xTt]: e[jbt] ?? qo(),
          });
        r.bp("/{Key+}"),
          r.p("Bucket", () => e.Bucket, "{Bucket}", !1),
          r.p("Key", () => e.Key, "{Key+}", !0);
        let n = g({ [eTt]: [, ""] });
        return (
          r
            .m("PUT")
            .h(o)
            .q(n)
            .b(void 0),
          r.build()
        );
      }),
      (s4e = async (e, t) => {
        let r = G(e, t),
          o = g({}, k, {
            "content-type": "application/xml",
            [Gt]: e[qt],
            [br]: e[et],
            [te]: e[ee],
          });
        r.bp("/{Key+}"),
          r.p("Bucket", () => e.Bucket, "{Bucket}", !1),
          r.p("Key", () => e.Key, "{Key+}", !0);
        let n = g({ [tTt]: [, ""], [In]: [, e[st]] }),
          i,
          a;
        return (
          e.RestoreRequest !== void 0 &&
            ((a = _Et(e.RestoreRequest, t)),
            (i = jt),
            a.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/"),
            (i += a.toString())),
          r.m("POST").h(o).q(n).b(i),
          r.build()
        );
      }),
      (i4e = async (e, t) => {
        let r = G(e, t),
          o = g({}, k, {
            "content-type": "application/xml",
            [Co]: e[so],
            [Zs]: e[Js],
            [bo]: e[io],
            [te]: e[ee],
          });
        r.bp("/{Key+}"),
          r.p("Bucket", () => e.Bucket, "{Bucket}", !1),
          r.p("Key", () => e.Key, "{Key+}", !0);
        let n = g({ [nTt]: [, ""], [sTt]: [, "2"] }),
          i;
        i = jt;
        let a = new C(vwt);
        return (
          a.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/"),
          a.cc(e, k8e),
          a.cc(e, O8e),
          e[pm] != null && a.c(n8e(e[pm], t).n(pm)),
          e[Em] != null && a.c(s8e(e[Em], t).n(Em)),
          e[VI] != null && a.c(bEt(e[VI], t).n(VI)),
          e[QI] != null && a.c(PEt(e[QI], t).n(QI)),
          (i += a.toString()),
          r.m("POST").h(o).q(n).b(i),
          r.build()
        );
      }),
      (a4e = async (e, t) => {
        let r = G(e, t),
          o = g({}, k, {
            "content-type": "application/octet-stream",
            [km]: [() => k(e[Oc]), () => e[Oc].toString()],
            [Xr]: e[Qr],
            [br]: e[et],
            [Fm]: e[rr],
            [Um]: e[or],
            [$m]: e[nr],
            [Hm]: e[sr],
            [zm]: e[ir],
            [Co]: e[so],
            [Zs]: e[Js],
            [bo]: e[io],
            [Gt]: e[qt],
            [te]: e[ee],
          });
        r.bp("/{Key+}"),
          r.p("Bucket", () => e.Bucket, "{Bucket}", !1),
          r.p("Key", () => e.Key, "{Key+}", !0);
        let n = g({
            [_o]: [, "UploadPart"],
            [vP]: [
              F(e.PartNumber, "PartNumber") != null,
              () => e[wn].toString(),
            ],
            [ix]: [, F(e[Rn], "UploadId")],
          }),
          i,
          a;
        return (
          e.Body !== void 0 && ((a = e.Body), (i = a)),
          r.m("PUT").h(o).q(n).b(i),
          r.build()
        );
      }),
      (c4e = async (e, t) => {
        let r = G(e, t),
          o = g({}, k, {
            [CWe]: e[b8e],
            [bWe]: e[_8e],
            [_We]: [() => k(e[sP]), () => dr(e[sP]).toString()],
            [wWe]: e[w8e],
            [TWe]: [() => k(e[iP]), () => dr(e[iP]).toString()],
            [yTt]: e[Hbt],
            [Co]: e[so],
            [Zs]: e[Js],
            [bo]: e[io],
            [AWe]: e[T8e],
            [RWe]: e[A8e],
            [IWe]: e[R8e],
            [Gt]: e[qt],
            [te]: e[ee],
            [kWe]: e[v8e],
          });
        r.bp("/{Key+}"),
          r.p("Bucket", () => e.Bucket, "{Bucket}", !1),
          r.p("Key", () => e.Key, "{Key+}", !0);
        let n = g({
          [_o]: [, "UploadPartCopy"],
          [vP]: [F(e.PartNumber, "PartNumber") != null, () => e[wn].toString()],
          [ix]: [, F(e[Rn], "UploadId")],
        });
        return (
          r
            .m("PUT")
            .h(o)
            .q(n)
            .b(void 0),
          r.build()
        );
      }),
      (d4e = async (e, t) => {
        let r = G(e, t),
          o = g({}, k, {
            "x-amz-content-sha256": "UNSIGNED-PAYLOAD",
            ...(e.Metadata !== void 0 &&
              Object.keys(e.Metadata).reduce(
                (c, d) => (
                  (c[`x-amz-meta-${d.toLowerCase()}`] = e.Metadata[d]), c
                ),
                {}
              )),
            "content-type": "application/octet-stream",
            [lAt]: e[lwt],
            [yAt]: e[Ewt],
            [eAt]: [() => k(e[aje]), () => e[aje].toString()],
            [ETt]: e[II],
            [STt]: e[PI],
            [CTt]: e[G2],
            [bTt]: e[Np],
            [_Tt]: e[Bp],
            [wTt]: e[Mp],
            [TTt]: e[Lp],
            [km]: [() => k(e[Oc]), () => e[Oc].toString()],
            [ATt]: e[V2],
            [RTt]: e[Fp],
            [OTt]: e[rr],
            [kTt]: e[or],
            [DTt]: e[nr],
            [NTt]: e[sr],
            [BTt]: e[ir],
            [MTt]: [() => k(e[Qs]), () => e[Qs].toString()],
            [ITt]: e[Qt],
            [PTt]: [() => k(e[ki]), () => dr(e[ki]).toString()],
            [LTt]: e[ln],
            [vTt]: [() => k(e[Or]), () => dr(e[Or]).toString()],
            [FTt]: [() => k(e[dP]), () => e[dP].toString()],
            [HTt]: e[qp],
            [$Tt]: e[Mm],
            [zTt]: [() => k(e[Di]), () => wc(e[Di]).toString()],
            [UTt]: [() => k(e[Ip]), () => e[Ip].toString()],
            [GTt]: e[J2],
            [jTt]: e[hr],
            [qTt]: e[Z2],
            [WTt]: e[en],
            [QTt]: e[so],
            [KTt]: e[Do],
            [XTt]: e[io],
            [VTt]: e[tt],
            [JTt]: [() => k(e[pP]), () => e[pP].toString()],
            [ZTt]: e[st],
            [YTt]: [() => k(e[ur]), () => e[ur].toString()],
          });
        r.bp("/WriteGetObjectResponse");
        let n, i;
        e.Body !== void 0 && ((i = e.Body), (n = i));
        let { hostname: a } = await t.endpoint();
        if (t.disableHostPrefix !== !0) {
          if (((a = "{RequestRoute}." + a), e.RequestRoute === void 0))
            throw new Error(
              "Empty value provided for input host prefix: RequestRoute."
            );
          if (((a = a.replace("{RequestRoute}", e.RequestRoute)), !vFe(a)))
            throw new Error(
              "ValidationError: prefixed hostname must be hostname compatible."
            );
        }
        return r.hn(a), r.m("POST").h(o).b(n), r.build();
      }),
      (m4e = async (e, t) => {
        if (e.statusCode !== 204 && e.statusCode >= 300) return Z(e, t);
        let r = g({ $metadata: W(e), [hr]: [, e.headers[xr]] });
        return await ne(e.body, t), r;
      }),
      (l4e = async (e, t) => {
        if (e.statusCode !== 200 && e.statusCode >= 300) return Z(e, t);
        let r = g({
            $metadata: W(e),
            [ln]: [, e.headers[ax]],
            [en]: [, e.headers[Fn]],
            [st]: [, e.headers[Ni]],
            [Do]: [, e.headers[Un]],
            [ur]: [() => e.headers[Br] !== void 0, () => mt(e.headers[Br])],
            [hr]: [, e.headers[xr]],
          }),
          o = F(Se(await De(e.body, t)), "body");
        return (
          o[ft] != null && (r[ft] = p(o[ft])),
          o[rr] != null && (r[rr] = p(o[rr])),
          o[or] != null && (r[or] = p(o[or])),
          o[nr] != null && (r[nr] = p(o[nr])),
          o[sr] != null && (r[sr] = p(o[sr])),
          o[ir] != null && (r[ir] = p(o[ir])),
          o[ar] != null && (r[ar] = p(o[ar])),
          o[Qt] != null && (r[Qt] = p(o[Qt])),
          o[Ge] != null && (r[Ge] = p(o[Ge])),
          o[hm] != null && (r[hm] = p(o[hm])),
          r
        );
      }),
      (f4e = async (e, t) => {
        if (e.statusCode !== 200 && e.statusCode >= 300) return Z(e, t);
        let r = g({
            $metadata: W(e),
            [ln]: [, e.headers[ax]],
            [I8e]: [, e.headers[PWe]],
            [st]: [, e.headers[Ni]],
            [en]: [, e.headers[Fn]],
            [so]: [, e.headers[Co]],
            [io]: [, e.headers[bo]],
            [Do]: [, e.headers[Un]],
            [Nc]: [, e.headers[Bc]],
            [ur]: [() => e.headers[Br] !== void 0, () => mt(e.headers[Br])],
            [hr]: [, e.headers[xr]],
          }),
          o = Se(await De(e.body, t));
        return (r.CopyObjectResult = hSt(o, t)), r;
      }),
      (u4e = async (e, t) => {
        if (e.statusCode !== 200 && e.statusCode >= 300) return Z(e, t);
        let r = g({ $metadata: W(e), [hm]: [, e.headers[oWe]] });
        return await ne(e.body, t), r;
      }),
      (p4e = async (e, t) => {
        if (e.statusCode !== 200 && e.statusCode >= 300) return Z(e, t);
        let r = g({ $metadata: W(e) });
        return await ne(e.body, t), r;
      }),
      (h4e = async (e, t) => {
        if (e.statusCode !== 200 && e.statusCode >= 300) return Z(e, t);
        let r = g({
            $metadata: W(e),
            [E8e]: [() => e.headers[hP] !== void 0, () => F(Hn(e.headers[hP]))],
            [S8e]: [, e.headers[xWe]],
            [en]: [, e.headers[Fn]],
            [so]: [, e.headers[Co]],
            [io]: [, e.headers[bo]],
            [Do]: [, e.headers[Un]],
            [Nc]: [, e.headers[Bc]],
            [ur]: [() => e.headers[Br] !== void 0, () => mt(e.headers[Br])],
            [hr]: [, e.headers[xr]],
            [et]: [, e.headers[pq]],
            [ar]: [, e.headers[Wp]],
          }),
          o = F(Se(await De(e.body, t)), "body");
        return (
          o[ft] != null && (r[ft] = p(o[ft])),
          o[Ge] != null && (r[Ge] = p(o[Ge])),
          o[Rn] != null && (r[Rn] = p(o[Rn])),
          r
        );
      }),
      (g4e = async (e, t) => {
        if (e.statusCode !== 200 && e.statusCode >= 300) return Z(e, t);
        let r = g({
            $metadata: W(e),
            [en]: [, e.headers[Fn]],
            [Do]: [, e.headers[Un]],
            [Nc]: [, e.headers[Bc]],
            [ur]: [() => e.headers[Br] !== void 0, () => mt(e.headers[Br])],
          }),
          o = F(Se(await De(e.body, t)), "body");
        return o[Oz] != null && (r[Oz] = JCt(o[Oz], t)), r;
      }),
      (y4e = async (e, t) => {
        if (e.statusCode !== 204 && e.statusCode >= 300) return Z(e, t);
        let r = g({ $metadata: W(e) });
        return await ne(e.body, t), r;
      }),
      (x4e = async (e, t) => {
        if (e.statusCode !== 204 && e.statusCode >= 300) return Z(e, t);
        let r = g({ $metadata: W(e) });
        return await ne(e.body, t), r;
      }),
      (E4e = async (e, t) => {
        if (e.statusCode !== 204 && e.statusCode >= 300) return Z(e, t);
        let r = g({ $metadata: W(e) });
        return await ne(e.body, t), r;
      }),
      (S4e = async (e, t) => {
        if (e.statusCode !== 204 && e.statusCode >= 300) return Z(e, t);
        let r = g({ $metadata: W(e) });
        return await ne(e.body, t), r;
      }),
      (C4e = async (e, t) => {
        if (e.statusCode !== 204 && e.statusCode >= 300) return Z(e, t);
        let r = g({ $metadata: W(e) });
        return await ne(e.body, t), r;
      }),
      (b4e = async (e, t) => {
        if (e.statusCode !== 204 && e.statusCode >= 300) return Z(e, t);
        let r = g({ $metadata: W(e) });
        return await ne(e.body, t), r;
      }),
      (_4e = async (e, t) => {
        if (e.statusCode !== 204 && e.statusCode >= 300) return Z(e, t);
        let r = g({ $metadata: W(e) });
        return await ne(e.body, t), r;
      }),
      (w4e = async (e, t) => {
        if (e.statusCode !== 204 && e.statusCode >= 300) return Z(e, t);
        let r = g({ $metadata: W(e) });
        return await ne(e.body, t), r;
      }),
      (T4e = async (e, t) => {
        if (e.statusCode !== 204 && e.statusCode >= 300) return Z(e, t);
        let r = g({ $metadata: W(e) });
        return await ne(e.body, t), r;
      }),
      (A4e = async (e, t) => {
        if (e.statusCode !== 204 && e.statusCode >= 300) return Z(e, t);
        let r = g({ $metadata: W(e) });
        return await ne(e.body, t), r;
      }),
      (R4e = async (e, t) => {
        if (e.statusCode !== 204 && e.statusCode >= 300) return Z(e, t);
        let r = g({ $metadata: W(e) });
        return await ne(e.body, t), r;
      }),
      (I4e = async (e, t) => {
        if (e.statusCode !== 204 && e.statusCode >= 300) return Z(e, t);
        let r = g({ $metadata: W(e) });
        return await ne(e.body, t), r;
      }),
      (P4e = async (e, t) => {
        if (e.statusCode !== 204 && e.statusCode >= 300) return Z(e, t);
        let r = g({ $metadata: W(e) });
        return await ne(e.body, t), r;
      }),
      (v4e = async (e, t) => {
        if (e.statusCode !== 204 && e.statusCode >= 300) return Z(e, t);
        let r = g({ $metadata: W(e) });
        return await ne(e.body, t), r;
      }),
      (O4e = async (e, t) => {
        if (e.statusCode !== 204 && e.statusCode >= 300) return Z(e, t);
        let r = g({
          $metadata: W(e),
          [Qs]: [() => e.headers[kc] !== void 0, () => mt(e.headers[kc])],
          [st]: [, e.headers[Ni]],
          [hr]: [, e.headers[xr]],
        });
        return await ne(e.body, t), r;
      }),
      (k4e = async (e, t) => {
        if (e.statusCode !== 200 && e.statusCode >= 300) return Z(e, t);
        let r = g({ $metadata: W(e), [hr]: [, e.headers[xr]] }),
          o = F(Se(await De(e.body, t)), "body");
        return (
          o.Deleted === ""
            ? (r[CI] = [])
            : o[CI] != null && (r[CI] = CSt(Ne(o[CI]), t)),
          o.Error === ""
            ? (r[Xqe] = [])
            : o[Wy] != null && (r[Xqe] = OSt(Ne(o[Wy]), t)),
          r
        );
      }),
      (D4e = async (e, t) => {
        if (e.statusCode !== 204 && e.statusCode >= 300) return Z(e, t);
        let r = g({ $metadata: W(e), [st]: [, e.headers[Ni]] });
        return await ne(e.body, t), r;
      }),
      (N4e = async (e, t) => {
        if (e.statusCode !== 204 && e.statusCode >= 300) return Z(e, t);
        let r = g({ $metadata: W(e) });
        return await ne(e.body, t), r;
      }),
      (B4e = async (e, t) => {
        if (e.statusCode !== 200 && e.statusCode >= 300) return Z(e, t);
        let r = g({ $metadata: W(e), [hr]: [, e.headers[xr]] }),
          o = F(Se(await De(e.body, t)), "body");
        return o[de] != null && (r[de] = p(o[de])), r;
      }),
      (M4e = async (e, t) => {
        if (e.statusCode !== 200 && e.statusCode >= 300) return Z(e, t);
        let r = g({ $metadata: W(e) }),
          o = F(Se(await De(e.body, t)), "body");
        return (
          o.AccessControlList === ""
            ? (r[Yy] = [])
            : o[om] != null &&
              o[om][ga] != null &&
              (r[Yy] = l8e(Ne(o[om][ga]), t)),
          o[Ct] != null && (r[Ct] = Dc(o[Ct], t)),
          r
        );
      }),
      (L4e = async (e, t) => {
        if (e.statusCode !== 200 && e.statusCode >= 300) return Z(e, t);
        let r = g({ $metadata: W(e) }),
          o = Se(await De(e.body, t));
        return (r.AnalyticsConfiguration = a8e(o, t)), r;
      }),
      (F4e = async (e, t) => {
        if (e.statusCode !== 200 && e.statusCode >= 300) return Z(e, t);
        let r = g({ $metadata: W(e) }),
          o = F(Se(await De(e.body, t)), "body");
        return (
          o.CORSRule === ""
            ? (r[p2] = [])
            : o[u2] != null && (r[p2] = xSt(Ne(o[u2]), t)),
          r
        );
      }),
      (U4e = async (e, t) => {
        if (e.statusCode !== 200 && e.statusCode >= 300) return Z(e, t);
        let r = g({ $metadata: W(e) }),
          o = Se(await De(e.body, t));
        return (r.ServerSideEncryptionConfiguration = YCt(o, t)), r;
      }),
      ($4e = async (e, t) => {
        if (e.statusCode !== 200 && e.statusCode >= 300) return Z(e, t);
        let r = g({ $metadata: W(e) }),
          o = Se(await De(e.body, t));
        return (r.IntelligentTieringConfiguration = u8e(o, t)), r;
      }),
      (H4e = async (e, t) => {
        if (e.statusCode !== 200 && e.statusCode >= 300) return Z(e, t);
        let r = g({ $metadata: W(e) }),
          o = Se(await De(e.body, t));
        return (r.InventoryConfiguration = p8e(o, t)), r;
      }),
      (z4e = async (e, t) => {
        if (e.statusCode !== 200 && e.statusCode >= 300) return Z(e, t);
        let r = g({ $metadata: W(e), [eq]: [, e.headers[Eq]] }),
          o = F(Se(await De(e.body, t)), "body");
        return (
          o.Rule === ""
            ? (r[Ts] = [])
            : o[Tn] != null && (r[Ts] = oCt(Ne(o[Tn]), t)),
          r
        );
      }),
      (q4e = async (e, t) => {
        if (e.statusCode !== 200 && e.statusCode >= 300) return Z(e, t);
        let r = g({ $metadata: W(e) }),
          o = F(Se(await De(e.body, t)), "body");
        return o[pp] != null && (r[pp] = p(o[pp])), r;
      }),
      (j4e = async (e, t) => {
        if (e.statusCode !== 200 && e.statusCode >= 300) return Z(e, t);
        let r = g({ $metadata: W(e) }),
          o = F(Se(await De(e.body, t)), "body");
        return o[gm] != null && (r[gm] = nCt(o[gm], t)), r;
      }),
      (G4e = async (e, t) => {
        if (e.statusCode !== 200 && e.statusCode >= 300) return Z(e, t);
        let r = g({ $metadata: W(e) }),
          o = Se(await De(e.body, t));
        return (r.GetBucketMetadataTableConfigurationResult = LSt(o, t)), r;
      }),
      (V4e = async (e, t) => {
        if (e.statusCode !== 200 && e.statusCode >= 300) return Z(e, t);
        let r = g({ $metadata: W(e) }),
          o = Se(await De(e.body, t));
        return (r.MetricsConfiguration = h8e(o, t)), r;
      }),
      (W4e = async (e, t) => {
        if (e.statusCode !== 200 && e.statusCode >= 300) return Z(e, t);
        let r = g({ $metadata: W(e) }),
          o = F(Se(await De(e.body, t)), "body");
        return (
          o[dm] != null && (r[dm] = kSt(o[dm], t)),
          o.CloudFunctionConfiguration === ""
            ? (r[b2] = [])
            : o[Vqe] != null && (r[b2] = JSt(Ne(o[Vqe]), t)),
          o.QueueConfiguration === ""
            ? (r[I2] = [])
            : o[R2] != null && (r[I2] = NCt(Ne(o[R2]), t)),
          o.TopicConfiguration === ""
            ? (r[N2] = [])
            : o[D2] != null && (r[N2] = ubt(Ne(o[D2]), t)),
          r
        );
      }),
      (K4e = async (e, t) => {
        if (e.statusCode !== 200 && e.statusCode >= 300) return Z(e, t);
        let r = g({ $metadata: W(e) }),
          o = Se(await De(e.body, t));
        return (r.OwnershipControls = _Ct(o, t)), r;
      }),
      (Y4e = async (e, t) => {
        if (e.statusCode !== 200 && e.statusCode >= 300) return Z(e, t);
        let r = g({ $metadata: W(e) }),
          o = await gbt(e.body, t);
        return (r.Policy = p(o)), r;
      }),
      (Q4e = async (e, t) => {
        if (e.statusCode !== 200 && e.statusCode >= 300) return Z(e, t);
        let r = g({ $metadata: W(e) }),
          o = Se(await De(e.body, t));
        return (r.PolicyStatus = vCt(o, t)), r;
      }),
      (X4e = async (e, t) => {
        if (e.statusCode !== 200 && e.statusCode >= 300) return Z(e, t);
        let r = g({ $metadata: W(e) }),
          o = Se(await De(e.body, t));
        return (r.ReplicationConfiguration = FCt(o, t)), r;
      }),
      (J4e = async (e, t) => {
        if (e.statusCode !== 200 && e.statusCode >= 300) return Z(e, t);
        let r = g({ $metadata: W(e) }),
          o = F(Se(await De(e.body, t)), "body");
        return o[HI] != null && (r[HI] = p(o[HI])), r;
      }),
      (Z4e = async (e, t) => {
        if (e.statusCode !== 200 && e.statusCode >= 300) return Z(e, t);
        let r = g({ $metadata: W(e) }),
          o = F(Se(await De(e.body, t)), "body");
        return (
          o.TagSet === ""
            ? (r[Ys] = [])
            : o[Ys] != null &&
              o[Ys][Xe] != null &&
              (r[Ys] = Bm(Ne(o[Ys][Xe]), t)),
          r
        );
      }),
      (eVe = async (e, t) => {
        if (e.statusCode !== 200 && e.statusCode >= 300) return Z(e, t);
        let r = g({ $metadata: W(e) }),
          o = F(Se(await De(e.body, t)), "body");
        return (
          o[w2] != null && (r[MI] = p(o[w2])),
          o[de] != null && (r[de] = p(o[de])),
          r
        );
      }),
      (tVe = async (e, t) => {
        if (e.statusCode !== 200 && e.statusCode >= 300) return Z(e, t);
        let r = g({ $metadata: W(e) }),
          o = F(Se(await De(e.body, t)), "body");
        return (
          o[lm] != null && (r[lm] = vSt(o[lm], t)),
          o[um] != null && (r[um] = $St(o[um], t)),
          o[Cm] != null && (r[Cm] = MCt(o[Cm], t)),
          o.RoutingRules === ""
            ? (r[Vu] = [])
            : o[Vu] != null &&
              o[Vu][lP] != null &&
              (r[Vu] = GCt(Ne(o[Vu][lP]), t)),
          r
        );
      }),
      (rVe = async (e, t) => {
        if (e.statusCode !== 200 && e.statusCode >= 300) return Z(e, t);
        let r = g({
            $metadata: W(e),
            [Qs]: [() => e.headers[kc] !== void 0, () => mt(e.headers[kc])],
            [G2]: [, e.headers[J8e]],
            [ln]: [, e.headers[ax]],
            [Z2]: [, e.headers[vWe]],
            [Or]: [() => e.headers[Pp] !== void 0, () => F(Hn(e.headers[Pp]))],
            [Oc]: [() => e.headers[km] !== void 0, () => Jr(e.headers[km])],
            [Qt]: [, e.headers[AP]],
            [rr]: [, e.headers[Fm]],
            [or]: [, e.headers[Um]],
            [nr]: [, e.headers[$m]],
            [sr]: [, e.headers[Hm]],
            [ir]: [, e.headers[zm]],
            [ar]: [, e.headers[Wp]],
            [dP]: [() => e.headers[gP] !== void 0, () => wt(e.headers[gP])],
            [st]: [, e.headers[Ni]],
            [Np]: [, e.headers[Zy]],
            [Bp]: [, e.headers[ex]],
            [Mp]: [, e.headers[tx]],
            [Lp]: [, e.headers[rx]],
            [V2]: [, e.headers[Z8e]],
            [Fp]: [, e.headers[ox]],
            [ki]: [() => e.headers[Dm] !== void 0, () => F(Hn(e.headers[Dm]))],
            [P8e]: [, e.headers[eWe]],
            [Jy]: [, e.headers[lx]],
            [en]: [, e.headers[Fn]],
            [so]: [, e.headers[Co]],
            [io]: [, e.headers[bo]],
            [Do]: [, e.headers[Un]],
            [ur]: [() => e.headers[Br] !== void 0, () => mt(e.headers[Br])],
            [tt]: [, e.headers[mx]],
            [hr]: [, e.headers[xr]],
            [J2]: [, e.headers[OWe]],
            [Ip]: [() => e.headers[yP] !== void 0, () => wt(e.headers[yP])],
            [pP]: [() => e.headers[xP] !== void 0, () => wt(e.headers[xP])],
            [qp]: [, e.headers[dx]],
            [Di]: [() => e.headers[Nm] !== void 0, () => F(qr(e.headers[Nm]))],
            [Mm]: [, e.headers[cx]],
            Metadata: [
              ,
              Object.keys(e.headers)
                .filter((n) => n.startsWith("x-amz-meta-"))
                .reduce((n, i) => ((n[i.substring(11)] = e.headers[i]), n), {}),
            ],
          }),
          o = e.body;
        return t.sdkStreamMixin(o), (r.Body = o), r;
      }),
      (oVe = async (e, t) => {
        if (e.statusCode !== 200 && e.statusCode >= 300) return Z(e, t);
        let r = g({ $metadata: W(e), [hr]: [, e.headers[xr]] }),
          o = F(Se(await De(e.body, t)), "body");
        return (
          o.AccessControlList === ""
            ? (r[Yy] = [])
            : o[om] != null &&
              o[om][ga] != null &&
              (r[Yy] = l8e(Ne(o[om][ga]), t)),
          o[Ct] != null && (r[Ct] = Dc(o[Ct], t)),
          r
        );
      }),
      (nVe = async (e, t) => {
        if (e.statusCode !== 200 && e.statusCode >= 300) return Z(e, t);
        let r = g({
            $metadata: W(e),
            [Qs]: [() => e.headers[kc] !== void 0, () => mt(e.headers[kc])],
            [Or]: [() => e.headers[Pp] !== void 0, () => F(Hn(e.headers[Pp]))],
            [st]: [, e.headers[Ni]],
            [hr]: [, e.headers[xr]],
          }),
          o = F(Se(await De(e.body, t)), "body");
        return (
          o[Nz] != null && (r[Nz] = lSt(o[Nz], t)),
          o[Qt] != null && (r[Qt] = p(o[Qt])),
          o[Yz] != null && (r[Yz] = FSt(o[Yz], t)),
          o[Qz] != null && (r[Qz] = Jr(o[Qz])),
          o[tt] != null && (r[tt] = p(o[tt])),
          r
        );
      }),
      (sVe = async (e, t) => {
        if (e.statusCode !== 200 && e.statusCode >= 300) return Z(e, t);
        let r = g({ $metadata: W(e) }),
          o = Se(await De(e.body, t));
        return (r.LegalHold = yCt(o, t)), r;
      }),
      (iVe = async (e, t) => {
        if (e.statusCode !== 200 && e.statusCode >= 300) return Z(e, t);
        let r = g({ $metadata: W(e) }),
          o = Se(await De(e.body, t));
        return (r.ObjectLockConfiguration = gCt(o, t)), r;
      }),
      (aVe = async (e, t) => {
        if (e.statusCode !== 200 && e.statusCode >= 300) return Z(e, t);
        let r = g({ $metadata: W(e) }),
          o = Se(await De(e.body, t));
        return (r.Retention = xCt(o, t)), r;
      }),
      (cVe = async (e, t) => {
        if (e.statusCode !== 200 && e.statusCode >= 300) return Z(e, t);
        let r = g({ $metadata: W(e), [st]: [, e.headers[Ni]] }),
          o = F(Se(await De(e.body, t)), "body");
        return (
          o.TagSet === ""
            ? (r[Ys] = [])
            : o[Ys] != null &&
              o[Ys][Xe] != null &&
              (r[Ys] = Bm(Ne(o[Ys][Xe]), t)),
          r
        );
      }),
      (dVe = async (e, t) => {
        if (e.statusCode !== 200 && e.statusCode >= 300) return Z(e, t);
        let r = g({ $metadata: W(e), [hr]: [, e.headers[xr]] }),
          o = e.body;
        return t.sdkStreamMixin(o), (r.Body = o), r;
      }),
      (mVe = async (e, t) => {
        if (e.statusCode !== 200 && e.statusCode >= 300) return Z(e, t);
        let r = g({ $metadata: W(e) }),
          o = Se(await De(e.body, t));
        return (r.PublicAccessBlockConfiguration = kCt(o, t)), r;
      }),
      (lVe = async (e, t) => {
        if (e.statusCode !== 200 && e.statusCode >= 300) return Z(e, t);
        let r = g({
          $metadata: W(e),
          [Nbt]: [, e.headers[fTt]],
          [Obt]: [, e.headers[lTt]],
          [Vy]: [, e.headers[pTt]],
          [_bt]: [() => e.headers[yje] !== void 0, () => mt(e.headers[yje])],
        });
        return await ne(e.body, t), r;
      }),
      (fVe = async (e, t) => {
        if (e.statusCode !== 200 && e.statusCode >= 300) return Z(e, t);
        let r = g({
          $metadata: W(e),
          [Qs]: [() => e.headers[kc] !== void 0, () => mt(e.headers[kc])],
          [G2]: [, e.headers[J8e]],
          [ln]: [, e.headers[ax]],
          [Z2]: [, e.headers[vWe]],
          [wbt]: [, e.headers[mTt]],
          [Or]: [() => e.headers[Pp] !== void 0, () => F(Hn(e.headers[Pp]))],
          [Oc]: [() => e.headers[km] !== void 0, () => Jr(e.headers[km])],
          [rr]: [, e.headers[Fm]],
          [or]: [, e.headers[Um]],
          [nr]: [, e.headers[$m]],
          [sr]: [, e.headers[Hm]],
          [ir]: [, e.headers[zm]],
          [ar]: [, e.headers[Wp]],
          [Qt]: [, e.headers[AP]],
          [dP]: [() => e.headers[gP] !== void 0, () => wt(e.headers[gP])],
          [st]: [, e.headers[Ni]],
          [Np]: [, e.headers[Zy]],
          [Bp]: [, e.headers[ex]],
          [Mp]: [, e.headers[tx]],
          [Lp]: [, e.headers[rx]],
          [Fp]: [, e.headers[ox]],
          [V2]: [, e.headers[Z8e]],
          [ki]: [() => e.headers[Dm] !== void 0, () => F(Hn(e.headers[Dm]))],
          [P8e]: [, e.headers[eWe]],
          [Jy]: [, e.headers[lx]],
          [en]: [, e.headers[Fn]],
          [so]: [, e.headers[Co]],
          [io]: [, e.headers[bo]],
          [Do]: [, e.headers[Un]],
          [ur]: [() => e.headers[Br] !== void 0, () => mt(e.headers[Br])],
          [tt]: [, e.headers[mx]],
          [hr]: [, e.headers[xr]],
          [J2]: [, e.headers[OWe]],
          [Ip]: [() => e.headers[yP] !== void 0, () => wt(e.headers[yP])],
          [pP]: [() => e.headers[xP] !== void 0, () => wt(e.headers[xP])],
          [qp]: [, e.headers[dx]],
          [Di]: [() => e.headers[Nm] !== void 0, () => F(qr(e.headers[Nm]))],
          [Mm]: [, e.headers[cx]],
          Metadata: [
            ,
            Object.keys(e.headers)
              .filter((o) => o.startsWith("x-amz-meta-"))
              .reduce((o, n) => ((o[n.substring(11)] = e.headers[n]), o), {}),
          ],
        });
        return await ne(e.body, t), r;
      }),
      (uVe = async (e, t) => {
        if (e.statusCode !== 200 && e.statusCode >= 300) return Z(e, t);
        let r = g({ $metadata: W(e) }),
          o = F(Se(await De(e.body, t)), "body");
        return (
          o.AnalyticsConfiguration === ""
            ? (r[Gqe] = [])
            : o[s2] != null && (r[Gqe] = iSt(Ne(o[s2]), t)),
          o[Yt] != null && (r[Yt] = p(o[Yt])),
          o[Ft] != null && (r[Ft] = mt(o[Ft])),
          o[fn] != null && (r[fn] = p(o[fn])),
          r
        );
      }),
      (pVe = async (e, t) => {
        if (e.statusCode !== 200 && e.statusCode >= 300) return Z(e, t);
        let r = g({ $metadata: W(e) }),
          o = F(Se(await De(e.body, t)), "body");
        return (
          o[Yt] != null && (r[Yt] = p(o[Yt])),
          o.IntelligentTieringConfiguration === ""
            ? (r[rje] = [])
            : o[C2] != null && (r[rje] = zSt(Ne(o[C2]), t)),
          o[Ft] != null && (r[Ft] = mt(o[Ft])),
          o[fn] != null && (r[fn] = p(o[fn])),
          r
        );
      }),
      (hVe = async (e, t) => {
        if (e.statusCode !== 200 && e.statusCode >= 300) return Z(e, t);
        let r = g({ $metadata: W(e) }),
          o = F(Se(await De(e.body, t)), "body");
        return (
          o[Yt] != null && (r[Yt] = p(o[Yt])),
          o.InventoryConfiguration === ""
            ? (r[Jqe] = [])
            : o[S2] != null && (r[Jqe] = jSt(Ne(o[S2]), t)),
          o[Ft] != null && (r[Ft] = mt(o[Ft])),
          o[fn] != null && (r[fn] = p(o[fn])),
          r
        );
      }),
      (gVe = async (e, t) => {
        if (e.statusCode !== 200 && e.statusCode >= 300) return Z(e, t);
        let r = g({ $metadata: W(e) }),
          o = F(Se(await De(e.body, t)), "body");
        return (
          o[Yt] != null && (r[Yt] = p(o[Yt])),
          o[Ft] != null && (r[Ft] = mt(o[Ft])),
          o.MetricsConfiguration === ""
            ? (r[oje] = [])
            : o[_2] != null && (r[oje] = cCt(Ne(o[_2]), t)),
          o[fn] != null && (r[fn] = p(o[fn])),
          r
        );
      }),
      (yVe = async (e, t) => {
        if (e.statusCode !== 200 && e.statusCode >= 300) return Z(e, t);
        let r = g({ $metadata: W(e) }),
          o = F(Se(await De(e.body, t)), "body");
        return (
          o.Buckets === ""
            ? (r[Pi] = [])
            : o[Pi] != null &&
              o[Pi][ft] != null &&
              (r[Pi] = c8e(Ne(o[Pi][ft]), t)),
          o[Yt] != null && (r[Yt] = p(o[Yt])),
          o[Ct] != null && (r[Ct] = Dc(o[Ct], t)),
          o[se] != null && (r[se] = p(o[se])),
          r
        );
      }),
      (xVe = async (e, t) => {
        if (e.statusCode !== 200 && e.statusCode >= 300) return Z(e, t);
        let r = g({ $metadata: W(e) }),
          o = F(Se(await De(e.body, t)), "body");
        return (
          o.Buckets === ""
            ? (r[Pi] = [])
            : o[Pi] != null &&
              o[Pi][ft] != null &&
              (r[Pi] = c8e(Ne(o[Pi][ft]), t)),
          o[Yt] != null && (r[Yt] = p(o[Yt])),
          r
        );
      }),
      (EVe = async (e, t) => {
        if (e.statusCode !== 200 && e.statusCode >= 300) return Z(e, t);
        let r = g({ $metadata: W(e), [hr]: [, e.headers[xr]] }),
          o = F(Se(await De(e.body, t)), "body");
        return (
          o[ft] != null && (r[ft] = p(o[ft])),
          o.CommonPrefixes === ""
            ? (r[Xo] = [])
            : o[Xo] != null && (r[Xo] = EP(Ne(o[Xo]), t)),
          o[Jo] != null && (r[Jo] = p(o[Jo])),
          o[Zo] != null && (r[Zo] = p(o[Zo])),
          o[Ft] != null && (r[Ft] = mt(o[Ft])),
          o[Ic] != null && (r[Ic] = p(o[Ic])),
          o[LI] != null && (r[LI] = wt(o[LI])),
          o[hp] != null && (r[hp] = p(o[hp])),
          o[Wz] != null && (r[Wz] = p(o[Wz])),
          o[se] != null && (r[se] = p(o[se])),
          o[rP] != null && (r[rP] = p(o[rP])),
          o.Upload === ""
            ? (r[fje] = [])
            : o[lje] != null && (r[fje] = lCt(Ne(o[lje]), t)),
          r
        );
      }),
      (SVe = async (e, t) => {
        if (e.statusCode !== 200 && e.statusCode >= 300) return Z(e, t);
        let r = g({ $metadata: W(e), [hr]: [, e.headers[xr]] }),
          o = F(Se(await De(e.body, t)), "body");
        return (
          o.CommonPrefixes === ""
            ? (r[Xo] = [])
            : o[Xo] != null && (r[Xo] = EP(Ne(o[Xo]), t)),
          o.Contents === ""
            ? (r[Ac] = [])
            : o[Ac] != null && (r[Ac] = g8e(Ne(o[Ac]), t)),
          o[Jo] != null && (r[Jo] = p(o[Jo])),
          o[Zo] != null && (r[Zo] = p(o[Zo])),
          o[Ft] != null && (r[Ft] = mt(o[Ft])),
          o[BI] != null && (r[BI] = p(o[BI])),
          o[xs] != null && (r[xs] = wt(o[xs])),
          o[Cr] != null && (r[Cr] = p(o[Cr])),
          o[Vz] != null && (r[Vz] = p(o[Vz])),
          o[se] != null && (r[se] = p(o[se])),
          r
        );
      }),
      (CVe = async (e, t) => {
        if (e.statusCode !== 200 && e.statusCode >= 300) return Z(e, t);
        let r = g({ $metadata: W(e), [hr]: [, e.headers[xr]] }),
          o = F(Se(await De(e.body, t)), "body");
        return (
          o.CommonPrefixes === ""
            ? (r[Xo] = [])
            : o[Xo] != null && (r[Xo] = EP(Ne(o[Xo]), t)),
          o.Contents === ""
            ? (r[Ac] = [])
            : o[Ac] != null && (r[Ac] = g8e(Ne(o[Ac]), t)),
          o[Yt] != null && (r[Yt] = p(o[Yt])),
          o[Jo] != null && (r[Jo] = p(o[Jo])),
          o[Zo] != null && (r[Zo] = p(o[Zo])),
          o[Ft] != null && (r[Ft] = mt(o[Ft])),
          o[zz] != null && (r[zz] = wt(o[zz])),
          o[xs] != null && (r[xs] = wt(o[xs])),
          o[Cr] != null && (r[Cr] = p(o[Cr])),
          o[fn] != null && (r[fn] = p(o[fn])),
          o[se] != null && (r[se] = p(o[se])),
          o[KI] != null && (r[KI] = p(o[KI])),
          r
        );
      }),
      (bVe = async (e, t) => {
        if (e.statusCode !== 200 && e.statusCode >= 300) return Z(e, t);
        let r = g({ $metadata: W(e), [hr]: [, e.headers[xr]] }),
          o = F(Se(await De(e.body, t)), "body");
        return (
          o.CommonPrefixes === ""
            ? (r[Xo] = [])
            : o[Xo] != null && (r[Xo] = EP(Ne(o[Xo]), t)),
          o.DeleteMarker === ""
            ? (r[Qqe] = [])
            : o[Qs] != null && (r[Qqe] = wSt(Ne(o[Qs]), t)),
          o[Jo] != null && (r[Jo] = p(o[Jo])),
          o[Zo] != null && (r[Zo] = p(o[Zo])),
          o[Ft] != null && (r[Ft] = mt(o[Ft])),
          o[Ic] != null && (r[Ic] = p(o[Ic])),
          o[xs] != null && (r[xs] = wt(o[xs])),
          o[Cr] != null && (r[Cr] = p(o[Cr])),
          o[hp] != null && (r[hp] = p(o[hp])),
          o[Kz] != null && (r[Kz] = p(o[Kz])),
          o[se] != null && (r[se] = p(o[se])),
          o[nP] != null && (r[nP] = p(o[nP])),
          o.Version === ""
            ? (r[pje] = [])
            : o[uje] != null && (r[pje] = bCt(Ne(o[uje]), t)),
          r
        );
      }),
      (_Ve = async (e, t) => {
        if (e.statusCode !== 200 && e.statusCode >= 300) return Z(e, t);
        let r = g({
            $metadata: W(e),
            [E8e]: [() => e.headers[hP] !== void 0, () => F(Hn(e.headers[hP]))],
            [S8e]: [, e.headers[xWe]],
            [hr]: [, e.headers[xr]],
          }),
          o = F(Se(await De(e.body, t)), "body");
        return (
          o[ft] != null && (r[ft] = p(o[ft])),
          o[et] != null && (r[et] = p(o[et])),
          o[ar] != null && (r[ar] = p(o[ar])),
          o[mp] != null && (r[mp] = f8e(o[mp], t)),
          o[Ft] != null && (r[Ft] = mt(o[Ft])),
          o[Ge] != null && (r[Ge] = p(o[Ge])),
          o[pa] != null && (r[pa] = wt(o[pa])),
          o[gp] != null && (r[gp] = p(o[gp])),
          o[Ct] != null && (r[Ct] = Dc(o[Ct], t)),
          o[Pc] != null && (r[Pc] = p(o[Pc])),
          o.Part === ""
            ? (r[Qy] = [])
            : o[mP] != null && (r[Qy] = ICt(Ne(o[mP]), t)),
          o[tt] != null && (r[tt] = p(o[tt])),
          o[Rn] != null && (r[Rn] = p(o[Rn])),
          r
        );
      }),
      (wVe = async (e, t) => {
        if (e.statusCode !== 200 && e.statusCode >= 300) return Z(e, t);
        let r = g({ $metadata: W(e) });
        return await ne(e.body, t), r;
      }),
      (TVe = async (e, t) => {
        if (e.statusCode !== 200 && e.statusCode >= 300) return Z(e, t);
        let r = g({ $metadata: W(e) });
        return await ne(e.body, t), r;
      }),
      (AVe = async (e, t) => {
        if (e.statusCode !== 200 && e.statusCode >= 300) return Z(e, t);
        let r = g({ $metadata: W(e) });
        return await ne(e.body, t), r;
      }),
      (RVe = async (e, t) => {
        if (e.statusCode !== 200 && e.statusCode >= 300) return Z(e, t);
        let r = g({ $metadata: W(e) });
        return await ne(e.body, t), r;
      }),
      (IVe = async (e, t) => {
        if (e.statusCode !== 200 && e.statusCode >= 300) return Z(e, t);
        let r = g({ $metadata: W(e) });
        return await ne(e.body, t), r;
      }),
      (PVe = async (e, t) => {
        if (e.statusCode !== 200 && e.statusCode >= 300) return Z(e, t);
        let r = g({ $metadata: W(e) });
        return await ne(e.body, t), r;
      }),
      (vVe = async (e, t) => {
        if (e.statusCode !== 200 && e.statusCode >= 300) return Z(e, t);
        let r = g({ $metadata: W(e) });
        return await ne(e.body, t), r;
      }),
      (OVe = async (e, t) => {
        if (e.statusCode !== 200 && e.statusCode >= 300) return Z(e, t);
        let r = g({ $metadata: W(e), [eq]: [, e.headers[Eq]] });
        return await ne(e.body, t), r;
      }),
      (kVe = async (e, t) => {
        if (e.statusCode !== 200 && e.statusCode >= 300) return Z(e, t);
        let r = g({ $metadata: W(e) });
        return await ne(e.body, t), r;
      }),
      (DVe = async (e, t) => {
        if (e.statusCode !== 200 && e.statusCode >= 300) return Z(e, t);
        let r = g({ $metadata: W(e) });
        return await ne(e.body, t), r;
      }),
      (NVe = async (e, t) => {
        if (e.statusCode !== 200 && e.statusCode >= 300) return Z(e, t);
        let r = g({ $metadata: W(e) });
        return await ne(e.body, t), r;
      }),
      (BVe = async (e, t) => {
        if (e.statusCode !== 200 && e.statusCode >= 300) return Z(e, t);
        let r = g({ $metadata: W(e) });
        return await ne(e.body, t), r;
      }),
      (MVe = async (e, t) => {
        if (e.statusCode !== 200 && e.statusCode >= 300) return Z(e, t);
        let r = g({ $metadata: W(e) });
        return await ne(e.body, t), r;
      }),
      (LVe = async (e, t) => {
        if (e.statusCode !== 200 && e.statusCode >= 300) return Z(e, t);
        let r = g({ $metadata: W(e) });
        return await ne(e.body, t), r;
      }),
      (FVe = async (e, t) => {
        if (e.statusCode !== 200 && e.statusCode >= 300) return Z(e, t);
        let r = g({ $metadata: W(e) });
        return await ne(e.body, t), r;
      }),
      (UVe = async (e, t) => {
        if (e.statusCode !== 200 && e.statusCode >= 300) return Z(e, t);
        let r = g({ $metadata: W(e) });
        return await ne(e.body, t), r;
      }),
      ($Ve = async (e, t) => {
        if (e.statusCode !== 200 && e.statusCode >= 300) return Z(e, t);
        let r = g({ $metadata: W(e) });
        return await ne(e.body, t), r;
      }),
      (HVe = async (e, t) => {
        if (e.statusCode !== 200 && e.statusCode >= 300) return Z(e, t);
        let r = g({ $metadata: W(e) });
        return await ne(e.body, t), r;
      }),
      (zVe = async (e, t) => {
        if (e.statusCode !== 200 && e.statusCode >= 300) return Z(e, t);
        let r = g({
          $metadata: W(e),
          [ln]: [, e.headers[ax]],
          [Qt]: [, e.headers[AP]],
          [rr]: [, e.headers[Fm]],
          [or]: [, e.headers[Um]],
          [nr]: [, e.headers[$m]],
          [sr]: [, e.headers[Hm]],
          [ir]: [, e.headers[zm]],
          [ar]: [, e.headers[Wp]],
          [en]: [, e.headers[Fn]],
          [st]: [, e.headers[Ni]],
          [so]: [, e.headers[Co]],
          [io]: [, e.headers[bo]],
          [Do]: [, e.headers[Un]],
          [Nc]: [, e.headers[Bc]],
          [ur]: [() => e.headers[Br] !== void 0, () => mt(e.headers[Br])],
          [ko]: [() => e.headers[xje] !== void 0, () => Jr(e.headers[xje])],
          [hr]: [, e.headers[xr]],
        });
        return await ne(e.body, t), r;
      }),
      (qVe = async (e, t) => {
        if (e.statusCode !== 200 && e.statusCode >= 300) return Z(e, t);
        let r = g({ $metadata: W(e), [hr]: [, e.headers[xr]] });
        return await ne(e.body, t), r;
      }),
      (jVe = async (e, t) => {
        if (e.statusCode !== 200 && e.statusCode >= 300) return Z(e, t);
        let r = g({ $metadata: W(e), [hr]: [, e.headers[xr]] });
        return await ne(e.body, t), r;
      }),
      (GVe = async (e, t) => {
        if (e.statusCode !== 200 && e.statusCode >= 300) return Z(e, t);
        let r = g({ $metadata: W(e), [hr]: [, e.headers[xr]] });
        return await ne(e.body, t), r;
      }),
      (VVe = async (e, t) => {
        if (e.statusCode !== 200 && e.statusCode >= 300) return Z(e, t);
        let r = g({ $metadata: W(e), [hr]: [, e.headers[xr]] });
        return await ne(e.body, t), r;
      }),
      (WVe = async (e, t) => {
        if (e.statusCode !== 200 && e.statusCode >= 300) return Z(e, t);
        let r = g({ $metadata: W(e), [st]: [, e.headers[Ni]] });
        return await ne(e.body, t), r;
      }),
      (KVe = async (e, t) => {
        if (e.statusCode !== 200 && e.statusCode >= 300) return Z(e, t);
        let r = g({ $metadata: W(e) });
        return await ne(e.body, t), r;
      }),
      (YVe = async (e, t) => {
        if (e.statusCode !== 200 && e.statusCode >= 300) return Z(e, t);
        let r = g({ $metadata: W(e) });
        return await ne(e.body, t), r;
      }),
      (QVe = async (e, t) => {
        if (e.statusCode !== 200 && e.statusCode >= 300) return Z(e, t);
        let r = g({
          $metadata: W(e),
          [hr]: [, e.headers[xr]],
          [dwt]: [, e.headers[mAt]],
        });
        return await ne(e.body, t), r;
      }),
      (XVe = async (e, t) => {
        if (e.statusCode !== 200 && e.statusCode >= 300) return Z(e, t);
        let r = g({ $metadata: W(e) }),
          o = e.body;
        return (r.Payload = Iyt(o, t)), r;
      }),
      (JVe = async (e, t) => {
        if (e.statusCode !== 200 && e.statusCode >= 300) return Z(e, t);
        let r = g({
          $metadata: W(e),
          [en]: [, e.headers[Fn]],
          [Qt]: [, e.headers[AP]],
          [rr]: [, e.headers[Fm]],
          [or]: [, e.headers[Um]],
          [nr]: [, e.headers[$m]],
          [sr]: [, e.headers[Hm]],
          [ir]: [, e.headers[zm]],
          [so]: [, e.headers[Co]],
          [io]: [, e.headers[bo]],
          [Do]: [, e.headers[Un]],
          [ur]: [() => e.headers[Br] !== void 0, () => mt(e.headers[Br])],
          [hr]: [, e.headers[xr]],
        });
        return await ne(e.body, t), r;
      }),
      (ZVe = async (e, t) => {
        if (e.statusCode !== 200 && e.statusCode >= 300) return Z(e, t);
        let r = g({
            $metadata: W(e),
            [I8e]: [, e.headers[PWe]],
            [en]: [, e.headers[Fn]],
            [so]: [, e.headers[Co]],
            [io]: [, e.headers[bo]],
            [Do]: [, e.headers[Un]],
            [ur]: [() => e.headers[Br] !== void 0, () => mt(e.headers[Br])],
            [hr]: [, e.headers[xr]],
          }),
          o = Se(await De(e.body, t));
        return (r.CopyPartResult = gSt(o, t)), r;
      }),
      (e8e = async (e, t) => {
        if (e.statusCode !== 200 && e.statusCode >= 300) return Z(e, t);
        let r = g({ $metadata: W(e) });
        return await ne(e.body, t), r;
      }),
      (Z = async (e, t) => {
        let r = { ...e, body: await vE(e.body, t) },
          o = jre(e, r.body);
        switch (o) {
          case "NoSuchUpload":
          case "com.amazonaws.s3#NoSuchUpload":
            throw await _yt(r, t);
          case "ObjectNotInActiveTierError":
          case "com.amazonaws.s3#ObjectNotInActiveTierError":
            throw await Ayt(r, t);
          case "BucketAlreadyExists":
          case "com.amazonaws.s3#BucketAlreadyExists":
            throw await pyt(r, t);
          case "BucketAlreadyOwnedByYou":
          case "com.amazonaws.s3#BucketAlreadyOwnedByYou":
            throw await hyt(r, t);
          case "NoSuchBucket":
          case "com.amazonaws.s3#NoSuchBucket":
            throw await Cyt(r, t);
          case "InvalidObjectState":
          case "com.amazonaws.s3#InvalidObjectState":
            throw await xyt(r, t);
          case "NoSuchKey":
          case "com.amazonaws.s3#NoSuchKey":
            throw await byt(r, t);
          case "NotFound":
          case "com.amazonaws.s3#NotFound":
            throw await wyt(r, t);
          case "EncryptionTypeMismatch":
          case "com.amazonaws.s3#EncryptionTypeMismatch":
            throw await gyt(r, t);
          case "InvalidRequest":
          case "com.amazonaws.s3#InvalidRequest":
            throw await Eyt(r, t);
          case "InvalidWriteOffset":
          case "com.amazonaws.s3#InvalidWriteOffset":
            throw await Syt(r, t);
          case "TooManyParts":
          case "com.amazonaws.s3#TooManyParts":
            throw await Ryt(r, t);
          case "IdempotencyParameterMismatch":
          case "com.amazonaws.s3#IdempotencyParameterMismatch":
            throw await yyt(r, t);
          case "ObjectAlreadyInActiveTierError":
          case "com.amazonaws.s3#ObjectAlreadyInActiveTierError":
            throw await Tyt(r, t);
          default:
            let n = r.body;
            return uyt({ output: e, parsedBody: n, errorCode: o });
        }
      }),
      (uyt = HR(Yr)),
      (pyt = async (e, t) => {
        let r = g({}),
          o = e.body,
          n = new sI({ $metadata: W(e), ...r });
        return Nr(n, e.body);
      }),
      (hyt = async (e, t) => {
        let r = g({}),
          o = e.body,
          n = new iI({ $metadata: W(e), ...r });
        return Nr(n, e.body);
      }),
      (gyt = async (e, t) => {
        let r = g({}),
          o = e.body,
          n = new pI({ $metadata: W(e), ...r });
        return Nr(n, e.body);
      }),
      (yyt = async (e, t) => {
        let r = g({}),
          o = e.body,
          n = new xI({ $metadata: W(e), ...r });
        return Nr(n, e.body);
      }),
      (xyt = async (e, t) => {
        let r = g({}),
          o = e.body;
        o[ua] != null && (r[ua] = p(o[ua])),
          o[tt] != null && (r[tt] = p(o[tt]));
        let n = new mI({ $metadata: W(e), ...r });
        return Nr(n, e.body);
      }),
      (Eyt = async (e, t) => {
        let r = g({}),
          o = e.body,
          n = new hI({ $metadata: W(e), ...r });
        return Nr(n, e.body);
      }),
      (Syt = async (e, t) => {
        let r = g({}),
          o = e.body,
          n = new gI({ $metadata: W(e), ...r });
        return Nr(n, e.body);
      }),
      (Cyt = async (e, t) => {
        let r = g({}),
          o = e.body,
          n = new aI({ $metadata: W(e), ...r });
        return Nr(n, e.body);
      }),
      (byt = async (e, t) => {
        let r = g({}),
          o = e.body,
          n = new lI({ $metadata: W(e), ...r });
        return Nr(n, e.body);
      }),
      (_yt = async (e, t) => {
        let r = g({}),
          o = e.body,
          n = new oI({ $metadata: W(e), ...r });
        return Nr(n, e.body);
      }),
      (wyt = async (e, t) => {
        let r = g({}),
          o = e.body,
          n = new fI({ $metadata: W(e), ...r });
        return Nr(n, e.body);
      }),
      (Tyt = async (e, t) => {
        let r = g({}),
          o = e.body,
          n = new EI({ $metadata: W(e), ...r });
        return Nr(n, e.body);
      }),
      (Ayt = async (e, t) => {
        let r = g({}),
          o = e.body,
          n = new nI({ $metadata: W(e), ...r });
        return Nr(n, e.body);
      }),
      (Ryt = async (e, t) => {
        let r = g({}),
          o = e.body,
          n = new yI({ $metadata: W(e), ...r });
        return Nr(n, e.body);
      }),
      (Iyt = (e, t) =>
        t.eventStreamMarshaller.deserialize(e, async (r) =>
          r.Records != null
            ? { Records: await kyt(r.Records, t) }
            : r.Stats != null
              ? { Stats: await Dyt(r.Stats, t) }
              : r.Progress != null
                ? { Progress: await Oyt(r.Progress, t) }
                : r.Cont != null
                  ? { Cont: await Pyt(r.Cont, t) }
                  : r.End != null
                    ? { End: await vyt(r.End, t) }
                    : { $unknown: r }
        )),
      (Pyt = async (e, t) => {
        let r = {},
          o = await De(e.body, t);
        return Object.assign(r, pSt(o, t)), r;
      }),
      (vyt = async (e, t) => {
        let r = {},
          o = await De(e.body, t);
        return Object.assign(r, RSt(o, t)), r;
      }),
      (Oyt = async (e, t) => {
        let r = {},
          o = await De(e.body, t);
        return (r.Details = OCt(o, t)), r;
      }),
      (kyt = async (e, t) => {
        let r = {};
        return (r.Payload = e.body), r;
      }),
      (Dyt = async (e, t) => {
        let r = {},
          o = await De(e.body, t);
        return (r.Details = nbt(o, t)), r;
      }),
      (Nyt = (e, t) => {
        let r = new C(sm);
        return e[Qd] != null && r.c(C.of(Qd, String(e[Qd])).n(Qd)), r;
      }),
      (Byt = (e, t) => {
        let r = new C(Ebt);
        return e[de] != null && r.c(C.of(Rbt, e[de]).n(de)), r;
      }),
      (t8e = (e, t) => {
        let r = new C(xbt);
        return (
          r.lc(e, "Grants", "AccessControlList", () => o8e(e[Yy], t)),
          e[Ct] != null && r.c(oEt(e[Ct], t).n(Ct)),
          r
        );
      }),
      (Myt = (e, t) => {
        let r = new C(nm);
        return e[Ct] != null && r.c(C.of(twt, e[Ct]).n(Ct)), r;
      }),
      (Lyt = (e, t) =>
        e.filter((r) => r != null).map((r) => C.of(i2, r).n(ao))),
      (Fyt = (e, t) =>
        e.filter((r) => r != null).map((r) => C.of(c2, r).n(ao))),
      (Uyt = (e, t) =>
        e.filter((r) => r != null).map((r) => C.of(m2, r).n(ao))),
      ($yt = (e, t) => {
        let r = new C(ybt);
        return r.cc(e, se), r.l(e, "Tags", "Tag", () => Op(e[un], t)), r;
      }),
      (Hyt = (e, t) => {
        let r = new C(s2);
        return (
          e[ke] != null && r.c(C.of(bbt, e[ke]).n(ke)),
          e[Oe] != null && r.c(qyt(e[Oe], t).n(Oe)),
          e[Tm] != null && r.c($Et(e[Tm], t).n(Tm)),
          r
        );
      }),
      (zyt = (e, t) => {
        let r = new C(Sbt);
        return e[ws] != null && r.c(jyt(e[ws], t).n(ws)), r;
      }),
      (qyt = (e, t) => {
        let r = new C(Cbt);
        return (
          cI.visit(e, {
            Prefix: (o) => {
              e[se] != null && r.c(C.of(se, o).n(se));
            },
            Tag: (o) => {
              e[Xe] != null && r.c(vp(o, t).n(Xe));
            },
            And: (o) => {
              e[pr] != null && r.c($yt(o, t).n(pr));
            },
            _: (o, n) => {
              if (!(n instanceof C || n instanceof Yd))
                throw new Error(
                  "Unable to serialize unknown union members in XML."
                );
              r.c(new C(o).c(n));
            },
          }),
          r
        );
      }),
      (jyt = (e, t) => {
        let r = new C(Tbt);
        return (
          e[ys] != null && r.c(C.of(Abt, e[ys]).n(ys)),
          e[Xu] != null && r.c(C.of(Ku, e[Xu]).n(Xu)),
          e[ft] != null && r.c(C.of(SP, e[ft]).n(ft)),
          r.cc(e, se),
          r
        );
      }),
      (Gyt = (e, t) => {
        let r = new C(Ibt);
        return r.cc(e, Qbt), e[An] != null && r.c(C.of(Bbt, e[An]).n(An)), r;
      }),
      (Vyt = (e, t) => {
        let r = new C(Pbt);
        return r.l(e, "Rules", "Rule", () => Lxt(e[Ts], t)), r;
      }),
      (Wyt = (e, t) => {
        let r = new C(Dbt);
        return e[gm] != null && r.c(Uxt(e[gm], t).n(gm)), r;
      }),
      (Kyt = (e, t) => {
        let r = new C(Fbt);
        return r.l(e, "Parts", "Part", () => Qyt(e[Qy], t)), r;
      }),
      (Yyt = (e, t) => {
        let r = new C($bt);
        return (
          r.cc(e, Qt),
          r.cc(e, rr),
          r.cc(e, or),
          r.cc(e, nr),
          r.cc(e, sr),
          r.cc(e, ir),
          e[wn] != null && r.c(C.of(wn, String(e[wn])).n(wn)),
          r
        );
      }),
      (Qyt = (e, t) => e.filter((r) => r != null).map((r) => Yyt(r, t).n(ao))),
      (Xyt = (e, t) => {
        let r = new C(im);
        return r.cc(e, OI), r.cc(e, DI), r;
      }),
      (Jyt = (e, t) => {
        let r = new C(Ubt);
        return r.l(e, "CORSRules", "CORSRule", () => ext(e[p2], t)), r;
      }),
      (Zyt = (e, t) => {
        let r = new C(u2);
        return (
          r.cc(e, vr),
          r.l(e, "AllowedHeaders", "AllowedHeader", () => Lyt(e[a2], t)),
          r.l(e, "AllowedMethods", "AllowedMethod", () => Fyt(e[d2], t)),
          r.l(e, "AllowedOrigins", "AllowedOrigin", () => Uyt(e[l2], t)),
          r.l(e, "ExposeHeaders", "ExposeHeader", () => uxt(e[h2], t)),
          e[Zd] != null && r.c(C.of(Zd, String(e[Zd])).n(Zd)),
          r
        );
      }),
      (ext = (e, t) => e.filter((r) => r != null).map((r) => Zyt(r, t).n(ao))),
      (txt = (e, t) => {
        let r = new C(Lbt);
        return (
          e[pp] != null && r.c(C.of(vbt, e[pp]).n(pp)),
          e[hm] != null && r.c(Fxt(e[hm], t).n(hm)),
          e[ft] != null && r.c(Gyt(e[ft], t).n(ft)),
          r
        );
      }),
      (rxt = (e, t) => {
        let r = new C(zbt);
        return (
          r.cc(e, r_t),
          r.cc(e, Vbt),
          r.cc(e, U8e),
          r.cc(e, X2),
          r.cc(e, D8e),
          r.cc(e, F8e),
          e[SI] != null && r.c(C.of(SI, String(e[SI])).n(SI)),
          r
        );
      }),
      (oxt = (e, t) => {
        let r = new C(qbt);
        return (
          r.cc(e, iwt), r.cc(e, U8e), r.cc(e, X2), r.cc(e, D8e), r.cc(e, F8e), r
        );
      }),
      (nxt = (e, t) => {
        let r = new C(cm);
        return (
          e[Es] != null && r.c(C.of(B8e, e[Es]).n(Es)),
          e[Rt] != null && r.c(C.of(Rt, String(e[Rt])).n(Rt)),
          e[rm] != null && r.c(C.of(rm, String(e[rm])).n(rm)),
          r
        );
      }),
      (sxt = (e, t) => {
        let r = new C(Xbt);
        return (
          r.l(e, "Objects", "Object", () => Xxt(e[owt], t)),
          e[wI] != null && r.c(C.of(wI, String(e[wI])).n(wI)),
          r
        );
      }),
      (ixt = (e, t) => {
        let r = new C(am);
        return e[de] != null && r.c(C.of(Ybt, e[de]).n(de)), r;
      }),
      (axt = (e, t) => {
        let r = new C(no);
        return (
          e[ft] != null && r.c(C.of(SP, e[ft]).n(ft)),
          e[Qu] != null && r.c(C.of(Ku, e[Qu]).n(Qu)),
          r.cc(e, tt),
          e[nm] != null && r.c(Myt(e[nm], t).n(nm)),
          e[mm] != null && r.c(dxt(e[mm], t).n(mm)),
          e[_m] != null && r.c(SEt(e[_m], t).n(_m)),
          e[ym] != null && r.c(zxt(e[ym], t).n(ym)),
          r
        );
      }),
      (cxt = (e, t) => {
        let r = new C(vi);
        return (
          e[Lz] != null && r.c(C.of(en, e[Lz]).n(Lz)),
          e[qz] != null && r.c(C.of(Do, e[qz]).n(qz)),
          r.cc(e, T_t),
          r
        );
      }),
      (dxt = (e, t) => {
        let r = new C(mm);
        return r.cc(e, qI), r;
      }),
      (mxt = (e, t) => {
        let r = new C(lm);
        return e[Ge] != null && r.c(C.of(Q2, e[Ge]).n(Ge)), r;
      }),
      (lxt = (e, t) => new C(dm)),
      ($2 = (e, t) => e.filter((r) => r != null).map((r) => C.of(Om, r).n(ao))),
      (fxt = (e, t) => {
        let r = new C(fm);
        return e[de] != null && r.c(C.of(Zbt, e[de]).n(de)), r;
      }),
      (uxt = (e, t) =>
        e.filter((r) => r != null).map((r) => C.of(g2, r).n(ao))),
      (pxt = (e, t) => {
        let r = new C(y2);
        return (
          e[Cr] != null && r.c(C.of(n_t, e[Cr]).n(Cr)),
          e[Ln] != null && r.c(C.of(s_t, e[Ln]).n(Ln)),
          r
        );
      }),
      (hxt = (e, t) => e.filter((r) => r != null).map((r) => pxt(r, t).n(ao))),
      (gxt = (e, t) => {
        let r = new C(vI);
        return r.cc(e, K8e), r;
      }),
      (yxt = (e, t) => {
        let r = new C(ga);
        if (e[Mn] != null) {
          let o = r8e(e[Mn], t).n(Mn);
          o.a("xmlns:xsi", "http://www.w3.org/2001/XMLSchema-instance"), r.c(o);
        }
        return r.cc(e, Oi), r;
      }),
      (r8e = (e, t) => {
        let r = new C(Mn);
        return (
          r.cc(e, Xs),
          r.cc(e, RI),
          r.cc(e, vr),
          r.cc(e, oP),
          r.a("xsi:type", e[An]),
          r
        );
      }),
      (o8e = (e, t) => e.filter((r) => r != null).map((r) => yxt(r, t).n(ga))),
      (xxt = (e, t) => {
        let r = new C(um);
        return r.cc(e, JI), r;
      }),
      (n8e = (e, t) => {
        let r = new C(pm);
        return (
          e[op] != null && r.c(rxt(e[op], t).n(op)),
          r.cc(e, Gbt),
          e[lp] != null && r.c(Pxt(e[lp], t).n(lp)),
          e[Xz] != null && r.c(aEt(e[Xz], t).n(Xz)),
          r
        );
      }),
      (Ext = (e, t) => {
        let r = new C(g_t);
        return r.cc(e, se), r.l(e, "Tags", "Tag", () => Op(e[un], t)), r;
      }),
      (Sxt = (e, t) => {
        let r = new C(C2);
        return (
          e[ke] != null && r.c(C.of(S_t, e[ke]).n(ke)),
          e[Oe] != null && r.c(Cxt(e[Oe], t).n(Oe)),
          e[de] != null && r.c(C.of(C_t, e[de]).n(de)),
          r.l(e, "Tierings", "Tiering", () => VEt(e[B2], t)),
          r
        );
      }),
      (Cxt = (e, t) => {
        let r = new C(E_t);
        return (
          r.cc(e, se),
          e[Xe] != null && r.c(vp(e[Xe], t).n(Xe)),
          e[pr] != null && r.c(Ext(e[pr], t).n(pr)),
          r
        );
      }),
      (bxt = (e, t) => {
        let r = new C(S2);
        return (
          e[no] != null && r.c(_xt(e[no], t).n(no)),
          e[Jd] != null && r.c(C.of(Jd, String(e[Jd])).n(Jd)),
          e[Oe] != null && r.c(Txt(e[Oe], t).n(Oe)),
          e[ke] != null && r.c(C.of(l_t, e[ke]).n(ke)),
          e[cp] != null && r.c(C.of(f_t, e[cp]).n(cp)),
          r.lc(e, "OptionalFields", "OptionalFields", () => Axt(e[Gu], t)),
          e[bp] != null && r.c(Ixt(e[bp], t).n(bp)),
          r
        );
      }),
      (_xt = (e, t) => {
        let r = new C(i_t);
        return e[ws] != null && r.c(Rxt(e[ws], t).n(ws)), r;
      }),
      (wxt = (e, t) => {
        let r = new C(a_t);
        return (
          e[k2] != null && r.c(UEt(e[k2], t).n(uP)),
          e[O2] != null && r.c(LEt(e[O2], t).n(fP)),
          r
        );
      }),
      (Txt = (e, t) => {
        let r = new C(c_t);
        return r.cc(e, se), r;
      }),
      (Axt = (e, t) =>
        e.filter((r) => r != null).map((r) => C.of(u_t, r).n(E2))),
      (Rxt = (e, t) => {
        let r = new C(p_t);
        return (
          r.cc(e, Ku),
          e[ft] != null && r.c(C.of(SP, e[ft]).n(ft)),
          e[ys] != null && r.c(C.of(d_t, e[ys]).n(ys)),
          r.cc(e, se),
          e[vi] != null && r.c(wxt(e[vi], t).n(vi)),
          r
        );
      }),
      (Ixt = (e, t) => {
        let r = new C(h_t);
        return e[ip] != null && r.c(C.of(m_t, e[ip]).n(ip)), r;
      }),
      (Pxt = (e, t) => {
        let r = new C(b_t);
        return e[An] != null && r.c(C.of(w_t, e[An]).n(An)), r;
      }),
      (vxt = (e, t) => {
        let r = new C(__t);
        return r.cc(e, X2), r;
      }),
      (Oxt = (e, t) => {
        let r = new C(R_t);
        return (
          e[ke] != null && r.c(C.of(Y2, e[ke]).n(ke)),
          e[NI] != null && r.c(C.of(NI, e[NI]).n(f2)),
          r.l(e, "Events", "Event", () => $2(e[ha], t)),
          e[Oe] != null && r.c(H2(e[Oe], t).n(Oe)),
          r
        );
      }),
      (kxt = (e, t) => e.filter((r) => r != null).map((r) => Oxt(r, t).n(ao))),
      (Dxt = (e, t) => {
        let r = new C(A_t);
        return (
          e[mn] != null && r.c(C.of(mn, wc(e[mn]).toString()).n(mn)),
          e[Rt] != null && r.c(C.of(Rt, String(e[Rt])).n(Rt)),
          e[Xd] != null && r.c(C.of(Xd, String(e[Xd])).n(Xd)),
          r
        );
      }),
      (Nxt = (e, t) => {
        let r = new C(O_t);
        return (
          e[ln] != null && r.c(Dxt(e[ln], t).n(ln)),
          r.cc(e, vr),
          r.cc(e, se),
          e[Oe] != null && r.c(Mxt(e[Oe], t).n(Oe)),
          e[de] != null && r.c(C.of(t_t, e[de]).n(de)),
          r.l(e, "Transitions", "Transition", () => QEt(e[F2], t)),
          r.l(
            e,
            "NoncurrentVersionTransitions",
            "NoncurrentVersionTransition",
            () => Kxt(e[T2], t)
          ),
          e[xm] != null && r.c(Vxt(e[xm], t).n(xm)),
          e[sm] != null && r.c(Nyt(e[sm], t).n(sm)),
          r
        );
      }),
      (Bxt = (e, t) => {
        let r = new C(k_t);
        return (
          r.cc(e, se),
          r.l(e, "Tags", "Tag", () => Op(e[un], t)),
          e[bs] != null && r.c(C.of(M8e, String(e[bs])).n(bs)),
          e[_s] != null && r.c(C.of(L8e, String(e[_s])).n(_s)),
          r
        );
      }),
      (Mxt = (e, t) => {
        let r = new C(D_t);
        return (
          r.cc(e, se),
          e[Xe] != null && r.c(vp(e[Xe], t).n(Xe)),
          e[bs] != null && r.c(C.of(M8e, String(e[bs])).n(bs)),
          e[_s] != null && r.c(C.of(L8e, String(e[_s])).n(_s)),
          e[pr] != null && r.c(Bxt(e[pr], t).n(pr)),
          r
        );
      }),
      (Lxt = (e, t) => e.filter((r) => r != null).map((r) => Nxt(r, t).n(ao))),
      (Fxt = (e, t) => {
        let r = new C(I_t);
        return (
          e[An] != null && r.c(C.of(N_t, e[An]).n(An)),
          e[Cr] != null && r.c(C.of(P_t, e[Cr]).n(Cr)),
          r
        );
      }),
      (Uxt = (e, t) => {
        let r = new C(gm);
        return (
          r.cc(e, eP),
          r.lc(e, "TargetGrants", "TargetGrants", () => qEt(e[Wu], t)),
          r.cc(e, tP),
          e[vm] != null && r.c(jEt(e[vm], t).n(vm)),
          r
        );
      }),
      ($xt = (e, t) => {
        let r = new C(N8e);
        return (
          e[Cr] != null && r.c(C.of(H_t, e[Cr]).n(Cr)),
          e[Ln] != null && r.c(C.of(j_t, e[Ln]).n(Ln)),
          r
        );
      }),
      (Hxt = (e, t) => {
        let r = new C(q_t);
        return e[XI] != null && r.c(IEt(e[XI], t).n(XI)), r;
      }),
      (zxt = (e, t) => {
        let r = new C(ym);
        return (
          e[de] != null && r.c(C.of(z_t, e[de]).n(de)),
          e[sp] != null && r.c(i8e(e[sp], t).n(sp)),
          r
        );
      }),
      (qxt = (e, t) => {
        let r = new C(B_t);
        return (
          r.cc(e, se), r.l(e, "Tags", "Tag", () => Op(e[un], t)), r.cc(e, fa), r
        );
      }),
      (jxt = (e, t) => {
        let r = new C(_2);
        return (
          e[ke] != null && r.c(C.of($_t, e[ke]).n(ke)),
          e[Oe] != null && r.c(Gxt(e[Oe], t).n(Oe)),
          r
        );
      }),
      (Gxt = (e, t) => {
        let r = new C(U_t);
        return (
          dI.visit(e, {
            Prefix: (o) => {
              e[se] != null && r.c(C.of(se, o).n(se));
            },
            Tag: (o) => {
              e[Xe] != null && r.c(vp(o, t).n(Xe));
            },
            AccessPointArn: (o) => {
              e[fa] != null && r.c(C.of(fa, o).n(fa));
            },
            And: (o) => {
              e[pr] != null && r.c(qxt(o, t).n(pr));
            },
            _: (o, n) => {
              if (!(n instanceof C || n instanceof Yd))
                throw new Error(
                  "Unable to serialize unknown union members in XML."
                );
              r.c(new C(o).c(n));
            },
          }),
          r
        );
      }),
      (Vxt = (e, t) => {
        let r = new C(xm);
        return (
          e[Ss] != null && r.c(C.of(Rt, String(e[Ss])).n(Ss)),
          e[Cs] != null && r.c(C.of(Q8e, String(e[Cs])).n(Cs)),
          r
        );
      }),
      (Wxt = (e, t) => {
        let r = new C(A2);
        return (
          e[Ss] != null && r.c(C.of(Rt, String(e[Ss])).n(Ss)),
          e[tt] != null && r.c(C.of(W8e, e[tt]).n(tt)),
          e[Cs] != null && r.c(C.of(Q8e, String(e[Cs])).n(Cs)),
          r
        );
      }),
      (Kxt = (e, t) => e.filter((r) => r != null).map((r) => Wxt(r, t).n(ao))),
      (Yxt = (e, t) => {
        let r = new C(G_t);
        return (
          r.l(e, "TopicConfigurations", "TopicConfiguration", () =>
            KEt(e[N2], t)
          ),
          r.l(e, "QueueConfigurations", "QueueConfiguration", () =>
            lEt(e[I2], t)
          ),
          r.l(
            e,
            "LambdaFunctionConfigurations",
            "CloudFunctionConfiguration",
            () => kxt(e[b2], t)
          ),
          e[dm] != null && r.c(lxt(e[dm], t).n(dm)),
          r
        );
      }),
      (H2 = (e, t) => {
        let r = new C(V_t);
        return e[Ge] != null && r.c(AEt(e[Ge], t).n(v2)), r;
      }),
      (Qxt = (e, t) => {
        let r = new C(Q_t);
        return (
          e[Ge] != null && r.c(C.of(Q2, e[Ge]).n(Ge)),
          e[st] != null && r.c(C.of(rwt, e[st]).n(st)),
          r.cc(e, Qt),
          e[_I] != null && r.c(C.of(_I, dr(e[_I]).toString()).n(_I)),
          e[ko] != null && r.c(C.of(ko, String(e[ko])).n(ko)),
          r
        );
      }),
      (Xxt = (e, t) => e.filter((r) => r != null).map((r) => Qxt(r, t).n(ao))),
      (Jxt = (e, t) => {
        let r = new C(X_t);
        return r.cc(e, UI), e[Tn] != null && r.c(tEt(e[Tn], t).n(Tn)), r;
      }),
      (Zxt = (e, t) => {
        let r = new C(J_t);
        return e[de] != null && r.c(C.of(Mm, e[de]).n(de)), r;
      }),
      (eEt = (e, t) => {
        let r = new C(Z_t);
        return (
          e[Es] != null && r.c(C.of(B8e, e[Es]).n(Es)),
          e[Sp] != null && r.c(C.of(mn, wc(e[Sp]).toString()).n(Sp)),
          r
        );
      }),
      (tEt = (e, t) => {
        let r = new C(ewt);
        return e[cm] != null && r.c(nxt(e[cm], t).n(cm)), r;
      }),
      (rEt = (e, t) => {
        let r = new C(FI);
        return e[r2] != null && r.c(REt(e[r2], t).n(r2)), r;
      }),
      (s8e = (e, t) => {
        let r = new C(Em);
        return (
          e[op] != null && r.c(oxt(e[op], t).n(op)),
          e[lp] != null && r.c(vxt(e[lp], t).n(lp)),
          r
        );
      }),
      (oEt = (e, t) => {
        let r = new C(Ct);
        return r.cc(e, Xs), r.cc(e, vr), r;
      }),
      (nEt = (e, t) => {
        let r = new C(W_t);
        return r.l(e, "Rules", "Rule", () => iEt(e[Ts], t)), r;
      }),
      (sEt = (e, t) => {
        let r = new C(Y_t);
        return r.cc(e, Ky), r;
      }),
      (iEt = (e, t) => e.filter((r) => r != null).map((r) => sEt(r, t).n(ao))),
      (aEt = (e, t) => new C(swt)),
      (cEt = (e, t) => {
        let r = new C(Sm);
        return r.cc(e, $I), r;
      }),
      (dEt = (e, t) => {
        let r = new C(nwt);
        return (
          e[Zu] != null && r.c(C.of(TI, String(e[Zu])).n(Zu)),
          e[dp] != null && r.c(C.of(TI, String(e[dp])).n(dp)),
          e[ep] != null && r.c(C.of(TI, String(e[ep])).n(ep)),
          e[xp] != null && r.c(C.of(TI, String(e[xp])).n(xp)),
          r
        );
      }),
      (mEt = (e, t) => {
        let r = new C(R2);
        return (
          e[ke] != null && r.c(C.of(Y2, e[ke]).n(ke)),
          e[zI] != null && r.c(C.of(zI, e[zI]).n(P2)),
          r.l(e, "Events", "Event", () => $2(e[ha], t)),
          e[Oe] != null && r.c(H2(e[Oe], t).n(Oe)),
          r
        );
      }),
      (lEt = (e, t) => e.filter((r) => r != null).map((r) => mEt(r, t).n(ao))),
      (fEt = (e, t) => {
        let r = new C(wm);
        return (
          r.cc(e, Rc), r.cc(e, kI), r.cc(e, vc), r.cc(e, jI), r.cc(e, GI), r
        );
      }),
      (uEt = (e, t) => {
        let r = new C(Cm);
        return r.cc(e, Rc), r.cc(e, vc), r;
      }),
      (pEt = (e, t) => {
        let r = new C(bm);
        return e[de] != null && r.c(C.of(cwt, e[de]).n(de)), r;
      }),
      (hEt = (e, t) => {
        let r = new C(awt);
        return r.cc(e, WI), r.l(e, "Rules", "Rule", () => EEt(e[Ts], t)), r;
      }),
      (gEt = (e, t) => {
        let r = new C(gwt);
        return (
          r.cc(e, vr),
          e[tm] != null && r.c(C.of(tm, String(e[tm])).n(tm)),
          r.cc(e, se),
          e[Oe] != null && r.c(xEt(e[Oe], t).n(Oe)),
          e[de] != null && r.c(C.of(pwt, e[de]).n(de)),
          e[Im] != null && r.c(MEt(e[Im], t).n(Im)),
          e[fm] != null && r.c(fxt(e[fm], t).n(fm)),
          e[no] != null && r.c(axt(e[no], t).n(no)),
          e[am] != null && r.c(ixt(e[am], t).n(am)),
          r
        );
      }),
      (yEt = (e, t) => {
        let r = new C(fwt);
        return r.cc(e, se), r.l(e, "Tags", "Tag", () => Op(e[un], t)), r;
      }),
      (xEt = (e, t) => {
        let r = new C(uwt);
        return (
          r.cc(e, se),
          e[Xe] != null && r.c(vp(e[Xe], t).n(Xe)),
          e[pr] != null && r.c(yEt(e[pr], t).n(pr)),
          r
        );
      }),
      (EEt = (e, t) => e.filter((r) => r != null).map((r) => gEt(r, t).n(ao))),
      (SEt = (e, t) => {
        let r = new C(_m);
        return (
          e[de] != null && r.c(C.of(Swt, e[de]).n(de)),
          e[Tp] != null && r.c(i8e(e[Tp], t).n(Tp)),
          r
        );
      }),
      (i8e = (e, t) => {
        let r = new C(Cwt);
        return e[em] != null && r.c(C.of(em, String(e[em])).n(em)), r;
      }),
      (CEt = (e, t) => {
        let r = new C(mwt);
        return r.cc(e, HI), r;
      }),
      (bEt = (e, t) => {
        let r = new C(VI);
        return e[Fz] != null && r.c(C.of(e_t, String(e[Fz])).n(Fz)), r;
      }),
      (_Et = (e, t) => {
        let r = new C(ywt);
        return (
          e[Rt] != null && r.c(C.of(Rt, String(e[Rt])).n(Rt)),
          e[vI] != null && r.c(gxt(e[vI], t).n(vI)),
          e[An] != null && r.c(C.of(hwt, e[An]).n(An)),
          r.cc(e, K8e),
          r.cc(e, Jbt),
          e[YI] != null && r.c(vEt(e[YI], t).n(YI)),
          e[FI] != null && r.c(rEt(e[FI], t).n(FI)),
          r
        );
      }),
      (wEt = (e, t) => {
        let r = new C(lP);
        return (
          e[im] != null && r.c(Xyt(e[im], t).n(im)),
          e[wm] != null && r.c(fEt(e[wm], t).n(wm)),
          r
        );
      }),
      (TEt = (e, t) => e.filter((r) => r != null).map((r) => wEt(r, t).n(lP))),
      (AEt = (e, t) => {
        let r = new C(Rwt);
        return r.l(e, "FilterRules", "FilterRule", () => hxt(e[x2], t)), r;
      }),
      (REt = (e, t) => {
        let r = new C(Iwt);
        return (
          r.cc(e, SP),
          e[se] != null && r.c(C.of(v_t, e[se]).n(se)),
          e[vi] != null && r.c(cxt(e[vi], t).n(vi)),
          e[kz] != null && r.c(C.of(K_t, e[kz]).n(kz)),
          r.lc(e, "AccessControlList", "AccessControlList", () =>
            o8e(e[om], t)
          ),
          e[Pm] != null && r.c(z2(e[Pm], t).n(Pm)),
          r.lc(e, "UserMetadata", "UserMetadata", () => XEt(e[Uwt], t)),
          r.cc(e, tt),
          r
        );
      }),
      (IEt = (e, t) => {
        let r = new C(XI);
        return (
          e[_p] != null && r.c(C.of(Nwt, e[_p]).n(_p)),
          e[wp] != null && r.c(C.of(Bwt, e[wp]).n(wp)),
          r
        );
      }),
      (PEt = (e, t) => {
        let r = new C(QI);
        return (
          e[AI] != null && r.c(C.of(AI, String(e[AI])).n(AI)),
          e[bI] != null && r.c(C.of(bI, String(e[bI])).n(bI)),
          r
        );
      }),
      (vEt = (e, t) => {
        let r = new C(YI);
        return (
          e[pm] != null && r.c(n8e(e[pm], t).n(pm)),
          r.cc(e, O8e),
          r.cc(e, k8e),
          e[Em] != null && r.c(s8e(e[Em], t).n(Em)),
          r
        );
      }),
      (OEt = (e, t) => {
        let r = new C(Owt);
        return (
          e[Cp] != null && r.c(C.of(en, e[Cp]).n(Cp)),
          e[up] != null && r.c(C.of(Do, e[up]).n(up)),
          r
        );
      }),
      (kEt = (e, t) => {
        let r = new C(kwt);
        return r.l(e, "Rules", "Rule", () => NEt(e[Ts], t)), r;
      }),
      (DEt = (e, t) => {
        let r = new C(Dwt);
        return (
          e[Yu] != null && r.c(OEt(e[Yu], t).n(Yu)),
          e[ur] != null && r.c(C.of(ur, String(e[ur])).n(ur)),
          r
        );
      }),
      (NEt = (e, t) => e.filter((r) => r != null).map((r) => DEt(r, t).n(ao))),
      (BEt = (e, t) => new C(Rm)),
      (MEt = (e, t) => {
        let r = new C(Im);
        return (
          e[Am] != null && r.c(FEt(e[Am], t).n(Am)),
          e[bm] != null && r.c(pEt(e[bm], t).n(bm)),
          r
        );
      }),
      (LEt = (e, t) => {
        let r = new C(fP);
        return e[fp] != null && r.c(C.of(Do, e[fp]).n(fp)), r;
      }),
      (FEt = (e, t) => {
        let r = new C(Am);
        return e[de] != null && r.c(C.of(Awt, e[de]).n(de)), r;
      }),
      (UEt = (e, t) => new C(uP)),
      ($Et = (e, t) => {
        let r = new C(Tm);
        return e[np] != null && r.c(HEt(e[np], t).n(np)), r;
      }),
      (HEt = (e, t) => {
        let r = new C(bwt);
        return (
          e[yp] != null && r.c(C.of(_wt, e[yp]).n(yp)),
          e[no] != null && r.c(zyt(e[no], t).n(no)),
          r
        );
      }),
      (vp = (e, t) => {
        let r = new C(Xe);
        return e[Ge] != null && r.c(C.of(Q2, e[Ge]).n(Ge)), r.cc(e, Ln), r;
      }),
      (z2 = (e, t) => {
        let r = new C(Pm);
        return r.lc(e, "TagSet", "TagSet", () => Op(e[Ys], t)), r;
      }),
      (Op = (e, t) => e.filter((r) => r != null).map((r) => vp(r, t).n(Xe))),
      (zEt = (e, t) => {
        let r = new C(Lwt);
        if (e[Mn] != null) {
          let o = r8e(e[Mn], t).n(Mn);
          o.a("xmlns:xsi", "http://www.w3.org/2001/XMLSchema-instance"), r.c(o);
        }
        return e[Oi] != null && r.c(C.of(kbt, e[Oi]).n(Oi)), r;
      }),
      (qEt = (e, t) => e.filter((r) => r != null).map((r) => zEt(r, t).n(ga))),
      (jEt = (e, t) => {
        let r = new C(vm);
        return (
          e[Rm] != null && r.c(BEt(e[Rm], t).n(Rm)),
          e[Sm] != null && r.c(cEt(e[Sm], t).n(Sm)),
          r
        );
      }),
      (GEt = (e, t) => {
        let r = new C(M2);
        return (
          e[Rt] != null && r.c(C.of(x_t, String(e[Rt])).n(Rt)),
          e[ua] != null && r.c(C.of(y_t, e[ua]).n(ua)),
          r
        );
      }),
      (VEt = (e, t) => e.filter((r) => r != null).map((r) => GEt(r, t).n(ao))),
      (WEt = (e, t) => {
        let r = new C(D2);
        return (
          e[ke] != null && r.c(C.of(Y2, e[ke]).n(ke)),
          e[ZI] != null && r.c(C.of(ZI, e[ZI]).n(L2)),
          r.l(e, "Events", "Event", () => $2(e[ha], t)),
          e[Oe] != null && r.c(H2(e[Oe], t).n(Oe)),
          r
        );
      }),
      (KEt = (e, t) => e.filter((r) => r != null).map((r) => WEt(r, t).n(ao))),
      (YEt = (e, t) => {
        let r = new C(U2);
        return (
          e[mn] != null && r.c(C.of(mn, wc(e[mn]).toString()).n(mn)),
          e[Rt] != null && r.c(C.of(Rt, String(e[Rt])).n(Rt)),
          e[tt] != null && r.c(C.of(W8e, e[tt]).n(tt)),
          r
        );
      }),
      (QEt = (e, t) => e.filter((r) => r != null).map((r) => YEt(r, t).n(ao))),
      (XEt = (e, t) => e.filter((r) => r != null).map((r) => $xt(r, t).n(N8e))),
      (JEt = (e, t) => {
        let r = new C($wt);
        return (
          e[MI] != null && r.c(C.of(MI, e[MI]).n(w2)),
          e[de] != null && r.c(C.of(Mbt, e[de]).n(de)),
          r
        );
      }),
      (ZEt = (e, t) => {
        let r = new C(Hwt);
        return (
          e[lm] != null && r.c(mxt(e[lm], t).n(lm)),
          e[um] != null && r.c(xxt(e[um], t).n(um)),
          e[Cm] != null && r.c(uEt(e[Cm], t).n(Cm)),
          r.lc(e, "RoutingRules", "RoutingRules", () => TEt(e[Vu], t)),
          r
        );
      }),
      (eSt = (e, t) => {
        let r = {};
        return e[Qd] != null && (r[Qd] = wt(e[Qd])), r;
      }),
      (tSt = (e, t) => {
        let r = {};
        return e[Ct] != null && (r[Ct] = p(e[Ct])), r;
      }),
      (rSt = (e, t) => (e || []).filter((r) => r != null).map((r) => p(r))),
      (oSt = (e, t) => (e || []).filter((r) => r != null).map((r) => p(r))),
      (nSt = (e, t) => (e || []).filter((r) => r != null).map((r) => p(r))),
      (sSt = (e, t) => {
        let r = {};
        return (
          e[se] != null && (r[se] = p(e[se])),
          e.Tag === ""
            ? (r[un] = [])
            : e[Xe] != null && (r[un] = Bm(Ne(e[Xe]), t)),
          r
        );
      }),
      (a8e = (e, t) => {
        let r = {};
        return (
          e[ke] != null && (r[ke] = p(e[ke])),
          e.Filter === "" || (e[Oe] != null && (r[Oe] = cSt(Mh(e[Oe]), t))),
          e[Tm] != null && (r[Tm] = sbt(e[Tm], t)),
          r
        );
      }),
      (iSt = (e, t) =>
        (e || []).filter((r) => r != null).map((r) => a8e(r, t))),
      (aSt = (e, t) => {
        let r = {};
        return e[ws] != null && (r[ws] = dSt(e[ws], t)), r;
      }),
      (cSt = (e, t) =>
        e[se] != null
          ? { Prefix: p(e[se]) }
          : e[Xe] != null
            ? { Tag: kp(e[Xe], t) }
            : e[pr] != null
              ? { And: sSt(e[pr], t) }
              : { $unknown: Object.entries(e)[0] }),
      (dSt = (e, t) => {
        let r = {};
        return (
          e[ys] != null && (r[ys] = p(e[ys])),
          e[Xu] != null && (r[Xu] = p(e[Xu])),
          e[ft] != null && (r[ft] = p(e[ft])),
          e[se] != null && (r[se] = p(e[se])),
          r
        );
      }),
      (mSt = (e, t) => {
        let r = {};
        return (
          e[Cr] != null && (r[Cr] = p(e[Cr])),
          e[Dz] != null && (r[Dz] = F(qr(e[Dz]))),
          e[Vy] != null && (r[Vy] = p(e[Vy])),
          r
        );
      }),
      (c8e = (e, t) =>
        (e || []).filter((r) => r != null).map((r) => mSt(r, t))),
      (lSt = (e, t) => {
        let r = {};
        return (
          e[rr] != null && (r[rr] = p(e[rr])),
          e[or] != null && (r[or] = p(e[or])),
          e[nr] != null && (r[nr] = p(e[nr])),
          e[sr] != null && (r[sr] = p(e[sr])),
          e[ir] != null && (r[ir] = p(e[ir])),
          e[ar] != null && (r[ar] = p(e[ar])),
          r
        );
      }),
      (d8e = (e, t) => (e || []).filter((r) => r != null).map((r) => p(r))),
      (fSt = (e, t) => {
        let r = {};
        return e[se] != null && (r[se] = p(e[se])), r;
      }),
      (EP = (e, t) => (e || []).filter((r) => r != null).map((r) => fSt(r, t))),
      (uSt = (e, t) => {
        let r = {};
        return (
          e[OI] != null && (r[OI] = p(e[OI])),
          e[DI] != null && (r[DI] = p(e[DI])),
          r
        );
      }),
      (pSt = (e, t) => ({})),
      (hSt = (e, t) => {
        let r = {};
        return (
          e[Qt] != null && (r[Qt] = p(e[Qt])),
          e[Or] != null && (r[Or] = F(qr(e[Or]))),
          e[ar] != null && (r[ar] = p(e[ar])),
          e[rr] != null && (r[rr] = p(e[rr])),
          e[or] != null && (r[or] = p(e[or])),
          e[nr] != null && (r[nr] = p(e[nr])),
          e[sr] != null && (r[sr] = p(e[sr])),
          e[ir] != null && (r[ir] = p(e[ir])),
          r
        );
      }),
      (gSt = (e, t) => {
        let r = {};
        return (
          e[Qt] != null && (r[Qt] = p(e[Qt])),
          e[Or] != null && (r[Or] = F(qr(e[Or]))),
          e[rr] != null && (r[rr] = p(e[rr])),
          e[or] != null && (r[or] = p(e[or])),
          e[nr] != null && (r[nr] = p(e[nr])),
          e[sr] != null && (r[sr] = p(e[sr])),
          e[ir] != null && (r[ir] = p(e[ir])),
          r
        );
      }),
      (ySt = (e, t) => {
        let r = {};
        return (
          e[vr] != null && (r[vr] = p(e[vr])),
          e.AllowedHeader === ""
            ? (r[a2] = [])
            : e[i2] != null && (r[a2] = rSt(Ne(e[i2]), t)),
          e.AllowedMethod === ""
            ? (r[d2] = [])
            : e[c2] != null && (r[d2] = oSt(Ne(e[c2]), t)),
          e.AllowedOrigin === ""
            ? (r[l2] = [])
            : e[m2] != null && (r[l2] = nSt(Ne(e[m2]), t)),
          e.ExposeHeader === ""
            ? (r[h2] = [])
            : e[g2] != null && (r[h2] = NSt(Ne(e[g2]), t)),
          e[Zd] != null && (r[Zd] = wt(e[Zd])),
          r
        );
      }),
      (xSt = (e, t) =>
        (e || []).filter((r) => r != null).map((r) => ySt(r, t))),
      (ESt = (e, t) => {
        let r = {};
        return (
          e[Es] != null && (r[Es] = p(e[Es])),
          e[Rt] != null && (r[Rt] = wt(e[Rt])),
          e[rm] != null && (r[rm] = wt(e[rm])),
          r
        );
      }),
      (SSt = (e, t) => {
        let r = {};
        return (
          e[Ge] != null && (r[Ge] = p(e[Ge])),
          e[st] != null && (r[st] = p(e[st])),
          e[Qs] != null && (r[Qs] = mt(e[Qs])),
          e[Mz] != null && (r[Mz] = p(e[Mz])),
          r
        );
      }),
      (CSt = (e, t) =>
        (e || []).filter((r) => r != null).map((r) => SSt(r, t))),
      (bSt = (e, t) => {
        let r = {};
        return (
          e[Ct] != null && (r[Ct] = Dc(e[Ct], t)),
          e[Ge] != null && (r[Ge] = p(e[Ge])),
          e[st] != null && (r[st] = p(e[st])),
          e[ap] != null && (r[ap] = mt(e[ap])),
          e[Or] != null && (r[Or] = F(qr(e[Or]))),
          r
        );
      }),
      (_St = (e, t) => {
        let r = {};
        return e[de] != null && (r[de] = p(e[de])), r;
      }),
      (wSt = (e, t) =>
        (e || []).filter((r) => r != null).map((r) => bSt(r, t))),
      (TSt = (e, t) => {
        let r = {};
        return (
          e[ft] != null && (r[ft] = p(e[ft])),
          e[Qu] != null && (r[Qu] = p(e[Qu])),
          e[tt] != null && (r[tt] = p(e[tt])),
          e[nm] != null && (r[nm] = tSt(e[nm], t)),
          e[mm] != null && (r[mm] = ASt(e[mm], t)),
          e[_m] != null && (r[_m] = qCt(e[_m], t)),
          e[ym] != null && (r[ym] = iCt(e[ym], t)),
          r
        );
      }),
      (ASt = (e, t) => {
        let r = {};
        return e[qI] != null && (r[qI] = p(e[qI])), r;
      }),
      (RSt = (e, t) => ({})),
      (ISt = (e, t) => {
        let r = {};
        return (
          e[Ge] != null && (r[Ge] = p(e[Ge])),
          e[st] != null && (r[st] = p(e[st])),
          e[Bz] != null && (r[Bz] = p(e[Bz])),
          e[Gz] != null && (r[Gz] = p(e[Gz])),
          r
        );
      }),
      (PSt = (e, t) => {
        let r = {};
        return (
          e[II] != null && (r[II] = p(e[II])),
          e[PI] != null && (r[PI] = p(e[PI])),
          r
        );
      }),
      (vSt = (e, t) => {
        let r = {};
        return e[Ge] != null && (r[Ge] = p(e[Ge])), r;
      }),
      (OSt = (e, t) =>
        (e || []).filter((r) => r != null).map((r) => ISt(r, t))),
      (kSt = (e, t) => ({})),
      (q2 = (e, t) => (e || []).filter((r) => r != null).map((r) => p(r))),
      (DSt = (e, t) => {
        let r = {};
        return e[de] != null && (r[de] = p(e[de])), r;
      }),
      (NSt = (e, t) => (e || []).filter((r) => r != null).map((r) => p(r))),
      (BSt = (e, t) => {
        let r = {};
        return (
          e[Cr] != null && (r[Cr] = p(e[Cr])),
          e[Ln] != null && (r[Ln] = p(e[Ln])),
          r
        );
      }),
      (MSt = (e, t) =>
        (e || []).filter((r) => r != null).map((r) => BSt(r, t))),
      (LSt = (e, t) => {
        let r = {};
        return (
          e[jz] != null && (r[jz] = sCt(e[jz], t)),
          e[de] != null && (r[de] = p(e[de])),
          e[Wy] != null && (r[Wy] = PSt(e[Wy], t)),
          r
        );
      }),
      (FSt = (e, t) => {
        let r = {};
        return (
          e[Ip] != null && (r[Fwt] = wt(e[Ip])),
          e[Pc] != null && (r[Pc] = p(e[Pc])),
          e[gp] != null && (r[gp] = p(e[gp])),
          e[pa] != null && (r[pa] = wt(e[pa])),
          e[Ft] != null && (r[Ft] = mt(e[Ft])),
          e.Part === ""
            ? (r[Qy] = [])
            : e[mP] != null && (r[Qy] = PCt(Ne(e[mP]), t)),
          r
        );
      }),
      (USt = (e, t) => {
        let r = {};
        return (
          e[Mn] != null && (r[Mn] = m8e(e[Mn], t)),
          e[Oi] != null && (r[Oi] = p(e[Oi])),
          r
        );
      }),
      (m8e = (e, t) => {
        let r = {};
        return (
          e[Xs] != null && (r[Xs] = p(e[Xs])),
          e[RI] != null && (r[RI] = p(e[RI])),
          e[vr] != null && (r[vr] = p(e[vr])),
          e[oP] != null && (r[oP] = p(e[oP])),
          e[gje] != null && (r[An] = p(e[gje])),
          r
        );
      }),
      (l8e = (e, t) =>
        (e || []).filter((r) => r != null).map((r) => USt(r, t))),
      ($St = (e, t) => {
        let r = {};
        return e[JI] != null && (r[JI] = p(e[JI])), r;
      }),
      (f8e = (e, t) => {
        let r = {};
        return (
          e[vr] != null && (r[vr] = p(e[vr])),
          e[Xs] != null && (r[Xs] = p(e[Xs])),
          r
        );
      }),
      (HSt = (e, t) => {
        let r = {};
        return (
          e[se] != null && (r[se] = p(e[se])),
          e.Tag === ""
            ? (r[un] = [])
            : e[Xe] != null && (r[un] = Bm(Ne(e[Xe]), t)),
          r
        );
      }),
      (u8e = (e, t) => {
        let r = {};
        return (
          e[ke] != null && (r[ke] = p(e[ke])),
          e[Oe] != null && (r[Oe] = qSt(e[Oe], t)),
          e[de] != null && (r[de] = p(e[de])),
          e.Tiering === ""
            ? (r[B2] = [])
            : e[M2] != null && (r[B2] = lbt(Ne(e[M2]), t)),
          r
        );
      }),
      (zSt = (e, t) =>
        (e || []).filter((r) => r != null).map((r) => u8e(r, t))),
      (qSt = (e, t) => {
        let r = {};
        return (
          e[se] != null && (r[se] = p(e[se])),
          e[Xe] != null && (r[Xe] = kp(e[Xe], t)),
          e[pr] != null && (r[pr] = HSt(e[pr], t)),
          r
        );
      }),
      (p8e = (e, t) => {
        let r = {};
        return (
          e[no] != null && (r[no] = GSt(e[no], t)),
          e[Jd] != null && (r[Jd] = mt(e[Jd])),
          e[Oe] != null && (r[Oe] = WSt(e[Oe], t)),
          e[ke] != null && (r[ke] = p(e[ke])),
          e[cp] != null && (r[cp] = p(e[cp])),
          e.OptionalFields === ""
            ? (r[Gu] = [])
            : e[Gu] != null &&
              e[Gu][E2] != null &&
              (r[Gu] = KSt(Ne(e[Gu][E2]), t)),
          e[bp] != null && (r[bp] = QSt(e[bp], t)),
          r
        );
      }),
      (jSt = (e, t) =>
        (e || []).filter((r) => r != null).map((r) => p8e(r, t))),
      (GSt = (e, t) => {
        let r = {};
        return e[ws] != null && (r[ws] = YSt(e[ws], t)), r;
      }),
      (VSt = (e, t) => {
        let r = {};
        return (
          e[uP] != null && (r[k2] = obt(e[uP], t)),
          e[fP] != null && (r[O2] = tbt(e[fP], t)),
          r
        );
      }),
      (WSt = (e, t) => {
        let r = {};
        return e[se] != null && (r[se] = p(e[se])), r;
      }),
      (KSt = (e, t) => (e || []).filter((r) => r != null).map((r) => p(r))),
      (YSt = (e, t) => {
        let r = {};
        return (
          e[Ku] != null && (r[Ku] = p(e[Ku])),
          e[ft] != null && (r[ft] = p(e[ft])),
          e[ys] != null && (r[ys] = p(e[ys])),
          e[se] != null && (r[se] = p(e[se])),
          e[vi] != null && (r[vi] = VSt(e[vi], t)),
          r
        );
      }),
      (QSt = (e, t) => {
        let r = {};
        return e[ip] != null && (r[ip] = p(e[ip])), r;
      }),
      (XSt = (e, t) => {
        let r = {};
        return (
          e[ke] != null && (r[ke] = p(e[ke])),
          e[f2] != null && (r[NI] = p(e[f2])),
          e.Event === ""
            ? (r[ha] = [])
            : e[Om] != null && (r[ha] = q2(Ne(e[Om]), t)),
          e[Oe] != null && (r[Oe] = j2(e[Oe], t)),
          r
        );
      }),
      (JSt = (e, t) =>
        (e || []).filter((r) => r != null).map((r) => XSt(r, t))),
      (ZSt = (e, t) => {
        let r = {};
        return (
          e[mn] != null && (r[mn] = F(qr(e[mn]))),
          e[Rt] != null && (r[Rt] = wt(e[Rt])),
          e[Xd] != null && (r[Xd] = mt(e[Xd])),
          r
        );
      }),
      (eCt = (e, t) => {
        let r = {};
        return (
          e[ln] != null && (r[ln] = ZSt(e[ln], t)),
          e[vr] != null && (r[vr] = p(e[vr])),
          e[se] != null && (r[se] = p(e[se])),
          e[Oe] != null && (r[Oe] = rCt(e[Oe], t)),
          e[de] != null && (r[de] = p(e[de])),
          e.Transition === ""
            ? (r[F2] = [])
            : e[U2] != null && (r[F2] = hbt(Ne(e[U2]), t)),
          e.NoncurrentVersionTransition === ""
            ? (r[T2] = [])
            : e[A2] != null && (r[T2] = pCt(Ne(e[A2]), t)),
          e[xm] != null && (r[xm] = fCt(e[xm], t)),
          e[sm] != null && (r[sm] = eSt(e[sm], t)),
          r
        );
      }),
      (tCt = (e, t) => {
        let r = {};
        return (
          e[se] != null && (r[se] = p(e[se])),
          e.Tag === ""
            ? (r[un] = [])
            : e[Xe] != null && (r[un] = Bm(Ne(e[Xe]), t)),
          e[bs] != null && (r[bs] = Jr(e[bs])),
          e[_s] != null && (r[_s] = Jr(e[_s])),
          r
        );
      }),
      (rCt = (e, t) => {
        let r = {};
        return (
          e[se] != null && (r[se] = p(e[se])),
          e[Xe] != null && (r[Xe] = kp(e[Xe], t)),
          e[bs] != null && (r[bs] = Jr(e[bs])),
          e[_s] != null && (r[_s] = Jr(e[_s])),
          e[pr] != null && (r[pr] = tCt(e[pr], t)),
          r
        );
      }),
      (oCt = (e, t) =>
        (e || []).filter((r) => r != null).map((r) => eCt(r, t))),
      (nCt = (e, t) => {
        let r = {};
        return (
          e[eP] != null && (r[eP] = p(e[eP])),
          e.TargetGrants === ""
            ? (r[Wu] = [])
            : e[Wu] != null &&
              e[Wu][ga] != null &&
              (r[Wu] = cbt(Ne(e[Wu][ga]), t)),
          e[tP] != null && (r[tP] = p(e[tP])),
          e[vm] != null && (r[vm] = dbt(e[vm], t)),
          r
        );
      }),
      (sCt = (e, t) => {
        let r = {};
        return e[t2] != null && (r[t2] = WCt(e[t2], t)), r;
      }),
      (iCt = (e, t) => {
        let r = {};
        return (
          e[de] != null && (r[de] = p(e[de])),
          e[sp] != null && (r[sp] = y8e(e[sp], t)),
          r
        );
      }),
      (aCt = (e, t) => {
        let r = {};
        return (
          e[se] != null && (r[se] = p(e[se])),
          e.Tag === ""
            ? (r[un] = [])
            : e[Xe] != null && (r[un] = Bm(Ne(e[Xe]), t)),
          e[fa] != null && (r[fa] = p(e[fa])),
          r
        );
      }),
      (h8e = (e, t) => {
        let r = {};
        return (
          e[ke] != null && (r[ke] = p(e[ke])),
          e.Filter === "" || (e[Oe] != null && (r[Oe] = dCt(Mh(e[Oe]), t))),
          r
        );
      }),
      (cCt = (e, t) =>
        (e || []).filter((r) => r != null).map((r) => h8e(r, t))),
      (dCt = (e, t) =>
        e[se] != null
          ? { Prefix: p(e[se]) }
          : e[Xe] != null
            ? { Tag: kp(e[Xe], t) }
            : e[fa] != null
              ? { AccessPointArn: p(e[fa]) }
              : e[pr] != null
                ? { And: aCt(e[pr], t) }
                : { $unknown: Object.entries(e)[0] }),
      (mCt = (e, t) => {
        let r = {};
        return (
          e[Rn] != null && (r[Rn] = p(e[Rn])),
          e[Ge] != null && (r[Ge] = p(e[Ge])),
          e[Hz] != null && (r[Hz] = F(qr(e[Hz]))),
          e[tt] != null && (r[tt] = p(e[tt])),
          e[Ct] != null && (r[Ct] = Dc(e[Ct], t)),
          e[mp] != null && (r[mp] = f8e(e[mp], t)),
          e[et] != null && (r[et] = p(e[et])),
          e[ar] != null && (r[ar] = p(e[ar])),
          r
        );
      }),
      (lCt = (e, t) =>
        (e || []).filter((r) => r != null).map((r) => mCt(r, t))),
      (fCt = (e, t) => {
        let r = {};
        return (
          e[Ss] != null && (r[Ss] = wt(e[Ss])),
          e[Cs] != null && (r[Cs] = wt(e[Cs])),
          r
        );
      }),
      (uCt = (e, t) => {
        let r = {};
        return (
          e[Ss] != null && (r[Ss] = wt(e[Ss])),
          e[tt] != null && (r[tt] = p(e[tt])),
          e[Cs] != null && (r[Cs] = wt(e[Cs])),
          r
        );
      }),
      (pCt = (e, t) =>
        (e || []).filter((r) => r != null).map((r) => uCt(r, t))),
      (j2 = (e, t) => {
        let r = {};
        return e[v2] != null && (r[Ge] = VCt(e[v2], t)), r;
      }),
      (hCt = (e, t) => {
        let r = {};
        return (
          e[Ge] != null && (r[Ge] = p(e[Ge])),
          e[Or] != null && (r[Or] = F(qr(e[Or]))),
          e[Qt] != null && (r[Qt] = p(e[Qt])),
          e.ChecksumAlgorithm === ""
            ? (r[et] = [])
            : e[et] != null && (r[et] = d8e(Ne(e[et]), t)),
          e[ar] != null && (r[ar] = p(e[ar])),
          e[ko] != null && (r[ko] = Jr(e[ko])),
          e[tt] != null && (r[tt] = p(e[tt])),
          e[Ct] != null && (r[Ct] = Dc(e[Ct], t)),
          e[Ep] != null && (r[Ep] = x8e(e[Ep], t)),
          r
        );
      }),
      (g8e = (e, t) =>
        (e || []).filter((r) => r != null).map((r) => hCt(r, t))),
      (gCt = (e, t) => {
        let r = {};
        return (
          e[UI] != null && (r[UI] = p(e[UI])),
          e[Tn] != null && (r[Tn] = ECt(e[Tn], t)),
          r
        );
      }),
      (yCt = (e, t) => {
        let r = {};
        return e[de] != null && (r[de] = p(e[de])), r;
      }),
      (xCt = (e, t) => {
        let r = {};
        return (
          e[Es] != null && (r[Es] = p(e[Es])),
          e[Sp] != null && (r[Sp] = F(qr(e[Sp]))),
          r
        );
      }),
      (ECt = (e, t) => {
        let r = {};
        return e[cm] != null && (r[cm] = ESt(e[cm], t)), r;
      }),
      (SCt = (e, t) => {
        let r = {};
        return (
          e[wn] != null && (r[wn] = wt(e[wn])),
          e[ko] != null && (r[ko] = Jr(e[ko])),
          e[rr] != null && (r[rr] = p(e[rr])),
          e[or] != null && (r[or] = p(e[or])),
          e[nr] != null && (r[nr] = p(e[nr])),
          e[sr] != null && (r[sr] = p(e[sr])),
          e[ir] != null && (r[ir] = p(e[ir])),
          r
        );
      }),
      (CCt = (e, t) => {
        let r = {};
        return (
          e[Qt] != null && (r[Qt] = p(e[Qt])),
          e.ChecksumAlgorithm === ""
            ? (r[et] = [])
            : e[et] != null && (r[et] = d8e(Ne(e[et]), t)),
          e[ar] != null && (r[ar] = p(e[ar])),
          e[ko] != null && (r[ko] = Jr(e[ko])),
          e[tt] != null && (r[tt] = p(e[tt])),
          e[Ge] != null && (r[Ge] = p(e[Ge])),
          e[st] != null && (r[st] = p(e[st])),
          e[ap] != null && (r[ap] = mt(e[ap])),
          e[Or] != null && (r[Or] = F(qr(e[Or]))),
          e[Ct] != null && (r[Ct] = Dc(e[Ct], t)),
          e[Ep] != null && (r[Ep] = x8e(e[Ep], t)),
          r
        );
      }),
      (bCt = (e, t) =>
        (e || []).filter((r) => r != null).map((r) => CCt(r, t))),
      (Dc = (e, t) => {
        let r = {};
        return (
          e[Xs] != null && (r[Xs] = p(e[Xs])),
          e[vr] != null && (r[vr] = p(e[vr])),
          r
        );
      }),
      (_Ct = (e, t) => {
        let r = {};
        return (
          e.Rule === ""
            ? (r[Ts] = [])
            : e[Tn] != null && (r[Ts] = TCt(Ne(e[Tn]), t)),
          r
        );
      }),
      (wCt = (e, t) => {
        let r = {};
        return e[Ky] != null && (r[Ky] = p(e[Ky])), r;
      }),
      (TCt = (e, t) =>
        (e || []).filter((r) => r != null).map((r) => wCt(r, t))),
      (ACt = (e, t) => {
        let r = {};
        return (
          e[wn] != null && (r[wn] = wt(e[wn])),
          e[Or] != null && (r[Or] = F(qr(e[Or]))),
          e[Qt] != null && (r[Qt] = p(e[Qt])),
          e[ko] != null && (r[ko] = Jr(e[ko])),
          e[rr] != null && (r[rr] = p(e[rr])),
          e[or] != null && (r[or] = p(e[or])),
          e[nr] != null && (r[nr] = p(e[nr])),
          e[sr] != null && (r[sr] = p(e[sr])),
          e[ir] != null && (r[ir] = p(e[ir])),
          r
        );
      }),
      (RCt = (e, t) => {
        let r = {};
        return e[$I] != null && (r[$I] = p(e[$I])), r;
      }),
      (ICt = (e, t) =>
        (e || []).filter((r) => r != null).map((r) => ACt(r, t))),
      (PCt = (e, t) =>
        (e || []).filter((r) => r != null).map((r) => SCt(r, t))),
      (vCt = (e, t) => {
        let r = {};
        return e[Uz] != null && (r[Uz] = mt(e[Uz])), r;
      }),
      (OCt = (e, t) => {
        let r = {};
        return (
          e[rp] != null && (r[rp] = Jr(e[rp])),
          e[Ju] != null && (r[Ju] = Jr(e[Ju])),
          e[tp] != null && (r[tp] = Jr(e[tp])),
          r
        );
      }),
      (kCt = (e, t) => {
        let r = {};
        return (
          e[Zu] != null && (r[Zu] = mt(e[Zu])),
          e[dp] != null && (r[dp] = mt(e[dp])),
          e[ep] != null && (r[ep] = mt(e[ep])),
          e[xp] != null && (r[xp] = mt(e[xp])),
          r
        );
      }),
      (DCt = (e, t) => {
        let r = {};
        return (
          e[ke] != null && (r[ke] = p(e[ke])),
          e[P2] != null && (r[zI] = p(e[P2])),
          e.Event === ""
            ? (r[ha] = [])
            : e[Om] != null && (r[ha] = q2(Ne(e[Om]), t)),
          e[Oe] != null && (r[Oe] = j2(e[Oe], t)),
          r
        );
      }),
      (NCt = (e, t) =>
        (e || []).filter((r) => r != null).map((r) => DCt(r, t))),
      (BCt = (e, t) => {
        let r = {};
        return (
          e[Rc] != null && (r[Rc] = p(e[Rc])),
          e[kI] != null && (r[kI] = p(e[kI])),
          e[vc] != null && (r[vc] = p(e[vc])),
          e[jI] != null && (r[jI] = p(e[jI])),
          e[GI] != null && (r[GI] = p(e[GI])),
          r
        );
      }),
      (MCt = (e, t) => {
        let r = {};
        return (
          e[Rc] != null && (r[Rc] = p(e[Rc])),
          e[vc] != null && (r[vc] = p(e[vc])),
          r
        );
      }),
      (LCt = (e, t) => {
        let r = {};
        return e[de] != null && (r[de] = p(e[de])), r;
      }),
      (FCt = (e, t) => {
        let r = {};
        return (
          e[WI] != null && (r[WI] = p(e[WI])),
          e.Rule === ""
            ? (r[Ts] = [])
            : e[Tn] != null && (r[Ts] = zCt(Ne(e[Tn]), t)),
          r
        );
      }),
      (UCt = (e, t) => {
        let r = {};
        return (
          e[vr] != null && (r[vr] = p(e[vr])),
          e[tm] != null && (r[tm] = wt(e[tm])),
          e[se] != null && (r[se] = p(e[se])),
          e[Oe] != null && (r[Oe] = HCt(e[Oe], t)),
          e[de] != null && (r[de] = p(e[de])),
          e[Im] != null && (r[Im] = ebt(e[Im], t)),
          e[fm] != null && (r[fm] = DSt(e[fm], t)),
          e[no] != null && (r[no] = TSt(e[no], t)),
          e[am] != null && (r[am] = _St(e[am], t)),
          r
        );
      }),
      ($Ct = (e, t) => {
        let r = {};
        return (
          e[se] != null && (r[se] = p(e[se])),
          e.Tag === ""
            ? (r[un] = [])
            : e[Xe] != null && (r[un] = Bm(Ne(e[Xe]), t)),
          r
        );
      }),
      (HCt = (e, t) => {
        let r = {};
        return (
          e[se] != null && (r[se] = p(e[se])),
          e[Xe] != null && (r[Xe] = kp(e[Xe], t)),
          e[pr] != null && (r[pr] = $Ct(e[pr], t)),
          r
        );
      }),
      (zCt = (e, t) =>
        (e || []).filter((r) => r != null).map((r) => UCt(r, t))),
      (qCt = (e, t) => {
        let r = {};
        return (
          e[de] != null && (r[de] = p(e[de])),
          e[Tp] != null && (r[Tp] = y8e(e[Tp], t)),
          r
        );
      }),
      (y8e = (e, t) => {
        let r = {};
        return e[em] != null && (r[em] = wt(e[em])), r;
      }),
      (x8e = (e, t) => {
        let r = {};
        return (
          e[$z] != null && (r[$z] = mt(e[$z])),
          e[Jz] != null && (r[Jz] = F(qr(e[Jz]))),
          r
        );
      }),
      (jCt = (e, t) => {
        let r = {};
        return (
          e[im] != null && (r[im] = uSt(e[im], t)),
          e[wm] != null && (r[wm] = BCt(e[wm], t)),
          r
        );
      }),
      (GCt = (e, t) =>
        (e || []).filter((r) => r != null).map((r) => jCt(r, t))),
      (VCt = (e, t) => {
        let r = {};
        return (
          e.FilterRule === ""
            ? (r[x2] = [])
            : e[y2] != null && (r[x2] = MSt(Ne(e[y2]), t)),
          r
        );
      }),
      (WCt = (e, t) => {
        let r = {};
        return (
          e[_p] != null && (r[_p] = p(e[_p])),
          e[wp] != null && (r[wp] = p(e[wp])),
          e[o2] != null && (r[o2] = p(e[o2])),
          e[n2] != null && (r[n2] = p(e[n2])),
          r
        );
      }),
      (KCt = (e, t) => {
        let r = {};
        return (
          e[Cp] != null && (r[Cp] = p(e[Cp])),
          e[up] != null && (r[up] = p(e[up])),
          r
        );
      }),
      (YCt = (e, t) => {
        let r = {};
        return (
          e.Rule === ""
            ? (r[Ts] = [])
            : e[Tn] != null && (r[Ts] = XCt(Ne(e[Tn]), t)),
          r
        );
      }),
      (QCt = (e, t) => {
        let r = {};
        return (
          e[Yu] != null && (r[Yu] = KCt(e[Yu], t)),
          e[ur] != null && (r[ur] = mt(e[ur])),
          r
        );
      }),
      (XCt = (e, t) =>
        (e || []).filter((r) => r != null).map((r) => QCt(r, t))),
      (JCt = (e, t) => {
        let r = {};
        return (
          e[vz] != null && (r[vz] = p(e[vz])),
          e[Zz] != null && (r[Zz] = p(e[Zz])),
          e[e2] != null && (r[e2] = p(e[e2])),
          e[ln] != null && (r[ln] = F(qr(e[ln]))),
          r
        );
      }),
      (ZCt = (e, t) => ({})),
      (ebt = (e, t) => {
        let r = {};
        return (
          e[Am] != null && (r[Am] = rbt(e[Am], t)),
          e[bm] != null && (r[bm] = LCt(e[bm], t)),
          r
        );
      }),
      (tbt = (e, t) => {
        let r = {};
        return e[fp] != null && (r[fp] = p(e[fp])), r;
      }),
      (rbt = (e, t) => {
        let r = {};
        return e[de] != null && (r[de] = p(e[de])), r;
      }),
      (obt = (e, t) => ({})),
      (nbt = (e, t) => {
        let r = {};
        return (
          e[rp] != null && (r[rp] = Jr(e[rp])),
          e[Ju] != null && (r[Ju] = Jr(e[Ju])),
          e[tp] != null && (r[tp] = Jr(e[tp])),
          r
        );
      }),
      (sbt = (e, t) => {
        let r = {};
        return e[np] != null && (r[np] = ibt(e[np], t)), r;
      }),
      (ibt = (e, t) => {
        let r = {};
        return (
          e[yp] != null && (r[yp] = p(e[yp])),
          e[no] != null && (r[no] = aSt(e[no], t)),
          r
        );
      }),
      (kp = (e, t) => {
        let r = {};
        return (
          e[Ge] != null && (r[Ge] = p(e[Ge])),
          e[Ln] != null && (r[Ln] = p(e[Ln])),
          r
        );
      }),
      (Bm = (e, t) => (e || []).filter((r) => r != null).map((r) => kp(r, t))),
      (abt = (e, t) => {
        let r = {};
        return (
          e[Mn] != null && (r[Mn] = m8e(e[Mn], t)),
          e[Oi] != null && (r[Oi] = p(e[Oi])),
          r
        );
      }),
      (cbt = (e, t) =>
        (e || []).filter((r) => r != null).map((r) => abt(r, t))),
      (dbt = (e, t) => {
        let r = {};
        return (
          e[Rm] != null && (r[Rm] = ZCt(e[Rm], t)),
          e[Sm] != null && (r[Sm] = RCt(e[Sm], t)),
          r
        );
      }),
      (mbt = (e, t) => {
        let r = {};
        return (
          e[Rt] != null && (r[Rt] = wt(e[Rt])),
          e[ua] != null && (r[ua] = p(e[ua])),
          r
        );
      }),
      (lbt = (e, t) =>
        (e || []).filter((r) => r != null).map((r) => mbt(r, t))),
      (fbt = (e, t) => {
        let r = {};
        return (
          e[ke] != null && (r[ke] = p(e[ke])),
          e[L2] != null && (r[ZI] = p(e[L2])),
          e.Event === ""
            ? (r[ha] = [])
            : e[Om] != null && (r[ha] = q2(Ne(e[Om]), t)),
          e[Oe] != null && (r[Oe] = j2(e[Oe], t)),
          r
        );
      }),
      (ubt = (e, t) =>
        (e || []).filter((r) => r != null).map((r) => fbt(r, t))),
      (pbt = (e, t) => {
        let r = {};
        return (
          e[mn] != null && (r[mn] = F(qr(e[mn]))),
          e[Rt] != null && (r[Rt] = wt(e[Rt])),
          e[tt] != null && (r[tt] = p(e[tt])),
          r
        );
      }),
      (hbt = (e, t) =>
        (e || []).filter((r) => r != null).map((r) => pbt(r, t))),
      (W = (e) => ({
        httpStatusCode: e.statusCode,
        requestId:
          e.headers["x-amzn-requestid"] ??
          e.headers["x-amzn-request-id"] ??
          e.headers["x-amz-request-id"],
        extendedRequestId: e.headers["x-amz-id-2"],
        cfId: e.headers["x-amz-cf-id"],
      })),
      (gbt = (e, t) => ne(e, t).then((r) => t.utf8Encoder(r))),
      (pr = "And"),
      (ybt = "AnalyticsAndOperator"),
      (s2 = "AnalyticsConfiguration"),
      (Dp = "ACL"),
      (om = "AccessControlList"),
      (Gqe = "AnalyticsConfigurationList"),
      (xbt = "AccessControlPolicy"),
      (nm = "AccessControlTranslation"),
      (Ebt = "AccelerateConfiguration"),
      (E8e = "AbortDate"),
      (Sbt = "AnalyticsExportDestination"),
      (Cbt = "AnalyticsFilter"),
      (i2 = "AllowedHeader"),
      (a2 = "AllowedHeaders"),
      (bbt = "AnalyticsId"),
      (sm = "AbortIncompleteMultipartUpload"),
      (Ku = "AccountId"),
      (vz = "AccessKeyId"),
      (c2 = "AllowedMethod"),
      (d2 = "AllowedMethods"),
      (m2 = "AllowedOrigin"),
      (l2 = "AllowedOrigins"),
      (_bt = "AccessPointAlias"),
      (fa = "AccessPointArn"),
      (SI = "AllowQuotedRecordDelimiter"),
      (G2 = "AcceptRanges"),
      (S8e = "AbortRuleId"),
      (wbt = "ArchiveStatus"),
      (Tbt = "AnalyticsS3BucketDestination"),
      (Abt = "AnalyticsS3ExportFileFormat"),
      (Yu = "ApplyServerSideEncryptionByDefault"),
      (ua = "AccessTier"),
      (Qu = "Account"),
      (ft = "Bucket"),
      (Xu = "BucketAccountId"),
      (Rbt = "BucketAccelerateStatus"),
      (Ap = "BypassGovernanceRetention"),
      (Ibt = "BucketInfo"),
      (ur = "BucketKeyEnabled"),
      (Pbt = "BucketLifecycleConfiguration"),
      (vbt = "BucketLocationConstraint"),
      (Obt = "BucketLocationName"),
      (kbt = "BucketLogsPermission"),
      (Dbt = "BucketLoggingStatus"),
      (Nbt = "BucketLocationType"),
      (SP = "BucketName"),
      (Ju = "BytesProcessed"),
      (Zu = "BlockPublicAcls"),
      (ep = "BlockPublicPolicy"),
      (Vy = "BucketRegion"),
      (tp = "BytesReturned"),
      (rp = "BytesScanned"),
      (Bbt = "BucketType"),
      (Mbt = "BucketVersioningStatus"),
      (Pi = "Buckets"),
      (Oz = "Credentials"),
      (et = "ChecksumAlgorithm"),
      (kz = "CannedACL"),
      (Lbt = "CreateBucketConfiguration"),
      (Np = "CacheControl"),
      (rr = "ChecksumCRC32"),
      (or = "ChecksumCRC32C"),
      (nr = "ChecksumCRC64NVME"),
      (Bp = "ContentDisposition"),
      (Dz = "CreationDate"),
      (Mp = "ContentEncoding"),
      (f2 = "CloudFunction"),
      (Vqe = "CloudFunctionConfiguration"),
      (Lp = "ContentLanguage"),
      (Oc = "ContentLength"),
      (C8e = "ChecksumMode"),
      (Qr = "ContentMD5"),
      (Fbt = "CompletedMultipartUpload"),
      (Ubt = "CORSConfiguration"),
      (u2 = "CORSRule"),
      (p2 = "CORSRules"),
      (Xo = "CommonPrefixes"),
      ($bt = "CompletedPart"),
      (V2 = "ContentRange"),
      (Wqe = "ConfirmRemoveSelfBucketAccess"),
      (b8e = "CopySource"),
      (sr = "ChecksumSHA1"),
      (ir = "ChecksumSHA256"),
      (_8e = "CopySourceIfMatch"),
      (sP = "CopySourceIfModifiedSince"),
      (w8e = "CopySourceIfNoneMatch"),
      (iP = "CopySourceIfUnmodifiedSince"),
      (Hbt = "CopySourceRange"),
      (T8e = "CopySourceSSECustomerAlgorithm"),
      (A8e = "CopySourceSSECustomerKey"),
      (R8e = "CopySourceSSECustomerKeyMD5"),
      (op = "CSV"),
      (I8e = "CopySourceVersionId"),
      (zbt = "CSVInput"),
      (qbt = "CSVOutput"),
      (ar = "ChecksumType"),
      (jbt = "ClientToken"),
      (Fp = "ContentType"),
      (Gbt = "CompressionType"),
      (Yt = "ContinuationToken"),
      (Nz = "Checksum"),
      (Ac = "Contents"),
      (Bz = "Code"),
      (Vbt = "Comments"),
      (im = "Condition"),
      (Jo = "Delimiter"),
      (Qd = "DaysAfterInitiation"),
      (np = "DataExport"),
      (Wbt = "DestinationIfMatch"),
      (Kqe = "DestinationIfModifiedSince"),
      (Kbt = "DestinationIfNoneMatch"),
      (Yqe = "DestinationIfUnmodifiedSince"),
      (Qs = "DeleteMarker"),
      (am = "DeleteMarkerReplication"),
      (Ybt = "DeleteMarkerReplicationStatus"),
      (Mz = "DeleteMarkerVersionId"),
      (Qqe = "DeleteMarkers"),
      (Xs = "DisplayName"),
      (Qbt = "DataRedundancy"),
      (cm = "DefaultRetention"),
      (Rt = "Days"),
      (mn = "Date"),
      (CI = "Deleted"),
      (Xbt = "Delete"),
      (no = "Destination"),
      (Jbt = "Description"),
      (ki = "Expires"),
      (RI = "EmailAddress"),
      (dm = "EventBridgeConfiguration"),
      (ee = "ExpectedBucketOwner"),
      (II = "ErrorCode"),
      (mm = "EncryptionConfiguration"),
      (lm = "ErrorDocument"),
      (h2 = "ExposeHeaders"),
      (g2 = "ExposeHeader"),
      (PI = "ErrorMessage"),
      (Xd = "ExpiredObjectDeleteMarker"),
      (fm = "ExistingObjectReplication"),
      (Zbt = "ExistingObjectReplicationStatus"),
      (e_t = "EnableRequestProgress"),
      (P8e = "ExpiresString"),
      (v8e = "ExpectedSourceBucketOwner"),
      (t_t = "ExpirationStatus"),
      (Zo = "EncodingType"),
      (Qt = "ETag"),
      (Lz = "EncryptionType"),
      (sp = "EventThreshold"),
      (O8e = "ExpressionType"),
      (vi = "Encryption"),
      (Fz = "Enabled"),
      (bI = "End"),
      (Wy = "Error"),
      (Xqe = "Errors"),
      (Om = "Event"),
      (ha = "Events"),
      (k8e = "Expression"),
      (ln = "Expiration"),
      (Oe = "Filter"),
      (D8e = "FieldDelimiter"),
      (r_t = "FileHeaderInfo"),
      (o_t = "FetchOwner"),
      (y2 = "FilterRule"),
      (n_t = "FilterRuleName"),
      (s_t = "FilterRuleValue"),
      (x2 = "FilterRules"),
      (E2 = "Field"),
      (ys = "Format"),
      (ip = "Frequency"),
      (ga = "Grant"),
      (Up = "GrantFullControl"),
      (vI = "GlacierJobParameters"),
      ($p = "GrantRead"),
      (Hp = "GrantReadACP"),
      (W2 = "GrantWrite"),
      (zp = "GrantWriteACP"),
      (Yy = "Grants"),
      (Mn = "Grantee"),
      (OI = "HttpErrorCodeReturnedEquals"),
      (Rc = "HostName"),
      (kI = "HttpRedirectCode"),
      (ke = "Id"),
      (S2 = "InventoryConfiguration"),
      (Jqe = "InventoryConfigurationList"),
      (um = "IndexDocument"),
      (vr = "ID"),
      (i_t = "InventoryDestination"),
      (Jd = "IsEnabled"),
      (a_t = "InventoryEncryption"),
      (c_t = "InventoryFilter"),
      (d_t = "InventoryFormat"),
      (m_t = "InventoryFrequency"),
      (l_t = "InventoryId"),
      (f_t = "InventoryIncludedObjectVersions"),
      (ap = "IsLatest"),
      (Xy = "IfMatch"),
      (Zqe = "IfMatchInitiatedTime"),
      (eje = "IfMatchLastModifiedTime"),
      (tje = "IfMatchSize"),
      (aP = "IfModifiedSince"),
      (CP = "IfNoneMatch"),
      (u_t = "InventoryOptionalField"),
      (cp = "IncludedObjectVersions"),
      (Uz = "IsPublic"),
      (dp = "IgnorePublicAcls"),
      ($z = "IsRestoreInProgress"),
      (pm = "InputSerialization"),
      (p_t = "InventoryS3BucketDestination"),
      (h_t = "InventorySchedule"),
      (Ft = "IsTruncated"),
      (g_t = "IntelligentTieringAndOperator"),
      (y_t = "IntelligentTieringAccessTier"),
      (C2 = "IntelligentTieringConfiguration"),
      (rje = "IntelligentTieringConfigurationList"),
      (x_t = "IntelligentTieringDays"),
      (E_t = "IntelligentTieringFilter"),
      (S_t = "IntelligentTieringId"),
      (C_t = "IntelligentTieringStatus"),
      (cP = "IfUnmodifiedSince"),
      (mp = "Initiator"),
      (Hz = "Initiated"),
      (lp = "JSON"),
      (b_t = "JSONInput"),
      (__t = "JSONOutput"),
      (w_t = "JSONType"),
      (Ge = "Key"),
      (zz = "KeyCount"),
      (fp = "KeyId"),
      (Ic = "KeyMarker"),
      (T_t = "KMSContext"),
      (qz = "KMSKeyId"),
      (up = "KMSMasterKeyID"),
      (DI = "KeyPrefixEquals"),
      (hm = "Location"),
      (pp = "LocationConstraint"),
      (gm = "LoggingEnabled"),
      (A_t = "LifecycleExpiration"),
      (NI = "LambdaFunctionArn"),
      (b2 = "LambdaFunctionConfigurations"),
      (R_t = "LambdaFunctionConfiguration"),
      (I_t = "LocationInfo"),
      (Or = "LastModified"),
      (_I = "LastModifiedTime"),
      (P_t = "LocationNameAsString"),
      (v_t = "LocationPrefix"),
      (O_t = "LifecycleRule"),
      (k_t = "LifecycleRuleAndOperator"),
      (D_t = "LifecycleRuleFilter"),
      (N_t = "LocationType"),
      (BI = "Marker"),
      (B_t = "MetricsAndOperator"),
      (Zd = "MaxAgeSeconds"),
      (M_t = "MaxBuckets"),
      (_2 = "MetricsConfiguration"),
      (oje = "MetricsConfigurationList"),
      (L_t = "MetadataDirective"),
      (F_t = "MaxDirectoryBuckets"),
      (w2 = "MfaDelete"),
      (N8e = "MetadataEntry"),
      (U_t = "MetricsFilter"),
      (K2 = "MFA"),
      (MI = "MFADelete"),
      ($_t = "MetricsId"),
      (xs = "MaxKeys"),
      (H_t = "MetadataKey"),
      (dP = "MissingMeta"),
      (nje = "MpuObjectSize"),
      (pa = "MaxParts"),
      (z_t = "MetricsStatus"),
      (q_t = "MetadataTableConfiguration"),
      (jz = "MetadataTableConfigurationResult"),
      (LI = "MaxUploads"),
      (j_t = "MetadataValue"),
      (ym = "Metrics"),
      (Gz = "Message"),
      (em = "Minutes"),
      (Es = "Mode"),
      (Cr = "Name"),
      (G_t = "NotificationConfiguration"),
      (V_t = "NotificationConfigurationFilter"),
      (fn = "NextContinuationToken"),
      (Ss = "NoncurrentDays"),
      (Y2 = "NotificationId"),
      (hp = "NextKeyMarker"),
      (Vz = "NextMarker"),
      (Cs = "NewerNoncurrentVersions"),
      (gp = "NextPartNumberMarker"),
      (Wz = "NextUploadIdMarker"),
      (xm = "NoncurrentVersionExpiration"),
      (Kz = "NextVersionIdMarker"),
      (T2 = "NoncurrentVersionTransitions"),
      (A2 = "NoncurrentVersionTransition"),
      (Ct = "Owner"),
      (sje = "ObjectAttributes"),
      (W_t = "OwnershipControls"),
      (K_t = "ObjectCannedACL"),
      (Y_t = "OwnershipControlsRule"),
      (Gu = "OptionalFields"),
      (Q_t = "ObjectIdentifier"),
      (Q2 = "ObjectKey"),
      (FI = "OutputLocation"),
      (X_t = "ObjectLockConfiguration"),
      (UI = "ObjectLockEnabled"),
      (ije = "ObjectLockEnabledForBucket"),
      (J_t = "ObjectLockLegalHold"),
      (Mm = "ObjectLockLegalHoldStatus"),
      (qp = "ObjectLockMode"),
      (Z_t = "ObjectLockRetention"),
      (B8e = "ObjectLockRetentionMode"),
      (Di = "ObjectLockRetainUntilDate"),
      (ewt = "ObjectLockRule"),
      (Ky = "ObjectOwnership"),
      (Rp = "OptionalObjectAttributes"),
      (twt = "OwnerOverride"),
      (Yz = "ObjectParts"),
      (Em = "OutputSerialization"),
      (bs = "ObjectSizeGreaterThan"),
      (M8e = "ObjectSizeGreaterThanBytes"),
      (_s = "ObjectSizeLessThan"),
      (L8e = "ObjectSizeLessThanBytes"),
      (yp = "OutputSchemaVersion"),
      (Qz = "ObjectSize"),
      (rwt = "ObjectVersionId"),
      (owt = "Objects"),
      (se = "Prefix"),
      (nwt = "PublicAccessBlockConfiguration"),
      (Ip = "PartsCount"),
      ($I = "PartitionDateSource"),
      (swt = "ParquetInput"),
      (wn = "PartNumber"),
      (Pc = "PartNumberMarker"),
      (Sm = "PartitionedPrefix"),
      (HI = "Payer"),
      (mP = "Part"),
      (Xz = "Parquet"),
      (Qy = "Parts"),
      (Oi = "Permission"),
      (vc = "Protocol"),
      (tm = "Priority"),
      (wI = "Quiet"),
      (zI = "QueueArn"),
      (R2 = "QueueConfiguration"),
      (I2 = "QueueConfigurations"),
      (F8e = "QuoteCharacter"),
      (U8e = "QuoteEscapeCharacter"),
      (iwt = "QuoteFields"),
      (P2 = "Queue"),
      ($8e = "Range"),
      (Cm = "RedirectAllRequestsTo"),
      (hr = "RequestCharged"),
      (H8e = "ResponseCacheControl"),
      (z8e = "ResponseContentDisposition"),
      (q8e = "ResponseContentEncoding"),
      (j8e = "ResponseContentLanguage"),
      (G8e = "ResponseContentType"),
      (awt = "ReplicationConfiguration"),
      (X2 = "RecordDelimiter"),
      (V8e = "ResponseExpires"),
      (Jz = "RestoreExpiryDate"),
      (qI = "ReplicaKmsKeyID"),
      (jI = "ReplaceKeyPrefixWith"),
      (GI = "ReplaceKeyWith"),
      (bm = "ReplicaModifications"),
      (cwt = "ReplicaModificationsStatus"),
      (dwt = "RestoreOutputPath"),
      (qt = "RequestPayer"),
      (xp = "RestrictPublicBuckets"),
      (mwt = "RequestPaymentConfiguration"),
      (VI = "RequestProgress"),
      (lwt = "RequestRoute"),
      (fwt = "ReplicationRuleAndOperator"),
      (uwt = "ReplicationRuleFilter"),
      (pwt = "ReplicationRuleStatus"),
      (hwt = "RestoreRequestType"),
      (gwt = "ReplicationRule"),
      (ywt = "RestoreRequest"),
      (Vu = "RoutingRules"),
      (lP = "RoutingRule"),
      (xwt = "RenameSource"),
      (J2 = "ReplicationStatus"),
      (Ep = "RestoreStatus"),
      (Ewt = "RequestToken"),
      (Swt = "ReplicationTimeStatus"),
      (Cwt = "ReplicationTimeValue"),
      (_m = "ReplicationTime"),
      (Sp = "RetainUntilDate"),
      (Z2 = "Restore"),
      (wm = "Redirect"),
      (WI = "Role"),
      (Tn = "Rule"),
      (Ts = "Rules"),
      (de = "Status"),
      (KI = "StartAfter"),
      (Zz = "SecretAccessKey"),
      (ws = "S3BucketDestination"),
      (tt = "StorageClass"),
      (Tm = "StorageClassAnalysis"),
      (bwt = "StorageClassAnalysisDataExport"),
      (_wt = "StorageClassAnalysisSchemaVersion"),
      (aje = "StatusCode"),
      (cje = "SkipDestinationValidation"),
      (wwt = "SourceIfMatch"),
      (dje = "SourceIfModifiedSince"),
      (Twt = "SourceIfNoneMatch"),
      (mje = "SourceIfUnmodifiedSince"),
      (fP = "SSE-KMS"),
      (Am = "SseKmsEncryptedObjects"),
      (Awt = "SseKmsEncryptedObjectsStatus"),
      (Rwt = "S3KeyFilter"),
      (v2 = "S3Key"),
      (Iwt = "S3Location"),
      (Pwt = "SessionMode"),
      (vwt = "SelectObjectContentRequest"),
      (YI = "SelectParameters"),
      (Rm = "SimplePrefix"),
      (QI = "ScanRange"),
      (uP = "SSE-S3"),
      (Im = "SourceSelectionCriteria"),
      (en = "ServerSideEncryption"),
      (Cp = "SSEAlgorithm"),
      (Owt = "ServerSideEncryptionByDefault"),
      (kwt = "ServerSideEncryptionConfiguration"),
      (so = "SSECustomerAlgorithm"),
      (Js = "SSECustomerKey"),
      (io = "SSECustomerKeyMD5"),
      (O2 = "SSEKMS"),
      (Nc = "SSEKMSEncryptionContext"),
      (Do = "SSEKMSKeyId"),
      (Dwt = "ServerSideEncryptionRule"),
      (k2 = "SSES3"),
      (e2 = "SessionToken"),
      (Nwt = "S3TablesBucketArn"),
      (XI = "S3TablesDestination"),
      (t2 = "S3TablesDestinationResult"),
      (Bwt = "S3TablesName"),
      (r2 = "S3"),
      (bp = "Schedule"),
      (TI = "Setting"),
      (ko = "Size"),
      (AI = "Start"),
      (JI = "Suffix"),
      (Pm = "Tagging"),
      (ZI = "TopicArn"),
      (o2 = "TableArn"),
      (eP = "TargetBucket"),
      (_p = "TableBucketArn"),
      (pP = "TagCount"),
      (D2 = "TopicConfiguration"),
      (N2 = "TopicConfigurations"),
      (Mwt = "TaggingDirective"),
      (eq = "TransitionDefaultMinimumObjectSize"),
      (Wu = "TargetGrants"),
      (Lwt = "TargetGrant"),
      (wp = "TableName"),
      (n2 = "TableNamespace"),
      (vm = "TargetObjectKeyFormat"),
      (tP = "TargetPrefix"),
      (Fwt = "TotalPartsCount"),
      (Ys = "TagSet"),
      (W8e = "TransitionStorageClass"),
      (Xe = "Tag"),
      (un = "Tags"),
      (K8e = "Tier"),
      (B2 = "Tierings"),
      (M2 = "Tiering"),
      (Tp = "Time"),
      (Y8e = "Token"),
      (L2 = "Topic"),
      (F2 = "Transitions"),
      (U2 = "Transition"),
      (An = "Type"),
      (lje = "Upload"),
      (Rn = "UploadId"),
      (rP = "UploadIdMarker"),
      (Uwt = "UserMetadata"),
      (oP = "URI"),
      (fje = "Uploads"),
      (uje = "Version"),
      (Q8e = "VersionCount"),
      ($wt = "VersioningConfiguration"),
      (st = "VersionId"),
      (nP = "VersionIdMarker"),
      (Ln = "Value"),
      (pje = "Versions"),
      (Hwt = "WebsiteConfiguration"),
      (hje = "WriteOffsetBytes"),
      (Jy = "WebsiteRedirectLocation"),
      (rm = "Years"),
      (bP = "analytics"),
      (X8e = "accelerate"),
      (_P = "acl"),
      (J8e = "accept-ranges"),
      (zwt = "attributes"),
      (qwt = "bucket-region"),
      (tq = "cors"),
      (Zy = "cache-control"),
      (ex = "content-disposition"),
      (tx = "content-encoding"),
      (rx = "content-language"),
      (km = "content-length"),
      (Xr = "content-md5"),
      (Z8e = "content-range"),
      (ox = "content-type"),
      (Lm = "continuation-token"),
      (jwt = "delete"),
      (wP = "delimiter"),
      (Dm = "expires"),
      (rq = "encryption"),
      (TP = "encoding-type"),
      (AP = "etag"),
      (eWe = "expiresstring"),
      (Gwt = "fetch-owner"),
      (As = "id"),
      (jp = "if-match"),
      (oq = "if-modified-since"),
      (RP = "inventory"),
      (nx = "if-none-match"),
      (IP = "intelligent-tiering"),
      (nq = "if-unmodified-since"),
      (tWe = "key-marker"),
      (sq = "lifecycle"),
      (rWe = "legal-hold"),
      (Pp = "last-modified"),
      (oWe = "location"),
      (nWe = "logging"),
      (Vwt = "list-type"),
      (PP = "metrics"),
      (iq = "metadataTable"),
      (Wwt = "marker"),
      (Kwt = "max-buckets"),
      (Ywt = "max-directory-buckets"),
      (ao = "member"),
      (aq = "max-keys"),
      (Qwt = "max-parts"),
      (Xwt = "max-uploads"),
      (sWe = "notification"),
      (cq = "ownershipControls"),
      (iWe = "object-lock"),
      (dq = "policy"),
      (mq = "publicAccessBlock"),
      (vP = "partNumber"),
      (Jwt = "policyStatus"),
      (Zwt = "part-number-marker"),
      (sx = "prefix"),
      (lq = "replication"),
      (eTt = "renameObject"),
      (aWe = "requestPayment"),
      (cWe = "range"),
      (dWe = "response-cache-control"),
      (mWe = "response-content-disposition"),
      (lWe = "response-content-encoding"),
      (fWe = "response-content-language"),
      (uWe = "response-content-type"),
      (pWe = "response-expires"),
      (tTt = "restore"),
      (hWe = "retention"),
      (rTt = "session"),
      (oTt = "start-after"),
      (nTt = "select"),
      (sTt = "select-type"),
      (Gp = "tagging"),
      (iTt = "torrent"),
      (gWe = "uploads"),
      (ix = "uploadId"),
      (aTt = "upload-id-marker"),
      (yWe = "versioning"),
      (In = "versionId"),
      (jt = '<?xml version="1.0" encoding="UTF-8"?>'),
      (cTt = "versions"),
      (dTt = "version-id-marker"),
      (fq = "website"),
      (gje = "xsi:type"),
      (Vp = "x-amz-acl"),
      (hP = "x-amz-abort-date"),
      (yje = "x-amz-access-point-alias"),
      (xWe = "x-amz-abort-rule-id"),
      (mTt = "x-amz-archive-status"),
      (uq = "x-amz-bypass-governance-retention"),
      (lTt = "x-amz-bucket-location-name"),
      (fTt = "x-amz-bucket-location-type"),
      (uTt = "x-amz-bucket-object-lock-enabled"),
      (EWe = "x-amz-bucket-object-lock-token"),
      (pTt = "x-amz-bucket-region"),
      (pq = "x-amz-checksum-algorithm"),
      (Fm = "x-amz-checksum-crc32"),
      (Um = "x-amz-checksum-crc32c"),
      ($m = "x-amz-checksum-crc64nvme"),
      (SWe = "x-amz-checksum-mode"),
      (hTt = "x-amz-confirm-remove-self-bucket-access"),
      (Hm = "x-amz-checksum-sha1"),
      (zm = "x-amz-checksum-sha256"),
      (CWe = "x-amz-copy-source"),
      (bWe = "x-amz-copy-source-if-match"),
      (_We = "x-amz-copy-source-if-modified-since"),
      (wWe = "x-amz-copy-source-if-none-match"),
      (TWe = "x-amz-copy-source-if-unmodified-since"),
      (gTt = "x-amz-create-session-mode"),
      (yTt = "x-amz-copy-source-range"),
      (AWe = "x-amz-copy-source-server-side-encryption-customer-algorithm"),
      (RWe = "x-amz-copy-source-server-side-encryption-customer-key"),
      (IWe = "x-amz-copy-source-server-side-encryption-customer-key-md5"),
      (PWe = "x-amz-copy-source-version-id"),
      (Wp = "x-amz-checksum-type"),
      (xTt = "x-amz-client-token"),
      (kc = "x-amz-delete-marker"),
      (ax = "x-amz-expiration"),
      (te = "x-amz-expected-bucket-owner"),
      (ETt = "x-amz-fwd-error-code"),
      (STt = "x-amz-fwd-error-message"),
      (CTt = "x-amz-fwd-header-accept-ranges"),
      (bTt = "x-amz-fwd-header-cache-control"),
      (_Tt = "x-amz-fwd-header-content-disposition"),
      (wTt = "x-amz-fwd-header-content-encoding"),
      (TTt = "x-amz-fwd-header-content-language"),
      (ATt = "x-amz-fwd-header-content-range"),
      (RTt = "x-amz-fwd-header-content-type"),
      (ITt = "x-amz-fwd-header-etag"),
      (PTt = "x-amz-fwd-header-expires"),
      (vTt = "x-amz-fwd-header-last-modified"),
      (OTt = "x-amz-fwd-header-x-amz-checksum-crc32"),
      (kTt = "x-amz-fwd-header-x-amz-checksum-crc32c"),
      (DTt = "x-amz-fwd-header-x-amz-checksum-crc64nvme"),
      (NTt = "x-amz-fwd-header-x-amz-checksum-sha1"),
      (BTt = "x-amz-fwd-header-x-amz-checksum-sha256"),
      (MTt = "x-amz-fwd-header-x-amz-delete-marker"),
      (LTt = "x-amz-fwd-header-x-amz-expiration"),
      (FTt = "x-amz-fwd-header-x-amz-missing-meta"),
      (UTt = "x-amz-fwd-header-x-amz-mp-parts-count"),
      ($Tt = "x-amz-fwd-header-x-amz-object-lock-legal-hold"),
      (HTt = "x-amz-fwd-header-x-amz-object-lock-mode"),
      (zTt = "x-amz-fwd-header-x-amz-object-lock-retain-until-date"),
      (qTt = "x-amz-fwd-header-x-amz-restore"),
      (jTt = "x-amz-fwd-header-x-amz-request-charged"),
      (GTt = "x-amz-fwd-header-x-amz-replication-status"),
      (VTt = "x-amz-fwd-header-x-amz-storage-class"),
      (WTt = "x-amz-fwd-header-x-amz-server-side-encryption"),
      (KTt = "x-amz-fwd-header-x-amz-server-side-encryption-aws-kms-key-id"),
      (YTt =
        "x-amz-fwd-header-x-amz-server-side-encryption-bucket-key-enabled"),
      (QTt =
        "x-amz-fwd-header-x-amz-server-side-encryption-customer-algorithm"),
      (XTt = "x-amz-fwd-header-x-amz-server-side-encryption-customer-key-md5"),
      (JTt = "x-amz-fwd-header-x-amz-tagging-count"),
      (ZTt = "x-amz-fwd-header-x-amz-version-id"),
      (eAt = "x-amz-fwd-status"),
      (Kp = "x-amz-grant-full-control"),
      (Yp = "x-amz-grant-read"),
      (Qp = "x-amz-grant-read-acp"),
      (hq = "x-amz-grant-write"),
      (Xp = "x-amz-grant-write-acp"),
      (tAt = "x-amz-if-match-initiated-time"),
      (rAt = "x-amz-if-match-last-modified-time"),
      (oAt = "x-amz-if-match-size"),
      (gq = "x-amz-mfa"),
      (nAt = "x-amz-metadata-directive"),
      (gP = "x-amz-missing-meta"),
      (sAt = "x-amz-mp-object-size"),
      (iAt = "x-amz-max-parts"),
      (yP = "x-amz-mp-parts-count"),
      (aAt = "x-amz-object-attributes"),
      (cx = "x-amz-object-lock-legal-hold"),
      (dx = "x-amz-object-lock-mode"),
      (Nm = "x-amz-object-lock-retain-until-date"),
      (cAt = "x-amz-object-ownership"),
      (yq = "x-amz-optional-object-attributes"),
      (xje = "x-amz-object-size"),
      (dAt = "x-amz-part-number-marker"),
      (vWe = "x-amz-restore"),
      (xr = "x-amz-request-charged"),
      (mAt = "x-amz-restore-output-path"),
      (Gt = "x-amz-request-payer"),
      (lAt = "x-amz-request-route"),
      (fAt = "x-amz-rename-source"),
      (OWe = "x-amz-replication-status"),
      (uAt = "x-amz-rename-source-if-match"),
      (pAt = "x-amz-rename-source-if-modified-since"),
      (hAt = "x-amz-rename-source-if-none-match"),
      (gAt = "x-amz-rename-source-if-unmodified-since"),
      (yAt = "x-amz-request-token"),
      (mx = "x-amz-storage-class"),
      (br = "x-amz-sdk-checksum-algorithm"),
      (xAt = "x-amz-skip-destination-validation"),
      (kWe = "x-amz-source-expected-bucket-owner"),
      (Fn = "x-amz-server-side-encryption"),
      (Un = "x-amz-server-side-encryption-aws-kms-key-id"),
      (Br = "x-amz-server-side-encryption-bucket-key-enabled"),
      (Bc = "x-amz-server-side-encryption-context"),
      (Co = "x-amz-server-side-encryption-customer-algorithm"),
      (Zs = "x-amz-server-side-encryption-customer-key"),
      (bo = "x-amz-server-side-encryption-customer-key-md5"),
      (xq = "x-amz-tagging"),
      (xP = "x-amz-tagging-count"),
      (EAt = "x-amz-tagging-directive"),
      (Eq = "x-amz-transition-default-minimum-object-size"),
      (Ni = "x-amz-version-id"),
      (SAt = "x-amz-write-offset-bytes"),
      (lx = "x-amz-website-redirect-location"),
      (_o = "x-id");
  });
var Jp,
  OP = s(() => {
    he();
    K();
    Y();
    $();
    X();
    Qo();
    J();
    Jp = class extends (
      _.classBuilder()
        .ep({
          ...R,
          DisableS3ExpressSessionAuth: {
            type: "staticContextParams",
            value: !0,
          },
          Bucket: { type: "contextParams", name: "Bucket" },
        })
        .m(function (t, r, o, n) {
          return [
            T(o, this.serialize, this.deserialize),
            A(o, t.getEndpointParameterInstructions()),
            U(o),
          ];
        })
        .s("AmazonS3", "CreateSession", {})
        .n("S3Client", "CreateSessionCommand")
        .f(hqe, pqe)
        .ser(Tje)
        .de(g4e)
        .build()
    ) {};
  });
var NWe,
  DWe = s(() => {
    NWe = {
      name: "@aws-sdk/client-s3",
      description:
        "AWS SDK for JavaScript S3 Client for Node.js, Browser and React Native",
      version: "3.839.0",
      scripts: {
        build:
          "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
        "build:cjs": "node ../../scripts/compilation/inline client-s3",
        "build:es": "tsc -p tsconfig.es.json",
        "build:include:deps":
          "lerna run --scope $npm_package_name --include-dependencies build",
        "build:types": "tsc -p tsconfig.types.json",
        "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
        clean: "rimraf ./dist-* && rimraf *.tsbuildinfo",
        "extract:docs": "api-extractor run --local",
        "generate:client":
          "node ../../scripts/generate-clients/single-service --solo s3",
        test: "yarn g:vitest run",
        "test:browser":
          "node ./test/browser-build/esbuild && yarn g:vitest run -c vitest.config.browser.ts",
        "test:browser:watch":
          "node ./test/browser-build/esbuild && yarn g:vitest watch -c vitest.config.browser.ts",
        "test:e2e":
          "yarn g:vitest run -c vitest.config.e2e.ts && yarn test:browser",
        "test:e2e:watch": "yarn g:vitest watch -c vitest.config.e2e.ts",
        "test:integration": "yarn g:vitest run -c vitest.config.integ.ts",
        "test:integration:watch":
          "yarn g:vitest watch -c vitest.config.integ.ts",
        "test:watch": "yarn g:vitest watch",
      },
      main: "./dist-cjs/index.js",
      types: "./dist-types/index.d.ts",
      module: "./dist-es/index.js",
      sideEffects: !1,
      dependencies: {
        "@aws-crypto/sha1-browser": "5.2.0",
        "@aws-crypto/sha256-browser": "5.2.0",
        "@aws-crypto/sha256-js": "5.2.0",
        "@aws-sdk/core": "3.839.0",
        "@aws-sdk/credential-provider-node": "3.839.0",
        "@aws-sdk/middleware-bucket-endpoint": "3.830.0",
        "@aws-sdk/middleware-expect-continue": "3.821.0",
        "@aws-sdk/middleware-flexible-checksums": "3.839.0",
        "@aws-sdk/middleware-host-header": "3.821.0",
        "@aws-sdk/middleware-location-constraint": "3.821.0",
        "@aws-sdk/middleware-logger": "3.821.0",
        "@aws-sdk/middleware-recursion-detection": "3.821.0",
        "@aws-sdk/middleware-sdk-s3": "3.839.0",
        "@aws-sdk/middleware-ssec": "3.821.0",
        "@aws-sdk/middleware-user-agent": "3.839.0",
        "@aws-sdk/region-config-resolver": "3.821.0",
        "@aws-sdk/signature-v4-multi-region": "3.839.0",
        "@aws-sdk/types": "3.821.0",
        "@aws-sdk/util-endpoints": "3.828.0",
        "@aws-sdk/util-user-agent-browser": "3.821.0",
        "@aws-sdk/util-user-agent-node": "3.839.0",
        "@aws-sdk/xml-builder": "3.821.0",
        "@smithy/config-resolver": "^4.1.4",
        "@smithy/core": "^3.6.0",
        "@smithy/eventstream-serde-browser": "^4.0.4",
        "@smithy/eventstream-serde-config-resolver": "^4.1.2",
        "@smithy/eventstream-serde-node": "^4.0.4",
        "@smithy/fetch-http-handler": "^5.0.4",
        "@smithy/hash-blob-browser": "^4.0.4",
        "@smithy/hash-node": "^4.0.4",
        "@smithy/hash-stream-node": "^4.0.4",
        "@smithy/invalid-dependency": "^4.0.4",
        "@smithy/md5-js": "^4.0.4",
        "@smithy/middleware-content-length": "^4.0.4",
        "@smithy/middleware-endpoint": "^4.1.13",
        "@smithy/middleware-retry": "^4.1.14",
        "@smithy/middleware-serde": "^4.0.8",
        "@smithy/middleware-stack": "^4.0.4",
        "@smithy/node-config-provider": "^4.1.3",
        "@smithy/node-http-handler": "^4.0.6",
        "@smithy/protocol-http": "^5.1.2",
        "@smithy/smithy-client": "^4.4.5",
        "@smithy/types": "^4.3.1",
        "@smithy/url-parser": "^4.0.4",
        "@smithy/util-base64": "^4.0.0",
        "@smithy/util-body-length-browser": "^4.0.0",
        "@smithy/util-body-length-node": "^4.0.0",
        "@smithy/util-defaults-mode-browser": "^4.0.21",
        "@smithy/util-defaults-mode-node": "^4.0.21",
        "@smithy/util-endpoints": "^3.0.6",
        "@smithy/util-middleware": "^4.0.4",
        "@smithy/util-retry": "^4.0.6",
        "@smithy/util-stream": "^4.2.2",
        "@smithy/util-utf8": "^4.0.0",
        "@smithy/util-waiter": "^4.0.6",
        "@types/uuid": "^9.0.1",
        tslib: "^2.6.2",
        uuid: "^9.0.1",
      },
      devDependencies: {
        "@aws-sdk/signature-v4-crt": "3.839.0",
        "@tsconfig/node18": "18.2.4",
        "@types/node": "^18.19.69",
        concurrently: "7.0.0",
        "downlevel-dts": "0.10.1",
        rimraf: "3.0.2",
        typescript: "~5.8.3",
      },
      engines: { node: ">=18.0.0" },
      typesVersions: { "<4.0": { "dist-types/*": ["dist-types/ts3.4/*"] } },
      files: ["dist-*/**"],
      author: {
        name: "AWS SDK for JavaScript Team",
        url: "https://aws.amazon.com/javascript/",
      },
      license: "Apache-2.0",
      browser: { "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.browser" },
      "react-native": {
        "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.native",
      },
      homepage:
        "https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-s3",
      repository: {
        type: "git",
        url: "https://github.com/aws/aws-sdk-js-v3.git",
        directory: "clients/client-s3",
      },
    };
  });
var kP,
  DP,
  BWe,
  MWe,
  LWe,
  FWe,
  Sq,
  UWe = s(() => {
    xt();
    re();
    (kP = "AWS_ACCESS_KEY_ID"),
      (DP = "AWS_SECRET_ACCESS_KEY"),
      (BWe = "AWS_SESSION_TOKEN"),
      (MWe = "AWS_CREDENTIAL_EXPIRATION"),
      (LWe = "AWS_CREDENTIAL_SCOPE"),
      (FWe = "AWS_ACCOUNT_ID"),
      (Sq = (e) => async () => {
        e?.logger?.debug("@aws-sdk/credential-provider-env - fromEnv");
        let t = process.env[kP],
          r = process.env[DP],
          o = process.env[BWe],
          n = process.env[MWe],
          i = process.env[LWe],
          a = process.env[FWe];
        if (t && r) {
          let c = {
            accessKeyId: t,
            secretAccessKey: r,
            ...(o && { sessionToken: o }),
            ...(n && { expiration: new Date(n) }),
            ...(i && { credentialScope: i }),
            ...(a && { accountId: a }),
          };
          return ce(c, "CREDENTIALS_ENV_VARS", "g"), c;
        }
        throw new P("Unable to find environment variable credentials.", {
          logger: e?.logger,
        });
      });
  });
var $We = {};
It($We, {
  ENV_ACCOUNT_ID: () => FWe,
  ENV_CREDENTIAL_SCOPE: () => LWe,
  ENV_EXPIRATION: () => MWe,
  ENV_KEY: () => kP,
  ENV_SECRET: () => DP,
  ENV_SESSION: () => BWe,
  fromEnv: () => Sq,
});
var Cq = s(() => {
  UWe();
});
import { Buffer as bAt } from "buffer";
import { request as _At } from "http";
function Mc(e) {
  return new Promise((t, r) => {
    let o = _At({
      method: "GET",
      ...e,
      hostname: e.hostname?.replace(/^\[(.+)\]$/, "$1"),
    });
    o.on("error", (n) => {
      r(
        Object.assign(
          new Zt("Unable to connect to instance metadata service"),
          n
        )
      ),
        o.destroy();
    }),
      o.on("timeout", () => {
        r(new Zt("TimeoutError from instance metadata service")), o.destroy();
      }),
      o.on("response", (n) => {
        let { statusCode: i = 400 } = n;
        (i < 200 || 300 <= i) &&
          (r(
            Object.assign(
              new Zt("Error response received from instance metadata service"),
              { statusCode: i }
            )
          ),
          o.destroy());
        let a = [];
        n.on("data", (c) => {
          a.push(c);
        }),
          n.on("end", () => {
            t(bAt.concat(a)), o.destroy();
          });
      }),
      o.end();
  });
}
var NP = s(() => {
  re();
});
var BP,
  MP,
  bq = s(() => {
    (BP = (e) =>
      !!e &&
      typeof e == "object" &&
      typeof e.AccessKeyId == "string" &&
      typeof e.SecretAccessKey == "string" &&
      typeof e.Token == "string" &&
      typeof e.Expiration == "string"),
      (MP = (e) => ({
        accessKeyId: e.AccessKeyId,
        secretAccessKey: e.SecretAccessKey,
        sessionToken: e.Token,
        expiration: new Date(e.Expiration),
        ...(e.AccountId && { accountId: e.AccountId }),
      }));
  });
var TRo,
  ARo,
  fx,
  LP = s(() => {
    (TRo = 1e3),
      (ARo = 0),
      (fx = ({ maxRetries: e = 0, timeout: t = 1e3 }) => ({
        maxRetries: e,
        timeout: t,
      }));
  });
var ux,
  _q = s(() => {
    ux = (e, t) => {
      let r = e();
      for (let o = 0; o < t; o++) r = r.catch(e);
      return r;
    };
  });
import { parse as wAt } from "url";
var FP,
  UP,
  wq,
  TAt,
  AAt,
  RAt,
  IAt,
  PAt,
  vAt,
  HWe = s(() => {
    re();
    NP();
    bq();
    LP();
    _q();
    (FP = "AWS_CONTAINER_CREDENTIALS_FULL_URI"),
      (UP = "AWS_CONTAINER_CREDENTIALS_RELATIVE_URI"),
      (wq = "AWS_CONTAINER_AUTHORIZATION_TOKEN"),
      (TAt = (e = {}) => {
        let { timeout: t, maxRetries: r } = fx(e);
        return () =>
          ux(async () => {
            let o = await vAt({ logger: e.logger }),
              n = JSON.parse(await AAt(t, o));
            if (!BP(n))
              throw new P(
                "Invalid response received from instance metadata service.",
                { logger: e.logger }
              );
            return MP(n);
          }, r);
      }),
      (AAt = async (e, t) => (
        process.env[wq] &&
          (t.headers = { ...t.headers, Authorization: process.env[wq] }),
        (await Mc({ ...t, timeout: e })).toString()
      )),
      (RAt = "169.254.170.2"),
      (IAt = { localhost: !0, "127.0.0.1": !0 }),
      (PAt = { "http:": !0, "https:": !0 }),
      (vAt = async ({ logger: e }) => {
        if (process.env[UP]) return { hostname: RAt, path: process.env[UP] };
        if (process.env[FP]) {
          let t = wAt(process.env[FP]);
          if (!t.hostname || !(t.hostname in IAt))
            throw new P(
              `${t.hostname} is not a valid container metadata service hostname`,
              { tryNextLink: !1, logger: e }
            );
          if (!t.protocol || !(t.protocol in PAt))
            throw new P(
              `${t.protocol} is not a valid container metadata service protocol`,
              { tryNextLink: !1, logger: e }
            );
          return { ...t, port: t.port ? parseInt(t.port, 10) : void 0 };
        }
        throw new P(
          `The container metadata credential provider cannot be used unless the ${UP} or ${FP} environment variable is set`,
          { tryNextLink: !1, logger: e }
        );
      });
  });
var $P,
  zWe = s(() => {
    re();
    $P = class e extends P {
      constructor(t, r = !0) {
        super(t, r),
          (this.tryNextLink = r),
          (this.name = "InstanceMetadataV1FallbackError"),
          Object.setPrototypeOf(this, e.prototype);
      }
    };
  });
var qm,
  Tq = s(() => {
    (function (e) {
      (e.IPv4 = "http://169.254.169.254"), (e.IPv6 = "http://[fd00:ec2::254]");
    })(qm || (qm = {}));
  });
var OAt,
  kAt,
  qWe,
  jWe = s(() => {
    (OAt = "AWS_EC2_METADATA_SERVICE_ENDPOINT"),
      (kAt = "ec2_metadata_service_endpoint"),
      (qWe = {
        environmentVariableSelector: (e) => e[OAt],
        configFileSelector: (e) => e[kAt],
        default: void 0,
      });
  });
var Lc,
  Aq = s(() => {
    (function (e) {
      (e.IPv4 = "IPv4"), (e.IPv6 = "IPv6");
    })(Lc || (Lc = {}));
  });
var DAt,
  NAt,
  GWe,
  VWe = s(() => {
    Aq();
    (DAt = "AWS_EC2_METADATA_SERVICE_ENDPOINT_MODE"),
      (NAt = "ec2_metadata_service_endpoint_mode"),
      (GWe = {
        environmentVariableSelector: (e) => e[DAt],
        configFileSelector: (e) => e[NAt],
        default: Lc.IPv4,
      });
  });
var HP,
  BAt,
  MAt,
  Rq = s(() => {
    zd();
    Ly();
    Tq();
    jWe();
    Aq();
    VWe();
    (HP = async () => wi((await BAt()) || (await MAt()))),
      (BAt = async () => Bt(qWe)()),
      (MAt = async () => {
        let e = await Bt(GWe)();
        switch (e) {
          case Lc.IPv4:
            return qm.IPv4;
          case Lc.IPv6:
            return qm.IPv6;
          default:
            throw new Error(
              `Unsupported endpoint mode: ${e}. Select from ${Object.values(Lc)}`
            );
        }
      });
  });
var LAt,
  Iq,
  WWe = s(() => {
    (LAt =
      "https://docs.aws.amazon.com/sdkref/latest/guide/feature-static-credentials.html"),
      (Iq = (e, t) => {
        let r = 300 + Math.floor(Math.random() * 300),
          o = new Date(Date.now() + r * 1e3);
        t.warn(
          `Attempting credential expiration extension due to a credential service availability issue. A refresh of these credentials will be attempted after ${new Date(o)}.
For more information, please visit: ` + LAt
        );
        let n = e.originalExpiration ?? e.expiration;
        return { ...e, ...(n ? { originalExpiration: n } : {}), expiration: o };
      });
  });
var KWe,
  YWe = s(() => {
    WWe();
    KWe = (e, t = {}) => {
      let r = t?.logger || console,
        o;
      return async () => {
        let n;
        try {
          (n = await e()),
            n.expiration &&
              n.expiration.getTime() < Date.now() &&
              (n = Iq(n, r));
        } catch (i) {
          if (o) r.warn("Credential renew failed: ", i), (n = Iq(o, r));
          else throw i;
        }
        return (o = n), n;
      };
    };
  });
var JWe,
  FAt,
  Pq,
  QWe,
  XWe,
  UAt,
  $At,
  HAt,
  zAt,
  qAt,
  ZWe = s(() => {
    zd();
    re();
    zWe();
    NP();
    bq();
    LP();
    _q();
    Rq();
    YWe();
    (JWe = "/latest/meta-data/iam/security-credentials/"),
      (FAt = "/latest/api/token"),
      (Pq = "AWS_EC2_METADATA_V1_DISABLED"),
      (QWe = "ec2_metadata_v1_disabled"),
      (XWe = "x-aws-ec2-metadata-token"),
      (UAt = (e = {}) => KWe($At(e), { logger: e.logger })),
      ($At = (e = {}) => {
        let t = !1,
          { logger: r, profile: o } = e,
          { timeout: n, maxRetries: i } = fx(e),
          a = async (c, d) => {
            if (t || d.headers?.[XWe] == null) {
              let l = !1,
                u = !1,
                h = await Bt(
                  {
                    environmentVariableSelector: (y) => {
                      let S = y[Pq];
                      if (((u = !!S && S !== "false"), S === void 0))
                        throw new P(
                          `${Pq} not set in env, checking config file next.`,
                          { logger: e.logger }
                        );
                      return u;
                    },
                    configFileSelector: (y) => {
                      let S = y[QWe];
                      return (l = !!S && S !== "false"), l;
                    },
                    default: !1,
                  },
                  { profile: o }
                )();
              if (e.ec2MetadataV1Disabled || h) {
                let y = [];
                throw (
                  (e.ec2MetadataV1Disabled &&
                    y.push(
                      "credential provider initialization (runtime option ec2MetadataV1Disabled)"
                    ),
                  l && y.push(`config file profile (${QWe})`),
                  u && y.push(`process environment variable (${Pq})`),
                  new $P(
                    `AWS EC2 Metadata v1 fallback has been blocked by AWS SDK configuration in the following: [${y.join(", ")}].`
                  ))
                );
              }
            }
            let f = (
              await ux(async () => {
                let l;
                try {
                  l = await zAt(d);
                } catch (u) {
                  throw (u.statusCode === 401 && (t = !1), u);
                }
                return l;
              }, c)
            ).trim();
            return ux(async () => {
              let l;
              try {
                l = await qAt(f, d, e);
              } catch (u) {
                throw (u.statusCode === 401 && (t = !1), u);
              }
              return l;
            }, c);
          };
        return async () => {
          let c = await HP();
          if (t)
            return (
              r?.debug(
                "AWS SDK Instance Metadata",
                "using v1 fallback (no token fetch)"
              ),
              a(i, { ...c, timeout: n })
            );
          {
            let d;
            try {
              d = (await HAt({ ...c, timeout: n })).toString();
            } catch (m) {
              if (m?.statusCode === 400)
                throw Object.assign(m, {
                  message: "EC2 Metadata token request returned error",
                });
              return (
                (m.message === "TimeoutError" ||
                  [403, 404, 405].includes(m.statusCode)) &&
                  (t = !0),
                r?.debug(
                  "AWS SDK Instance Metadata",
                  "using v1 fallback (initial)"
                ),
                a(i, { ...c, timeout: n })
              );
            }
            return a(i, { ...c, headers: { [XWe]: d }, timeout: n });
          }
        };
      }),
      (HAt = async (e) =>
        Mc({
          ...e,
          path: FAt,
          method: "PUT",
          headers: { "x-aws-ec2-metadata-token-ttl-seconds": "21600" },
        })),
      (zAt = async (e) => (await Mc({ ...e, path: JWe })).toString()),
      (qAt = async (e, t, r) => {
        let o = JSON.parse((await Mc({ ...t, path: JWe + e })).toString());
        if (!BP(o))
          throw new P(
            "Invalid response received from instance metadata service.",
            { logger: r.logger }
          );
        return MP(o);
      });
  });
var e6e = s(() => {});
var px = {};
It(px, {
  DEFAULT_MAX_RETRIES: () => ARo,
  DEFAULT_TIMEOUT: () => TRo,
  ENV_CMDS_AUTH_TOKEN: () => wq,
  ENV_CMDS_FULL_URI: () => FP,
  ENV_CMDS_RELATIVE_URI: () => UP,
  Endpoint: () => qm,
  fromContainerMetadata: () => TAt,
  fromInstanceMetadata: () => UAt,
  getInstanceMetadataEndpoint: () => HP,
  httpRequest: () => Mc,
  providerConfigFromInit: () => fx,
});
var hx = s(() => {
  HWe();
  ZWe();
  LP();
  e6e();
  NP();
  Rq();
  Tq();
});
var t6e,
  r6e,
  o6e = s(() => {
    re();
    (t6e = "AWS_EC2_METADATA_DISABLED"),
      (r6e = async (e) => {
        let {
          ENV_CMDS_FULL_URI: t,
          ENV_CMDS_RELATIVE_URI: r,
          fromContainerMetadata: o,
          fromInstanceMetadata: n,
        } = await Promise.resolve().then(() => (hx(), px));
        if (process.env[r] || process.env[t]) {
          e.logger?.debug(
            "@aws-sdk/credential-provider-node - remoteProvider::fromHttp/fromContainerMetadata"
          );
          let { fromHttp: i } = await Promise.resolve().then(() => (ld(), md));
          return Ht(i(e), o(e));
        }
        return process.env[t6e] && process.env[t6e] !== "false"
          ? async () => {
              throw new P("EC2 Instance Metadata Service access disabled", {
                logger: e.logger,
              });
            }
          : (e.logger?.debug(
              "@aws-sdk/credential-provider-node - remoteProvider::fromInstanceMetadata"
            ),
            n(e));
      });
  });
var vq,
  Oq = s(() => {
    vq = (e) =>
      e &&
      (typeof e.sso_start_url == "string" ||
        typeof e.sso_account_id == "string" ||
        typeof e.sso_session == "string" ||
        typeof e.sso_region == "string" ||
        typeof e.sso_role_name == "string");
  });
var n6e = s(() => {
  re();
});
var Zp,
  zP = s(() => {
    Zp =
      "To refresh this SSO session run 'aws sso login' with the corresponding profile.";
  });
var s6e,
  i6e = s(() => {
    s6e = async (e, t = {}) => {
      let { SSOOIDCClient: r } = await Promise.resolve().then(() => (Sd(), Ed));
      return new r(
        Object.assign({}, t.clientConfig ?? {}, {
          region: e ?? t.clientConfig?.region,
          logger: t.clientConfig?.logger ?? t.parentClientConfig?.logger,
        })
      );
    };
  });
var a6e,
  c6e = s(() => {
    i6e();
    a6e = async (e, t, r = {}) => {
      let { CreateTokenCommand: o } = await Promise.resolve().then(
        () => (Sd(), Ed)
      );
      return (await s6e(t, r)).send(
        new o({
          clientId: e.clientId,
          clientSecret: e.clientSecret,
          refreshToken: e.refreshToken,
          grantType: "refresh_token",
        })
      );
    };
  });
var kq,
  d6e = s(() => {
    re();
    zP();
    kq = (e) => {
      if (e.expiration && e.expiration.getTime() < Date.now())
        throw new Je(`Token is expired. ${Zp}`, !1);
    };
  });
var Fc,
  m6e = s(() => {
    re();
    zP();
    Fc = (e, t, r = !1) => {
      if (typeof t > "u")
        throw new Je(
          `Value not present for '${e}' in SSO Token${r ? ". Cannot refresh" : ""}. ${Zp}`,
          !1
        );
    };
  });
import { promises as jAt } from "fs";
var GAt,
  l6e,
  f6e = s(() => {
    Vs();
    ({ writeFile: GAt } = jAt),
      (l6e = (e, t) => {
        let r = bR(e),
          o = JSON.stringify(t, null, 2);
        return GAt(r, o);
      });
  });
var u6e,
  p6e,
  h6e = s(() => {
    re();
    Vs();
    zP();
    c6e();
    d6e();
    m6e();
    f6e();
    (u6e = new Date(0)),
      (p6e =
        (e = {}) =>
        async ({ callerClientConfig: t } = {}) => {
          let r = {
            ...e,
            parentClientConfig: { ...t, ...e.parentClientConfig },
          };
          r.logger?.debug("@aws-sdk/token-providers - fromSso");
          let o = await Sc(r),
            n = us({ profile: r.profile ?? t?.profile }),
            i = o[n];
          if (i) {
            if (!i.sso_session)
              throw new Je(
                `Profile '${n}' is missing required property 'sso_session'.`
              );
          } else
            throw new Je(
              `Profile '${n}' could not be found in shared credentials file.`,
              !1
            );
          let a = i.sso_session,
            d = (await AR(r))[a];
          if (!d)
            throw new Je(
              `Sso session '${a}' could not be found in shared credentials file.`,
              !1
            );
          for (let S of ["sso_start_url", "sso_region"])
            if (!d[S])
              throw new Je(
                `Sso session '${a}' is missing required property '${S}'.`,
                !1
              );
          let m = d.sso_start_url,
            f = d.sso_region,
            l;
          try {
            l = await _R(a);
          } catch {
            throw new Je(
              `The SSO session token associated with profile=${n} was not found or is invalid. ${Zp}`,
              !1
            );
          }
          Fc("accessToken", l.accessToken), Fc("expiresAt", l.expiresAt);
          let { accessToken: u, expiresAt: h } = l,
            y = { token: u, expiration: new Date(h) };
          if (y.expiration.getTime() - Date.now() > 3e5) return y;
          if (Date.now() - u6e.getTime() < 30 * 1e3) return kq(y), y;
          Fc("clientId", l.clientId, !0),
            Fc("clientSecret", l.clientSecret, !0),
            Fc("refreshToken", l.refreshToken, !0);
          try {
            u6e.setTime(Date.now());
            let S = await a6e(l, f, r);
            Fc("accessToken", S.accessToken), Fc("expiresIn", S.expiresIn);
            let E = new Date(Date.now() + S.expiresIn * 1e3);
            try {
              await l6e(a, {
                ...l,
                accessToken: S.accessToken,
                expiresAt: E.toISOString(),
                refreshToken: S.refreshToken,
              });
            } catch {}
            return { token: S.accessToken, expiration: E };
          } catch {
            return kq(y), y;
          }
        });
  });
var g6e = s(() => {
  re();
});
var y6e = s(() => {
  re();
});
var x6e = s(() => {
  n6e();
  h6e();
  g6e();
  y6e();
});
function WAt(e) {
  return {
    schemeId: "aws.auth#sigv4",
    signingProperties: { name: "awsssoportal", region: e.region },
    propertiesExtractor: (t, r) => ({
      signingProperties: { config: t, context: r },
    }),
  };
}
function qP(e) {
  return { schemeId: "smithy.api#noAuth" };
}
var E6e,
  S6e,
  C6e,
  Dq = s(() => {
    rt();
    ct();
    E6e = async (e, t, r) => ({
      operation: bt(t).operation,
      region:
        (await pe(e.region)()) ||
        (() => {
          throw new Error(
            "expected `region` to be configured for `aws.auth#sigv4`"
          );
        })(),
    });
    (S6e = (e) => {
      let t = [];
      switch (e.operation) {
        case "GetRoleCredentials": {
          t.push(qP(e));
          break;
        }
        case "ListAccountRoles": {
          t.push(qP(e));
          break;
        }
        case "ListAccounts": {
          t.push(qP(e));
          break;
        }
        case "Logout": {
          t.push(qP(e));
          break;
        }
        default:
          t.push(WAt(e));
      }
      return t;
    }),
      (C6e = (e) => {
        let t = zo(e);
        return Object.assign(t, {
          authSchemePreference: pe(e.authSchemePreference ?? []),
        });
      });
  });
var b6e,
  Uc,
  eh = s(() => {
    (b6e = (e) =>
      Object.assign(e, {
        useDualstackEndpoint: e.useDualstackEndpoint ?? !1,
        useFipsEndpoint: e.useFipsEndpoint ?? !1,
        defaultSigningName: "awsssoportal",
      })),
      (Uc = {
        UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
        Endpoint: { type: "builtInParams", name: "endpoint" },
        Region: { type: "builtInParams", name: "region" },
        UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
      });
  });
var w6e,
  _6e = s(() => {
    w6e = {
      name: "@aws-sdk/client-sso",
      description:
        "AWS SDK for JavaScript Sso Client for Node.js, Browser and React Native",
      version: "3.839.0",
      scripts: {
        build:
          "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
        "build:cjs": "node ../../scripts/compilation/inline client-sso",
        "build:es": "tsc -p tsconfig.es.json",
        "build:include:deps":
          "lerna run --scope $npm_package_name --include-dependencies build",
        "build:types": "tsc -p tsconfig.types.json",
        "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
        clean: "rimraf ./dist-* && rimraf *.tsbuildinfo",
        "extract:docs": "api-extractor run --local",
        "generate:client":
          "node ../../scripts/generate-clients/single-service --solo sso",
      },
      main: "./dist-cjs/index.js",
      types: "./dist-types/index.d.ts",
      module: "./dist-es/index.js",
      sideEffects: !1,
      dependencies: {
        "@aws-crypto/sha256-browser": "5.2.0",
        "@aws-crypto/sha256-js": "5.2.0",
        "@aws-sdk/core": "3.839.0",
        "@aws-sdk/middleware-host-header": "3.821.0",
        "@aws-sdk/middleware-logger": "3.821.0",
        "@aws-sdk/middleware-recursion-detection": "3.821.0",
        "@aws-sdk/middleware-user-agent": "3.839.0",
        "@aws-sdk/region-config-resolver": "3.821.0",
        "@aws-sdk/types": "3.821.0",
        "@aws-sdk/util-endpoints": "3.828.0",
        "@aws-sdk/util-user-agent-browser": "3.821.0",
        "@aws-sdk/util-user-agent-node": "3.839.0",
        "@smithy/config-resolver": "^4.1.4",
        "@smithy/core": "^3.6.0",
        "@smithy/fetch-http-handler": "^5.0.4",
        "@smithy/hash-node": "^4.0.4",
        "@smithy/invalid-dependency": "^4.0.4",
        "@smithy/middleware-content-length": "^4.0.4",
        "@smithy/middleware-endpoint": "^4.1.13",
        "@smithy/middleware-retry": "^4.1.14",
        "@smithy/middleware-serde": "^4.0.8",
        "@smithy/middleware-stack": "^4.0.4",
        "@smithy/node-config-provider": "^4.1.3",
        "@smithy/node-http-handler": "^4.0.6",
        "@smithy/protocol-http": "^5.1.2",
        "@smithy/smithy-client": "^4.4.5",
        "@smithy/types": "^4.3.1",
        "@smithy/url-parser": "^4.0.4",
        "@smithy/util-base64": "^4.0.0",
        "@smithy/util-body-length-browser": "^4.0.0",
        "@smithy/util-body-length-node": "^4.0.0",
        "@smithy/util-defaults-mode-browser": "^4.0.21",
        "@smithy/util-defaults-mode-node": "^4.0.21",
        "@smithy/util-endpoints": "^3.0.6",
        "@smithy/util-middleware": "^4.0.4",
        "@smithy/util-retry": "^4.0.6",
        "@smithy/util-utf8": "^4.0.0",
        tslib: "^2.6.2",
      },
      devDependencies: {
        "@tsconfig/node18": "18.2.4",
        "@types/node": "^18.19.69",
        concurrently: "7.0.0",
        "downlevel-dts": "0.10.1",
        rimraf: "3.0.2",
        typescript: "~5.8.3",
      },
      engines: { node: ">=18.0.0" },
      typesVersions: { "<4.0": { "dist-types/*": ["dist-types/ts3.4/*"] } },
      files: ["dist-*/**"],
      author: {
        name: "AWS SDK for JavaScript Team",
        url: "https://aws.amazon.com/javascript/",
      },
      license: "Apache-2.0",
      browser: { "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.browser" },
      "react-native": {
        "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.native",
      },
      homepage:
        "https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-sso",
      repository: {
        type: "git",
        url: "https://github.com/aws/aws-sdk-js-v3.git",
        directory: "clients/client-sso",
      },
    };
  });
var Nq,
  Bq = s(() => {
    Nq = { isCrtAvailable: !1 };
  });
var T6e,
  A6e = s(() => {
    Bq();
    T6e = () => (Nq.isCrtAvailable ? ["md/crt-avail"] : null);
  });
import { platform as YAt, release as QAt } from "os";
import { env as R6e, versions as XAt } from "process";
var jP,
  I6e = s(() => {
    A6e();
    Bq();
    jP =
      ({ serviceId: e, clientVersion: t }) =>
      async (r) => {
        let o = [
            ["aws-sdk-js", t],
            ["ua", "2.1"],
            [`os/${YAt()}`, QAt()],
            ["lang/js"],
            ["md/nodejs", `${XAt.node}`],
          ],
          n = T6e();
        n && o.push(n),
          e && o.push([`api/${e}`, t]),
          R6e.AWS_EXECUTION_ENV &&
            o.push([`exec-env/${R6e.AWS_EXECUTION_ENV}`]);
        let i = await r?.userAgentAppId?.();
        return i ? [...o, [`app/${i}`]] : [...o];
      };
  });
var JAt,
  ZAt,
  eRt,
  GP,
  P6e = s(() => {
    pR();
    (JAt = "AWS_SDK_UA_APP_ID"),
      (ZAt = "sdk_ua_app_id"),
      (eRt = "sdk-ua-app-id"),
      (GP = {
        environmentVariableSelector: (e) => e[JAt],
        configFileSelector: (e) => e[ZAt] ?? e[eRt],
        default: l3,
      });
  });
var Mq = s(() => {
  I6e();
  P6e();
});
import { Buffer as Lq } from "buffer";
var Fq,
  v6e,
  O6e = s(() => {
    cr();
    (Fq = (e, t = 0, r = e.byteLength - t) => {
      if (!Ke(e))
        throw new TypeError(
          `The "input" argument must be ArrayBuffer. Received type ${typeof e} (${e})`
        );
      return Lq.from(e, t, r);
    }),
      (v6e = (e, t) => {
        if (typeof e != "string")
          throw new TypeError(
            `The "input" argument must be of type string. Received type ${typeof e} (${e})`
          );
        return t ? Lq.from(e, t) : Lq.from(e);
      });
  });
import { Buffer as Uq } from "buffer";
var k6e,
  D6e,
  $q = s(() => {
    cr();
    (k6e = (e, t = 0, r = e.byteLength - t) => {
      if (!Ke(e))
        throw new TypeError(
          `The "input" argument must be ArrayBuffer. Received type ${typeof e} (${e})`
        );
      return Uq.from(e, t, r);
    }),
      (D6e = (e, t) => {
        if (typeof e != "string")
          throw new TypeError(
            `The "input" argument must be of type string. Received type ${typeof e} (${e})`
          );
        return t ? Uq.from(e, t) : Uq.from(e);
      });
  });
var ya,
  Hq = s(() => {
    $q();
    ya = (e) => {
      let t = D6e(e, "utf8");
      return new Uint8Array(
        t.buffer,
        t.byteOffset,
        t.byteLength / Uint8Array.BYTES_PER_ELEMENT
      );
    };
  });
var N6e,
  B6e = s(() => {
    Hq();
    N6e = (e) =>
      typeof e == "string"
        ? ya(e)
        : ArrayBuffer.isView(e)
          ? new Uint8Array(
              e.buffer,
              e.byteOffset,
              e.byteLength / Uint8Array.BYTES_PER_ELEMENT
            )
          : new Uint8Array(e);
  });
var jm,
  M6e = s(() => {
    $q();
    jm = (e) => {
      if (typeof e == "string") return e;
      if (
        typeof e != "object" ||
        typeof e.byteOffset != "number" ||
        typeof e.byteLength != "number"
      )
        throw new Error(
          "@smithy/util-utf8: toUtf8 encoder function only accepts string | Uint8Array."
        );
      return k6e(e.buffer, e.byteOffset, e.byteLength).toString("utf8");
    };
  });
var Gm = s(() => {
  Hq();
  B6e();
  M6e();
});
import { Buffer as tRt } from "buffer";
import { createHash as rRt, createHmac as oRt } from "crypto";
function L6e(e, t) {
  return tRt.isBuffer(e)
    ? e
    : typeof e == "string"
      ? v6e(e, t)
      : ArrayBuffer.isView(e)
        ? Fq(e.buffer, e.byteOffset, e.byteLength)
        : Fq(e);
}
var $c,
  zq = s(() => {
    O6e();
    Gm();
    $c = class {
      constructor(t, r) {
        (this.algorithmIdentifier = t), (this.secret = r), this.reset();
      }
      update(t, r) {
        this.hash.update(N6e(L6e(t, r)));
      }
      digest() {
        return Promise.resolve(this.hash.digest());
      }
      reset() {
        this.hash = this.secret
          ? oRt(this.algorithmIdentifier, L6e(this.secret))
          : rRt(this.algorithmIdentifier);
      }
    };
  });
var gx,
  nRt,
  qq = s(() => {
    (gx = (e) => encodeURIComponent(e).replace(/[!'()*]/g, nRt)),
      (nRt = (e) => `%${e.charCodeAt(0).toString(16).toUpperCase()}`);
  });
var F6e = s(() => {
  qq();
});
var U6e = s(() => {
  qq();
  F6e();
});
function VP(e) {
  let t = [];
  for (let r of Object.keys(e).sort()) {
    let o = e[r];
    if (((r = gx(r)), Array.isArray(o)))
      for (let n = 0, i = o.length; n < i; n++) t.push(`${r}=${gx(o[n])}`);
    else {
      let n = r;
      (o || typeof o == "string") && (n += `=${gx(o)}`), t.push(n);
    }
  }
  return t.join("&");
}
var WP = s(() => {
  U6e();
});
var $6e,
  H6e = s(() => {
    $6e = ["ECONNRESET", "EPIPE", "ETIMEDOUT"];
  });
var jq,
  Gq = s(() => {
    jq = (e) => {
      let t = {};
      for (let r of Object.keys(e)) {
        let o = e[r];
        t[r] = Array.isArray(o) ? o.join(",") : o;
      }
      return t;
    };
  });
var co,
  th = s(() => {
    co = {
      setTimeout: (e, t) => setTimeout(e, t),
      clearTimeout: (e) => clearTimeout(e),
    };
  });
var z6e,
  q6e,
  j6e = s(() => {
    th();
    (z6e = 1e3),
      (q6e = (e, t, r = 0) => {
        if (!r) return -1;
        let o = (n) => {
          let i = co.setTimeout(() => {
              e.destroy(),
                t(
                  Object.assign(
                    new Error(
                      `Socket timed out without establishing a connection within ${r} ms`
                    ),
                    { name: "TimeoutError" }
                  )
                );
            }, r - n),
            a = (c) => {
              c?.connecting
                ? c.on("connect", () => {
                    co.clearTimeout(i);
                  })
                : co.clearTimeout(i);
            };
          e.socket ? a(e.socket) : e.on("socket", a);
        };
        return r < 2e3 ? (o(0), 0) : co.setTimeout(o.bind(null, z6e), z6e);
      });
  });
var sRt,
  G6e,
  V6e = s(() => {
    th();
    (sRt = 3e3),
      (G6e = (e, { keepAlive: t, keepAliveMsecs: r }, o = sRt) => {
        if (t !== !0) return -1;
        let n = () => {
          e.socket
            ? e.socket.setKeepAlive(t, r || 0)
            : e.on("socket", (i) => {
                i.setKeepAlive(t, r || 0);
              });
        };
        return o === 0 ? (n(), 0) : co.setTimeout(n, o);
      });
  });
var W6e,
  K6e,
  Y6e = s(() => {
    Vq();
    th();
    (W6e = 3e3),
      (K6e = (e, t, r = Q6e) => {
        let o = (n) => {
          let i = r - n,
            a = () => {
              e.destroy(),
                t(
                  Object.assign(
                    new Error(`Connection timed out after ${r} ms`),
                    { name: "TimeoutError" }
                  )
                );
            };
          e.socket
            ? (e.socket.setTimeout(i, a),
              e.on("close", () => e.socket?.removeListener("timeout", a)))
            : e.setTimeout(i, a);
        };
        return 0 < r && r < 6e3
          ? (o(0), 0)
          : co.setTimeout(o.bind(null, r === 0 ? 0 : W6e), W6e);
      });
  });
import { Readable as iRt } from "stream";
async function Wq(e, t, r = X6e) {
  let o = t.headers ?? {},
    n = o.Expect || o.expect,
    i = -1,
    a = !0;
  n === "100-continue" &&
    (a = await Promise.race([
      new Promise((c) => {
        i = Number(co.setTimeout(() => c(!0), Math.max(X6e, r)));
      }),
      new Promise((c) => {
        e.on("continue", () => {
          co.clearTimeout(i), c(!0);
        }),
          e.on("response", () => {
            co.clearTimeout(i), c(!1);
          }),
          e.on("error", () => {
            co.clearTimeout(i), c(!1);
          });
      }),
    ])),
    a && aRt(e, t.body);
}
function aRt(e, t) {
  if (t instanceof iRt) {
    t.pipe(e);
    return;
  }
  if (t) {
    if (Buffer.isBuffer(t) || typeof t == "string") {
      e.end(t);
      return;
    }
    let r = t;
    if (
      typeof r == "object" &&
      r.buffer &&
      typeof r.byteOffset == "number" &&
      typeof r.byteLength == "number"
    ) {
      e.end(Buffer.from(r.buffer, r.byteOffset, r.byteLength));
      return;
    }
    e.end(Buffer.from(t));
    return;
  }
  e.end();
}
var X6e,
  Kq = s(() => {
    th();
    X6e = 6e3;
  });
import { Agent as J6e, request as cRt } from "http";
import { Agent as Z6e, request as dRt } from "https";
var Q6e,
  rh,
  Vq = s(() => {
    an();
    WP();
    H6e();
    Gq();
    j6e();
    V6e();
    Y6e();
    th();
    Kq();
    (Q6e = 0),
      (rh = class e {
        static create(t) {
          return typeof t?.handle == "function" ? t : new e(t);
        }
        static checkSocketUsage(t, r, o = console) {
          let { sockets: n, requests: i, maxSockets: a } = t;
          if (typeof a != "number" || a === 1 / 0 || Date.now() - 15e3 < r)
            return r;
          if (n && i)
            for (let d in n) {
              let m = n[d]?.length ?? 0,
                f = i[d]?.length ?? 0;
              if (m >= a && f >= 2 * a)
                return (
                  o?.warn?.(`@smithy/node-http-handler:WARN - socket usage at capacity=${m} and ${f} additional requests are enqueued.
See https://docs.aws.amazon.com/sdk-for-javascript/v3/developer-guide/node-configuring-maxsockets.html
or increase socketAcquisitionWarningTimeout=(millis) in the NodeHttpHandler config.`),
                  Date.now()
                );
            }
          return r;
        }
        constructor(t) {
          (this.socketWarningTimestamp = 0),
            (this.metadata = { handlerProtocol: "http/1.1" }),
            (this.configProvider = new Promise((r, o) => {
              typeof t == "function"
                ? t()
                    .then((n) => {
                      r(this.resolveDefaultConfig(n));
                    })
                    .catch(o)
                : r(this.resolveDefaultConfig(t));
            }));
        }
        resolveDefaultConfig(t) {
          let {
              requestTimeout: r,
              connectionTimeout: o,
              socketTimeout: n,
              socketAcquisitionWarningTimeout: i,
              httpAgent: a,
              httpsAgent: c,
            } = t || {},
            d = !0,
            m = 50;
          return {
            connectionTimeout: o,
            requestTimeout: r ?? n,
            socketAcquisitionWarningTimeout: i,
            httpAgent:
              a instanceof J6e || typeof a?.destroy == "function"
                ? a
                : new J6e({ keepAlive: d, maxSockets: m, ...a }),
            httpsAgent:
              c instanceof Z6e || typeof c?.destroy == "function"
                ? c
                : new Z6e({ keepAlive: d, maxSockets: m, ...c }),
            logger: console,
          };
        }
        destroy() {
          this.config?.httpAgent?.destroy(), this.config?.httpsAgent?.destroy();
        }
        async handle(t, { abortSignal: r } = {}) {
          return (
            this.config || (this.config = await this.configProvider),
            new Promise((o, n) => {
              let i,
                a = [],
                c = async (I) => {
                  await i, a.forEach(co.clearTimeout), o(I);
                },
                d = async (I) => {
                  await i, a.forEach(co.clearTimeout), n(I);
                };
              if (!this.config)
                throw new Error(
                  "Node HTTP request handler config is not resolved"
                );
              if (r?.aborted) {
                let I = new Error("Request aborted");
                (I.name = "AbortError"), d(I);
                return;
              }
              let m = t.protocol === "https:",
                f = m ? this.config.httpsAgent : this.config.httpAgent;
              a.push(
                co.setTimeout(
                  () => {
                    this.socketWarningTimestamp = e.checkSocketUsage(
                      f,
                      this.socketWarningTimestamp,
                      this.config.logger
                    );
                  },
                  this.config.socketAcquisitionWarningTimeout ??
                    (this.config.requestTimeout ?? 2e3) +
                      (this.config.connectionTimeout ?? 1e3)
                )
              );
              let l = VP(t.query || {}),
                u;
              if (t.username != null || t.password != null) {
                let I = t.username ?? "",
                  O = t.password ?? "";
                u = `${I}:${O}`;
              }
              let h = t.path;
              l && (h += `?${l}`), t.fragment && (h += `#${t.fragment}`);
              let y = t.hostname ?? "";
              y[0] === "[" && y.endsWith("]")
                ? (y = t.hostname.slice(1, -1))
                : (y = t.hostname);
              let S = {
                  headers: t.headers,
                  host: y,
                  method: t.method,
                  path: h,
                  port: t.port,
                  agent: f,
                  auth: u,
                },
                b = (m ? dRt : cRt)(S, (I) => {
                  let O = new Gs({
                    statusCode: I.statusCode || -1,
                    reason: I.statusMessage,
                    headers: jq(I.headers),
                    body: I,
                  });
                  c({ response: O });
                });
              if (
                (b.on("error", (I) => {
                  $6e.includes(I.code)
                    ? d(Object.assign(I, { name: "TimeoutError" }))
                    : d(I);
                }),
                r)
              ) {
                let I = () => {
                  b.destroy();
                  let O = new Error("Request aborted");
                  (O.name = "AbortError"), d(O);
                };
                if (typeof r.addEventListener == "function") {
                  let O = r;
                  O.addEventListener("abort", I, { once: !0 }),
                    b.once("close", () => O.removeEventListener("abort", I));
                } else r.onabort = I;
              }
              a.push(q6e(b, d, this.config.connectionTimeout)),
                a.push(K6e(b, d, this.config.requestTimeout));
              let v = S.agent;
              typeof v == "object" &&
                "keepAlive" in v &&
                a.push(
                  G6e(b, {
                    keepAlive: v.keepAlive,
                    keepAliveMsecs: v.keepAliveMsecs,
                  })
                ),
                (i = Wq(b, t, this.config.requestTimeout).catch(
                  (I) => (a.forEach(co.clearTimeout), n(I))
                ));
            })
          );
        }
        updateHttpClientConfig(t, r) {
          (this.config = void 0),
            (this.configProvider = this.configProvider.then((o) => ({
              ...o,
              [t]: r,
            })));
        }
        httpHandlerConfigs() {
          return this.config ?? {};
        }
      });
  });
var eKe = s(() => {});
var tKe = s(() => {
  eKe();
});
var rKe = s(() => {
  an();
  WP();
  Gq();
  tKe();
  Kq();
});
import { Writable as mRt } from "stream";
var KP,
  oKe = s(() => {
    KP = class extends mRt {
      constructor() {
        super(...arguments), (this.bufferedBytes = []);
      }
      _write(t, r, o) {
        this.bufferedBytes.push(t), o();
      }
    };
  });
async function fRt(e) {
  let t = [],
    r = e.getReader(),
    o = !1,
    n = 0;
  for (; !o; ) {
    let { done: c, value: d } = await r.read();
    d && (t.push(d), (n += d.length)), (o = c);
  }
  let i = new Uint8Array(n),
    a = 0;
  for (let c of t) i.set(c, a), (a += c.length);
  return i;
}
var oh,
  lRt,
  nKe = s(() => {
    oKe();
    (oh = (e) =>
      lRt(e)
        ? fRt(e)
        : new Promise((t, r) => {
            let o = new KP();
            e.pipe(o),
              e.on("error", (n) => {
                o.end(), r(n);
              }),
              o.on("error", r),
              o.on("finish", function () {
                let n = new Uint8Array(Buffer.concat(this.bufferedBytes));
                t(n);
              });
          })),
      (lRt = (e) =>
        typeof ReadableStream == "function" && e instanceof ReadableStream);
  });
var YP = s(() => {
  Vq();
  rKe();
  nKe();
});
import { fstatSync as uRt, lstatSync as pRt } from "fs";
var QP,
  sKe = s(() => {
    QP = (e) => {
      if (!e) return 0;
      if (typeof e == "string") return Buffer.byteLength(e);
      if (typeof e.byteLength == "number") return e.byteLength;
      if (typeof e.size == "number") return e.size;
      if (typeof e.start == "number" && typeof e.end == "number")
        return e.end + 1 - e.start;
      if (typeof e.path == "string" || Buffer.isBuffer(e.path))
        return pRt(e.path).size;
      if (typeof e.fd == "number") return uRt(e.fd).size;
      throw new Error(`Body Length computation failed for ${e}`);
    };
  });
var Yq = s(() => {
  sKe();
});
import { Buffer as Qq } from "buffer";
var iKe,
  aKe,
  Xq = s(() => {
    cr();
    (iKe = (e, t = 0, r = e.byteLength - t) => {
      if (!Ke(e))
        throw new TypeError(
          `The "input" argument must be ArrayBuffer. Received type ${typeof e} (${e})`
        );
      return Qq.from(e, t, r);
    }),
      (aKe = (e, t) => {
        if (typeof e != "string")
          throw new TypeError(
            `The "input" argument must be of type string. Received type ${typeof e} (${e})`
          );
        return t ? Qq.from(e, t) : Qq.from(e);
      });
  });
var hRt,
  Vm,
  cKe = s(() => {
    Xq();
    (hRt = /^[A-Za-z0-9+/]*={0,2}$/),
      (Vm = (e) => {
        if ((e.length * 3) % 4 !== 0)
          throw new TypeError("Incorrect padding on base64 string.");
        if (!hRt.exec(e)) throw new TypeError("Invalid base64 string.");
        let t = aKe(e, "base64");
        return new Uint8Array(t.buffer, t.byteOffset, t.byteLength);
      });
  });
var xa,
  dKe = s(() => {
    Xq();
    Gm();
    xa = (e) => {
      let t;
      if (
        (typeof e == "string" ? (t = ya(e)) : (t = e),
        typeof t != "object" ||
          typeof t.byteOffset != "number" ||
          typeof t.byteLength != "number")
      )
        throw new Error(
          "@smithy/util-base64: toBase64 encoder function only accepts string | Uint8Array."
        );
      return iKe(t.buffer, t.byteOffset, t.byteLength).toString("base64");
    };
  });
var Hc = s(() => {
  cKe();
  dKe();
});
var EKe,
  Is,
  Ps,
  ih,
  mKe,
  yx,
  nh,
  sh,
  Ea,
  Jq,
  Zq,
  lKe,
  fKe,
  uKe,
  SKe,
  CKe,
  Rs,
  pKe,
  bKe,
  hKe,
  gKe,
  yKe,
  xKe,
  gRt,
  _Ke,
  wKe = s(() => {
    (EKe = "required"),
      (Is = "fn"),
      (Ps = "argv"),
      (ih = "ref"),
      (mKe = "isSet"),
      (yx = "booleanEquals"),
      (nh = "error"),
      (sh = "endpoint"),
      (Ea = "tree"),
      (Jq = "PartitionResult"),
      (Zq = "getAttr"),
      (lKe = { [EKe]: !1, type: "String" }),
      (fKe = { [EKe]: !0, default: !1, type: "Boolean" }),
      (uKe = { [ih]: "Endpoint" }),
      (SKe = { [Is]: yx, [Ps]: [{ [ih]: "UseFIPS" }, !0] }),
      (CKe = { [Is]: yx, [Ps]: [{ [ih]: "UseDualStack" }, !0] }),
      (Rs = {}),
      (pKe = { [Is]: Zq, [Ps]: [{ [ih]: Jq }, "supportsFIPS"] }),
      (bKe = { [ih]: Jq }),
      (hKe = {
        [Is]: yx,
        [Ps]: [!0, { [Is]: Zq, [Ps]: [bKe, "supportsDualStack"] }],
      }),
      (gKe = [SKe]),
      (yKe = [CKe]),
      (xKe = [{ [ih]: "Region" }]),
      (gRt = {
        version: "1.0",
        parameters: {
          Region: lKe,
          UseDualStack: fKe,
          UseFIPS: fKe,
          Endpoint: lKe,
        },
        rules: [
          {
            conditions: [{ [Is]: mKe, [Ps]: [uKe] }],
            rules: [
              {
                conditions: gKe,
                error:
                  "Invalid Configuration: FIPS and custom endpoint are not supported",
                type: nh,
              },
              {
                conditions: yKe,
                error:
                  "Invalid Configuration: Dualstack and custom endpoint are not supported",
                type: nh,
              },
              { endpoint: { url: uKe, properties: Rs, headers: Rs }, type: sh },
            ],
            type: Ea,
          },
          {
            conditions: [{ [Is]: mKe, [Ps]: xKe }],
            rules: [
              {
                conditions: [{ [Is]: "aws.partition", [Ps]: xKe, assign: Jq }],
                rules: [
                  {
                    conditions: [SKe, CKe],
                    rules: [
                      {
                        conditions: [{ [Is]: yx, [Ps]: [!0, pKe] }, hKe],
                        rules: [
                          {
                            endpoint: {
                              url: "https://portal.sso-fips.{Region}.{PartitionResult#dualStackDnsSuffix}",
                              properties: Rs,
                              headers: Rs,
                            },
                            type: sh,
                          },
                        ],
                        type: Ea,
                      },
                      {
                        error:
                          "FIPS and DualStack are enabled, but this partition does not support one or both",
                        type: nh,
                      },
                    ],
                    type: Ea,
                  },
                  {
                    conditions: gKe,
                    rules: [
                      {
                        conditions: [{ [Is]: yx, [Ps]: [pKe, !0] }],
                        rules: [
                          {
                            conditions: [
                              {
                                [Is]: "stringEquals",
                                [Ps]: [
                                  { [Is]: Zq, [Ps]: [bKe, "name"] },
                                  "aws-us-gov",
                                ],
                              },
                            ],
                            endpoint: {
                              url: "https://portal.sso.{Region}.amazonaws.com",
                              properties: Rs,
                              headers: Rs,
                            },
                            type: sh,
                          },
                          {
                            endpoint: {
                              url: "https://portal.sso-fips.{Region}.{PartitionResult#dnsSuffix}",
                              properties: Rs,
                              headers: Rs,
                            },
                            type: sh,
                          },
                        ],
                        type: Ea,
                      },
                      {
                        error:
                          "FIPS is enabled but this partition does not support FIPS",
                        type: nh,
                      },
                    ],
                    type: Ea,
                  },
                  {
                    conditions: yKe,
                    rules: [
                      {
                        conditions: [hKe],
                        rules: [
                          {
                            endpoint: {
                              url: "https://portal.sso.{Region}.{PartitionResult#dualStackDnsSuffix}",
                              properties: Rs,
                              headers: Rs,
                            },
                            type: sh,
                          },
                        ],
                        type: Ea,
                      },
                      {
                        error:
                          "DualStack is enabled but this partition does not support DualStack",
                        type: nh,
                      },
                    ],
                    type: Ea,
                  },
                  {
                    endpoint: {
                      url: "https://portal.sso.{Region}.{PartitionResult#dnsSuffix}",
                      properties: Rs,
                      headers: Rs,
                    },
                    type: sh,
                  },
                ],
                type: Ea,
              },
            ],
            type: Ea,
          },
          { error: "Invalid Configuration: Missing Region", type: nh },
        ],
      }),
      (_Ke = gRt);
  });
var yRt,
  TKe,
  AKe = s(() => {
    dR();
    $t();
    wKe();
    (yRt = new uo({
      size: 50,
      params: ["Endpoint", "Region", "UseDualStack", "UseFIPS"],
    })),
      (TKe = (e, t = {}) =>
        yRt.get(e, () => jr(_Ke, { endpointParams: e, logger: t.logger })));
    Jt.aws = Ny;
  });
var RKe,
  IKe = s(() => {
    rt();
    Ue();
    $();
    Ly();
    Hc();
    Gm();
    Dq();
    AKe();
    RKe = (e) => ({
      apiVersion: "2019-06-10",
      base64Decoder: e?.base64Decoder ?? Vm,
      base64Encoder: e?.base64Encoder ?? xa,
      disableHostPrefix: e?.disableHostPrefix ?? !1,
      endpointProvider: e?.endpointProvider ?? TKe,
      extensions: e?.extensions ?? [],
      httpAuthSchemeProvider: e?.httpAuthSchemeProvider ?? S6e,
      httpAuthSchemes: e?.httpAuthSchemes ?? [
        {
          schemeId: "aws.auth#sigv4",
          identityProvider: (t) => t.getIdentityProvider("aws.auth#sigv4"),
          signer: new wr(),
        },
        {
          schemeId: "smithy.api#noAuth",
          identityProvider: (t) =>
            t.getIdentityProvider("smithy.api#noAuth") || (async () => ({})),
          signer: new hn(),
        },
      ],
      logger: e?.logger ?? new bc(),
      serviceId: e?.serviceId ?? "SSO",
      urlParser: e?.urlParser ?? wi,
      utf8Decoder: e?.utf8Decoder ?? ya,
      utf8Encoder: e?.utf8Encoder ?? jm,
    });
  });
var PKe,
  ej,
  tj,
  vKe,
  OKe,
  kKe,
  DKe = s(() => {
    (PKe = "AWS_EXECUTION_ENV"),
      (ej = "AWS_REGION"),
      (tj = "AWS_DEFAULT_REGION"),
      (vKe = "AWS_EC2_METADATA_DISABLED"),
      (OKe = ["in-region", "cross-region", "mobile", "standard", "legacy"]),
      (kKe = "/latest/meta-data/placement/region");
  });
var xRt,
  ERt,
  NKe,
  BKe = s(() => {
    (xRt = "AWS_DEFAULTS_MODE"),
      (ERt = "defaults_mode"),
      (NKe = {
        environmentVariableSelector: (e) => e[xRt],
        configFileSelector: (e) => e[ERt],
        default: "legacy",
      });
  });
var XP,
  SRt,
  CRt,
  MKe = s(() => {
    Ru();
    zd();
    re();
    DKe();
    BKe();
    (XP = ({ region: e = Bt(Au), defaultsMode: t = Bt(NKe) } = {}) =>
      gr(async () => {
        let r = typeof t == "function" ? await t() : t;
        switch (r?.toLowerCase()) {
          case "auto":
            return SRt(e);
          case "in-region":
          case "cross-region":
          case "mobile":
          case "standard":
          case "legacy":
            return Promise.resolve(r?.toLocaleLowerCase());
          case void 0:
            return Promise.resolve("legacy");
          default:
            throw new Error(
              `Invalid parameter for "defaultsMode", expect ${OKe.join(", ")}, got ${r}`
            );
        }
      })),
      (SRt = async (e) => {
        if (e) {
          let t = typeof e == "function" ? await e() : e,
            r = await CRt();
          return r ? (t === r ? "in-region" : "cross-region") : "standard";
        }
        return "standard";
      }),
      (CRt = async () => {
        if (process.env[PKe] && (process.env[ej] || process.env[tj]))
          return process.env[ej] ?? process.env[tj];
        if (!process.env[vKe])
          try {
            let { getInstanceMetadataEndpoint: e, httpRequest: t } =
                await Promise.resolve().then(() => (hx(), px)),
              r = await e();
            return (await t({ ...r, path: kKe })).toString();
          } catch {}
      });
  });
var rj = s(() => {
  MKe();
});
var LKe,
  FKe = s(() => {
    _6e();
    rt();
    Mq();
    Ru();
    zq();
    $y();
    zd();
    YP();
    Yq();
    Ti();
    IKe();
    $();
    rj();
    $();
    LKe = (e) => {
      qR(process.version);
      let t = XP(e),
        r = () => t().then(zR),
        o = RKe(e);
      $o(process.version);
      let n = { profile: e?.profile, logger: o.logger };
      return {
        ...o,
        ...e,
        runtime: "node",
        defaultsMode: t,
        authSchemePreference: e?.authSchemePreference ?? Bt(Ho, n),
        bodyLengthChecker: e?.bodyLengthChecker ?? QP,
        defaultUserAgentProvider:
          e?.defaultUserAgentProvider ??
          jP({ serviceId: o.serviceId, clientVersion: w6e.version }),
        maxAttempts: e?.maxAttempts ?? Bt(LR, e),
        region: e?.region ?? Bt(Au, { ...yR, ...n }),
        requestHandler: rh.create(e?.requestHandler ?? r),
        retryMode:
          e?.retryMode ??
          Bt({ ...UR, default: async () => (await r()).retryMode || vu }, e),
        sha256: e?.sha256 ?? $c.bind(null, "sha256"),
        streamCollector: e?.streamCollector ?? oh,
        useDualstackEndpoint: e?.useDualstackEndpoint ?? Bt(hR, n),
        useFipsEndpoint: e?.useFipsEndpoint ?? Bt(gR, n),
        userAgentAppId: e?.userAgentAppId ?? Bt(GP, n),
      };
    };
  });
var UKe,
  $Ke,
  HKe = s(() => {
    (UKe = (e) => {
      let t = e.httpAuthSchemes,
        r = e.httpAuthSchemeProvider,
        o = e.credentials;
      return {
        setHttpAuthScheme(n) {
          let i = t.findIndex((a) => a.schemeId === n.schemeId);
          i === -1 ? t.push(n) : t.splice(i, 1, n);
        },
        httpAuthSchemes() {
          return t;
        },
        setHttpAuthSchemeProvider(n) {
          r = n;
        },
        httpAuthSchemeProvider() {
          return r;
        },
        setCredentials(n) {
          o = n;
        },
        credentials() {
          return o;
        },
      };
    }),
      ($Ke = (e) => ({
        httpAuthSchemes: e.httpAuthSchemes(),
        httpAuthSchemeProvider: e.httpAuthSchemeProvider(),
        credentials: e.credentials(),
      }));
  });
var zKe,
  qKe = s(() => {
    Xi();
    an();
    $();
    HKe();
    zKe = (e, t) => {
      let r = Object.assign(Go(e), jR(e), YA(e), UKe(e));
      return (
        t.forEach((o) => o.configure(r)),
        Object.assign(e, Vo(r), GR(r), QA(r), $Ke(r))
      );
    };
  });
var Bi,
  xx = s(() => {
    LH();
    FH();
    $H();
    pR();
    Ru();
    Ue();
    S3();
    K();
    $y();
    $();
    Dq();
    eh();
    FKe();
    qKe();
    Bi = class extends Mu {
      config;
      constructor(...[t]) {
        let r = LKe(t || {});
        super(r), (this.initConfig = r);
        let o = b6e(r),
          n = cR(o),
          i = FR(n),
          a = ER(i),
          c = a,
          d = vR(c),
          m = C6e(d),
          f = zKe(m, t?.extensions || []);
        (this.config = f),
          this.middlewareStack.use(uR(this.config)),
          this.middlewareStack.use(VR(this.config)),
          this.middlewareStack.use(SR(this.config)),
          this.middlewareStack.use(XA(this.config)),
          this.middlewareStack.use(JA(this.config)),
          this.middlewareStack.use(ZA(this.config)),
          this.middlewareStack.use(
            Mo(this.config, {
              httpAuthSchemeParametersProvider: E6e,
              identityProviderConfigProvider: async (l) =>
                new fo({ "aws.auth#sigv4": l.credentials }),
            })
          ),
          this.middlewareStack.use(Lo(this.config));
      }
      destroy() {
        super.destroy();
      }
    };
  });
var Sa,
  oj = s(() => {
    $();
    Sa = class e extends Lu {
      constructor(t) {
        super(t), Object.setPrototypeOf(this, e.prototype);
      }
    };
  });
var JP,
  ZP,
  ev,
  tv,
  jKe,
  _Rt,
  GKe,
  VKe,
  WKe,
  KKe,
  Wm = s(() => {
    $();
    oj();
    (JP = class e extends Sa {
      name = "InvalidRequestException";
      $fault = "client";
      constructor(t) {
        super({ name: "InvalidRequestException", $fault: "client", ...t }),
          Object.setPrototypeOf(this, e.prototype);
      }
    }),
      (ZP = class e extends Sa {
        name = "ResourceNotFoundException";
        $fault = "client";
        constructor(t) {
          super({ name: "ResourceNotFoundException", $fault: "client", ...t }),
            Object.setPrototypeOf(this, e.prototype);
        }
      }),
      (ev = class e extends Sa {
        name = "TooManyRequestsException";
        $fault = "client";
        constructor(t) {
          super({ name: "TooManyRequestsException", $fault: "client", ...t }),
            Object.setPrototypeOf(this, e.prototype);
        }
      }),
      (tv = class e extends Sa {
        name = "UnauthorizedException";
        $fault = "client";
        constructor(t) {
          super({ name: "UnauthorizedException", $fault: "client", ...t }),
            Object.setPrototypeOf(this, e.prototype);
        }
      }),
      (jKe = (e) => ({ ...e, ...(e.accessToken && { accessToken: $e }) })),
      (_Rt = (e) => ({
        ...e,
        ...(e.secretAccessKey && { secretAccessKey: $e }),
        ...(e.sessionToken && { sessionToken: $e }),
      })),
      (GKe = (e) => ({
        ...e,
        ...(e.roleCredentials && { roleCredentials: _Rt(e.roleCredentials) }),
      })),
      (VKe = (e) => ({ ...e, ...(e.accessToken && { accessToken: $e }) })),
      (WKe = (e) => ({ ...e, ...(e.accessToken && { accessToken: $e }) })),
      (KKe = (e) => ({ ...e, ...(e.accessToken && { accessToken: $e }) }));
  });
var YKe,
  QKe,
  XKe,
  JKe,
  ZKe,
  e5e,
  t5e,
  r5e,
  rv,
  wRt,
  TRt,
  ARt,
  RRt,
  IRt,
  zc,
  o5e,
  ov,
  n5e,
  s5e,
  i5e,
  a5e,
  c5e,
  PRt,
  vRt,
  nv,
  Ex = s(() => {
    rt();
    Ue();
    $();
    Wm();
    oj();
    (YKe = async (e, t) => {
      let r = G(e, t),
        o = g({}, k, { [nv]: e[ov] });
      r.bp("/federation/credentials");
      let n = g({
        [vRt]: [, F(e[PRt], "roleName")],
        [n5e]: [, F(e[o5e], "accountId")],
      });
      return (
        r
          .m("GET")
          .h(o)
          .q(n)
          .b(void 0),
        r.build()
      );
    }),
      (QKe = async (e, t) => {
        let r = G(e, t),
          o = g({}, k, { [nv]: e[ov] });
        r.bp("/assignment/roles");
        let n = g({
          [c5e]: [, e[a5e]],
          [i5e]: [() => e.maxResults !== void 0, () => e[s5e].toString()],
          [n5e]: [, F(e[o5e], "accountId")],
        });
        return (
          r
            .m("GET")
            .h(o)
            .q(n)
            .b(void 0),
          r.build()
        );
      }),
      (XKe = async (e, t) => {
        let r = G(e, t),
          o = g({}, k, { [nv]: e[ov] });
        r.bp("/assignment/accounts");
        let n = g({
          [c5e]: [, e[a5e]],
          [i5e]: [() => e.maxResults !== void 0, () => e[s5e].toString()],
        });
        return (
          r
            .m("GET")
            .h(o)
            .q(n)
            .b(void 0),
          r.build()
        );
      }),
      (JKe = async (e, t) => {
        let r = G(e, t),
          o = g({}, k, { [nv]: e[ov] });
        return (
          r.bp("/logout"),
          r
            .m("POST")
            .h(o)
            .b(void 0),
          r.build()
        );
      }),
      (ZKe = async (e, t) => {
        if (e.statusCode !== 200 && e.statusCode >= 300) return rv(e, t);
        let r = g({ $metadata: zc(e) }),
          o = F(Se(await ie(e.body, t)), "body"),
          n = _c(o, { roleCredentials: Fu });
        return Object.assign(r, n), r;
      }),
      (e5e = async (e, t) => {
        if (e.statusCode !== 200 && e.statusCode >= 300) return rv(e, t);
        let r = g({ $metadata: zc(e) }),
          o = F(Se(await ie(e.body, t)), "body"),
          n = _c(o, { nextToken: p, roleList: Fu });
        return Object.assign(r, n), r;
      }),
      (t5e = async (e, t) => {
        if (e.statusCode !== 200 && e.statusCode >= 300) return rv(e, t);
        let r = g({ $metadata: zc(e) }),
          o = F(Se(await ie(e.body, t)), "body"),
          n = _c(o, { accountList: Fu, nextToken: p });
        return Object.assign(r, n), r;
      }),
      (r5e = async (e, t) => {
        if (e.statusCode !== 200 && e.statusCode >= 300) return rv(e, t);
        let r = g({ $metadata: zc(e) });
        return await ne(e.body, t), r;
      }),
      (rv = async (e, t) => {
        let r = { ...e, body: await Gn(e.body, t) },
          o = Vn(e, r.body);
        switch (o) {
          case "InvalidRequestException":
          case "com.amazonaws.sso#InvalidRequestException":
            throw await TRt(r, t);
          case "ResourceNotFoundException":
          case "com.amazonaws.sso#ResourceNotFoundException":
            throw await ARt(r, t);
          case "TooManyRequestsException":
          case "com.amazonaws.sso#TooManyRequestsException":
            throw await RRt(r, t);
          case "UnauthorizedException":
          case "com.amazonaws.sso#UnauthorizedException":
            throw await IRt(r, t);
          default:
            let n = r.body;
            return wRt({ output: e, parsedBody: n, errorCode: o });
        }
      }),
      (wRt = HR(Sa)),
      (TRt = async (e, t) => {
        let r = g({}),
          o = e.body,
          n = _c(o, { message: p });
        Object.assign(r, n);
        let i = new JP({ $metadata: zc(e), ...r });
        return Nr(i, e.body);
      }),
      (ARt = async (e, t) => {
        let r = g({}),
          o = e.body,
          n = _c(o, { message: p });
        Object.assign(r, n);
        let i = new ZP({ $metadata: zc(e), ...r });
        return Nr(i, e.body);
      }),
      (RRt = async (e, t) => {
        let r = g({}),
          o = e.body,
          n = _c(o, { message: p });
        Object.assign(r, n);
        let i = new ev({ $metadata: zc(e), ...r });
        return Nr(i, e.body);
      }),
      (IRt = async (e, t) => {
        let r = g({}),
          o = e.body,
          n = _c(o, { message: p });
        Object.assign(r, n);
        let i = new tv({ $metadata: zc(e), ...r });
        return Nr(i, e.body);
      }),
      (zc = (e) => ({
        httpStatusCode: e.statusCode,
        requestId:
          e.headers["x-amzn-requestid"] ??
          e.headers["x-amzn-request-id"] ??
          e.headers["x-amz-request-id"],
        extendedRequestId: e.headers["x-amz-id-2"],
        cfId: e.headers["x-amz-cf-id"],
      })),
      (o5e = "accountId"),
      (ov = "accessToken"),
      (n5e = "account_id"),
      (s5e = "maxResults"),
      (i5e = "max_result"),
      (a5e = "nextToken"),
      (c5e = "next_token"),
      (PRt = "roleName"),
      (vRt = "role_name"),
      (nv = "x-amz-sso_bearer_token");
  });
var ah,
  nj = s(() => {
    K();
    Y();
    $();
    eh();
    Wm();
    Ex();
    ah = class extends (
      _.classBuilder()
        .ep(Uc)
        .m(function (t, r, o, n) {
          return [
            T(o, this.serialize, this.deserialize),
            A(o, t.getEndpointParameterInstructions()),
          ];
        })
        .s("SWBPortalService", "GetRoleCredentials", {})
        .n("SSOClient", "GetRoleCredentialsCommand")
        .f(jKe, GKe)
        .ser(YKe)
        .de(ZKe)
        .build()
    ) {};
  });
var ch,
  sv = s(() => {
    K();
    Y();
    $();
    eh();
    Wm();
    Ex();
    ch = class extends (
      _.classBuilder()
        .ep(Uc)
        .m(function (t, r, o, n) {
          return [
            T(o, this.serialize, this.deserialize),
            A(o, t.getEndpointParameterInstructions()),
          ];
        })
        .s("SWBPortalService", "ListAccountRoles", {})
        .n("SSOClient", "ListAccountRolesCommand")
        .f(VKe, void 0)
        .ser(QKe)
        .de(e5e)
        .build()
    ) {};
  });
var dh,
  iv = s(() => {
    K();
    Y();
    $();
    eh();
    Wm();
    Ex();
    dh = class extends (
      _.classBuilder()
        .ep(Uc)
        .m(function (t, r, o, n) {
          return [
            T(o, this.serialize, this.deserialize),
            A(o, t.getEndpointParameterInstructions()),
          ];
        })
        .s("SWBPortalService", "ListAccounts", {})
        .n("SSOClient", "ListAccountsCommand")
        .f(WKe, void 0)
        .ser(XKe)
        .de(t5e)
        .build()
    ) {};
  });
var av,
  sj = s(() => {
    K();
    Y();
    $();
    eh();
    Wm();
    Ex();
    av = class extends (
      _.classBuilder()
        .ep(Uc)
        .m(function (t, r, o, n) {
          return [
            T(o, this.serialize, this.deserialize),
            A(o, t.getEndpointParameterInstructions()),
          ];
        })
        .s("SWBPortalService", "Logout", {})
        .n("SSOClient", "LogoutCommand")
        .f(KKe, void 0)
        .ser(JKe)
        .de(r5e)
        .build()
    ) {};
  });
var ORt,
  ij,
  d5e = s(() => {
    $();
    nj();
    sv();
    iv();
    sj();
    xx();
    (ORt = {
      GetRoleCredentialsCommand: ah,
      ListAccountRolesCommand: ch,
      ListAccountsCommand: dh,
      LogoutCommand: av,
    }),
      (ij = class extends Bi {});
    $R(ORt, ij);
  });
var m5e = s(() => {
  nj();
  sv();
  iv();
  sj();
});
var l5e = s(() => {});
var tko,
  f5e = s(() => {
    Ue();
    sv();
    xx();
    tko = dt(Bi, ch, "nextToken", "nextToken", "maxResults");
  });
var iko,
  u5e = s(() => {
    Ue();
    iv();
    xx();
    iko = dt(Bi, dh, "nextToken", "nextToken", "maxResults");
  });
var p5e = s(() => {
  l5e();
  f5e();
  u5e();
});
var h5e = s(() => {
  Wm();
});
var g5e = s(() => {
  xx();
  d5e();
  m5e();
  p5e();
  h5e();
});
var y5e = {};
It(y5e, { GetRoleCredentialsCommand: () => ah, SSOClient: () => Bi });
var x5e = s(() => {
  g5e();
});
var Sx,
  aj,
  E5e = s(() => {
    xt();
    x6e();
    re();
    Vs();
    (Sx = !1),
      (aj = async ({
        ssoStartUrl: e,
        ssoSession: t,
        ssoAccountId: r,
        ssoRegion: o,
        ssoRoleName: n,
        ssoClient: i,
        clientConfig: a,
        parentClientConfig: c,
        profile: d,
        logger: m,
      }) => {
        let f,
          l =
            "To refresh this SSO session run aws sso login with the corresponding profile.";
        if (t)
          try {
            let yt = await p6e({ profile: d })();
            f = {
              accessToken: yt.token,
              expiresAt: new Date(yt.expiration).toISOString(),
            };
          } catch (yt) {
            throw new P(yt.message, { tryNextLink: Sx, logger: m });
          }
        else
          try {
            f = await _R(e);
          } catch {
            throw new P(
              `The SSO session associated with this profile is invalid. ${l}`,
              { tryNextLink: Sx, logger: m }
            );
          }
        if (new Date(f.expiresAt).getTime() - Date.now() <= 0)
          throw new P(
            `The SSO session associated with this profile has expired. ${l}`,
            { tryNextLink: Sx, logger: m }
          );
        let { accessToken: u } = f,
          { SSOClient: h, GetRoleCredentialsCommand: y } =
            await Promise.resolve().then(() => (x5e(), y5e)),
          S =
            i ||
            new h(
              Object.assign({}, a ?? {}, {
                logger: a?.logger ?? c?.logger,
                region: a?.region ?? o,
              })
            ),
          E;
        try {
          E = await S.send(
            new y({ accountId: r, roleName: n, accessToken: u })
          );
        } catch (yt) {
          throw new P(yt, { tryNextLink: Sx, logger: m });
        }
        let {
          roleCredentials: {
            accessKeyId: b,
            secretAccessKey: v,
            sessionToken: I,
            expiration: O,
            credentialScope: ge,
            accountId: Fe,
          } = {},
        } = E;
        if (!b || !v || !I || !O)
          throw new P("SSO returns an invalid temporary credential.", {
            tryNextLink: Sx,
            logger: m,
          });
        let Vt = {
          accessKeyId: b,
          secretAccessKey: v,
          sessionToken: I,
          expiration: new Date(O),
          ...(ge && { credentialScope: ge }),
          ...(Fe && { accountId: Fe }),
        };
        return (
          t
            ? ce(Vt, "CREDENTIALS_SSO", "s")
            : ce(Vt, "CREDENTIALS_SSO_LEGACY", "u"),
          Vt
        );
      });
  });
var cj,
  dj = s(() => {
    re();
    cj = (e, t) => {
      let {
        sso_start_url: r,
        sso_account_id: o,
        sso_region: n,
        sso_role_name: i,
      } = e;
      if (!r || !o || !n || !i)
        throw new P(
          `Profile is configured with invalid SSO credentials. Required parameters "sso_account_id", "sso_region", "sso_role_name", "sso_start_url". Got ${Object.keys(e).join(", ")}
Reference: https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-sso.html`,
          { tryNextLink: !1, logger: t }
        );
      return e;
    };
  });
var kRt,
  S5e = s(() => {
    re();
    Vs();
    Oq();
    E5e();
    dj();
    kRt =
      (e = {}) =>
      async ({ callerClientConfig: t } = {}) => {
        e.logger?.debug("@aws-sdk/credential-provider-sso - fromSSO");
        let {
            ssoStartUrl: r,
            ssoAccountId: o,
            ssoRegion: n,
            ssoRoleName: i,
            ssoSession: a,
          } = e,
          { ssoClient: c } = e,
          d = us({ profile: e.profile ?? t?.profile });
        if (!r && !o && !n && !i && !a) {
          let f = (await Sc(e))[d];
          if (!f)
            throw new P(`Profile ${d} was not found.`, { logger: e.logger });
          if (!vq(f))
            throw new P(
              `Profile ${d} is not configured with SSO credentials.`,
              { logger: e.logger }
            );
          if (f?.sso_session) {
            let b = (await AR(e))[f.sso_session],
              v = ` configurations in profile ${d} and sso-session ${f.sso_session}`;
            if (n && n !== b.sso_region)
              throw new P("Conflicting SSO region" + v, {
                tryNextLink: !1,
                logger: e.logger,
              });
            if (r && r !== b.sso_start_url)
              throw new P("Conflicting SSO start_url" + v, {
                tryNextLink: !1,
                logger: e.logger,
              });
            (f.sso_region = b.sso_region), (f.sso_start_url = b.sso_start_url);
          }
          let {
            sso_start_url: l,
            sso_account_id: u,
            sso_region: h,
            sso_role_name: y,
            sso_session: S,
          } = cj(f, e.logger);
          return aj({
            ssoStartUrl: l,
            ssoSession: S,
            ssoAccountId: u,
            ssoRegion: h,
            ssoRoleName: y,
            ssoClient: c,
            clientConfig: e.clientConfig,
            parentClientConfig: e.parentClientConfig,
            profile: d,
          });
        } else {
          if (!r || !o || !n || !i)
            throw new P(
              'Incomplete configuration. The fromSSO() argument hash must include "ssoStartUrl", "ssoAccountId", "ssoRegion", "ssoRoleName"',
              { tryNextLink: !1, logger: e.logger }
            );
          return aj({
            ssoStartUrl: r,
            ssoSession: a,
            ssoAccountId: o,
            ssoRegion: n,
            ssoRoleName: i,
            ssoClient: c,
            clientConfig: e.clientConfig,
            parentClientConfig: e.parentClientConfig,
            profile: d,
          });
        }
      };
  });
var C5e = s(() => {});
var mj = {};
It(mj, {
  fromSSO: () => kRt,
  isSsoProfile: () => vq,
  validateSsoProfile: () => cj,
});
var lj = s(() => {
  S5e();
  Oq();
  C5e();
  dj();
});
var b5e,
  fj,
  _5e = s(() => {
    xt();
    re();
    (b5e = (e, t, r) => {
      let o = {
        EcsContainer: async (n) => {
          let { fromHttp: i } = await Promise.resolve().then(() => (ld(), md)),
            { fromContainerMetadata: a } = await Promise.resolve().then(
              () => (hx(), px)
            );
          return (
            r?.debug(
              "@aws-sdk/credential-provider-ini - credential_source is EcsContainer"
            ),
            async () => Ht(i(n ?? {}), a(n))().then(fj)
          );
        },
        Ec2InstanceMetadata: async (n) => {
          r?.debug(
            "@aws-sdk/credential-provider-ini - credential_source is Ec2InstanceMetadata"
          );
          let { fromInstanceMetadata: i } = await Promise.resolve().then(
            () => (hx(), px)
          );
          return async () => i(n)().then(fj);
        },
        Environment: async (n) => {
          r?.debug(
            "@aws-sdk/credential-provider-ini - credential_source is Environment"
          );
          let { fromEnv: i } = await Promise.resolve().then(() => (Cq(), $We));
          return async () => i(n)().then(fj);
        },
      };
      if (e in o) return o[e];
      throw new P(
        `Unsupported credential source in profile ${t}. Got ${e}, expected EcsContainer or Ec2InstanceMetadata or Environment.`,
        { logger: r }
      );
    }),
      (fj = (e) => ce(e, "CREDENTIALS_PROFILE_NAMED_PROVIDER", "p"));
  });
var T5e,
  DRt,
  NRt,
  A5e,
  w5e,
  R5e = s(() => {
    xt();
    re();
    Vs();
    _5e();
    uj();
    (T5e = (e, { profile: t = "default", logger: r } = {}) =>
      !!e &&
      typeof e == "object" &&
      typeof e.role_arn == "string" &&
      ["undefined", "string"].indexOf(typeof e.role_session_name) > -1 &&
      ["undefined", "string"].indexOf(typeof e.external_id) > -1 &&
      ["undefined", "string"].indexOf(typeof e.mfa_serial) > -1 &&
      (DRt(e, { profile: t, logger: r }) || NRt(e, { profile: t, logger: r }))),
      (DRt = (e, { profile: t, logger: r }) => {
        let o =
          typeof e.source_profile == "string" &&
          typeof e.credential_source > "u";
        return (
          o &&
            r?.debug?.(
              `    ${t} isAssumeRoleWithSourceProfile source_profile=${e.source_profile}`
            ),
          o
        );
      }),
      (NRt = (e, { profile: t, logger: r }) => {
        let o =
          typeof e.credential_source == "string" &&
          typeof e.source_profile > "u";
        return (
          o &&
            r?.debug?.(
              `    ${t} isCredentialSourceProfile credential_source=${e.credential_source}`
            ),
          o
        );
      }),
      (A5e = async (e, t, r, o = {}) => {
        r.logger?.debug(
          "@aws-sdk/credential-provider-ini - resolveAssumeRoleCredentials (STS)"
        );
        let n = t[e],
          { source_profile: i, region: a } = n;
        if (!r.roleAssumer) {
          let { getDefaultRoleAssumer: d } = await Promise.resolve().then(
            () => (Td(), wd)
          );
          r.roleAssumer = d(
            {
              ...r.clientConfig,
              credentialProviderLogger: r.logger,
              parentClientConfig: {
                ...r?.parentClientConfig,
                region: a ?? r?.parentClientConfig?.region,
              },
            },
            r.clientPlugins
          );
        }
        if (i && i in o)
          throw new P(
            `Detected a cycle attempting to resolve credentials for profile ${us(r)}. Profiles visited: ` +
              Object.keys(o).join(", "),
            { logger: r.logger }
          );
        r.logger?.debug(
          `@aws-sdk/credential-provider-ini - finding credential resolver using ${i ? `source_profile=[${i}]` : `profile=[${e}]`}`
        );
        let c = i
          ? cv(i, t, r, { ...o, [i]: !0 }, w5e(t[i] ?? {}))
          : (await b5e(n.credential_source, e, r.logger)(r))();
        if (w5e(n))
          return c.then((d) =>
            ce(d, "CREDENTIALS_PROFILE_SOURCE_PROFILE", "o")
          );
        {
          let d = {
              RoleArn: n.role_arn,
              RoleSessionName:
                n.role_session_name || `aws-sdk-js-${Date.now()}`,
              ExternalId: n.external_id,
              DurationSeconds: parseInt(n.duration_seconds || "3600", 10),
            },
            { mfa_serial: m } = n;
          if (m) {
            if (!r.mfaCodeProvider)
              throw new P(
                `Profile ${e} requires multi-factor authentication, but no MFA code callback was provided.`,
                { logger: r.logger, tryNextLink: !1 }
              );
            (d.SerialNumber = m), (d.TokenCode = await r.mfaCodeProvider(m));
          }
          let f = await c;
          return r
            .roleAssumer(f, d)
            .then((l) => ce(l, "CREDENTIALS_PROFILE_SOURCE_PROFILE", "o"));
        }
      }),
      (w5e = (e) => !e.role_arn && !!e.credential_source);
  });
var I5e,
  P5e = s(() => {
    xt();
    I5e = (e, t, r) => {
      if (t.Version !== 1)
        throw Error(
          `Profile ${e} credential_process did not return Version 1.`
        );
      if (t.AccessKeyId === void 0 || t.SecretAccessKey === void 0)
        throw Error(
          `Profile ${e} credential_process returned invalid credentials.`
        );
      if (t.Expiration) {
        let i = new Date();
        if (new Date(t.Expiration) < i)
          throw Error(
            `Profile ${e} credential_process returned expired credentials.`
          );
      }
      let o = t.AccountId;
      !o && r?.[e]?.aws_account_id && (o = r[e].aws_account_id);
      let n = {
        accessKeyId: t.AccessKeyId,
        secretAccessKey: t.SecretAccessKey,
        ...(t.SessionToken && { sessionToken: t.SessionToken }),
        ...(t.Expiration && { expiration: new Date(t.Expiration) }),
        ...(t.CredentialScope && { credentialScope: t.CredentialScope }),
        ...(o && { accountId: o }),
      };
      return ce(n, "CREDENTIALS_PROCESS", "w"), n;
    };
  });
import { exec as BRt } from "child_process";
import { promisify as MRt } from "util";
var v5e,
  O5e = s(() => {
    re();
    P5e();
    v5e = async (e, t, r) => {
      let o = t[e];
      if (t[e]) {
        let n = o.credential_process;
        if (n !== void 0) {
          let i = MRt(BRt);
          try {
            let { stdout: a } = await i(n),
              c;
            try {
              c = JSON.parse(a.trim());
            } catch {
              throw Error(
                `Profile ${e} credential_process returned invalid JSON.`
              );
            }
            return I5e(e, c, t);
          } catch (a) {
            throw new P(a.message, { logger: r });
          }
        } else
          throw new P(`Profile ${e} did not contain credential_process.`, {
            logger: r,
          });
      } else
        throw new P(
          `Profile ${e} could not be found in shared credentials file.`,
          { logger: r }
        );
    };
  });
var LRt,
  k5e = s(() => {
    Vs();
    O5e();
    LRt =
      (e = {}) =>
      async ({ callerClientConfig: t } = {}) => {
        e.logger?.debug("@aws-sdk/credential-provider-process - fromProcess");
        let r = await Sc(e);
        return v5e(us({ profile: e.profile ?? t?.profile }), r, e.logger);
      };
  });
var pj = {};
It(pj, { fromProcess: () => LRt });
var hj = s(() => {
  k5e();
});
var D5e,
  N5e,
  B5e = s(() => {
    xt();
    (D5e = (e) =>
      !!e && typeof e == "object" && typeof e.credential_process == "string"),
      (N5e = async (e, t) =>
        Promise.resolve()
          .then(() => (hj(), pj))
          .then(({ fromProcess: r }) =>
            r({ ...e, profile: t })().then((o) =>
              ce(o, "CREDENTIALS_PROFILE_PROCESS", "v")
            )
          ));
  });
var M5e,
  L5e,
  F5e = s(() => {
    xt();
    (M5e = async (e, t, r = {}) => {
      let { fromSSO: o } = await Promise.resolve().then(() => (lj(), mj));
      return o({
        profile: e,
        logger: r.logger,
        parentClientConfig: r.parentClientConfig,
        clientConfig: r.clientConfig,
      })().then((n) =>
        t.sso_session
          ? ce(n, "CREDENTIALS_PROFILE_SSO", "r")
          : ce(n, "CREDENTIALS_PROFILE_SSO_LEGACY", "t")
      );
    }),
      (L5e = (e) =>
        e &&
        (typeof e.sso_start_url == "string" ||
          typeof e.sso_account_id == "string" ||
          typeof e.sso_session == "string" ||
          typeof e.sso_region == "string" ||
          typeof e.sso_role_name == "string"));
  });
var gj,
  yj,
  U5e = s(() => {
    xt();
    (gj = (e) =>
      !!e &&
      typeof e == "object" &&
      typeof e.aws_access_key_id == "string" &&
      typeof e.aws_secret_access_key == "string" &&
      ["undefined", "string"].indexOf(typeof e.aws_session_token) > -1 &&
      ["undefined", "string"].indexOf(typeof e.aws_account_id) > -1),
      (yj = async (e, t) => {
        t?.logger?.debug(
          "@aws-sdk/credential-provider-ini - resolveStaticCredentials"
        );
        let r = {
          accessKeyId: e.aws_access_key_id,
          secretAccessKey: e.aws_secret_access_key,
          sessionToken: e.aws_session_token,
          ...(e.aws_credential_scope && {
            credentialScope: e.aws_credential_scope,
          }),
          ...(e.aws_account_id && { accountId: e.aws_account_id }),
        };
        return ce(r, "CREDENTIALS_PROFILE", "n");
      });
  });
var xj,
  Ej = s(() => {
    xj = (e) => async (t) => {
      e.logger?.debug(
        "@aws-sdk/credential-provider-web-identity - fromWebToken"
      );
      let {
          roleArn: r,
          roleSessionName: o,
          webIdentityToken: n,
          providerId: i,
          policyArns: a,
          policy: c,
          durationSeconds: d,
        } = e,
        { roleAssumerWithWebIdentity: m } = e;
      if (!m) {
        let { getDefaultRoleAssumerWithWebIdentity: f } =
          await Promise.resolve().then(() => (Td(), wd));
        m = f(
          {
            ...e.clientConfig,
            credentialProviderLogger: e.logger,
            parentClientConfig: {
              ...t?.callerClientConfig,
              ...e.parentClientConfig,
            },
          },
          e.clientPlugins
        );
      }
      return m({
        RoleArn: r,
        RoleSessionName: o ?? `aws-sdk-js-session-${Date.now()}`,
        WebIdentityToken: n,
        ProviderId: i,
        PolicyArns: a,
        Policy: c,
        DurationSeconds: d,
      });
    };
  });
import { readFileSync as FRt } from "fs";
var $5e,
  URt,
  $Rt,
  HRt,
  H5e = s(() => {
    xt();
    re();
    Ej();
    ($5e = "AWS_WEB_IDENTITY_TOKEN_FILE"),
      (URt = "AWS_ROLE_ARN"),
      ($Rt = "AWS_ROLE_SESSION_NAME"),
      (HRt =
        (e = {}) =>
        async () => {
          e.logger?.debug(
            "@aws-sdk/credential-provider-web-identity - fromTokenFile"
          );
          let t = e?.webIdentityTokenFile ?? process.env[$5e],
            r = e?.roleArn ?? process.env[URt],
            o = e?.roleSessionName ?? process.env[$Rt];
          if (!t || !r)
            throw new P("Web identity configuration not specified", {
              logger: e.logger,
            });
          let n = await xj({
            ...e,
            webIdentityToken: FRt(t, { encoding: "ascii" }),
            roleArn: r,
            roleSessionName: o,
          })();
          return (
            t === process.env[$5e] &&
              ce(n, "CREDENTIALS_ENV_VARS_STS_WEB_ID_TOKEN", "h"),
            n
          );
        });
  });
var Sj = {};
It(Sj, { fromTokenFile: () => HRt, fromWebToken: () => xj });
var Cj = s(() => {
  H5e();
  Ej();
});
var z5e,
  q5e,
  j5e = s(() => {
    xt();
    (z5e = (e) =>
      !!e &&
      typeof e == "object" &&
      typeof e.web_identity_token_file == "string" &&
      typeof e.role_arn == "string" &&
      ["undefined", "string"].indexOf(typeof e.role_session_name) > -1),
      (q5e = async (e, t) =>
        Promise.resolve()
          .then(() => (Cj(), Sj))
          .then(({ fromTokenFile: r }) =>
            r({
              webIdentityTokenFile: e.web_identity_token_file,
              roleArn: e.role_arn,
              roleSessionName: e.role_session_name,
              roleAssumerWithWebIdentity: t.roleAssumerWithWebIdentity,
              logger: t.logger,
              parentClientConfig: t.parentClientConfig,
            })().then((o) => ce(o, "CREDENTIALS_PROFILE_STS_WEB_ID_TOKEN", "q"))
          ));
  });
var cv,
  uj = s(() => {
    re();
    R5e();
    B5e();
    F5e();
    U5e();
    j5e();
    cv = async (e, t, r, o = {}, n = !1) => {
      let i = t[e];
      if (Object.keys(o).length > 0 && gj(i)) return yj(i, r);
      if (n || T5e(i, { profile: e, logger: r.logger })) return A5e(e, t, r, o);
      if (gj(i)) return yj(i, r);
      if (z5e(i)) return q5e(i, r);
      if (D5e(i)) return N5e(r, e);
      if (L5e(i)) return await M5e(e, i, r);
      throw new P(
        `Could not resolve credentials using profile: [${e}] in configuration/credentials file(s).`,
        { logger: r.logger }
      );
    };
  });
var zRt,
  G5e = s(() => {
    Vs();
    uj();
    zRt =
      (e = {}) =>
      async ({ callerClientConfig: t } = {}) => {
        let r = { ...e, parentClientConfig: { ...t, ...e.parentClientConfig } };
        r.logger?.debug("@aws-sdk/credential-provider-ini - fromIni");
        let o = await Sc(r);
        return cv(us({ profile: e.profile ?? t?.profile }), o, r);
      };
  });
var V5e = {};
It(V5e, { fromIni: () => zRt });
var W5e = s(() => {
  G5e();
});
var K5e,
  Y5e,
  qRt,
  jRt,
  Q5e = s(() => {
    Cq();
    re();
    Vs();
    o6e();
    (K5e = !1),
      (Y5e = (e = {}) =>
        gr(
          Ht(
            async () => {
              if (e.profile ?? process.env[_3])
                throw (
                  (process.env[kP] &&
                    process.env[DP] &&
                    (K5e ||
                      ((e.logger?.warn &&
                        e.logger?.constructor?.name !== "NoOpLogger"
                        ? e.logger.warn
                        : console.warn)(`@aws-sdk/credential-provider-node - defaultProvider::fromEnv WARNING:
    Multiple credential sources detected: 
    Both AWS_PROFILE and the pair AWS_ACCESS_KEY_ID/AWS_SECRET_ACCESS_KEY static credentials are set.
    This SDK will proceed with the AWS_PROFILE value.
    
    However, a future version may change this behavior to prefer the ENV static credentials.
    Please ensure that your environment only sets either the AWS_PROFILE or the
    AWS_ACCESS_KEY_ID/AWS_SECRET_ACCESS_KEY pair.
`),
                      (K5e = !0))),
                  new P("AWS_PROFILE is set, skipping fromEnv provider.", {
                    logger: e.logger,
                    tryNextLink: !0,
                  }))
                );
              return (
                e.logger?.debug(
                  "@aws-sdk/credential-provider-node - defaultProvider::fromEnv"
                ),
                Sq(e)()
              );
            },
            async () => {
              e.logger?.debug(
                "@aws-sdk/credential-provider-node - defaultProvider::fromSSO"
              );
              let {
                ssoStartUrl: t,
                ssoAccountId: r,
                ssoRegion: o,
                ssoRoleName: n,
                ssoSession: i,
              } = e;
              if (!t && !r && !o && !n && !i)
                throw new P(
                  "Skipping SSO provider in default chain (inputs do not include SSO fields).",
                  { logger: e.logger }
                );
              let { fromSSO: a } = await Promise.resolve().then(
                () => (lj(), mj)
              );
              return a(e)();
            },
            async () => {
              e.logger?.debug(
                "@aws-sdk/credential-provider-node - defaultProvider::fromIni"
              );
              let { fromIni: t } = await Promise.resolve().then(
                () => (W5e(), V5e)
              );
              return t(e)();
            },
            async () => {
              e.logger?.debug(
                "@aws-sdk/credential-provider-node - defaultProvider::fromProcess"
              );
              let { fromProcess: t } = await Promise.resolve().then(
                () => (hj(), pj)
              );
              return t(e)();
            },
            async () => {
              e.logger?.debug(
                "@aws-sdk/credential-provider-node - defaultProvider::fromTokenFile"
              );
              let { fromTokenFile: t } = await Promise.resolve().then(
                () => (Cj(), Sj)
              );
              return t(e)();
            },
            async () => (
              e.logger?.debug(
                "@aws-sdk/credential-provider-node - defaultProvider::remoteProvider"
              ),
              (await r6e(e))()
            ),
            async () => {
              throw new P("Could not load credentials from any providers", {
                tryNextLink: !1,
                logger: e.logger,
              });
            }
          ),
          jRt,
          qRt
        )),
      (qRt = (e) => e?.expiration !== void 0),
      (jRt = (e) =>
        e?.expiration !== void 0 && e.expiration.getTime() - Date.now() < 3e5);
  });
var X5e = s(() => {
  Q5e();
});
var J5e = s(() => {
  Wn();
});
var GRt,
  VRt,
  Z5e,
  e9e = s(() => {
    Wn();
    (GRt = "AWS_S3_USE_ARN_REGION"),
      (VRt = "s3_use_arn_region"),
      (Z5e = {
        environmentVariableSelector: (e) => Nt(e, GRt, Tt.ENV),
        configFileSelector: (e) => Nt(e, VRt, Tt.CONFIG),
        default: void 0,
      });
  });
var t9e = s(() => {});
var r9e = s(() => {
  t9e();
});
var o9e = s(() => {});
var n9e,
  s9e = s(() => {
    (function (e) {
      (e.HEADER = "header"), (e.QUERY = "query");
    })(n9e || (n9e = {}));
  });
var i9e,
  a9e = s(() => {
    (function (e) {
      (e.HEADER = "header"), (e.QUERY = "query");
    })(i9e || (i9e = {}));
  });
var c9e = s(() => {});
var d9e = s(() => {});
var m9e = s(() => {});
var l9e = s(() => {});
var f9e = s(() => {
  s9e();
  a9e();
  c9e();
  d9e();
  m9e();
  l9e();
});
var u9e = s(() => {});
var p9e = s(() => {});
var h9e = s(() => {});
var g9e = s(() => {});
var y9e = s(() => {});
var x9e = s(() => {});
var E9e = s(() => {});
var S9e = s(() => {
  y9e();
  x9e();
  E9e();
});
var C9e = s(() => {});
var b9e = s(() => {});
var _9e,
  w9e = s(() => {
    (function (e) {
      (e.HTTP = "http"), (e.HTTPS = "https");
    })(_9e || (_9e = {}));
  });
var T9e = s(() => {});
var A9e = s(() => {});
var R9e = s(() => {});
var I9e = s(() => {});
var P9e = s(() => {});
var v9e = s(() => {
  T9e();
  A9e();
  R9e();
  I9e();
  P9e();
});
var O9e = s(() => {});
var bj,
  _j = s(() => {
    (function (e) {
      (e.MD5 = "md5"),
        (e.CRC32 = "crc32"),
        (e.CRC32C = "crc32c"),
        (e.SHA1 = "sha1"),
        (e.SHA256 = "sha256");
    })(bj || (bj = {}));
  });
var k9e = s(() => {
  _j();
});
var D9e = s(() => {});
var N9e = s(() => {
  k9e();
  D9e();
  _j();
});
var B9e = s(() => {});
var wj,
  M9e = s(() => {
    (function (e) {
      (e[(e.HEADER = 0)] = "HEADER"), (e[(e.TRAILER = 1)] = "TRAILER");
    })(wj || (wj = {}));
  });
var L9e = s(() => {});
var F9e = s(() => {});
var U9e = s(() => {});
var $9e = s(() => {});
var H9e = s(() => {});
var z9e = s(() => {
  F9e();
  U9e();
  $9e();
  H9e();
});
var q9e = s(() => {});
var j9e = s(() => {});
var G9e = s(() => {});
var V9e,
  W9e = s(() => {
    (function (e) {
      (e.PROFILE = "profile"),
        (e.SSO_SESSION = "sso-session"),
        (e.SERVICES = "services");
    })(V9e || (V9e = {}));
  });
var K9e = s(() => {});
var Y9e = s(() => {});
var Q9e = s(() => {});
var X9e = s(() => {});
var J9e = s(() => {});
var Z9e = s(() => {});
var eYe = s(() => {});
var tYe = s(() => {});
var rYe = s(() => {});
var oYe = s(() => {});
var nYe = s(() => {});
var sYe,
  iYe = s(() => {
    (function (e) {
      (e.HTTP_0_9 = "http/0.9"),
        (e.HTTP_1_0 = "http/1.0"),
        (e.TDS_8_0 = "tds/8.0");
    })(sYe || (sYe = {}));
  });
var aYe = s(() => {});
var cYe = s(() => {});
var dYe = s(() => {});
var mYe = s(() => {});
var lYe = s(() => {});
var fYe = s(() => {});
var uYe = s(() => {});
var pYe = s(() => {
  o9e();
  f9e();
  u9e();
  p9e();
  h9e();
  g9e();
  S9e();
  C9e();
  b9e();
  w9e();
  v9e();
  O9e();
  N9e();
  B9e();
  M9e();
  L9e();
  z9e();
  q9e();
  j9e();
  G9e();
  W9e();
  K9e();
  Y9e();
  Q9e();
  X9e();
  J9e();
  Z9e();
  eYe();
  tYe();
  rYe();
  oYe();
  nYe();
  iYe();
  aYe();
  cYe();
  dYe();
  mYe();
  lYe();
  fYe();
  uYe();
});
var hYe = s(() => {
  pYe();
});
var gYe = s(() => {});
var yYe = s(() => {});
var xYe = s(() => {});
var EYe = s(() => {});
var SYe = s(() => {});
var CYe = s(() => {});
var bYe = s(() => {
  r9e();
  hYe();
  gYe();
  yYe();
  xYe();
  EYe();
  SYe();
  CYe();
});
var Tj = s(() => {});
var Aj = s(() => {
  Tj();
});
var _Ye = s(() => {
  m3();
  bYe();
  Aj();
});
var wYe = s(() => {});
var TYe = s(() => {
  J5e();
  e9e();
  _Ye();
  Aj();
  wYe();
  Tj();
});
function AYe(e) {
  for (let t = 0; t < 8; t++) e[t] ^= 255;
  for (let t = 7; t > -1 && (e[t]++, e[t] === 0); t--);
}
var mh,
  Rj = s(() => {
    Fo();
    mh = class e {
      constructor(t) {
        if (((this.bytes = t), t.byteLength !== 8))
          throw new Error("Int64 buffers must be exactly 8 bytes");
      }
      static fromNumber(t) {
        if (t > 9223372036854776e3 || t < -9223372036854776e3)
          throw new Error(
            `${t} is too large (or, if negative, too small) to represent as an Int64`
          );
        let r = new Uint8Array(8);
        for (
          let o = 7, n = Math.abs(Math.round(t));
          o > -1 && n > 0;
          o--, n /= 256
        )
          r[o] = n;
        return t < 0 && AYe(r), new e(r);
      }
      valueOf() {
        let t = this.bytes.slice(0),
          r = t[0] & 128;
        return r && AYe(t), parseInt(_t(t), 16) * (r ? -1 : 1);
      }
      toString() {
        return String(this.valueOf());
      }
    };
  });
var dv,
  RYe,
  IYe,
  eIt,
  tIt,
  rIt,
  oIt,
  nIt,
  sIt,
  iIt,
  aIt,
  cIt,
  Ij = s(() => {
    Fo();
    Rj();
    dv = class {
      constructor(t, r) {
        (this.toUtf8 = t), (this.fromUtf8 = r);
      }
      format(t) {
        let r = [];
        for (let i of Object.keys(t)) {
          let a = this.fromUtf8(i);
          r.push(
            Uint8Array.from([a.byteLength]),
            a,
            this.formatHeaderValue(t[i])
          );
        }
        let o = new Uint8Array(r.reduce((i, a) => i + a.byteLength, 0)),
          n = 0;
        for (let i of r) o.set(i, n), (n += i.byteLength);
        return o;
      }
      formatHeaderValue(t) {
        switch (t.type) {
          case "boolean":
            return Uint8Array.from([t.value ? 0 : 1]);
          case "byte":
            return Uint8Array.from([2, t.value]);
          case "short":
            let r = new DataView(new ArrayBuffer(3));
            return (
              r.setUint8(0, 3),
              r.setInt16(1, t.value, !1),
              new Uint8Array(r.buffer)
            );
          case "integer":
            let o = new DataView(new ArrayBuffer(5));
            return (
              o.setUint8(0, 4),
              o.setInt32(1, t.value, !1),
              new Uint8Array(o.buffer)
            );
          case "long":
            let n = new Uint8Array(9);
            return (n[0] = 5), n.set(t.value.bytes, 1), n;
          case "binary":
            let i = new DataView(new ArrayBuffer(3 + t.value.byteLength));
            i.setUint8(0, 6), i.setUint16(1, t.value.byteLength, !1);
            let a = new Uint8Array(i.buffer);
            return a.set(t.value, 3), a;
          case "string":
            let c = this.fromUtf8(t.value),
              d = new DataView(new ArrayBuffer(3 + c.byteLength));
            d.setUint8(0, 7), d.setUint16(1, c.byteLength, !1);
            let m = new Uint8Array(d.buffer);
            return m.set(c, 3), m;
          case "timestamp":
            let f = new Uint8Array(9);
            return (
              (f[0] = 8), f.set(mh.fromNumber(t.value.valueOf()).bytes, 1), f
            );
          case "uuid":
            if (!cIt.test(t.value))
              throw new Error(`Invalid UUID received: ${t.value}`);
            let l = new Uint8Array(17);
            return (l[0] = 9), l.set(Zx(t.value.replace(/\-/g, "")), 1), l;
        }
      }
      parse(t) {
        let r = {},
          o = 0;
        for (; o < t.byteLength; ) {
          let n = t.getUint8(o++),
            i = this.toUtf8(new Uint8Array(t.buffer, t.byteOffset + o, n));
          switch (((o += n), t.getUint8(o++))) {
            case 0:
              r[i] = { type: IYe, value: !0 };
              break;
            case 1:
              r[i] = { type: IYe, value: !1 };
              break;
            case 2:
              r[i] = { type: eIt, value: t.getInt8(o++) };
              break;
            case 3:
              (r[i] = { type: tIt, value: t.getInt16(o, !1) }), (o += 2);
              break;
            case 4:
              (r[i] = { type: rIt, value: t.getInt32(o, !1) }), (o += 4);
              break;
            case 5:
              (r[i] = {
                type: oIt,
                value: new mh(new Uint8Array(t.buffer, t.byteOffset + o, 8)),
              }),
                (o += 8);
              break;
            case 6:
              let a = t.getUint16(o, !1);
              (o += 2),
                (r[i] = {
                  type: nIt,
                  value: new Uint8Array(t.buffer, t.byteOffset + o, a),
                }),
                (o += a);
              break;
            case 7:
              let c = t.getUint16(o, !1);
              (o += 2),
                (r[i] = {
                  type: sIt,
                  value: this.toUtf8(
                    new Uint8Array(t.buffer, t.byteOffset + o, c)
                  ),
                }),
                (o += c);
              break;
            case 8:
              (r[i] = {
                type: iIt,
                value: new Date(
                  new mh(
                    new Uint8Array(t.buffer, t.byteOffset + o, 8)
                  ).valueOf()
                ),
              }),
                (o += 8);
              break;
            case 9:
              let d = new Uint8Array(t.buffer, t.byteOffset + o, 16);
              (o += 16),
                (r[i] = {
                  type: aIt,
                  value: `${_t(d.subarray(0, 4))}-${_t(d.subarray(4, 6))}-${_t(d.subarray(6, 8))}-${_t(d.subarray(8, 10))}-${_t(d.subarray(10))}`,
                });
              break;
            default:
              throw new Error("Unrecognized header type tag");
          }
        }
        return r;
      }
    };
    (function (e) {
      (e[(e.boolTrue = 0)] = "boolTrue"),
        (e[(e.boolFalse = 1)] = "boolFalse"),
        (e[(e.byte = 2)] = "byte"),
        (e[(e.short = 3)] = "short"),
        (e[(e.integer = 4)] = "integer"),
        (e[(e.long = 5)] = "long"),
        (e[(e.byteArray = 6)] = "byteArray"),
        (e[(e.string = 7)] = "string"),
        (e[(e.timestamp = 8)] = "timestamp"),
        (e[(e.uuid = 9)] = "uuid");
    })(RYe || (RYe = {}));
    (IYe = "boolean"),
      (eIt = "byte"),
      (tIt = "short"),
      (rIt = "integer"),
      (oIt = "long"),
      (nIt = "binary"),
      (sIt = "string"),
      (iIt = "timestamp"),
      (aIt = "uuid"),
      (cIt = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/);
  });
function vYe({ byteLength: e, byteOffset: t, buffer: r }) {
  if (e < dIt)
    throw new Error(
      "Provided message too short to accommodate event stream message overhead"
    );
  let o = new DataView(r, t, e),
    n = o.getUint32(0, !1);
  if (e !== n)
    throw new Error(
      "Reported message length does not match received message length"
    );
  let i = o.getUint32(PYe, !1),
    a = o.getUint32(qc, !1),
    c = o.getUint32(e - Km, !1),
    d = new Ud().update(new Uint8Array(r, t, qc));
  if (a !== d.digest())
    throw new Error(
      `The prelude checksum specified in the message (${a}) does not match the calculated CRC32 checksum (${d.digest()})`
    );
  if ((d.update(new Uint8Array(r, t + qc, e - (qc + Km))), c !== d.digest()))
    throw new Error(
      `The message checksum (${d.digest()}) did not match the expected value of ${c}`
    );
  return {
    headers: new DataView(r, t + qc + Km, i),
    body: new Uint8Array(r, t + qc + Km + i, n - i - (qc + Km + Km)),
  };
}
var PYe,
  qc,
  Km,
  dIt,
  OYe = s(() => {
    Iy();
    (PYe = 4), (qc = PYe * 2), (Km = 4), (dIt = qc + Km * 2);
  });
var mv,
  kYe = s(() => {
    Iy();
    Ij();
    OYe();
    mv = class {
      constructor(t, r) {
        (this.headerMarshaller = new dv(t, r)),
          (this.messageBuffer = []),
          (this.isEndOfStream = !1);
      }
      feed(t) {
        this.messageBuffer.push(this.decode(t));
      }
      endOfStream() {
        this.isEndOfStream = !0;
      }
      getMessage() {
        let t = this.messageBuffer.pop(),
          r = this.isEndOfStream;
        return {
          getMessage() {
            return t;
          },
          isEndOfStream() {
            return r;
          },
        };
      }
      getAvailableMessages() {
        let t = this.messageBuffer;
        this.messageBuffer = [];
        let r = this.isEndOfStream;
        return {
          getMessages() {
            return t;
          },
          isEndOfStream() {
            return r;
          },
        };
      }
      encode({ headers: t, body: r }) {
        let o = this.headerMarshaller.format(t),
          n = o.byteLength + r.byteLength + 16,
          i = new Uint8Array(n),
          a = new DataView(i.buffer, i.byteOffset, i.byteLength),
          c = new Ud();
        return (
          a.setUint32(0, n, !1),
          a.setUint32(4, o.byteLength, !1),
          a.setUint32(8, c.update(i.subarray(0, 8)).digest(), !1),
          i.set(o, 12),
          i.set(r, o.byteLength + 12),
          a.setUint32(n - 4, c.update(i.subarray(8, n - 4)).digest(), !1),
          i
        );
      }
      decode(t) {
        let { headers: r, body: o } = vYe(t);
        return { headers: this.headerMarshaller.parse(r), body: o };
      }
      formatHeaders(t) {
        return this.headerMarshaller.format(t);
      }
    };
  });
var DYe = s(() => {});
var lv,
  NYe = s(() => {
    lv = class {
      constructor(t) {
        this.options = t;
      }
      [Symbol.asyncIterator]() {
        return this.asyncIterator();
      }
      async *asyncIterator() {
        for await (let t of this.options.inputStream)
          yield this.options.decoder.decode(t);
      }
    };
  });
var fv,
  BYe = s(() => {
    fv = class {
      constructor(t) {
        this.options = t;
      }
      [Symbol.asyncIterator]() {
        return this.asyncIterator();
      }
      async *asyncIterator() {
        for await (let t of this.options.messageStream)
          yield this.options.encoder.encode(t);
        this.options.includeEndFrame && (yield new Uint8Array(0));
      }
    };
  });
var uv,
  MYe = s(() => {
    uv = class {
      constructor(t) {
        this.options = t;
      }
      [Symbol.asyncIterator]() {
        return this.asyncIterator();
      }
      async *asyncIterator() {
        for await (let t of this.options.messageStream) {
          let r = await this.options.deserializer(t);
          r !== void 0 && (yield r);
        }
      }
    };
  });
var pv,
  LYe = s(() => {
    pv = class {
      constructor(t) {
        this.options = t;
      }
      [Symbol.asyncIterator]() {
        return this.asyncIterator();
      }
      async *asyncIterator() {
        for await (let t of this.options.inputStream)
          yield this.options.serializer(t);
      }
    };
  });
var FYe = s(() => {
  kYe();
  Ij();
  Rj();
  DYe();
  NYe();
  BYe();
  MYe();
  LYe();
});
function UYe(e) {
  let t = 0,
    r = 0,
    o = null,
    n = null,
    i = (c) => {
      if (typeof c != "number")
        throw new Error(
          "Attempted to allocate an event message where size was not a number: " +
            c
        );
      (t = c),
        (r = 4),
        (o = new Uint8Array(c)),
        new DataView(o.buffer).setUint32(0, c, !1);
    },
    a = async function* () {
      let c = e[Symbol.asyncIterator]();
      for (;;) {
        let { value: d, done: m } = await c.next();
        if (m) {
          if (t)
            if (t === r) yield o;
            else throw new Error("Truncated event message received.");
          else return;
          return;
        }
        let f = d.length,
          l = 0;
        for (; l < f; ) {
          if (!o) {
            let h = f - l;
            n || (n = new Uint8Array(4));
            let y = Math.min(4 - r, h);
            if ((n.set(d.slice(l, l + y), r), (r += y), (l += y), r < 4)) break;
            i(new DataView(n.buffer).getUint32(0, !1)), (n = null);
          }
          let u = Math.min(t - r, f - l);
          o.set(d.slice(l, l + u), r),
            (r += u),
            (l += u),
            t && t === r && (yield o, (o = null), (t = 0), (r = 0));
        }
      }
    };
  return { [Symbol.asyncIterator]: a };
}
var $Ye = s(() => {});
function HYe(e, t) {
  return async function (r) {
    let { value: o } = r.headers[":message-type"];
    if (o === "error") {
      let n = new Error(r.headers[":error-message"].value || "UnknownError");
      throw ((n.name = r.headers[":error-code"].value), n);
    } else if (o === "exception") {
      let n = r.headers[":exception-type"].value,
        i = { [n]: r },
        a = await e(i);
      if (a.$unknown) {
        let c = new Error(t(r.body));
        throw ((c.name = n), c);
      }
      throw a[n];
    } else if (o === "event") {
      let n = { [r.headers[":event-type"].value]: r },
        i = await e(n);
      return i.$unknown ? void 0 : i;
    } else
      throw Error(
        `Unrecognizable event type: ${r.headers[":event-type"].value}`
      );
  };
}
var zYe = s(() => {});
var Cx,
  Pj = s(() => {
    FYe();
    $Ye();
    zYe();
    Cx = class {
      constructor({ utf8Encoder: t, utf8Decoder: r }) {
        (this.eventStreamCodec = new mv(t, r)), (this.utfEncoder = t);
      }
      deserialize(t, r) {
        let o = UYe(t);
        return new uv({
          messageStream: new lv({
            inputStream: o,
            decoder: this.eventStreamCodec,
          }),
          deserializer: HYe(r, this.utfEncoder),
        });
      }
      serialize(t, r) {
        return new fv({
          messageStream: new pv({ inputStream: t, serializer: r }),
          encoder: this.eventStreamCodec,
          includeEndFrame: !0,
        });
      }
    };
  });
var qYe = s(() => {
  Pj();
});
var jYe = s(() => {
  Pj();
  qYe();
});
async function* GYe(e) {
  let t = !1,
    r = !1,
    o = new Array();
  for (
    e.on("error", (n) => {
      if ((t || (t = !0), n)) throw n;
    }),
      e.on("data", (n) => {
        o.push(n);
      }),
      e.on("end", () => {
        t = !0;
      });
    !r;

  ) {
    let n = await new Promise((i) => setTimeout(() => i(o.shift()), 0));
    n && (yield n), (r = t && o.length === 0);
  }
}
var VYe = s(() => {});
import { Readable as mIt } from "stream";
var hv,
  vj = s(() => {
    jYe();
    VYe();
    hv = class {
      constructor({ utf8Encoder: t, utf8Decoder: r }) {
        this.universalMarshaller = new Cx({ utf8Decoder: r, utf8Encoder: t });
      }
      deserialize(t, r) {
        let o = typeof t[Symbol.asyncIterator] == "function" ? t : GYe(t);
        return this.universalMarshaller.deserialize(o, r);
      }
      serialize(t, r) {
        return mIt.from(this.universalMarshaller.serialize(t, r));
      }
    };
  });
var WYe,
  KYe = s(() => {
    vj();
    WYe = (e) => new hv(e);
  });
var YYe = s(() => {
  vj();
  KYe();
});
import { Buffer as QYe } from "buffer";
var XYe,
  Oj = s(() => {
    cr();
    XYe = (e, t) => {
      if (typeof e != "string")
        throw new TypeError(
          `The "input" argument must be of type string. Received type ${typeof e} (${e})`
        );
      return t ? QYe.from(e, t) : QYe.from(e);
    };
  });
var JYe,
  kj = s(() => {
    Oj();
    JYe = (e) => {
      let t = XYe(e, "utf8");
      return new Uint8Array(
        t.buffer,
        t.byteOffset,
        t.byteLength / Uint8Array.BYTES_PER_ELEMENT
      );
    };
  });
var ZYe,
  eQe = s(() => {
    kj();
    ZYe = (e) =>
      typeof e == "string"
        ? JYe(e)
        : ArrayBuffer.isView(e)
          ? new Uint8Array(
              e.buffer,
              e.byteOffset,
              e.byteLength / Uint8Array.BYTES_PER_ELEMENT
            )
          : new Uint8Array(e);
  });
var tQe = s(() => {
  Oj();
});
var rQe = s(() => {
  kj();
  eQe();
  tQe();
});
import { Writable as lIt } from "stream";
var bx,
  Dj = s(() => {
    rQe();
    bx = class extends lIt {
      constructor(t, r) {
        super(r), (this.hash = t);
      }
      _write(t, r, o) {
        try {
          this.hash.update(ZYe(t));
        } catch (n) {
          return o(n);
        }
        o();
      }
    };
  });
var oQe = s(() => {
  Dj();
});
var nQe,
  sQe = s(() => {
    Dj();
    nQe = (e, t) => {
      if (t.readableFlowing !== null)
        throw new Error("Unable to calculate hash for flowing readable stream");
      let r = new e(),
        o = new bx(r);
      return (
        t.pipe(o),
        new Promise((n, i) => {
          t.on("error", (a) => {
            o.end(), i(a);
          }),
            o.on("error", i),
            o.on("finish", () => {
              r.digest().then(n).catch(i);
            });
        })
      );
    };
  });
var iQe = s(() => {
  oQe();
  sQe();
});
var aQe = s(() => {
  Hc();
  Gm();
  Nj();
});
var Nj = s(() => {
  aQe();
});
var Bj = s(() => {
  Hc();
});
var jc,
  Gc = s(() => {
    jc = (e) =>
      typeof ReadableStream == "function" &&
      (e?.constructor?.name === ReadableStream.name ||
        e instanceof ReadableStream);
  });
var cQe = s(() => {});
var dQe = s(() => {
  Hc();
  Gc();
  cQe();
});
var mQe = s(() => {
  Gc();
  Bj();
  dQe();
});
var Mj = s(() => {});
var lQe = s(() => {
  Mj();
});
var fQe = s(() => {
  Mj();
  lQe();
  Gc();
});
import { Readable as uIt } from "stream";
var uQe,
  pQe = s(() => {
    uQe = (e, t) => {
      let {
          base64Encoder: r,
          bodyLengthChecker: o,
          checksumAlgorithmFn: n,
          checksumLocationName: i,
          streamHasher: a,
        } = t,
        c = r !== void 0 && n !== void 0 && i !== void 0 && a !== void 0,
        d = c ? a(n, e) : void 0,
        m = new uIt({ read: () => {} });
      return (
        e.on("data", (f) => {
          let l = o(f) || 0;
          m.push(`${l.toString(16)}\r
`),
            m.push(f),
            m.push(`\r
`);
        }),
        e.on("end", async () => {
          if (
            (m.push(`0\r
`),
            c)
          ) {
            let f = r(await d);
            m.push(`${i}:${f}\r
`),
              m.push(`\r
`);
          }
          m.push(null);
        }),
        m
      );
    };
  });
var hQe = s(() => {});
var gQe = s(() => {
  hQe();
  Gc();
});
import { Buffer as pIt } from "buffer";
var yQe,
  xQe = s(() => {
    cr();
    yQe = (e, t = 0, r = e.byteLength - t) => {
      if (!Ke(e))
        throw new TypeError(
          `The "input" argument must be ArrayBuffer. Received type ${typeof e} (${e})`
        );
      return pIt.from(e, t, r);
    };
  });
var EQe = s(() => {});
var SQe = s(() => {});
var CQe = s(() => {
  an();
  WP();
  EQe();
  SQe();
});
async function hIt(e) {
  let t = await yIt(e),
    r = Vm(t);
  return new Uint8Array(r);
}
async function gIt(e) {
  let t = [],
    r = e.getReader(),
    o = !1,
    n = 0;
  for (; !o; ) {
    let { done: c, value: d } = await r.read();
    d && (t.push(d), (n += d.length)), (o = c);
  }
  let i = new Uint8Array(n),
    a = 0;
  for (let c of t) i.set(c, a), (a += c.length);
  return i;
}
function yIt(e) {
  return new Promise((t, r) => {
    let o = new FileReader();
    (o.onloadend = () => {
      if (o.readyState !== 2) return r(new Error("Reader aborted too early"));
      let n = o.result ?? "",
        i = n.indexOf(","),
        a = i > -1 ? i + 1 : n.length;
      t(n.substring(a));
    }),
      (o.onabort = () => r(new Error("Read aborted"))),
      (o.onerror = () => r(o.error)),
      o.readAsDataURL(e);
  });
}
var bQe,
  _Qe = s(() => {
    Hc();
    bQe = async (e) =>
      (typeof Blob == "function" && e instanceof Blob) ||
      e.constructor?.name === "Blob"
        ? Blob.prototype.arrayBuffer !== void 0
          ? new Uint8Array(await e.arrayBuffer())
          : hIt(e)
        : gIt(e);
  });
var wQe = s(() => {
  CQe();
  _Qe();
});
var TQe,
  RQe,
  AQe,
  IQe = s(() => {
    wQe();
    Hc();
    Fo();
    Gm();
    Gc();
    (TQe = "The stream has already been transformed."),
      (RQe = (e) => {
        if (!AQe(e) && !jc(e)) {
          let n = e?.__proto__?.constructor?.name || e;
          throw new Error(
            `Unexpected stream implementation, expect Blob or ReadableStream, got ${n}`
          );
        }
        let t = !1,
          r = async () => {
            if (t) throw new Error(TQe);
            return (t = !0), await bQe(e);
          },
          o = (n) => {
            if (typeof n.stream != "function")
              throw new Error(`Cannot transform payload Blob to web stream. Please make sure the Blob.stream() is polyfilled.
If you are using React Native, this API is not yet supported, see: https://react-native.canny.io/feature-requests/p/fetch-streaming-body`);
            return n.stream();
          };
        return Object.assign(e, {
          transformToByteArray: r,
          transformToString: async (n) => {
            let i = await r();
            if (n === "base64") return xa(i);
            if (n === "hex") return _t(i);
            if (n === void 0 || n === "utf8" || n === "utf-8") return jm(i);
            if (typeof TextDecoder == "function")
              return new TextDecoder(n).decode(i);
            throw new Error(
              "TextDecoder is not available, please make sure polyfill is provided."
            );
          },
          transformToWebStream: () => {
            if (t) throw new Error(TQe);
            if (((t = !0), AQe(e))) return o(e);
            if (jc(e)) return e;
            throw new Error(`Cannot transform payload to web stream, got ${e}`);
          },
        });
      }),
      (AQe = (e) => typeof Blob == "function" && e instanceof Blob);
  });
import { Readable as Lj } from "stream";
var PQe,
  vQe,
  OQe = s(() => {
    YP();
    xQe();
    IQe();
    (PQe = "The stream has already been transformed."),
      (vQe = (e) => {
        if (!(e instanceof Lj))
          try {
            return RQe(e);
          } catch {
            let n = e?.__proto__?.constructor?.name || e;
            throw new Error(
              `Unexpected stream implementation, expect Stream.Readable instance, got ${n}`
            );
          }
        let t = !1,
          r = async () => {
            if (t) throw new Error(PQe);
            return (t = !0), await oh(e);
          };
        return Object.assign(e, {
          transformToByteArray: r,
          transformToString: async (o) => {
            let n = await r();
            return o === void 0 || Buffer.isEncoding(o)
              ? yQe(n.buffer, n.byteOffset, n.byteLength).toString(o)
              : new TextDecoder(o).decode(n);
          },
          transformToWebStream: () => {
            if (t) throw new Error(PQe);
            if (e.readableFlowing !== null)
              throw new Error(
                "The stream has been consumed by other callbacks."
              );
            if (typeof Lj.toWeb != "function")
              throw new Error(
                "Readable.toWeb() is not supported. Please ensure a polyfill is available."
              );
            return (t = !0), Lj.toWeb(e);
          },
        });
      });
  });
var kQe = s(() => {});
var DQe = s(() => {
  kQe();
  Gc();
});
var NQe = s(() => {
  Nj();
  Bj();
  mQe();
  fQe();
  pQe();
  gQe();
  OQe();
  DQe();
  Gc();
});
var BQe,
  MQe = s(() => {
    rt();
    Y3();
    $();
    Ly();
    Hc();
    NQe();
    Gm();
    Rz();
    Az();
    BQe = (e) => ({
      apiVersion: "2006-03-01",
      base64Decoder: e?.base64Decoder ?? Vm,
      base64Encoder: e?.base64Encoder ?? xa,
      disableHostPrefix: e?.disableHostPrefix ?? !1,
      endpointProvider: e?.endpointProvider ?? tI,
      extensions: e?.extensions ?? [],
      getAwsChunkedEncodingStream: e?.getAwsChunkedEncodingStream ?? uQe,
      httpAuthSchemeProvider: e?.httpAuthSchemeProvider ?? sqe,
      httpAuthSchemes: e?.httpAuthSchemes ?? [
        {
          schemeId: "aws.auth#sigv4",
          identityProvider: (t) => t.getIdentityProvider("aws.auth#sigv4"),
          signer: new wr(),
        },
        {
          schemeId: "aws.auth#sigv4a",
          identityProvider: (t) => t.getIdentityProvider("aws.auth#sigv4a"),
          signer: new zh(),
        },
      ],
      logger: e?.logger ?? new bc(),
      sdkStreamMixin: e?.sdkStreamMixin ?? vQe,
      serviceId: e?.serviceId ?? "S3",
      signerConstructor: e?.signerConstructor ?? Uu,
      signingEscapePath: e?.signingEscapePath ?? !1,
      urlParser: e?.urlParser ?? wi,
      useArnRegion: e?.useArnRegion ?? void 0,
      utf8Decoder: e?.utf8Decoder ?? ya,
      utf8Encoder: e?.utf8Encoder ?? jm,
    });
  });
var LQe,
  FQe = s(() => {
    DWe();
    rt();
    X5e();
    TYe();
    Kt();
    he();
    Mq();
    Ru();
    YYe();
    zq();
    iQe();
    $y();
    zd();
    YP();
    Yq();
    Ti();
    MQe();
    $();
    rj();
    $();
    LQe = (e) => {
      qR(process.version);
      let t = XP(e),
        r = () => t().then(zR),
        o = BQe(e);
      $o(process.version);
      let n = { profile: e?.profile, logger: o.logger };
      return {
        ...o,
        ...e,
        runtime: "node",
        defaultsMode: t,
        authSchemePreference: e?.authSchemePreference ?? Bt(Ho, n),
        bodyLengthChecker: e?.bodyLengthChecker ?? QP,
        credentialDefaultProvider: e?.credentialDefaultProvider ?? Y5e,
        defaultUserAgentProvider:
          e?.defaultUserAgentProvider ??
          jP({ serviceId: o.serviceId, clientVersion: NWe.version }),
        disableS3ExpressSessionAuth:
          e?.disableS3ExpressSessionAuth ?? Bt(YH, n),
        eventStreamSerdeProvider: e?.eventStreamSerdeProvider ?? WYe,
        maxAttempts: e?.maxAttempts ?? Bt(LR, e),
        md5: e?.md5 ?? $c.bind(null, "md5"),
        region: e?.region ?? Bt(Au, { ...yR, ...n }),
        requestChecksumCalculation: e?.requestChecksumCalculation ?? Bt(rNe, n),
        requestHandler: rh.create(e?.requestHandler ?? r),
        responseChecksumValidation: e?.responseChecksumValidation ?? Bt(nNe, n),
        retryMode:
          e?.retryMode ??
          Bt({ ...UR, default: async () => (await r()).retryMode || vu }, e),
        sha1: e?.sha1 ?? $c.bind(null, "sha1"),
        sha256: e?.sha256 ?? $c.bind(null, "sha256"),
        sigv4aSigningRegionSet: e?.sigv4aSigningRegionSet ?? Bt(AZ, n),
        streamCollector: e?.streamCollector ?? oh,
        streamHasher: e?.streamHasher ?? nQe,
        useArnRegion: e?.useArnRegion ?? Bt(Z5e, n),
        useDualstackEndpoint: e?.useDualstackEndpoint ?? Bt(hR, n),
        useFipsEndpoint: e?.useFipsEndpoint ?? Bt(gR, n),
        userAgentAppId: e?.userAgentAppId ?? Bt(GP, n),
      };
    };
  });
var UQe,
  $Qe,
  HQe = s(() => {
    (UQe = (e) => {
      let t = e.httpAuthSchemes,
        r = e.httpAuthSchemeProvider,
        o = e.credentials;
      return {
        setHttpAuthScheme(n) {
          let i = t.findIndex((a) => a.schemeId === n.schemeId);
          i === -1 ? t.push(n) : t.splice(i, 1, n);
        },
        httpAuthSchemes() {
          return t;
        },
        setHttpAuthSchemeProvider(n) {
          r = n;
        },
        httpAuthSchemeProvider() {
          return r;
        },
        setCredentials(n) {
          o = n;
        },
        credentials() {
          return o;
        },
      };
    }),
      ($Qe = (e) => ({
        httpAuthSchemes: e.httpAuthSchemes(),
        httpAuthSchemeProvider: e.httpAuthSchemeProvider(),
        credentials: e.credentials(),
      }));
  });
var zQe,
  qQe = s(() => {
    Xi();
    an();
    $();
    HQe();
    zQe = (e, t) => {
      let r = Object.assign(Go(e), jR(e), YA(e), UQe(e));
      return (
        t.forEach((o) => o.configure(r)),
        Object.assign(e, Vo(r), GR(r), QA(r), $Qe(r))
      );
    };
  });
var Pn,
  Ym = s(() => {
    eNe();
    Kt();
    LH();
    FH();
    $H();
    he();
    pR();
    Ru();
    Ue();
    DHe();
    S3();
    K();
    $y();
    $();
    Rz();
    OP();
    X();
    FQe();
    qQe();
    Pn = class extends Mu {
      config;
      constructor(...[t]) {
        let r = LQe(t || {});
        super(r), (this.initConfig = r);
        let o = aqe(r),
          n = cR(o),
          i = mLe(n),
          a = FR(i),
          c = ER(a),
          d = c,
          m = vR(d),
          f = OHe(m),
          l = iqe(f),
          u = q$e(l, { session: [() => this, Jp] }),
          h = zQe(u, t?.extensions || []);
        (this.config = h),
          this.middlewareStack.use(uR(this.config)),
          this.middlewareStack.use(VR(this.config)),
          this.middlewareStack.use(SR(this.config)),
          this.middlewareStack.use(XA(this.config)),
          this.middlewareStack.use(JA(this.config)),
          this.middlewareStack.use(ZA(this.config)),
          this.middlewareStack.use(
            Mo(this.config, {
              httpAuthSchemeParametersProvider: rqe,
              identityProviderConfigProvider: async (y) =>
                new fo({
                  "aws.auth#sigv4": y.credentials,
                  "aws.auth#sigv4a": y.credentials,
                }),
            })
          ),
          this.middlewareStack.use(Lo(this.config)),
          this.middlewareStack.use(U1e(this.config)),
          this.middlewareStack.use(ZDe(this.config)),
          this.middlewareStack.use(A$e(this.config)),
          this.middlewareStack.use(QH(this.config)),
          this.middlewareStack.use(XH(this.config));
      }
      destroy() {
        super.destroy();
      }
    };
  });
var gv,
  Fj = s(() => {
    he();
    K();
    Y();
    $();
    X();
    J();
    gv = class extends (
      _.classBuilder()
        .ep({
          ...R,
          Bucket: { type: "contextParams", name: "Bucket" },
          Key: { type: "contextParams", name: "Key" },
        })
        .m(function (t, r, o, n) {
          return [
            T(o, this.serialize, this.deserialize),
            A(o, t.getEndpointParameterInstructions()),
            U(o),
          ];
        })
        .s("AmazonS3", "AbortMultipartUpload", {})
        .n("S3Client", "AbortMultipartUploadCommand")
        .f(void 0, void 0)
        .ser(Eje)
        .de(m4e)
        .build()
    ) {};
  });
function xIt(e) {
  return (t) => async (r) => {
    let o = { ...r.input },
      n = [
        { target: "SSECustomerKey", hash: "SSECustomerKeyMD5" },
        {
          target: "CopySourceSSECustomerKey",
          hash: "CopySourceSSECustomerKeyMD5",
        },
      ];
    for (let i of n) {
      let a = o[i.target];
      if (a) {
        let c;
        typeof a == "string"
          ? SIt(a, e)
            ? (c = e.base64Decoder(a))
            : ((c = e.utf8Decoder(a)), (o[i.target] = e.base64Encoder(c)))
          : ((c = ArrayBuffer.isView(a)
              ? new Uint8Array(a.buffer, a.byteOffset, a.byteLength)
              : new Uint8Array(a)),
            (o[i.target] = e.base64Encoder(c)));
        let d = new e.md5();
        d.update(c), (o[i.hash] = e.base64Encoder(await d.digest()));
      }
    }
    return t({ ...r, input: o });
  };
}
function SIt(e, t) {
  if (!/^(?:[A-Za-z0-9+/]{4})*([A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(e))
    return !1;
  try {
    return t.base64Decoder(e).length === 32;
  } catch {
    return !1;
  }
}
var EIt,
  Mr,
  vs = s(() => {
    (EIt = {
      name: "ssecMiddleware",
      step: "initialize",
      tags: ["SSE"],
      override: !0,
    }),
      (Mr = (e) => ({
        applyToStack: (t) => {
          t.add(xIt(e), EIt);
        },
      }));
  });
var yv,
  Uj = s(() => {
    he();
    vs();
    K();
    Y();
    $();
    X();
    Qo();
    J();
    yv = class extends (
      _.classBuilder()
        .ep({
          ...R,
          Bucket: { type: "contextParams", name: "Bucket" },
          Key: { type: "contextParams", name: "Key" },
        })
        .m(function (t, r, o, n) {
          return [
            T(o, this.serialize, this.deserialize),
            A(o, t.getEndpointParameterInstructions()),
            U(o),
            Mr(o),
          ];
        })
        .s("AmazonS3", "CompleteMultipartUpload", {})
        .n("S3Client", "CompleteMultipartUploadCommand")
        .f(dqe, cqe)
        .ser(Sje)
        .de(l4e)
        .build()
    ) {};
  });
var xv,
  $j = s(() => {
    he();
    vs();
    K();
    Y();
    $();
    X();
    Qo();
    J();
    xv = class extends (
      _.classBuilder()
        .ep({
          ...R,
          DisableS3ExpressSessionAuth: {
            type: "staticContextParams",
            value: !0,
          },
          Bucket: { type: "contextParams", name: "Bucket" },
          Key: { type: "contextParams", name: "Key" },
          CopySource: { type: "contextParams", name: "CopySource" },
        })
        .m(function (t, r, o, n) {
          return [
            T(o, this.serialize, this.deserialize),
            A(o, t.getEndpointParameterInstructions()),
            U(o),
            Mr(o),
          ];
        })
        .s("AmazonS3", "CopyObject", {})
        .n("S3Client", "CopyObjectCommand")
        .f(lqe, mqe)
        .ser(Cje)
        .de(f4e)
        .build()
    ) {};
  });
function CIt(e) {
  return (t) => async (r) => {
    let { CreateBucketConfiguration: o } = r.input,
      n = await e.region();
    return (
      !o?.LocationConstraint &&
        !o?.Location &&
        (r = {
          ...r,
          input: {
            ...r.input,
            CreateBucketConfiguration:
              n === "us-east-1" ? void 0 : { LocationConstraint: n },
          },
        }),
      t(r)
    );
  };
}
var bIt,
  jQe,
  GQe = s(() => {
    (bIt = {
      step: "initialize",
      tags: ["LOCATION_CONSTRAINT", "CREATE_BUCKET_CONFIGURATION"],
      name: "locationConstraintMiddleware",
      override: !0,
    }),
      (jQe = (e) => ({
        applyToStack: (t) => {
          t.add(CIt(e), bIt);
        },
      }));
  });
var Ev,
  Hj = s(() => {
    GQe();
    he();
    K();
    Y();
    $();
    X();
    J();
    Ev = class extends (
      _.classBuilder()
        .ep({
          ...R,
          UseS3ExpressControlEndpoint: {
            type: "staticContextParams",
            value: !0,
          },
          DisableAccessPoints: { type: "staticContextParams", value: !0 },
          Bucket: { type: "contextParams", name: "Bucket" },
        })
        .m(function (t, r, o, n) {
          return [
            T(o, this.serialize, this.deserialize),
            A(o, t.getEndpointParameterInstructions()),
            U(o),
            jQe(o),
          ];
        })
        .s("AmazonS3", "CreateBucket", {})
        .n("S3Client", "CreateBucketCommand")
        .f(void 0, void 0)
        .ser(bje)
        .de(u4e)
        .build()
    ) {};
  });
var Sv,
  zj = s(() => {
    Kt();
    K();
    Y();
    $();
    X();
    J();
    Sv = class extends (
      _.classBuilder()
        .ep({
          ...R,
          UseS3ExpressControlEndpoint: {
            type: "staticContextParams",
            value: !0,
          },
          Bucket: { type: "contextParams", name: "Bucket" },
        })
        .m(function (t, r, o, n) {
          return [
            T(o, this.serialize, this.deserialize),
            A(o, t.getEndpointParameterInstructions()),
            Le(o, {
              requestAlgorithmMember: {
                httpHeader: "x-amz-sdk-checksum-algorithm",
                name: "ChecksumAlgorithm",
              },
              requestChecksumRequired: !0,
            }),
          ];
        })
        .s("AmazonS3", "CreateBucketMetadataTableConfiguration", {})
        .n("S3Client", "CreateBucketMetadataTableConfigurationCommand")
        .f(void 0, void 0)
        .ser(_je)
        .de(p4e)
        .build()
    ) {};
  });
var Cv,
  qj = s(() => {
    he();
    vs();
    K();
    Y();
    $();
    X();
    Qo();
    J();
    Cv = class extends (
      _.classBuilder()
        .ep({
          ...R,
          Bucket: { type: "contextParams", name: "Bucket" },
          Key: { type: "contextParams", name: "Key" },
        })
        .m(function (t, r, o, n) {
          return [
            T(o, this.serialize, this.deserialize),
            A(o, t.getEndpointParameterInstructions()),
            U(o),
            Mr(o),
          ];
        })
        .s("AmazonS3", "CreateMultipartUpload", {})
        .n("S3Client", "CreateMultipartUploadCommand")
        .f(uqe, fqe)
        .ser(wje)
        .de(h4e)
        .build()
    ) {};
  });
var bv,
  jj = s(() => {
    K();
    Y();
    $();
    X();
    J();
    bv = class extends (
      _.classBuilder()
        .ep({
          ...R,
          UseS3ExpressControlEndpoint: {
            type: "staticContextParams",
            value: !0,
          },
          Bucket: { type: "contextParams", name: "Bucket" },
        })
        .m(function (t, r, o, n) {
          return [
            T(o, this.serialize, this.deserialize),
            A(o, t.getEndpointParameterInstructions()),
          ];
        })
        .s("AmazonS3", "DeleteBucketAnalyticsConfiguration", {})
        .n("S3Client", "DeleteBucketAnalyticsConfigurationCommand")
        .f(void 0, void 0)
        .ser(Rje)
        .de(x4e)
        .build()
    ) {};
  });
var _v,
  Gj = s(() => {
    K();
    Y();
    $();
    X();
    J();
    _v = class extends (
      _.classBuilder()
        .ep({
          ...R,
          UseS3ExpressControlEndpoint: {
            type: "staticContextParams",
            value: !0,
          },
          Bucket: { type: "contextParams", name: "Bucket" },
        })
        .m(function (t, r, o, n) {
          return [
            T(o, this.serialize, this.deserialize),
            A(o, t.getEndpointParameterInstructions()),
          ];
        })
        .s("AmazonS3", "DeleteBucket", {})
        .n("S3Client", "DeleteBucketCommand")
        .f(void 0, void 0)
        .ser(Aje)
        .de(y4e)
        .build()
    ) {};
  });
var wv,
  Vj = s(() => {
    K();
    Y();
    $();
    X();
    J();
    wv = class extends (
      _.classBuilder()
        .ep({
          ...R,
          UseS3ExpressControlEndpoint: {
            type: "staticContextParams",
            value: !0,
          },
          Bucket: { type: "contextParams", name: "Bucket" },
        })
        .m(function (t, r, o, n) {
          return [
            T(o, this.serialize, this.deserialize),
            A(o, t.getEndpointParameterInstructions()),
          ];
        })
        .s("AmazonS3", "DeleteBucketCors", {})
        .n("S3Client", "DeleteBucketCorsCommand")
        .f(void 0, void 0)
        .ser(Ije)
        .de(E4e)
        .build()
    ) {};
  });
var Tv,
  Wj = s(() => {
    K();
    Y();
    $();
    X();
    J();
    Tv = class extends (
      _.classBuilder()
        .ep({
          ...R,
          UseS3ExpressControlEndpoint: {
            type: "staticContextParams",
            value: !0,
          },
          Bucket: { type: "contextParams", name: "Bucket" },
        })
        .m(function (t, r, o, n) {
          return [
            T(o, this.serialize, this.deserialize),
            A(o, t.getEndpointParameterInstructions()),
          ];
        })
        .s("AmazonS3", "DeleteBucketEncryption", {})
        .n("S3Client", "DeleteBucketEncryptionCommand")
        .f(void 0, void 0)
        .ser(Pje)
        .de(S4e)
        .build()
    ) {};
  });
var Av,
  Kj = s(() => {
    K();
    Y();
    $();
    X();
    J();
    Av = class extends (
      _.classBuilder()
        .ep({
          ...R,
          UseS3ExpressControlEndpoint: {
            type: "staticContextParams",
            value: !0,
          },
          Bucket: { type: "contextParams", name: "Bucket" },
        })
        .m(function (t, r, o, n) {
          return [
            T(o, this.serialize, this.deserialize),
            A(o, t.getEndpointParameterInstructions()),
          ];
        })
        .s("AmazonS3", "DeleteBucketIntelligentTieringConfiguration", {})
        .n("S3Client", "DeleteBucketIntelligentTieringConfigurationCommand")
        .f(void 0, void 0)
        .ser(vje)
        .de(C4e)
        .build()
    ) {};
  });
var Rv,
  Yj = s(() => {
    K();
    Y();
    $();
    X();
    J();
    Rv = class extends (
      _.classBuilder()
        .ep({
          ...R,
          UseS3ExpressControlEndpoint: {
            type: "staticContextParams",
            value: !0,
          },
          Bucket: { type: "contextParams", name: "Bucket" },
        })
        .m(function (t, r, o, n) {
          return [
            T(o, this.serialize, this.deserialize),
            A(o, t.getEndpointParameterInstructions()),
          ];
        })
        .s("AmazonS3", "DeleteBucketInventoryConfiguration", {})
        .n("S3Client", "DeleteBucketInventoryConfigurationCommand")
        .f(void 0, void 0)
        .ser(Oje)
        .de(b4e)
        .build()
    ) {};
  });
var Iv,
  Qj = s(() => {
    K();
    Y();
    $();
    X();
    J();
    Iv = class extends (
      _.classBuilder()
        .ep({
          ...R,
          UseS3ExpressControlEndpoint: {
            type: "staticContextParams",
            value: !0,
          },
          Bucket: { type: "contextParams", name: "Bucket" },
        })
        .m(function (t, r, o, n) {
          return [
            T(o, this.serialize, this.deserialize),
            A(o, t.getEndpointParameterInstructions()),
          ];
        })
        .s("AmazonS3", "DeleteBucketLifecycle", {})
        .n("S3Client", "DeleteBucketLifecycleCommand")
        .f(void 0, void 0)
        .ser(kje)
        .de(_4e)
        .build()
    ) {};
  });
var Pv,
  Xj = s(() => {
    K();
    Y();
    $();
    X();
    J();
    Pv = class extends (
      _.classBuilder()
        .ep({
          ...R,
          UseS3ExpressControlEndpoint: {
            type: "staticContextParams",
            value: !0,
          },
          Bucket: { type: "contextParams", name: "Bucket" },
        })
        .m(function (t, r, o, n) {
          return [
            T(o, this.serialize, this.deserialize),
            A(o, t.getEndpointParameterInstructions()),
          ];
        })
        .s("AmazonS3", "DeleteBucketMetadataTableConfiguration", {})
        .n("S3Client", "DeleteBucketMetadataTableConfigurationCommand")
        .f(void 0, void 0)
        .ser(Dje)
        .de(w4e)
        .build()
    ) {};
  });
var vv,
  Jj = s(() => {
    K();
    Y();
    $();
    X();
    J();
    vv = class extends (
      _.classBuilder()
        .ep({
          ...R,
          UseS3ExpressControlEndpoint: {
            type: "staticContextParams",
            value: !0,
          },
          Bucket: { type: "contextParams", name: "Bucket" },
        })
        .m(function (t, r, o, n) {
          return [
            T(o, this.serialize, this.deserialize),
            A(o, t.getEndpointParameterInstructions()),
          ];
        })
        .s("AmazonS3", "DeleteBucketMetricsConfiguration", {})
        .n("S3Client", "DeleteBucketMetricsConfigurationCommand")
        .f(void 0, void 0)
        .ser(Nje)
        .de(T4e)
        .build()
    ) {};
  });
var Ov,
  Zj = s(() => {
    K();
    Y();
    $();
    X();
    J();
    Ov = class extends (
      _.classBuilder()
        .ep({
          ...R,
          UseS3ExpressControlEndpoint: {
            type: "staticContextParams",
            value: !0,
          },
          Bucket: { type: "contextParams", name: "Bucket" },
        })
        .m(function (t, r, o, n) {
          return [
            T(o, this.serialize, this.deserialize),
            A(o, t.getEndpointParameterInstructions()),
          ];
        })
        .s("AmazonS3", "DeleteBucketOwnershipControls", {})
        .n("S3Client", "DeleteBucketOwnershipControlsCommand")
        .f(void 0, void 0)
        .ser(Bje)
        .de(A4e)
        .build()
    ) {};
  });
var kv,
  eG = s(() => {
    K();
    Y();
    $();
    X();
    J();
    kv = class extends (
      _.classBuilder()
        .ep({
          ...R,
          UseS3ExpressControlEndpoint: {
            type: "staticContextParams",
            value: !0,
          },
          Bucket: { type: "contextParams", name: "Bucket" },
        })
        .m(function (t, r, o, n) {
          return [
            T(o, this.serialize, this.deserialize),
            A(o, t.getEndpointParameterInstructions()),
          ];
        })
        .s("AmazonS3", "DeleteBucketPolicy", {})
        .n("S3Client", "DeleteBucketPolicyCommand")
        .f(void 0, void 0)
        .ser(Mje)
        .de(R4e)
        .build()
    ) {};
  });
var Dv,
  tG = s(() => {
    K();
    Y();
    $();
    X();
    J();
    Dv = class extends (
      _.classBuilder()
        .ep({
          ...R,
          UseS3ExpressControlEndpoint: {
            type: "staticContextParams",
            value: !0,
          },
          Bucket: { type: "contextParams", name: "Bucket" },
        })
        .m(function (t, r, o, n) {
          return [
            T(o, this.serialize, this.deserialize),
            A(o, t.getEndpointParameterInstructions()),
          ];
        })
        .s("AmazonS3", "DeleteBucketReplication", {})
        .n("S3Client", "DeleteBucketReplicationCommand")
        .f(void 0, void 0)
        .ser(Lje)
        .de(I4e)
        .build()
    ) {};
  });
var Nv,
  rG = s(() => {
    K();
    Y();
    $();
    X();
    J();
    Nv = class extends (
      _.classBuilder()
        .ep({
          ...R,
          UseS3ExpressControlEndpoint: {
            type: "staticContextParams",
            value: !0,
          },
          Bucket: { type: "contextParams", name: "Bucket" },
        })
        .m(function (t, r, o, n) {
          return [
            T(o, this.serialize, this.deserialize),
            A(o, t.getEndpointParameterInstructions()),
          ];
        })
        .s("AmazonS3", "DeleteBucketTagging", {})
        .n("S3Client", "DeleteBucketTaggingCommand")
        .f(void 0, void 0)
        .ser(Fje)
        .de(P4e)
        .build()
    ) {};
  });
var Bv,
  oG = s(() => {
    K();
    Y();
    $();
    X();
    J();
    Bv = class extends (
      _.classBuilder()
        .ep({
          ...R,
          UseS3ExpressControlEndpoint: {
            type: "staticContextParams",
            value: !0,
          },
          Bucket: { type: "contextParams", name: "Bucket" },
        })
        .m(function (t, r, o, n) {
          return [
            T(o, this.serialize, this.deserialize),
            A(o, t.getEndpointParameterInstructions()),
          ];
        })
        .s("AmazonS3", "DeleteBucketWebsite", {})
        .n("S3Client", "DeleteBucketWebsiteCommand")
        .f(void 0, void 0)
        .ser(Uje)
        .de(v4e)
        .build()
    ) {};
  });
var lh,
  nG = s(() => {
    he();
    K();
    Y();
    $();
    X();
    J();
    lh = class extends (
      _.classBuilder()
        .ep({
          ...R,
          Bucket: { type: "contextParams", name: "Bucket" },
          Key: { type: "contextParams", name: "Key" },
        })
        .m(function (t, r, o, n) {
          return [
            T(o, this.serialize, this.deserialize),
            A(o, t.getEndpointParameterInstructions()),
            U(o),
          ];
        })
        .s("AmazonS3", "DeleteObject", {})
        .n("S3Client", "DeleteObjectCommand")
        .f(void 0, void 0)
        .ser($je)
        .de(O4e)
        .build()
    ) {};
  });
var Mv,
  sG = s(() => {
    Kt();
    he();
    K();
    Y();
    $();
    X();
    J();
    Mv = class extends (
      _.classBuilder()
        .ep({ ...R, Bucket: { type: "contextParams", name: "Bucket" } })
        .m(function (t, r, o, n) {
          return [
            T(o, this.serialize, this.deserialize),
            A(o, t.getEndpointParameterInstructions()),
            Le(o, {
              requestAlgorithmMember: {
                httpHeader: "x-amz-sdk-checksum-algorithm",
                name: "ChecksumAlgorithm",
              },
              requestChecksumRequired: !0,
            }),
            U(o),
          ];
        })
        .s("AmazonS3", "DeleteObjects", {})
        .n("S3Client", "DeleteObjectsCommand")
        .f(void 0, void 0)
        .ser(Hje)
        .de(k4e)
        .build()
    ) {};
  });
var Lv,
  iG = s(() => {
    he();
    K();
    Y();
    $();
    X();
    J();
    Lv = class extends (
      _.classBuilder()
        .ep({ ...R, Bucket: { type: "contextParams", name: "Bucket" } })
        .m(function (t, r, o, n) {
          return [
            T(o, this.serialize, this.deserialize),
            A(o, t.getEndpointParameterInstructions()),
            U(o),
          ];
        })
        .s("AmazonS3", "DeleteObjectTagging", {})
        .n("S3Client", "DeleteObjectTaggingCommand")
        .f(void 0, void 0)
        .ser(zje)
        .de(D4e)
        .build()
    ) {};
  });
var Fv,
  aG = s(() => {
    K();
    Y();
    $();
    X();
    J();
    Fv = class extends (
      _.classBuilder()
        .ep({
          ...R,
          UseS3ExpressControlEndpoint: {
            type: "staticContextParams",
            value: !0,
          },
          Bucket: { type: "contextParams", name: "Bucket" },
        })
        .m(function (t, r, o, n) {
          return [
            T(o, this.serialize, this.deserialize),
            A(o, t.getEndpointParameterInstructions()),
          ];
        })
        .s("AmazonS3", "DeletePublicAccessBlock", {})
        .n("S3Client", "DeletePublicAccessBlockCommand")
        .f(void 0, void 0)
        .ser(qje)
        .de(N4e)
        .build()
    ) {};
  });
var Uv,
  cG = s(() => {
    he();
    K();
    Y();
    $();
    X();
    J();
    Uv = class extends (
      _.classBuilder()
        .ep({
          ...R,
          UseS3ExpressControlEndpoint: {
            type: "staticContextParams",
            value: !0,
          },
          Bucket: { type: "contextParams", name: "Bucket" },
        })
        .m(function (t, r, o, n) {
          return [
            T(o, this.serialize, this.deserialize),
            A(o, t.getEndpointParameterInstructions()),
            U(o),
          ];
        })
        .s("AmazonS3", "GetBucketAccelerateConfiguration", {})
        .n("S3Client", "GetBucketAccelerateConfigurationCommand")
        .f(void 0, void 0)
        .ser(jje)
        .de(B4e)
        .build()
    ) {};
  });
var $v,
  dG = s(() => {
    he();
    K();
    Y();
    $();
    X();
    J();
    $v = class extends (
      _.classBuilder()
        .ep({
          ...R,
          UseS3ExpressControlEndpoint: {
            type: "staticContextParams",
            value: !0,
          },
          Bucket: { type: "contextParams", name: "Bucket" },
        })
        .m(function (t, r, o, n) {
          return [
            T(o, this.serialize, this.deserialize),
            A(o, t.getEndpointParameterInstructions()),
            U(o),
          ];
        })
        .s("AmazonS3", "GetBucketAcl", {})
        .n("S3Client", "GetBucketAclCommand")
        .f(void 0, void 0)
        .ser(Gje)
        .de(M4e)
        .build()
    ) {};
  });
var Hv,
  mG = s(() => {
    he();
    K();
    Y();
    $();
    X();
    J();
    Hv = class extends (
      _.classBuilder()
        .ep({
          ...R,
          UseS3ExpressControlEndpoint: {
            type: "staticContextParams",
            value: !0,
          },
          Bucket: { type: "contextParams", name: "Bucket" },
        })
        .m(function (t, r, o, n) {
          return [
            T(o, this.serialize, this.deserialize),
            A(o, t.getEndpointParameterInstructions()),
            U(o),
          ];
        })
        .s("AmazonS3", "GetBucketAnalyticsConfiguration", {})
        .n("S3Client", "GetBucketAnalyticsConfigurationCommand")
        .f(void 0, void 0)
        .ser(Vje)
        .de(L4e)
        .build()
    ) {};
  });
var zv,
  lG = s(() => {
    he();
    K();
    Y();
    $();
    X();
    J();
    zv = class extends (
      _.classBuilder()
        .ep({
          ...R,
          UseS3ExpressControlEndpoint: {
            type: "staticContextParams",
            value: !0,
          },
          Bucket: { type: "contextParams", name: "Bucket" },
        })
        .m(function (t, r, o, n) {
          return [
            T(o, this.serialize, this.deserialize),
            A(o, t.getEndpointParameterInstructions()),
            U(o),
          ];
        })
        .s("AmazonS3", "GetBucketCors", {})
        .n("S3Client", "GetBucketCorsCommand")
        .f(void 0, void 0)
        .ser(Wje)
        .de(F4e)
        .build()
    ) {};
  });
var qv,
  fG = s(() => {
    he();
    K();
    Y();
    $();
    X();
    Qo();
    J();
    qv = class extends (
      _.classBuilder()
        .ep({
          ...R,
          UseS3ExpressControlEndpoint: {
            type: "staticContextParams",
            value: !0,
          },
          Bucket: { type: "contextParams", name: "Bucket" },
        })
        .m(function (t, r, o, n) {
          return [
            T(o, this.serialize, this.deserialize),
            A(o, t.getEndpointParameterInstructions()),
            U(o),
          ];
        })
        .s("AmazonS3", "GetBucketEncryption", {})
        .n("S3Client", "GetBucketEncryptionCommand")
        .f(void 0, gqe)
        .ser(Kje)
        .de(U4e)
        .build()
    ) {};
  });
var jv,
  uG = s(() => {
    he();
    K();
    Y();
    $();
    X();
    J();
    jv = class extends (
      _.classBuilder()
        .ep({
          ...R,
          UseS3ExpressControlEndpoint: {
            type: "staticContextParams",
            value: !0,
          },
          Bucket: { type: "contextParams", name: "Bucket" },
        })
        .m(function (t, r, o, n) {
          return [
            T(o, this.serialize, this.deserialize),
            A(o, t.getEndpointParameterInstructions()),
            U(o),
          ];
        })
        .s("AmazonS3", "GetBucketIntelligentTieringConfiguration", {})
        .n("S3Client", "GetBucketIntelligentTieringConfigurationCommand")
        .f(void 0, void 0)
        .ser(Yje)
        .de($4e)
        .build()
    ) {};
  });
var Gv,
  pG = s(() => {
    he();
    K();
    Y();
    $();
    X();
    Qo();
    J();
    Gv = class extends (
      _.classBuilder()
        .ep({
          ...R,
          UseS3ExpressControlEndpoint: {
            type: "staticContextParams",
            value: !0,
          },
          Bucket: { type: "contextParams", name: "Bucket" },
        })
        .m(function (t, r, o, n) {
          return [
            T(o, this.serialize, this.deserialize),
            A(o, t.getEndpointParameterInstructions()),
            U(o),
          ];
        })
        .s("AmazonS3", "GetBucketInventoryConfiguration", {})
        .n("S3Client", "GetBucketInventoryConfigurationCommand")
        .f(void 0, yqe)
        .ser(Qje)
        .de(H4e)
        .build()
    ) {};
  });
var Vv,
  hG = s(() => {
    he();
    K();
    Y();
    $();
    X();
    J();
    Vv = class extends (
      _.classBuilder()
        .ep({
          ...R,
          UseS3ExpressControlEndpoint: {
            type: "staticContextParams",
            value: !0,
          },
          Bucket: { type: "contextParams", name: "Bucket" },
        })
        .m(function (t, r, o, n) {
          return [
            T(o, this.serialize, this.deserialize),
            A(o, t.getEndpointParameterInstructions()),
            U(o),
          ];
        })
        .s("AmazonS3", "GetBucketLifecycleConfiguration", {})
        .n("S3Client", "GetBucketLifecycleConfigurationCommand")
        .f(void 0, void 0)
        .ser(Xje)
        .de(z4e)
        .build()
    ) {};
  });
var Wv,
  gG = s(() => {
    he();
    K();
    Y();
    $();
    X();
    J();
    Wv = class extends (
      _.classBuilder()
        .ep({
          ...R,
          UseS3ExpressControlEndpoint: {
            type: "staticContextParams",
            value: !0,
          },
          Bucket: { type: "contextParams", name: "Bucket" },
        })
        .m(function (t, r, o, n) {
          return [
            T(o, this.serialize, this.deserialize),
            A(o, t.getEndpointParameterInstructions()),
            U(o),
          ];
        })
        .s("AmazonS3", "GetBucketLocation", {})
        .n("S3Client", "GetBucketLocationCommand")
        .f(void 0, void 0)
        .ser(Jje)
        .de(q4e)
        .build()
    ) {};
  });
var Kv,
  yG = s(() => {
    he();
    K();
    Y();
    $();
    X();
    J();
    Kv = class extends (
      _.classBuilder()
        .ep({
          ...R,
          UseS3ExpressControlEndpoint: {
            type: "staticContextParams",
            value: !0,
          },
          Bucket: { type: "contextParams", name: "Bucket" },
        })
        .m(function (t, r, o, n) {
          return [
            T(o, this.serialize, this.deserialize),
            A(o, t.getEndpointParameterInstructions()),
            U(o),
          ];
        })
        .s("AmazonS3", "GetBucketLogging", {})
        .n("S3Client", "GetBucketLoggingCommand")
        .f(void 0, void 0)
        .ser(Zje)
        .de(j4e)
        .build()
    ) {};
  });
var Yv,
  xG = s(() => {
    he();
    K();
    Y();
    $();
    X();
    J();
    Yv = class extends (
      _.classBuilder()
        .ep({
          ...R,
          UseS3ExpressControlEndpoint: {
            type: "staticContextParams",
            value: !0,
          },
          Bucket: { type: "contextParams", name: "Bucket" },
        })
        .m(function (t, r, o, n) {
          return [
            T(o, this.serialize, this.deserialize),
            A(o, t.getEndpointParameterInstructions()),
            U(o),
          ];
        })
        .s("AmazonS3", "GetBucketMetadataTableConfiguration", {})
        .n("S3Client", "GetBucketMetadataTableConfigurationCommand")
        .f(void 0, void 0)
        .ser(eGe)
        .de(G4e)
        .build()
    ) {};
  });
var Qv,
  EG = s(() => {
    he();
    K();
    Y();
    $();
    X();
    J();
    Qv = class extends (
      _.classBuilder()
        .ep({
          ...R,
          UseS3ExpressControlEndpoint: {
            type: "staticContextParams",
            value: !0,
          },
          Bucket: { type: "contextParams", name: "Bucket" },
        })
        .m(function (t, r, o, n) {
          return [
            T(o, this.serialize, this.deserialize),
            A(o, t.getEndpointParameterInstructions()),
            U(o),
          ];
        })
        .s("AmazonS3", "GetBucketMetricsConfiguration", {})
        .n("S3Client", "GetBucketMetricsConfigurationCommand")
        .f(void 0, void 0)
        .ser(tGe)
        .de(V4e)
        .build()
    ) {};
  });
var Xv,
  SG = s(() => {
    he();
    K();
    Y();
    $();
    X();
    J();
    Xv = class extends (
      _.classBuilder()
        .ep({
          ...R,
          UseS3ExpressControlEndpoint: {
            type: "staticContextParams",
            value: !0,
          },
          Bucket: { type: "contextParams", name: "Bucket" },
        })
        .m(function (t, r, o, n) {
          return [
            T(o, this.serialize, this.deserialize),
            A(o, t.getEndpointParameterInstructions()),
            U(o),
          ];
        })
        .s("AmazonS3", "GetBucketNotificationConfiguration", {})
        .n("S3Client", "GetBucketNotificationConfigurationCommand")
        .f(void 0, void 0)
        .ser(rGe)
        .de(W4e)
        .build()
    ) {};
  });
var Jv,
  CG = s(() => {
    he();
    K();
    Y();
    $();
    X();
    J();
    Jv = class extends (
      _.classBuilder()
        .ep({
          ...R,
          UseS3ExpressControlEndpoint: {
            type: "staticContextParams",
            value: !0,
          },
          Bucket: { type: "contextParams", name: "Bucket" },
        })
        .m(function (t, r, o, n) {
          return [
            T(o, this.serialize, this.deserialize),
            A(o, t.getEndpointParameterInstructions()),
            U(o),
          ];
        })
        .s("AmazonS3", "GetBucketOwnershipControls", {})
        .n("S3Client", "GetBucketOwnershipControlsCommand")
        .f(void 0, void 0)
        .ser(oGe)
        .de(K4e)
        .build()
    ) {};
  });
var Zv,
  bG = s(() => {
    he();
    K();
    Y();
    $();
    X();
    J();
    Zv = class extends (
      _.classBuilder()
        .ep({
          ...R,
          UseS3ExpressControlEndpoint: {
            type: "staticContextParams",
            value: !0,
          },
          Bucket: { type: "contextParams", name: "Bucket" },
        })
        .m(function (t, r, o, n) {
          return [
            T(o, this.serialize, this.deserialize),
            A(o, t.getEndpointParameterInstructions()),
            U(o),
          ];
        })
        .s("AmazonS3", "GetBucketPolicy", {})
        .n("S3Client", "GetBucketPolicyCommand")
        .f(void 0, void 0)
        .ser(nGe)
        .de(Y4e)
        .build()
    ) {};
  });
var e0,
  _G = s(() => {
    he();
    K();
    Y();
    $();
    X();
    J();
    e0 = class extends (
      _.classBuilder()
        .ep({
          ...R,
          UseS3ExpressControlEndpoint: {
            type: "staticContextParams",
            value: !0,
          },
          Bucket: { type: "contextParams", name: "Bucket" },
        })
        .m(function (t, r, o, n) {
          return [
            T(o, this.serialize, this.deserialize),
            A(o, t.getEndpointParameterInstructions()),
            U(o),
          ];
        })
        .s("AmazonS3", "GetBucketPolicyStatus", {})
        .n("S3Client", "GetBucketPolicyStatusCommand")
        .f(void 0, void 0)
        .ser(sGe)
        .de(Q4e)
        .build()
    ) {};
  });
var t0,
  wG = s(() => {
    he();
    K();
    Y();
    $();
    X();
    J();
    t0 = class extends (
      _.classBuilder()
        .ep({
          ...R,
          UseS3ExpressControlEndpoint: {
            type: "staticContextParams",
            value: !0,
          },
          Bucket: { type: "contextParams", name: "Bucket" },
        })
        .m(function (t, r, o, n) {
          return [
            T(o, this.serialize, this.deserialize),
            A(o, t.getEndpointParameterInstructions()),
            U(o),
          ];
        })
        .s("AmazonS3", "GetBucketReplication", {})
        .n("S3Client", "GetBucketReplicationCommand")
        .f(void 0, void 0)
        .ser(iGe)
        .de(X4e)
        .build()
    ) {};
  });
var r0,
  TG = s(() => {
    he();
    K();
    Y();
    $();
    X();
    J();
    r0 = class extends (
      _.classBuilder()
        .ep({
          ...R,
          UseS3ExpressControlEndpoint: {
            type: "staticContextParams",
            value: !0,
          },
          Bucket: { type: "contextParams", name: "Bucket" },
        })
        .m(function (t, r, o, n) {
          return [
            T(o, this.serialize, this.deserialize),
            A(o, t.getEndpointParameterInstructions()),
            U(o),
          ];
        })
        .s("AmazonS3", "GetBucketRequestPayment", {})
        .n("S3Client", "GetBucketRequestPaymentCommand")
        .f(void 0, void 0)
        .ser(aGe)
        .de(J4e)
        .build()
    ) {};
  });
var o0,
  AG = s(() => {
    he();
    K();
    Y();
    $();
    X();
    J();
    o0 = class extends (
      _.classBuilder()
        .ep({
          ...R,
          UseS3ExpressControlEndpoint: {
            type: "staticContextParams",
            value: !0,
          },
          Bucket: { type: "contextParams", name: "Bucket" },
        })
        .m(function (t, r, o, n) {
          return [
            T(o, this.serialize, this.deserialize),
            A(o, t.getEndpointParameterInstructions()),
            U(o),
          ];
        })
        .s("AmazonS3", "GetBucketTagging", {})
        .n("S3Client", "GetBucketTaggingCommand")
        .f(void 0, void 0)
        .ser(cGe)
        .de(Z4e)
        .build()
    ) {};
  });
var n0,
  RG = s(() => {
    he();
    K();
    Y();
    $();
    X();
    J();
    n0 = class extends (
      _.classBuilder()
        .ep({
          ...R,
          UseS3ExpressControlEndpoint: {
            type: "staticContextParams",
            value: !0,
          },
          Bucket: { type: "contextParams", name: "Bucket" },
        })
        .m(function (t, r, o, n) {
          return [
            T(o, this.serialize, this.deserialize),
            A(o, t.getEndpointParameterInstructions()),
            U(o),
          ];
        })
        .s("AmazonS3", "GetBucketVersioning", {})
        .n("S3Client", "GetBucketVersioningCommand")
        .f(void 0, void 0)
        .ser(dGe)
        .de(eVe)
        .build()
    ) {};
  });
var s0,
  IG = s(() => {
    he();
    K();
    Y();
    $();
    X();
    J();
    s0 = class extends (
      _.classBuilder()
        .ep({
          ...R,
          UseS3ExpressControlEndpoint: {
            type: "staticContextParams",
            value: !0,
          },
          Bucket: { type: "contextParams", name: "Bucket" },
        })
        .m(function (t, r, o, n) {
          return [
            T(o, this.serialize, this.deserialize),
            A(o, t.getEndpointParameterInstructions()),
            U(o),
          ];
        })
        .s("AmazonS3", "GetBucketWebsite", {})
        .n("S3Client", "GetBucketWebsiteCommand")
        .f(void 0, void 0)
        .ser(mGe)
        .de(tVe)
        .build()
    ) {};
  });
var i0,
  PG = s(() => {
    he();
    K();
    Y();
    $();
    X();
    J();
    i0 = class extends (
      _.classBuilder()
        .ep({
          ...R,
          Bucket: { type: "contextParams", name: "Bucket" },
          Key: { type: "contextParams", name: "Key" },
        })
        .m(function (t, r, o, n) {
          return [
            T(o, this.serialize, this.deserialize),
            A(o, t.getEndpointParameterInstructions()),
            U(o),
          ];
        })
        .s("AmazonS3", "GetObjectAcl", {})
        .n("S3Client", "GetObjectAclCommand")
        .f(void 0, void 0)
        .ser(fGe)
        .de(oVe)
        .build()
    ) {};
  });
var a0,
  vG = s(() => {
    he();
    vs();
    K();
    Y();
    $();
    X();
    Qo();
    J();
    a0 = class extends (
      _.classBuilder()
        .ep({ ...R, Bucket: { type: "contextParams", name: "Bucket" } })
        .m(function (t, r, o, n) {
          return [
            T(o, this.serialize, this.deserialize),
            A(o, t.getEndpointParameterInstructions()),
            U(o),
            Mr(o),
          ];
        })
        .s("AmazonS3", "GetObjectAttributes", {})
        .n("S3Client", "GetObjectAttributesCommand")
        .f(Sqe, void 0)
        .ser(uGe)
        .de(nVe)
        .build()
    ) {};
  });
var fh,
  OG = s(() => {
    Kt();
    he();
    vs();
    K();
    Y();
    $();
    X();
    Qo();
    J();
    fh = class extends (
      _.classBuilder()
        .ep({
          ...R,
          Bucket: { type: "contextParams", name: "Bucket" },
          Key: { type: "contextParams", name: "Key" },
        })
        .m(function (t, r, o, n) {
          return [
            T(o, this.serialize, this.deserialize),
            A(o, t.getEndpointParameterInstructions()),
            Le(o, {
              requestChecksumRequired: !1,
              requestValidationModeMember: "ChecksumMode",
              responseAlgorithms: [
                "CRC64NVME",
                "CRC32",
                "CRC32C",
                "SHA256",
                "SHA1",
              ],
            }),
            Mr(o),
            rR(o),
          ];
        })
        .s("AmazonS3", "GetObject", {})
        .n("S3Client", "GetObjectCommand")
        .f(Eqe, xqe)
        .ser(lGe)
        .de(rVe)
        .build()
    ) {};
  });
var c0,
  kG = s(() => {
    he();
    K();
    Y();
    $();
    X();
    J();
    c0 = class extends (
      _.classBuilder()
        .ep({ ...R, Bucket: { type: "contextParams", name: "Bucket" } })
        .m(function (t, r, o, n) {
          return [
            T(o, this.serialize, this.deserialize),
            A(o, t.getEndpointParameterInstructions()),
            U(o),
          ];
        })
        .s("AmazonS3", "GetObjectLegalHold", {})
        .n("S3Client", "GetObjectLegalHoldCommand")
        .f(void 0, void 0)
        .ser(pGe)
        .de(sVe)
        .build()
    ) {};
  });
var d0,
  DG = s(() => {
    he();
    K();
    Y();
    $();
    X();
    J();
    d0 = class extends (
      _.classBuilder()
        .ep({ ...R, Bucket: { type: "contextParams", name: "Bucket" } })
        .m(function (t, r, o, n) {
          return [
            T(o, this.serialize, this.deserialize),
            A(o, t.getEndpointParameterInstructions()),
            U(o),
          ];
        })
        .s("AmazonS3", "GetObjectLockConfiguration", {})
        .n("S3Client", "GetObjectLockConfigurationCommand")
        .f(void 0, void 0)
        .ser(hGe)
        .de(iVe)
        .build()
    ) {};
  });
var m0,
  NG = s(() => {
    he();
    K();
    Y();
    $();
    X();
    J();
    m0 = class extends (
      _.classBuilder()
        .ep({ ...R, Bucket: { type: "contextParams", name: "Bucket" } })
        .m(function (t, r, o, n) {
          return [
            T(o, this.serialize, this.deserialize),
            A(o, t.getEndpointParameterInstructions()),
            U(o),
          ];
        })
        .s("AmazonS3", "GetObjectRetention", {})
        .n("S3Client", "GetObjectRetentionCommand")
        .f(void 0, void 0)
        .ser(gGe)
        .de(aVe)
        .build()
    ) {};
  });
var l0,
  BG = s(() => {
    he();
    K();
    Y();
    $();
    X();
    J();
    l0 = class extends (
      _.classBuilder()
        .ep({ ...R, Bucket: { type: "contextParams", name: "Bucket" } })
        .m(function (t, r, o, n) {
          return [
            T(o, this.serialize, this.deserialize),
            A(o, t.getEndpointParameterInstructions()),
            U(o),
          ];
        })
        .s("AmazonS3", "GetObjectTagging", {})
        .n("S3Client", "GetObjectTaggingCommand")
        .f(void 0, void 0)
        .ser(yGe)
        .de(cVe)
        .build()
    ) {};
  });
var f0,
  MG = s(() => {
    K();
    Y();
    $();
    X();
    Qo();
    J();
    f0 = class extends (
      _.classBuilder()
        .ep({ ...R, Bucket: { type: "contextParams", name: "Bucket" } })
        .m(function (t, r, o, n) {
          return [
            T(o, this.serialize, this.deserialize),
            A(o, t.getEndpointParameterInstructions()),
          ];
        })
        .s("AmazonS3", "GetObjectTorrent", {})
        .n("S3Client", "GetObjectTorrentCommand")
        .f(void 0, Cqe)
        .ser(xGe)
        .de(dVe)
        .build()
    ) {};
  });
var u0,
  LG = s(() => {
    he();
    K();
    Y();
    $();
    X();
    J();
    u0 = class extends (
      _.classBuilder()
        .ep({
          ...R,
          UseS3ExpressControlEndpoint: {
            type: "staticContextParams",
            value: !0,
          },
          Bucket: { type: "contextParams", name: "Bucket" },
        })
        .m(function (t, r, o, n) {
          return [
            T(o, this.serialize, this.deserialize),
            A(o, t.getEndpointParameterInstructions()),
            U(o),
          ];
        })
        .s("AmazonS3", "GetPublicAccessBlock", {})
        .n("S3Client", "GetPublicAccessBlockCommand")
        .f(void 0, void 0)
        .ser(EGe)
        .de(mVe)
        .build()
    ) {};
  });
var p0,
  FG = s(() => {
    he();
    K();
    Y();
    $();
    X();
    J();
    p0 = class extends (
      _.classBuilder()
        .ep({ ...R, Bucket: { type: "contextParams", name: "Bucket" } })
        .m(function (t, r, o, n) {
          return [
            T(o, this.serialize, this.deserialize),
            A(o, t.getEndpointParameterInstructions()),
            U(o),
          ];
        })
        .s("AmazonS3", "HeadBucket", {})
        .n("S3Client", "HeadBucketCommand")
        .f(void 0, void 0)
        .ser(SGe)
        .de(lVe)
        .build()
    ) {};
  });
var h0,
  UG = s(() => {
    he();
    vs();
    K();
    Y();
    $();
    X();
    Qo();
    J();
    h0 = class extends (
      _.classBuilder()
        .ep({
          ...R,
          Bucket: { type: "contextParams", name: "Bucket" },
          Key: { type: "contextParams", name: "Key" },
        })
        .m(function (t, r, o, n) {
          return [
            T(o, this.serialize, this.deserialize),
            A(o, t.getEndpointParameterInstructions()),
            U(o),
            Mr(o),
            rR(o),
          ];
        })
        .s("AmazonS3", "HeadObject", {})
        .n("S3Client", "HeadObjectCommand")
        .f(_qe, bqe)
        .ser(CGe)
        .de(fVe)
        .build()
    ) {};
  });
var g0,
  $G = s(() => {
    he();
    K();
    Y();
    $();
    X();
    J();
    g0 = class extends (
      _.classBuilder()
        .ep({
          ...R,
          UseS3ExpressControlEndpoint: {
            type: "staticContextParams",
            value: !0,
          },
          Bucket: { type: "contextParams", name: "Bucket" },
        })
        .m(function (t, r, o, n) {
          return [
            T(o, this.serialize, this.deserialize),
            A(o, t.getEndpointParameterInstructions()),
            U(o),
          ];
        })
        .s("AmazonS3", "ListBucketAnalyticsConfigurations", {})
        .n("S3Client", "ListBucketAnalyticsConfigurationsCommand")
        .f(void 0, void 0)
        .ser(bGe)
        .de(uVe)
        .build()
    ) {};
  });
var y0,
  HG = s(() => {
    he();
    K();
    Y();
    $();
    X();
    J();
    y0 = class extends (
      _.classBuilder()
        .ep({
          ...R,
          UseS3ExpressControlEndpoint: {
            type: "staticContextParams",
            value: !0,
          },
          Bucket: { type: "contextParams", name: "Bucket" },
        })
        .m(function (t, r, o, n) {
          return [
            T(o, this.serialize, this.deserialize),
            A(o, t.getEndpointParameterInstructions()),
            U(o),
          ];
        })
        .s("AmazonS3", "ListBucketIntelligentTieringConfigurations", {})
        .n("S3Client", "ListBucketIntelligentTieringConfigurationsCommand")
        .f(void 0, void 0)
        .ser(_Ge)
        .de(pVe)
        .build()
    ) {};
  });
var x0,
  zG = s(() => {
    he();
    K();
    Y();
    $();
    X();
    Qo();
    J();
    x0 = class extends (
      _.classBuilder()
        .ep({
          ...R,
          UseS3ExpressControlEndpoint: {
            type: "staticContextParams",
            value: !0,
          },
          Bucket: { type: "contextParams", name: "Bucket" },
        })
        .m(function (t, r, o, n) {
          return [
            T(o, this.serialize, this.deserialize),
            A(o, t.getEndpointParameterInstructions()),
            U(o),
          ];
        })
        .s("AmazonS3", "ListBucketInventoryConfigurations", {})
        .n("S3Client", "ListBucketInventoryConfigurationsCommand")
        .f(void 0, wqe)
        .ser(wGe)
        .de(hVe)
        .build()
    ) {};
  });
var E0,
  qG = s(() => {
    he();
    K();
    Y();
    $();
    X();
    J();
    E0 = class extends (
      _.classBuilder()
        .ep({ ...R, Bucket: { type: "contextParams", name: "Bucket" } })
        .m(function (t, r, o, n) {
          return [
            T(o, this.serialize, this.deserialize),
            A(o, t.getEndpointParameterInstructions()),
            U(o),
          ];
        })
        .s("AmazonS3", "ListBucketMetricsConfigurations", {})
        .n("S3Client", "ListBucketMetricsConfigurationsCommand")
        .f(void 0, void 0)
        .ser(TGe)
        .de(gVe)
        .build()
    ) {};
  });
var uh,
  S0 = s(() => {
    he();
    K();
    Y();
    $();
    X();
    J();
    uh = class extends (
      _.classBuilder()
        .ep(R)
        .m(function (t, r, o, n) {
          return [
            T(o, this.serialize, this.deserialize),
            A(o, t.getEndpointParameterInstructions()),
            U(o),
          ];
        })
        .s("AmazonS3", "ListBuckets", {})
        .n("S3Client", "ListBucketsCommand")
        .f(void 0, void 0)
        .ser(AGe)
        .de(yVe)
        .build()
    ) {};
  });
var ph,
  C0 = s(() => {
    he();
    K();
    Y();
    $();
    X();
    J();
    ph = class extends (
      _.classBuilder()
        .ep({
          ...R,
          UseS3ExpressControlEndpoint: {
            type: "staticContextParams",
            value: !0,
          },
        })
        .m(function (t, r, o, n) {
          return [
            T(o, this.serialize, this.deserialize),
            A(o, t.getEndpointParameterInstructions()),
            U(o),
          ];
        })
        .s("AmazonS3", "ListDirectoryBuckets", {})
        .n("S3Client", "ListDirectoryBucketsCommand")
        .f(void 0, void 0)
        .ser(RGe)
        .de(xVe)
        .build()
    ) {};
  });
var b0,
  jG = s(() => {
    he();
    K();
    Y();
    $();
    X();
    J();
    b0 = class extends (
      _.classBuilder()
        .ep({
          ...R,
          Bucket: { type: "contextParams", name: "Bucket" },
          Prefix: { type: "contextParams", name: "Prefix" },
        })
        .m(function (t, r, o, n) {
          return [
            T(o, this.serialize, this.deserialize),
            A(o, t.getEndpointParameterInstructions()),
            U(o),
          ];
        })
        .s("AmazonS3", "ListMultipartUploads", {})
        .n("S3Client", "ListMultipartUploadsCommand")
        .f(void 0, void 0)
        .ser(IGe)
        .de(EVe)
        .build()
    ) {};
  });
var _0,
  GG = s(() => {
    he();
    K();
    Y();
    $();
    X();
    J();
    _0 = class extends (
      _.classBuilder()
        .ep({
          ...R,
          Bucket: { type: "contextParams", name: "Bucket" },
          Prefix: { type: "contextParams", name: "Prefix" },
        })
        .m(function (t, r, o, n) {
          return [
            T(o, this.serialize, this.deserialize),
            A(o, t.getEndpointParameterInstructions()),
            U(o),
          ];
        })
        .s("AmazonS3", "ListObjects", {})
        .n("S3Client", "ListObjectsCommand")
        .f(void 0, void 0)
        .ser(PGe)
        .de(SVe)
        .build()
    ) {};
  });
var hh,
  w0 = s(() => {
    he();
    K();
    Y();
    $();
    X();
    J();
    hh = class extends (
      _.classBuilder()
        .ep({
          ...R,
          Bucket: { type: "contextParams", name: "Bucket" },
          Prefix: { type: "contextParams", name: "Prefix" },
        })
        .m(function (t, r, o, n) {
          return [
            T(o, this.serialize, this.deserialize),
            A(o, t.getEndpointParameterInstructions()),
            U(o),
          ];
        })
        .s("AmazonS3", "ListObjectsV2", {})
        .n("S3Client", "ListObjectsV2Command")
        .f(void 0, void 0)
        .ser(vGe)
        .de(CVe)
        .build()
    ) {};
  });
var T0,
  VG = s(() => {
    he();
    K();
    Y();
    $();
    X();
    J();
    T0 = class extends (
      _.classBuilder()
        .ep({
          ...R,
          Bucket: { type: "contextParams", name: "Bucket" },
          Prefix: { type: "contextParams", name: "Prefix" },
        })
        .m(function (t, r, o, n) {
          return [
            T(o, this.serialize, this.deserialize),
            A(o, t.getEndpointParameterInstructions()),
            U(o),
          ];
        })
        .s("AmazonS3", "ListObjectVersions", {})
        .n("S3Client", "ListObjectVersionsCommand")
        .f(void 0, void 0)
        .ser(OGe)
        .de(bVe)
        .build()
    ) {};
  });
var gh,
  A0 = s(() => {
    he();
    vs();
    K();
    Y();
    $();
    X();
    Qo();
    J();
    gh = class extends (
      _.classBuilder()
        .ep({
          ...R,
          Bucket: { type: "contextParams", name: "Bucket" },
          Key: { type: "contextParams", name: "Key" },
        })
        .m(function (t, r, o, n) {
          return [
            T(o, this.serialize, this.deserialize),
            A(o, t.getEndpointParameterInstructions()),
            U(o),
            Mr(o),
          ];
        })
        .s("AmazonS3", "ListParts", {})
        .n("S3Client", "ListPartsCommand")
        .f(Tqe, void 0)
        .ser(kGe)
        .de(_Ve)
        .build()
    ) {};
  });
var R0,
  WG = s(() => {
    Kt();
    K();
    Y();
    $();
    X();
    J();
    R0 = class extends (
      _.classBuilder()
        .ep({
          ...R,
          UseS3ExpressControlEndpoint: {
            type: "staticContextParams",
            value: !0,
          },
          Bucket: { type: "contextParams", name: "Bucket" },
        })
        .m(function (t, r, o, n) {
          return [
            T(o, this.serialize, this.deserialize),
            A(o, t.getEndpointParameterInstructions()),
            Le(o, {
              requestAlgorithmMember: {
                httpHeader: "x-amz-sdk-checksum-algorithm",
                name: "ChecksumAlgorithm",
              },
              requestChecksumRequired: !1,
            }),
          ];
        })
        .s("AmazonS3", "PutBucketAccelerateConfiguration", {})
        .n("S3Client", "PutBucketAccelerateConfigurationCommand")
        .f(void 0, void 0)
        .ser(DGe)
        .de(wVe)
        .build()
    ) {};
  });
var I0,
  KG = s(() => {
    Kt();
    K();
    Y();
    $();
    X();
    J();
    I0 = class extends (
      _.classBuilder()
        .ep({
          ...R,
          UseS3ExpressControlEndpoint: {
            type: "staticContextParams",
            value: !0,
          },
          Bucket: { type: "contextParams", name: "Bucket" },
        })
        .m(function (t, r, o, n) {
          return [
            T(o, this.serialize, this.deserialize),
            A(o, t.getEndpointParameterInstructions()),
            Le(o, {
              requestAlgorithmMember: {
                httpHeader: "x-amz-sdk-checksum-algorithm",
                name: "ChecksumAlgorithm",
              },
              requestChecksumRequired: !0,
            }),
          ];
        })
        .s("AmazonS3", "PutBucketAcl", {})
        .n("S3Client", "PutBucketAclCommand")
        .f(void 0, void 0)
        .ser(NGe)
        .de(TVe)
        .build()
    ) {};
  });
var P0,
  YG = s(() => {
    K();
    Y();
    $();
    X();
    J();
    P0 = class extends (
      _.classBuilder()
        .ep({
          ...R,
          UseS3ExpressControlEndpoint: {
            type: "staticContextParams",
            value: !0,
          },
          Bucket: { type: "contextParams", name: "Bucket" },
        })
        .m(function (t, r, o, n) {
          return [
            T(o, this.serialize, this.deserialize),
            A(o, t.getEndpointParameterInstructions()),
          ];
        })
        .s("AmazonS3", "PutBucketAnalyticsConfiguration", {})
        .n("S3Client", "PutBucketAnalyticsConfigurationCommand")
        .f(void 0, void 0)
        .ser(BGe)
        .de(AVe)
        .build()
    ) {};
  });
var v0,
  QG = s(() => {
    Kt();
    K();
    Y();
    $();
    X();
    J();
    v0 = class extends (
      _.classBuilder()
        .ep({
          ...R,
          UseS3ExpressControlEndpoint: {
            type: "staticContextParams",
            value: !0,
          },
          Bucket: { type: "contextParams", name: "Bucket" },
        })
        .m(function (t, r, o, n) {
          return [
            T(o, this.serialize, this.deserialize),
            A(o, t.getEndpointParameterInstructions()),
            Le(o, {
              requestAlgorithmMember: {
                httpHeader: "x-amz-sdk-checksum-algorithm",
                name: "ChecksumAlgorithm",
              },
              requestChecksumRequired: !0,
            }),
          ];
        })
        .s("AmazonS3", "PutBucketCors", {})
        .n("S3Client", "PutBucketCorsCommand")
        .f(void 0, void 0)
        .ser(MGe)
        .de(RVe)
        .build()
    ) {};
  });
var O0,
  XG = s(() => {
    Kt();
    K();
    Y();
    $();
    X();
    Ks();
    J();
    O0 = class extends (
      _.classBuilder()
        .ep({
          ...R,
          UseS3ExpressControlEndpoint: {
            type: "staticContextParams",
            value: !0,
          },
          Bucket: { type: "contextParams", name: "Bucket" },
        })
        .m(function (t, r, o, n) {
          return [
            T(o, this.serialize, this.deserialize),
            A(o, t.getEndpointParameterInstructions()),
            Le(o, {
              requestAlgorithmMember: {
                httpHeader: "x-amz-sdk-checksum-algorithm",
                name: "ChecksumAlgorithm",
              },
              requestChecksumRequired: !0,
            }),
          ];
        })
        .s("AmazonS3", "PutBucketEncryption", {})
        .n("S3Client", "PutBucketEncryptionCommand")
        .f(Dqe, void 0)
        .ser(LGe)
        .de(IVe)
        .build()
    ) {};
  });
var k0,
  JG = s(() => {
    K();
    Y();
    $();
    X();
    J();
    k0 = class extends (
      _.classBuilder()
        .ep({
          ...R,
          UseS3ExpressControlEndpoint: {
            type: "staticContextParams",
            value: !0,
          },
          Bucket: { type: "contextParams", name: "Bucket" },
        })
        .m(function (t, r, o, n) {
          return [
            T(o, this.serialize, this.deserialize),
            A(o, t.getEndpointParameterInstructions()),
          ];
        })
        .s("AmazonS3", "PutBucketIntelligentTieringConfiguration", {})
        .n("S3Client", "PutBucketIntelligentTieringConfigurationCommand")
        .f(void 0, void 0)
        .ser(FGe)
        .de(PVe)
        .build()
    ) {};
  });
var D0,
  ZG = s(() => {
    K();
    Y();
    $();
    X();
    Ks();
    J();
    D0 = class extends (
      _.classBuilder()
        .ep({
          ...R,
          UseS3ExpressControlEndpoint: {
            type: "staticContextParams",
            value: !0,
          },
          Bucket: { type: "contextParams", name: "Bucket" },
        })
        .m(function (t, r, o, n) {
          return [
            T(o, this.serialize, this.deserialize),
            A(o, t.getEndpointParameterInstructions()),
          ];
        })
        .s("AmazonS3", "PutBucketInventoryConfiguration", {})
        .n("S3Client", "PutBucketInventoryConfigurationCommand")
        .f(Nqe, void 0)
        .ser(UGe)
        .de(vVe)
        .build()
    ) {};
  });
var N0,
  e4 = s(() => {
    Kt();
    he();
    K();
    Y();
    $();
    X();
    J();
    N0 = class extends (
      _.classBuilder()
        .ep({
          ...R,
          UseS3ExpressControlEndpoint: {
            type: "staticContextParams",
            value: !0,
          },
          Bucket: { type: "contextParams", name: "Bucket" },
        })
        .m(function (t, r, o, n) {
          return [
            T(o, this.serialize, this.deserialize),
            A(o, t.getEndpointParameterInstructions()),
            Le(o, {
              requestAlgorithmMember: {
                httpHeader: "x-amz-sdk-checksum-algorithm",
                name: "ChecksumAlgorithm",
              },
              requestChecksumRequired: !0,
            }),
            U(o),
          ];
        })
        .s("AmazonS3", "PutBucketLifecycleConfiguration", {})
        .n("S3Client", "PutBucketLifecycleConfigurationCommand")
        .f(void 0, void 0)
        .ser($Ge)
        .de(OVe)
        .build()
    ) {};
  });
var B0,
  t4 = s(() => {
    Kt();
    K();
    Y();
    $();
    X();
    J();
    B0 = class extends (
      _.classBuilder()
        .ep({
          ...R,
          UseS3ExpressControlEndpoint: {
            type: "staticContextParams",
            value: !0,
          },
          Bucket: { type: "contextParams", name: "Bucket" },
        })
        .m(function (t, r, o, n) {
          return [
            T(o, this.serialize, this.deserialize),
            A(o, t.getEndpointParameterInstructions()),
            Le(o, {
              requestAlgorithmMember: {
                httpHeader: "x-amz-sdk-checksum-algorithm",
                name: "ChecksumAlgorithm",
              },
              requestChecksumRequired: !0,
            }),
          ];
        })
        .s("AmazonS3", "PutBucketLogging", {})
        .n("S3Client", "PutBucketLoggingCommand")
        .f(void 0, void 0)
        .ser(HGe)
        .de(kVe)
        .build()
    ) {};
  });
var M0,
  r4 = s(() => {
    K();
    Y();
    $();
    X();
    J();
    M0 = class extends (
      _.classBuilder()
        .ep({
          ...R,
          UseS3ExpressControlEndpoint: {
            type: "staticContextParams",
            value: !0,
          },
          Bucket: { type: "contextParams", name: "Bucket" },
        })
        .m(function (t, r, o, n) {
          return [
            T(o, this.serialize, this.deserialize),
            A(o, t.getEndpointParameterInstructions()),
          ];
        })
        .s("AmazonS3", "PutBucketMetricsConfiguration", {})
        .n("S3Client", "PutBucketMetricsConfigurationCommand")
        .f(void 0, void 0)
        .ser(zGe)
        .de(DVe)
        .build()
    ) {};
  });
var L0,
  o4 = s(() => {
    K();
    Y();
    $();
    X();
    J();
    L0 = class extends (
      _.classBuilder()
        .ep({
          ...R,
          UseS3ExpressControlEndpoint: {
            type: "staticContextParams",
            value: !0,
          },
          Bucket: { type: "contextParams", name: "Bucket" },
        })
        .m(function (t, r, o, n) {
          return [
            T(o, this.serialize, this.deserialize),
            A(o, t.getEndpointParameterInstructions()),
          ];
        })
        .s("AmazonS3", "PutBucketNotificationConfiguration", {})
        .n("S3Client", "PutBucketNotificationConfigurationCommand")
        .f(void 0, void 0)
        .ser(qGe)
        .de(NVe)
        .build()
    ) {};
  });
var F0,
  n4 = s(() => {
    Kt();
    K();
    Y();
    $();
    X();
    J();
    F0 = class extends (
      _.classBuilder()
        .ep({
          ...R,
          UseS3ExpressControlEndpoint: {
            type: "staticContextParams",
            value: !0,
          },
          Bucket: { type: "contextParams", name: "Bucket" },
        })
        .m(function (t, r, o, n) {
          return [
            T(o, this.serialize, this.deserialize),
            A(o, t.getEndpointParameterInstructions()),
            Le(o, {
              requestAlgorithmMember: {
                httpHeader: "x-amz-sdk-checksum-algorithm",
                name: "ChecksumAlgorithm",
              },
              requestChecksumRequired: !0,
            }),
          ];
        })
        .s("AmazonS3", "PutBucketOwnershipControls", {})
        .n("S3Client", "PutBucketOwnershipControlsCommand")
        .f(void 0, void 0)
        .ser(jGe)
        .de(BVe)
        .build()
    ) {};
  });
var U0,
  s4 = s(() => {
    Kt();
    K();
    Y();
    $();
    X();
    J();
    U0 = class extends (
      _.classBuilder()
        .ep({
          ...R,
          UseS3ExpressControlEndpoint: {
            type: "staticContextParams",
            value: !0,
          },
          Bucket: { type: "contextParams", name: "Bucket" },
        })
        .m(function (t, r, o, n) {
          return [
            T(o, this.serialize, this.deserialize),
            A(o, t.getEndpointParameterInstructions()),
            Le(o, {
              requestAlgorithmMember: {
                httpHeader: "x-amz-sdk-checksum-algorithm",
                name: "ChecksumAlgorithm",
              },
              requestChecksumRequired: !0,
            }),
          ];
        })
        .s("AmazonS3", "PutBucketPolicy", {})
        .n("S3Client", "PutBucketPolicyCommand")
        .f(void 0, void 0)
        .ser(GGe)
        .de(MVe)
        .build()
    ) {};
  });
var $0,
  i4 = s(() => {
    Kt();
    K();
    Y();
    $();
    X();
    J();
    $0 = class extends (
      _.classBuilder()
        .ep({
          ...R,
          UseS3ExpressControlEndpoint: {
            type: "staticContextParams",
            value: !0,
          },
          Bucket: { type: "contextParams", name: "Bucket" },
        })
        .m(function (t, r, o, n) {
          return [
            T(o, this.serialize, this.deserialize),
            A(o, t.getEndpointParameterInstructions()),
            Le(o, {
              requestAlgorithmMember: {
                httpHeader: "x-amz-sdk-checksum-algorithm",
                name: "ChecksumAlgorithm",
              },
              requestChecksumRequired: !0,
            }),
          ];
        })
        .s("AmazonS3", "PutBucketReplication", {})
        .n("S3Client", "PutBucketReplicationCommand")
        .f(void 0, void 0)
        .ser(VGe)
        .de(LVe)
        .build()
    ) {};
  });
var H0,
  a4 = s(() => {
    Kt();
    K();
    Y();
    $();
    X();
    J();
    H0 = class extends (
      _.classBuilder()
        .ep({
          ...R,
          UseS3ExpressControlEndpoint: {
            type: "staticContextParams",
            value: !0,
          },
          Bucket: { type: "contextParams", name: "Bucket" },
        })
        .m(function (t, r, o, n) {
          return [
            T(o, this.serialize, this.deserialize),
            A(o, t.getEndpointParameterInstructions()),
            Le(o, {
              requestAlgorithmMember: {
                httpHeader: "x-amz-sdk-checksum-algorithm",
                name: "ChecksumAlgorithm",
              },
              requestChecksumRequired: !0,
            }),
          ];
        })
        .s("AmazonS3", "PutBucketRequestPayment", {})
        .n("S3Client", "PutBucketRequestPaymentCommand")
        .f(void 0, void 0)
        .ser(WGe)
        .de(FVe)
        .build()
    ) {};
  });
var z0,
  c4 = s(() => {
    Kt();
    K();
    Y();
    $();
    X();
    J();
    z0 = class extends (
      _.classBuilder()
        .ep({
          ...R,
          UseS3ExpressControlEndpoint: {
            type: "staticContextParams",
            value: !0,
          },
          Bucket: { type: "contextParams", name: "Bucket" },
        })
        .m(function (t, r, o, n) {
          return [
            T(o, this.serialize, this.deserialize),
            A(o, t.getEndpointParameterInstructions()),
            Le(o, {
              requestAlgorithmMember: {
                httpHeader: "x-amz-sdk-checksum-algorithm",
                name: "ChecksumAlgorithm",
              },
              requestChecksumRequired: !0,
            }),
          ];
        })
        .s("AmazonS3", "PutBucketTagging", {})
        .n("S3Client", "PutBucketTaggingCommand")
        .f(void 0, void 0)
        .ser(KGe)
        .de(UVe)
        .build()
    ) {};
  });
var q0,
  d4 = s(() => {
    Kt();
    K();
    Y();
    $();
    X();
    J();
    q0 = class extends (
      _.classBuilder()
        .ep({
          ...R,
          UseS3ExpressControlEndpoint: {
            type: "staticContextParams",
            value: !0,
          },
          Bucket: { type: "contextParams", name: "Bucket" },
        })
        .m(function (t, r, o, n) {
          return [
            T(o, this.serialize, this.deserialize),
            A(o, t.getEndpointParameterInstructions()),
            Le(o, {
              requestAlgorithmMember: {
                httpHeader: "x-amz-sdk-checksum-algorithm",
                name: "ChecksumAlgorithm",
              },
              requestChecksumRequired: !0,
            }),
          ];
        })
        .s("AmazonS3", "PutBucketVersioning", {})
        .n("S3Client", "PutBucketVersioningCommand")
        .f(void 0, void 0)
        .ser(YGe)
        .de($Ve)
        .build()
    ) {};
  });
var j0,
  m4 = s(() => {
    Kt();
    K();
    Y();
    $();
    X();
    J();
    j0 = class extends (
      _.classBuilder()
        .ep({
          ...R,
          UseS3ExpressControlEndpoint: {
            type: "staticContextParams",
            value: !0,
          },
          Bucket: { type: "contextParams", name: "Bucket" },
        })
        .m(function (t, r, o, n) {
          return [
            T(o, this.serialize, this.deserialize),
            A(o, t.getEndpointParameterInstructions()),
            Le(o, {
              requestAlgorithmMember: {
                httpHeader: "x-amz-sdk-checksum-algorithm",
                name: "ChecksumAlgorithm",
              },
              requestChecksumRequired: !0,
            }),
          ];
        })
        .s("AmazonS3", "PutBucketWebsite", {})
        .n("S3Client", "PutBucketWebsiteCommand")
        .f(void 0, void 0)
        .ser(QGe)
        .de(HVe)
        .build()
    ) {};
  });
var G0,
  l4 = s(() => {
    Kt();
    he();
    K();
    Y();
    $();
    X();
    J();
    G0 = class extends (
      _.classBuilder()
        .ep({
          ...R,
          Bucket: { type: "contextParams", name: "Bucket" },
          Key: { type: "contextParams", name: "Key" },
        })
        .m(function (t, r, o, n) {
          return [
            T(o, this.serialize, this.deserialize),
            A(o, t.getEndpointParameterInstructions()),
            Le(o, {
              requestAlgorithmMember: {
                httpHeader: "x-amz-sdk-checksum-algorithm",
                name: "ChecksumAlgorithm",
              },
              requestChecksumRequired: !0,
            }),
            U(o),
          ];
        })
        .s("AmazonS3", "PutObjectAcl", {})
        .n("S3Client", "PutObjectAclCommand")
        .f(void 0, void 0)
        .ser(JGe)
        .de(qVe)
        .build()
    ) {};
  });
var yh,
  f4 = s(() => {
    Kt();
    he();
    vs();
    K();
    Y();
    $();
    X();
    Ks();
    J();
    yh = class extends (
      _.classBuilder()
        .ep({
          ...R,
          Bucket: { type: "contextParams", name: "Bucket" },
          Key: { type: "contextParams", name: "Key" },
        })
        .m(function (t, r, o, n) {
          return [
            T(o, this.serialize, this.deserialize),
            A(o, t.getEndpointParameterInstructions()),
            Le(o, {
              requestAlgorithmMember: {
                httpHeader: "x-amz-sdk-checksum-algorithm",
                name: "ChecksumAlgorithm",
              },
              requestChecksumRequired: !1,
            }),
            b$e(o),
            U(o),
            Mr(o),
          ];
        })
        .s("AmazonS3", "PutObject", {})
        .n("S3Client", "PutObjectCommand")
        .f(Mqe, Bqe)
        .ser(XGe)
        .de(zVe)
        .build()
    ) {};
  });
var V0,
  u4 = s(() => {
    Kt();
    he();
    K();
    Y();
    $();
    X();
    J();
    V0 = class extends (
      _.classBuilder()
        .ep({ ...R, Bucket: { type: "contextParams", name: "Bucket" } })
        .m(function (t, r, o, n) {
          return [
            T(o, this.serialize, this.deserialize),
            A(o, t.getEndpointParameterInstructions()),
            Le(o, {
              requestAlgorithmMember: {
                httpHeader: "x-amz-sdk-checksum-algorithm",
                name: "ChecksumAlgorithm",
              },
              requestChecksumRequired: !0,
            }),
            U(o),
          ];
        })
        .s("AmazonS3", "PutObjectLegalHold", {})
        .n("S3Client", "PutObjectLegalHoldCommand")
        .f(void 0, void 0)
        .ser(ZGe)
        .de(jVe)
        .build()
    ) {};
  });
var W0,
  p4 = s(() => {
    Kt();
    he();
    K();
    Y();
    $();
    X();
    J();
    W0 = class extends (
      _.classBuilder()
        .ep({ ...R, Bucket: { type: "contextParams", name: "Bucket" } })
        .m(function (t, r, o, n) {
          return [
            T(o, this.serialize, this.deserialize),
            A(o, t.getEndpointParameterInstructions()),
            Le(o, {
              requestAlgorithmMember: {
                httpHeader: "x-amz-sdk-checksum-algorithm",
                name: "ChecksumAlgorithm",
              },
              requestChecksumRequired: !0,
            }),
            U(o),
          ];
        })
        .s("AmazonS3", "PutObjectLockConfiguration", {})
        .n("S3Client", "PutObjectLockConfigurationCommand")
        .f(void 0, void 0)
        .ser(e4e)
        .de(GVe)
        .build()
    ) {};
  });
var K0,
  h4 = s(() => {
    Kt();
    he();
    K();
    Y();
    $();
    X();
    J();
    K0 = class extends (
      _.classBuilder()
        .ep({ ...R, Bucket: { type: "contextParams", name: "Bucket" } })
        .m(function (t, r, o, n) {
          return [
            T(o, this.serialize, this.deserialize),
            A(o, t.getEndpointParameterInstructions()),
            Le(o, {
              requestAlgorithmMember: {
                httpHeader: "x-amz-sdk-checksum-algorithm",
                name: "ChecksumAlgorithm",
              },
              requestChecksumRequired: !0,
            }),
            U(o),
          ];
        })
        .s("AmazonS3", "PutObjectRetention", {})
        .n("S3Client", "PutObjectRetentionCommand")
        .f(void 0, void 0)
        .ser(t4e)
        .de(VVe)
        .build()
    ) {};
  });
var Y0,
  g4 = s(() => {
    Kt();
    he();
    K();
    Y();
    $();
    X();
    J();
    Y0 = class extends (
      _.classBuilder()
        .ep({ ...R, Bucket: { type: "contextParams", name: "Bucket" } })
        .m(function (t, r, o, n) {
          return [
            T(o, this.serialize, this.deserialize),
            A(o, t.getEndpointParameterInstructions()),
            Le(o, {
              requestAlgorithmMember: {
                httpHeader: "x-amz-sdk-checksum-algorithm",
                name: "ChecksumAlgorithm",
              },
              requestChecksumRequired: !0,
            }),
            U(o),
          ];
        })
        .s("AmazonS3", "PutObjectTagging", {})
        .n("S3Client", "PutObjectTaggingCommand")
        .f(void 0, void 0)
        .ser(r4e)
        .de(WVe)
        .build()
    ) {};
  });
var Q0,
  y4 = s(() => {
    Kt();
    K();
    Y();
    $();
    X();
    J();
    Q0 = class extends (
      _.classBuilder()
        .ep({
          ...R,
          UseS3ExpressControlEndpoint: {
            type: "staticContextParams",
            value: !0,
          },
          Bucket: { type: "contextParams", name: "Bucket" },
        })
        .m(function (t, r, o, n) {
          return [
            T(o, this.serialize, this.deserialize),
            A(o, t.getEndpointParameterInstructions()),
            Le(o, {
              requestAlgorithmMember: {
                httpHeader: "x-amz-sdk-checksum-algorithm",
                name: "ChecksumAlgorithm",
              },
              requestChecksumRequired: !0,
            }),
          ];
        })
        .s("AmazonS3", "PutPublicAccessBlock", {})
        .n("S3Client", "PutPublicAccessBlockCommand")
        .f(void 0, void 0)
        .ser(o4e)
        .de(KVe)
        .build()
    ) {};
  });
var X0,
  x4 = s(() => {
    he();
    K();
    Y();
    $();
    X();
    J();
    X0 = class extends (
      _.classBuilder()
        .ep({
          ...R,
          Bucket: { type: "contextParams", name: "Bucket" },
          Key: { type: "contextParams", name: "Key" },
        })
        .m(function (t, r, o, n) {
          return [
            T(o, this.serialize, this.deserialize),
            A(o, t.getEndpointParameterInstructions()),
            U(o),
          ];
        })
        .s("AmazonS3", "RenameObject", {})
        .n("S3Client", "RenameObjectCommand")
        .f(void 0, void 0)
        .ser(n4e)
        .de(YVe)
        .build()
    ) {};
  });
var J0,
  E4 = s(() => {
    Kt();
    he();
    K();
    Y();
    $();
    X();
    Ks();
    J();
    J0 = class extends (
      _.classBuilder()
        .ep({ ...R, Bucket: { type: "contextParams", name: "Bucket" } })
        .m(function (t, r, o, n) {
          return [
            T(o, this.serialize, this.deserialize),
            A(o, t.getEndpointParameterInstructions()),
            Le(o, {
              requestAlgorithmMember: {
                httpHeader: "x-amz-sdk-checksum-algorithm",
                name: "ChecksumAlgorithm",
              },
              requestChecksumRequired: !1,
            }),
            U(o),
          ];
        })
        .s("AmazonS3", "RestoreObject", {})
        .n("S3Client", "RestoreObjectCommand")
        .f(Lqe, void 0)
        .ser(s4e)
        .de(QVe)
        .build()
    ) {};
  });
var Z0,
  S4 = s(() => {
    he();
    vs();
    K();
    Y();
    $();
    X();
    Ks();
    J();
    Z0 = class extends (
      _.classBuilder()
        .ep({ ...R, Bucket: { type: "contextParams", name: "Bucket" } })
        .m(function (t, r, o, n) {
          return [
            T(o, this.serialize, this.deserialize),
            A(o, t.getEndpointParameterInstructions()),
            U(o),
            Mr(o),
          ];
        })
        .s("AmazonS3", "SelectObjectContent", { eventStream: { output: !0 } })
        .n("S3Client", "SelectObjectContentCommand")
        .f(Uqe, Fqe)
        .ser(i4e)
        .de(XVe)
        .build()
    ) {};
  });
var eO,
  C4 = s(() => {
    Kt();
    he();
    vs();
    K();
    Y();
    $();
    X();
    Ks();
    J();
    eO = class extends (
      _.classBuilder()
        .ep({
          ...R,
          Bucket: { type: "contextParams", name: "Bucket" },
          Key: { type: "contextParams", name: "Key" },
        })
        .m(function (t, r, o, n) {
          return [
            T(o, this.serialize, this.deserialize),
            A(o, t.getEndpointParameterInstructions()),
            Le(o, {
              requestAlgorithmMember: {
                httpHeader: "x-amz-sdk-checksum-algorithm",
                name: "ChecksumAlgorithm",
              },
              requestChecksumRequired: !1,
            }),
            U(o),
            Mr(o),
          ];
        })
        .s("AmazonS3", "UploadPart", {})
        .n("S3Client", "UploadPartCommand")
        .f(Hqe, $qe)
        .ser(a4e)
        .de(JVe)
        .build()
    ) {};
  });
var tO,
  b4 = s(() => {
    he();
    vs();
    K();
    Y();
    $();
    X();
    Ks();
    J();
    tO = class extends (
      _.classBuilder()
        .ep({
          ...R,
          DisableS3ExpressSessionAuth: {
            type: "staticContextParams",
            value: !0,
          },
          Bucket: { type: "contextParams", name: "Bucket" },
        })
        .m(function (t, r, o, n) {
          return [
            T(o, this.serialize, this.deserialize),
            A(o, t.getEndpointParameterInstructions()),
            U(o),
            Mr(o),
          ];
        })
        .s("AmazonS3", "UploadPartCopy", {})
        .n("S3Client", "UploadPartCopyCommand")
        .f(qqe, zqe)
        .ser(c4e)
        .de(ZVe)
        .build()
    ) {};
  });
var rO,
  _4 = s(() => {
    K();
    Y();
    $();
    X();
    Ks();
    J();
    rO = class extends (
      _.classBuilder()
        .ep({
          ...R,
          UseObjectLambdaEndpoint: { type: "staticContextParams", value: !0 },
        })
        .m(function (t, r, o, n) {
          return [
            T(o, this.serialize, this.deserialize),
            A(o, t.getEndpointParameterInstructions()),
          ];
        })
        .s("AmazonS3", "WriteGetObjectResponse", {})
        .n("S3Client", "WriteGetObjectResponseCommand")
        .f(jqe, void 0)
        .ser(d4e)
        .de(e8e)
        .build()
    ) {};
  });
var _It,
  w4,
  VQe = s(() => {
    $();
    Fj();
    Uj();
    $j();
    Hj();
    zj();
    qj();
    OP();
    jj();
    Gj();
    Vj();
    Wj();
    Kj();
    Yj();
    Qj();
    Xj();
    Jj();
    Zj();
    eG();
    tG();
    rG();
    oG();
    nG();
    sG();
    iG();
    aG();
    cG();
    dG();
    mG();
    lG();
    fG();
    uG();
    pG();
    hG();
    gG();
    yG();
    xG();
    EG();
    SG();
    CG();
    bG();
    _G();
    wG();
    TG();
    AG();
    RG();
    IG();
    PG();
    vG();
    OG();
    kG();
    DG();
    NG();
    BG();
    MG();
    LG();
    FG();
    UG();
    $G();
    HG();
    zG();
    qG();
    S0();
    C0();
    jG();
    GG();
    w0();
    VG();
    A0();
    WG();
    KG();
    YG();
    QG();
    XG();
    JG();
    ZG();
    e4();
    t4();
    r4();
    o4();
    n4();
    s4();
    i4();
    a4();
    c4();
    d4();
    m4();
    l4();
    f4();
    u4();
    p4();
    h4();
    g4();
    y4();
    x4();
    E4();
    S4();
    C4();
    b4();
    _4();
    Ym();
    (_It = {
      AbortMultipartUploadCommand: gv,
      CompleteMultipartUploadCommand: yv,
      CopyObjectCommand: xv,
      CreateBucketCommand: Ev,
      CreateBucketMetadataTableConfigurationCommand: Sv,
      CreateMultipartUploadCommand: Cv,
      CreateSessionCommand: Jp,
      DeleteBucketCommand: _v,
      DeleteBucketAnalyticsConfigurationCommand: bv,
      DeleteBucketCorsCommand: wv,
      DeleteBucketEncryptionCommand: Tv,
      DeleteBucketIntelligentTieringConfigurationCommand: Av,
      DeleteBucketInventoryConfigurationCommand: Rv,
      DeleteBucketLifecycleCommand: Iv,
      DeleteBucketMetadataTableConfigurationCommand: Pv,
      DeleteBucketMetricsConfigurationCommand: vv,
      DeleteBucketOwnershipControlsCommand: Ov,
      DeleteBucketPolicyCommand: kv,
      DeleteBucketReplicationCommand: Dv,
      DeleteBucketTaggingCommand: Nv,
      DeleteBucketWebsiteCommand: Bv,
      DeleteObjectCommand: lh,
      DeleteObjectsCommand: Mv,
      DeleteObjectTaggingCommand: Lv,
      DeletePublicAccessBlockCommand: Fv,
      GetBucketAccelerateConfigurationCommand: Uv,
      GetBucketAclCommand: $v,
      GetBucketAnalyticsConfigurationCommand: Hv,
      GetBucketCorsCommand: zv,
      GetBucketEncryptionCommand: qv,
      GetBucketIntelligentTieringConfigurationCommand: jv,
      GetBucketInventoryConfigurationCommand: Gv,
      GetBucketLifecycleConfigurationCommand: Vv,
      GetBucketLocationCommand: Wv,
      GetBucketLoggingCommand: Kv,
      GetBucketMetadataTableConfigurationCommand: Yv,
      GetBucketMetricsConfigurationCommand: Qv,
      GetBucketNotificationConfigurationCommand: Xv,
      GetBucketOwnershipControlsCommand: Jv,
      GetBucketPolicyCommand: Zv,
      GetBucketPolicyStatusCommand: e0,
      GetBucketReplicationCommand: t0,
      GetBucketRequestPaymentCommand: r0,
      GetBucketTaggingCommand: o0,
      GetBucketVersioningCommand: n0,
      GetBucketWebsiteCommand: s0,
      GetObjectCommand: fh,
      GetObjectAclCommand: i0,
      GetObjectAttributesCommand: a0,
      GetObjectLegalHoldCommand: c0,
      GetObjectLockConfigurationCommand: d0,
      GetObjectRetentionCommand: m0,
      GetObjectTaggingCommand: l0,
      GetObjectTorrentCommand: f0,
      GetPublicAccessBlockCommand: u0,
      HeadBucketCommand: p0,
      HeadObjectCommand: h0,
      ListBucketAnalyticsConfigurationsCommand: g0,
      ListBucketIntelligentTieringConfigurationsCommand: y0,
      ListBucketInventoryConfigurationsCommand: x0,
      ListBucketMetricsConfigurationsCommand: E0,
      ListBucketsCommand: uh,
      ListDirectoryBucketsCommand: ph,
      ListMultipartUploadsCommand: b0,
      ListObjectsCommand: _0,
      ListObjectsV2Command: hh,
      ListObjectVersionsCommand: T0,
      ListPartsCommand: gh,
      PutBucketAccelerateConfigurationCommand: R0,
      PutBucketAclCommand: I0,
      PutBucketAnalyticsConfigurationCommand: P0,
      PutBucketCorsCommand: v0,
      PutBucketEncryptionCommand: O0,
      PutBucketIntelligentTieringConfigurationCommand: k0,
      PutBucketInventoryConfigurationCommand: D0,
      PutBucketLifecycleConfigurationCommand: N0,
      PutBucketLoggingCommand: B0,
      PutBucketMetricsConfigurationCommand: M0,
      PutBucketNotificationConfigurationCommand: L0,
      PutBucketOwnershipControlsCommand: F0,
      PutBucketPolicyCommand: U0,
      PutBucketReplicationCommand: $0,
      PutBucketRequestPaymentCommand: H0,
      PutBucketTaggingCommand: z0,
      PutBucketVersioningCommand: q0,
      PutBucketWebsiteCommand: j0,
      PutObjectCommand: yh,
      PutObjectAclCommand: G0,
      PutObjectLegalHoldCommand: V0,
      PutObjectLockConfigurationCommand: W0,
      PutObjectRetentionCommand: K0,
      PutObjectTaggingCommand: Y0,
      PutPublicAccessBlockCommand: Q0,
      RenameObjectCommand: X0,
      RestoreObjectCommand: J0,
      SelectObjectContentCommand: Z0,
      UploadPartCommand: eO,
      UploadPartCopyCommand: tO,
      WriteGetObjectResponseCommand: rO,
    }),
      (w4 = class extends Pn {});
    $R(_It, w4);
  });
var WQe = s(() => {
  Fj();
  Uj();
  $j();
  Hj();
  zj();
  qj();
  OP();
  jj();
  Gj();
  Vj();
  Wj();
  Kj();
  Yj();
  Qj();
  Xj();
  Jj();
  Zj();
  eG();
  tG();
  rG();
  oG();
  nG();
  iG();
  sG();
  aG();
  cG();
  dG();
  mG();
  lG();
  fG();
  uG();
  pG();
  hG();
  gG();
  yG();
  xG();
  EG();
  SG();
  CG();
  bG();
  _G();
  wG();
  TG();
  AG();
  RG();
  IG();
  PG();
  vG();
  OG();
  kG();
  DG();
  NG();
  BG();
  MG();
  LG();
  FG();
  UG();
  $G();
  HG();
  zG();
  qG();
  S0();
  C0();
  jG();
  VG();
  GG();
  w0();
  A0();
  WG();
  KG();
  YG();
  QG();
  XG();
  JG();
  ZG();
  e4();
  t4();
  r4();
  o4();
  n4();
  s4();
  i4();
  a4();
  c4();
  d4();
  m4();
  l4();
  f4();
  u4();
  p4();
  h4();
  g4();
  y4();
  x4();
  E4();
  S4();
  C4();
  b4();
  _4();
});
var KQe = s(() => {});
var Q9o,
  YQe = s(() => {
    Ue();
    S0();
    Ym();
    Q9o = dt(Pn, uh, "ContinuationToken", "ContinuationToken", "MaxBuckets");
  });
var tYo,
  QQe = s(() => {
    Ue();
    C0();
    Ym();
    tYo = dt(
      Pn,
      ph,
      "ContinuationToken",
      "ContinuationToken",
      "MaxDirectoryBuckets"
    );
  });
var iYo,
  XQe = s(() => {
    Ue();
    w0();
    Ym();
    iYo = dt(Pn, hh, "ContinuationToken", "NextContinuationToken", "MaxKeys");
  });
var lYo,
  JQe = s(() => {
    Ue();
    A0();
    Ym();
    lYo = dt(Pn, gh, "PartNumberMarker", "NextPartNumberMarker", "MaxParts");
  });
var ZQe = s(() => {
  KQe();
  YQe();
  QQe();
  XQe();
  JQe();
});
var T4 = s(() => {});
var Vc,
  oO = s(() => {
    (function (e) {
      (e.ABORTED = "ABORTED"),
        (e.FAILURE = "FAILURE"),
        (e.SUCCESS = "SUCCESS"),
        (e.RETRY = "RETRY"),
        (e.TIMEOUT = "TIMEOUT");
    })(Vc || (Vc = {}));
  });
var e7e = s(() => {
  T4();
  oO();
});
var t7e = s(() => {});
var r7e = s(() => {
  T4();
  t7e();
});
var o7e = s(() => {
  e7e();
  r7e();
  oO();
});
var _x = s(() => {
  o7e();
  oO();
});
var n7e = s(() => {
  _x();
});
var s7e = s(() => {
  _x();
});
var i7e = s(() => {
  _x();
});
var a7e = s(() => {
  _x();
});
var c7e = s(() => {
  n7e();
  s7e();
  i7e();
  a7e();
});
var d7e = s(() => {
  Qo();
  Ks();
});
var m7e = s(() => {
  Ym();
  VQe();
  WQe();
  ZQe();
  c7e();
  d7e();
});
var l7e = {};
It(l7e, { default: () => vIt });
import wIt from "node:path";
function IIt() {
  return {
    region: TIt,
    logger: Qm,
    maxAttempts: wx(process.env.AWS_SDK_S3_MAX_ATTEMPTS),
  };
}
function v4(e, t) {
  return wIt.posix.join(
    AIt ?? "",
    t === "fetch" ? "__fetch" : "",
    RIt ?? "",
    t === "fetch" ? e : `${e}.${t}`
  );
}
var TIt,
  AIt,
  RIt,
  I4,
  P4,
  PIt,
  vIt,
  f7e = s(() => {
    m7e();
    mo();
    Eh();
    ({
      CACHE_BUCKET_REGION: TIt,
      CACHE_BUCKET_KEY_PREFIX: AIt,
      NEXT_BUILD_ID: RIt,
      CACHE_BUCKET_NAME: I4,
    } = process.env);
    P4 = new Pn(IIt());
    (PIt = {
      async get(e, t) {
        let r = await P4.send(new fh({ Bucket: I4, Key: v4(e, t ?? "cache") }));
        return {
          value: JSON.parse((await r.Body?.transformToString()) ?? "{}"),
          lastModified: r.LastModified?.getTime(),
        };
      },
      async set(e, t, r) {
        await P4.send(
          new yh({
            Bucket: I4,
            Key: v4(e, r ?? "cache"),
            Body: JSON.stringify(t),
          })
        );
      },
      async delete(e) {
        await P4.send(new lh({ Bucket: I4, Key: v4(e, "cache") }));
      },
      name: "s3",
    }),
      (vIt = PIt);
  });
var p7e = {};
It(p7e, { default: () => NIt });
import { request as OIt } from "node:https";
import { Readable as kIt } from "node:stream";
function u7e(e) {
  let t = {},
    r = [
      "host",
      "connection",
      "via",
      "x-cache",
      "transfer-encoding",
      "content-encoding",
      "content-length",
    ];
  return (
    Object.entries(e)
      .filter(([o, n]) => {
        let i = o.toLowerCase();
        return !(r.includes(i) || i.startsWith("x-amz"));
      })
      .forEach(([o, n]) => {
        t[o] = n?.toString() ?? "";
      }),
    t
  );
}
var DIt,
  NIt,
  h7e = s(() => {
    mo();
    lO();
    (DIt = {
      name: "node-proxy",
      proxy: (e) => {
        let { url: t, headers: r, method: o, body: n } = e;
        return (
          He("proxyRequest", t),
          new Promise((i, a) => {
            let c = u7e(r);
            He("filteredHeaders", c);
            let d = OIt(
              t,
              { headers: c, method: o, rejectUnauthorized: !1 },
              (m) => {
                let f = m.headers,
                  l =
                    f["content-encoding"] === "br"
                      ? m.pipe(Mi("node:zlib").createBrotliDecompress())
                      : f["content-encoding"] === "gzip"
                        ? m.pipe(Mi("node:zlib").createGunzip())
                        : m,
                  u = vx(f["content-type"]) || !!f["content-encoding"],
                  h = {
                    type: "core",
                    headers: u7e(f),
                    statusCode: m.statusCode ?? 200,
                    isBase64Encoded: u,
                    body: kIt.toWeb(l),
                  };
                i(h),
                  m.on("error", (y) => {
                    kr("proxyRequest error", y), a(y);
                  });
              }
            );
            n && o !== "GET" && o !== "HEAD" && d.write(n), d.end();
          })
        );
      },
    }),
      (NIt = DIt);
  });
var g7e = {};
It(g7e, { default: () => BIt });
var BIt,
  y7e = s(() => {
    BIt = { name: "dummy", invalidatePaths: (e) => Promise.resolve() };
  });
ks();
mo();
Eh();
import { AsyncLocalStorage as vXe } from "node:async_hooks";
dO();
import U7e from "node:http";
var Ch = class extends U7e.IncomingMessage {
  constructor({ method: t, url: r, headers: o, body: n, remoteAddress: i }) {
    super({
      encrypted: !0,
      readable: !1,
      remoteAddress: i,
      address: () => ({ port: 443 }),
      end: Function.prototype,
      destroy: Function.prototype,
    }),
      n && (o["content-length"] ??= String(Buffer.byteLength(n))),
      Object.assign(this, {
        ip: i,
        complete: !0,
        httpVersion: "1.1",
        httpVersionMajor: "1",
        httpVersionMinor: "1",
        method: t,
        headers: o,
        body: n,
        url: r,
      }),
      (this._read = () => {
        this.push(n), this.push(null);
      });
  }
};
mo();
var Px = class {
    resolve;
    reject;
    promise;
    constructor() {
      let t, r;
      (this.promise = new Promise((o, n) => {
        (t = o), (r = n);
      })),
        (this.resolve = t),
        (this.reject = r);
    }
  },
  mO = class {
    promises = [];
    withResolvers() {
      let t = new Px();
      return this.promises.push(t), t;
    }
    add(t) {
      let r = new Px();
      this.promises.push(r), t.then(r.resolve, r.reject);
    }
    async await() {
      He(`Awaiting ${this.promises.length} detached promises`),
        (await Promise.allSettled(this.promises.map((o) => o.promise)))
          .filter((o) => o.status === "rejected")
          .forEach((o) => {
            kr(o.reason);
          });
    }
  };
async function $7e() {
  let e = globalThis.__openNextAls.getStore(),
    t = e?.pendingPromiseRunner.await() ?? Promise.resolve();
  if (e?.waitUntil) {
    e.waitUntil(t);
    return;
  }
  await t;
}
function H7e() {
  let e = Symbol.for("@next/request-context"),
    t = Symbol.for("@vercel/request-context"),
    r = globalThis.__openNextAls.getStore(),
    o = r?.waitUntil ?? ((i) => r?.pendingPromiseRunner.add(i)),
    n = { get: () => ({ waitUntil: o }) };
  (globalThis[e] = n),
    process.env.EMULATE_VERCEL_REQUEST_CONTEXT && (globalThis[t] = n);
}
function X4({ isISRRevalidation: e, waitUntil: t }, r) {
  return globalThis.__openNextAls.run(
    {
      requestId: Math.random().toString(36),
      pendingPromiseRunner: new mO(),
      isISRRevalidation: e,
      waitUntil: t,
    },
    async () => {
      H7e();
      let o;
      try {
        o = await r();
      } finally {
        await $7e();
      }
      return o;
    }
  );
}
ks();
mo();
var z7e = Mi("node:module"),
  mPt = z7e._resolveFilename;
Qc();
ks();
mo();
ks();
Zm();
import { createHash as rXe } from "node:crypto";
async function aV(e, t, r) {
  if (globalThis.openNextConfig.dangerous?.disableTagCache) return !1;
  if (!r.value) return !0;
  if ("type" in r && r.type === "page") return !1;
  let n = r.lastModified ?? Date.now();
  return globalThis.tagCache.mode === "nextMode"
    ? await globalThis.tagCache.hasBeenRevalidated(t, n)
    : (await globalThis.tagCache.getLastModified(e, n)) === -1;
}
function cV(e) {
  if (!e) return [];
  try {
    return e.meta?.headers?.["x-next-cache-tags"]?.split(",") ?? [];
  } catch {
    return [];
  }
}
mo();
el();
pO();
var wh = 60 * 60 * 24 * 365,
  dV = 60 * 60 * 24 * 30;
async function mV(e, t, r, o, n) {
  let i = wh,
    a = Object.entries(Fi.routes).find((f) => f[0] === e)?.[1];
  o === void 0 && a
    ? (i = a.initialRevalidateSeconds === !1 ? wh : a.initialRevalidateSeconds)
    : o !== void 0 && (i = o === !1 ? wh : o);
  let c = Math.round((Date.now() - (n ?? 0)) / 1e3),
    d = (f) => rXe("md5").update(f).digest("hex"),
    m = d(t);
  if (o === 0)
    return {
      "cache-control":
        "private, no-cache, no-store, max-age=0, must-revalidate",
      "x-opennext-cache": "ERROR",
      etag: m,
    };
  if (i !== wh) {
    let f = Math.max(i - c, 1);
    He("sMaxAge", {
      finalRevalidate: i,
      age: c,
      lastModified: n,
      revalidate: o,
    });
    let l = f === 1;
    if (l) {
      let u = it.trailingSlash ? `${e}/` : e;
      it.basePath && (u = `${it.basePath}${u}`),
        await globalThis.queue.send({
          MessageBody: {
            host: r,
            url: u,
            eTag: m,
            lastModified: n ?? Date.now(),
          },
          MessageDeduplicationId: d(`${e}-${n}-${m}`),
          MessageGroupId: kx(e),
        });
    }
    return {
      "cache-control": `s-maxage=${f}, stale-while-revalidate=${dV}`,
      "x-opennext-cache": l ? "STALE" : "HIT",
      etag: m,
    };
  }
  return {
    "cache-control": `s-maxage=${wh}, stale-while-revalidate=${dV}`,
    "x-opennext-cache": "HIT",
    etag: m,
  };
}
async function oXe(e, t, r, o) {
  He("Returning result from experimental cache");
  let n = "",
    i = "application/octet-stream",
    a = !1;
  switch (r.type) {
    case "app":
      (a = !!e.headers.rsc),
        (n = a ? r.rsc : r.html),
        (i = a ? "text/x-component" : "text/html; charset=utf-8");
      break;
    case "page":
      (a = !!e.query.__nextDataReq),
        (n = a ? JSON.stringify(r.json) : r.html),
        (i = a ? "application/json" : "text/html; charset=utf-8");
      break;
  }
  let c = await mV(t, n, e.headers.host, r.revalidate, o);
  return {
    type: "core",
    statusCode: 200,
    body: Ox(n, !1),
    isBase64Encoded: !1,
    headers: { ...c, "content-type": i, ...r.meta?.headers },
  };
}
function nXe(e, t) {
  return e.replace(
    new RegExp(`([/#?]${t ? "|%(2f|23|3f|5c)" : ""})`, "gi"),
    (r) => encodeURIComponent(r)
  );
}
function sXe(e) {
  return e
    .split("/")
    .map((t) => {
      try {
        return nXe(decodeURIComponent(t), !0);
      } catch {
        return t;
      }
    })
    .join("/");
}
async function lV(e) {
  if (e.headers["next-action"] || e.headers["x-prerender-revalidate"]) return e;
  let t = Ui(e);
  it.basePath && (t = t.replace(it.basePath, "")),
    (t = t.replace(/\/$/, "")),
    (t = sXe(t)),
    He("Checking cache for", t, Fi);
  let r =
    Object.keys(Fi.routes).includes(t ?? "/") ||
    Object.values(Fi.dynamicRoutes).some((o) =>
      new RegExp(o.routeRegex).test(t)
    );
  if ((He("isISR", r), r))
    try {
      let o = await globalThis.incrementalCache.get(t ?? "/index");
      if ((He("cached data in interceptor", o), !o?.value)) return e;
      if (o.value?.type === "app") {
        let i = cV(o.value);
        if (await aV(t, i, o)) return e;
      }
      let n = e.headers.host;
      switch (o?.value?.type) {
        case "app":
        case "page":
          return oXe(e, t, o.value, o.lastModified);
        case "redirect": {
          let i = await mV(t, "", n, o.value.revalidate, o.lastModified);
          return {
            type: "core",
            statusCode: o.value.meta?.status ?? 307,
            body: Ds(),
            headers: { ...(o.value.meta?.headers ?? {}), ...i },
            isBase64Encoded: !1,
          };
        }
        default:
          return e;
      }
    } catch (o) {
      return He("Error while fetching cache", o), e;
    }
  return e;
}
el();
ks();
function iXe(e) {
  for (var t = [], r = 0; r < e.length; ) {
    var o = e[r];
    if (o === "*" || o === "+" || o === "?") {
      t.push({ type: "MODIFIER", index: r, value: e[r++] });
      continue;
    }
    if (o === "\\") {
      t.push({ type: "ESCAPED_CHAR", index: r++, value: e[r++] });
      continue;
    }
    if (o === "{") {
      t.push({ type: "OPEN", index: r, value: e[r++] });
      continue;
    }
    if (o === "}") {
      t.push({ type: "CLOSE", index: r, value: e[r++] });
      continue;
    }
    if (o === ":") {
      for (var n = "", i = r + 1; i < e.length; ) {
        var a = e.charCodeAt(i);
        if (
          (a >= 48 && a <= 57) ||
          (a >= 65 && a <= 90) ||
          (a >= 97 && a <= 122) ||
          a === 95
        ) {
          n += e[i++];
          continue;
        }
        break;
      }
      if (!n) throw new TypeError("Missing parameter name at ".concat(r));
      t.push({ type: "NAME", index: r, value: n }), (r = i);
      continue;
    }
    if (o === "(") {
      var c = 1,
        d = "",
        i = r + 1;
      if (e[i] === "?")
        throw new TypeError('Pattern cannot start with "?" at '.concat(i));
      for (; i < e.length; ) {
        if (e[i] === "\\") {
          d += e[i++] + e[i++];
          continue;
        }
        if (e[i] === ")") {
          if ((c--, c === 0)) {
            i++;
            break;
          }
        } else if (e[i] === "(" && (c++, e[i + 1] !== "?"))
          throw new TypeError("Capturing groups are not allowed at ".concat(i));
        d += e[i++];
      }
      if (c) throw new TypeError("Unbalanced pattern at ".concat(r));
      if (!d) throw new TypeError("Missing pattern at ".concat(r));
      t.push({ type: "PATTERN", index: r, value: d }), (r = i);
      continue;
    }
    t.push({ type: "CHAR", index: r, value: e[r++] });
  }
  return t.push({ type: "END", index: r, value: "" }), t;
}
function fV(e, t) {
  t === void 0 && (t = {});
  for (
    var r = iXe(e),
      o = t.prefixes,
      n = o === void 0 ? "./" : o,
      i = t.delimiter,
      a = i === void 0 ? "/#?" : i,
      c = [],
      d = 0,
      m = 0,
      f = "",
      l = function (No) {
        if (m < r.length && r[m].type === No) return r[m++].value;
      },
      u = function (No) {
        var _r = l(No);
        if (_r !== void 0) return _r;
        var wo = r[m],
          Wc = wo.type,
          A7e = wo.index;
        throw new TypeError(
          "Unexpected ".concat(Wc, " at ").concat(A7e, ", expected ").concat(No)
        );
      },
      h = function () {
        for (var No = "", _r; (_r = l("CHAR") || l("ESCAPED_CHAR")); ) No += _r;
        return No;
      },
      y = function (No) {
        for (var _r = 0, wo = a; _r < wo.length; _r++) {
          var Wc = wo[_r];
          if (No.indexOf(Wc) > -1) return !0;
        }
        return !1;
      },
      S = function (No) {
        var _r = c[c.length - 1],
          wo = No || (_r && typeof _r == "string" ? _r : "");
        if (_r && !wo)
          throw new TypeError(
            'Must have text between two parameters, missing text after "'.concat(
              _r.name,
              '"'
            )
          );
        return !wo || y(wo)
          ? "[^".concat(Ca(a), "]+?")
          : "(?:(?!".concat(Ca(wo), ")[^").concat(Ca(a), "])+?");
      };
    m < r.length;

  ) {
    var E = l("CHAR"),
      b = l("NAME"),
      v = l("PATTERN");
    if (b || v) {
      var I = E || "";
      n.indexOf(I) === -1 && ((f += I), (I = "")),
        f && (c.push(f), (f = "")),
        c.push({
          name: b || d++,
          prefix: I,
          suffix: "",
          pattern: v || S(I),
          modifier: l("MODIFIER") || "",
        });
      continue;
    }
    var O = E || l("ESCAPED_CHAR");
    if (O) {
      f += O;
      continue;
    }
    f && (c.push(f), (f = ""));
    var ge = l("OPEN");
    if (ge) {
      var I = h(),
        Fe = l("NAME") || "",
        Vt = l("PATTERN") || "",
        yt = h();
      u("CLOSE"),
        c.push({
          name: Fe || (Vt ? d++ : ""),
          pattern: Fe && !Vt ? S(I) : Vt,
          prefix: I,
          suffix: yt,
          modifier: l("MODIFIER") || "",
        });
      continue;
    }
    u("END");
  }
  return c;
}
function tl(e, t) {
  return aXe(fV(e, t), t);
}
function aXe(e, t) {
  t === void 0 && (t = {});
  var r = xO(t),
    o = t.encode,
    n =
      o === void 0
        ? function (d) {
            return d;
          }
        : o,
    i = t.validate,
    a = i === void 0 ? !0 : i,
    c = e.map(function (d) {
      if (typeof d == "object")
        return new RegExp("^(?:".concat(d.pattern, ")$"), r);
    });
  return function (d) {
    for (var m = "", f = 0; f < e.length; f++) {
      var l = e[f];
      if (typeof l == "string") {
        m += l;
        continue;
      }
      var u = d ? d[l.name] : void 0,
        h = l.modifier === "?" || l.modifier === "*",
        y = l.modifier === "*" || l.modifier === "+";
      if (Array.isArray(u)) {
        if (!y)
          throw new TypeError(
            'Expected "'.concat(l.name, '" to not repeat, but got an array')
          );
        if (u.length === 0) {
          if (h) continue;
          throw new TypeError('Expected "'.concat(l.name, '" to not be empty'));
        }
        for (var S = 0; S < u.length; S++) {
          var E = n(u[S], l);
          if (a && !c[f].test(E))
            throw new TypeError(
              'Expected all "'
                .concat(l.name, '" to match "')
                .concat(l.pattern, '", but got "')
                .concat(E, '"')
            );
          m += l.prefix + E + l.suffix;
        }
        continue;
      }
      if (typeof u == "string" || typeof u == "number") {
        var E = n(String(u), l);
        if (a && !c[f].test(E))
          throw new TypeError(
            'Expected "'
              .concat(l.name, '" to match "')
              .concat(l.pattern, '", but got "')
              .concat(E, '"')
          );
        m += l.prefix + E + l.suffix;
        continue;
      }
      if (!h) {
        var b = y ? "an array" : "a string";
        throw new TypeError('Expected "'.concat(l.name, '" to be ').concat(b));
      }
    }
    return m;
  };
}
function yO(e, t) {
  var r = [],
    o = uV(e, r, t);
  return cXe(o, r, t);
}
function cXe(e, t, r) {
  r === void 0 && (r = {});
  var o = r.decode,
    n =
      o === void 0
        ? function (i) {
            return i;
          }
        : o;
  return function (i) {
    var a = e.exec(i);
    if (!a) return !1;
    for (
      var c = a[0],
        d = a.index,
        m = Object.create(null),
        f = function (u) {
          if (a[u] === void 0) return "continue";
          var h = t[u - 1];
          h.modifier === "*" || h.modifier === "+"
            ? (m[h.name] = a[u].split(h.prefix + h.suffix).map(function (y) {
                return n(y, h);
              }))
            : (m[h.name] = n(a[u], h));
        },
        l = 1;
      l < a.length;
      l++
    )
      f(l);
    return { path: c, index: d, params: m };
  };
}
function Ca(e) {
  return e.replace(/([.+*?=^!:${}()[\]|/\\])/g, "\\$1");
}
function xO(e) {
  return e && e.sensitive ? "" : "i";
}
function dXe(e, t) {
  if (!t) return e;
  for (var r = /\((?:\?<(.*?)>)?(?!\?)/g, o = 0, n = r.exec(e.source); n; )
    t.push({
      name: n[1] || o++,
      prefix: "",
      suffix: "",
      modifier: "",
      pattern: "",
    }),
      (n = r.exec(e.source));
  return e;
}
function mXe(e, t, r) {
  var o = e.map(function (n) {
    return uV(n, t, r).source;
  });
  return new RegExp("(?:".concat(o.join("|"), ")"), xO(r));
}
function lXe(e, t, r) {
  return fXe(fV(e, r), t, r);
}
function fXe(e, t, r) {
  r === void 0 && (r = {});
  for (
    var o = r.strict,
      n = o === void 0 ? !1 : o,
      i = r.start,
      a = i === void 0 ? !0 : i,
      c = r.end,
      d = c === void 0 ? !0 : c,
      m = r.encode,
      f =
        m === void 0
          ? function (_r) {
              return _r;
            }
          : m,
      l = r.delimiter,
      u = l === void 0 ? "/#?" : l,
      h = r.endsWith,
      y = h === void 0 ? "" : h,
      S = "[".concat(Ca(y), "]|$"),
      E = "[".concat(Ca(u), "]"),
      b = a ? "^" : "",
      v = 0,
      I = e;
    v < I.length;
    v++
  ) {
    var O = I[v];
    if (typeof O == "string") b += Ca(f(O));
    else {
      var ge = Ca(f(O.prefix)),
        Fe = Ca(f(O.suffix));
      if (O.pattern)
        if ((t && t.push(O), ge || Fe))
          if (O.modifier === "+" || O.modifier === "*") {
            var Vt = O.modifier === "*" ? "?" : "";
            b += "(?:"
              .concat(ge, "((?:")
              .concat(O.pattern, ")(?:")
              .concat(Fe)
              .concat(ge, "(?:")
              .concat(O.pattern, "))*)")
              .concat(Fe, ")")
              .concat(Vt);
          } else
            b += "(?:"
              .concat(ge, "(")
              .concat(O.pattern, ")")
              .concat(Fe, ")")
              .concat(O.modifier);
        else {
          if (O.modifier === "+" || O.modifier === "*")
            throw new TypeError(
              'Can not repeat "'.concat(O.name, '" without a prefix and suffix')
            );
          b += "(".concat(O.pattern, ")").concat(O.modifier);
        }
      else b += "(?:".concat(ge).concat(Fe, ")").concat(O.modifier);
    }
  }
  if (d)
    n || (b += "".concat(E, "?")),
      (b += r.endsWith ? "(?=".concat(S, ")") : "$");
  else {
    var yt = e[e.length - 1],
      No =
        typeof yt == "string"
          ? E.indexOf(yt[yt.length - 1]) > -1
          : yt === void 0;
    n || (b += "(?:".concat(E, "(?=").concat(S, "))?")),
      No || (b += "(?=".concat(E, "|").concat(S, ")"));
  }
  return new RegExp(b, xO(r));
}
function uV(e, t, r) {
  return e instanceof RegExp
    ? dXe(e, t)
    : Array.isArray(e)
      ? mXe(e, t, r)
      : lXe(e, t, r);
}
function pV(e) {
  let t = e.host + e.pathname;
  return `${e.protocol}//${t.replace(/\\/g, "/").replace(/\/\/+/g, "/")}${e.search}`;
}
Zm();
mo();
el();
ks();
var uXe = `^/(?:${vn.locales.map((e) => `${e}/?`).join("|")})?`,
  pXe = vn.basePath ? `^${vn.basePath}/?` : "^/",
  hXe = uXe.replace("^/", pXe);
function hV(e) {
  let t = e.map((n) => ({
      page: n.page,
      regexp: new RegExp(n.regex.replace("^/", hXe)),
    })),
    r = new Set(),
    o = new Set();
  for (let [n, i] of Object.entries(aO))
    n.endsWith("page") ? r.add(i) : n.endsWith("route") && o.add(i);
  return function (i) {
    return t
      .filter((c) => c.regexp.test(i))
      .map((c) => {
        let d = "page";
        return (
          r.has(c.page) ? (d = "app") : o.has(c.page) && (d = "route"),
          { route: c.page, type: d }
        );
      });
  };
}
var Th = hV([...vn.routes.static, ...gXe()]),
  Ah = hV(vn.routes.dynamic);
function gXe() {
  let e = (n) => ({ page: n, regex: `^${n}(?:/)?$` }),
    t = new Set(vn.routes.dynamic.map(({ page: n }) => n)),
    r = Object.keys(V4)
      .filter((n) => n.startsWith("/api/") && !t.has(n))
      .map(e),
    o = Object.values(aO)
      .filter((n) => n.startsWith("/api/") || (n === "/api" && !t.has(n)))
      .map(e);
  return [...r, ...o];
}
Qc();
var yV = (e, t, r) => (o) => {
  switch (o.type) {
    case "header":
      return (
        !!e?.[o.key.toLowerCase()] &&
        new RegExp(o.value ?? "").test(e[o.key.toLowerCase()] ?? "")
      );
    case "cookie":
      return !!t?.[o.key] && new RegExp(o.value ?? "").test(t[o.key] ?? "");
    case "query":
      return r[o.key] && Array.isArray(o.value)
        ? o.value.reduce((n, i) => n || new RegExp(i).test(r[o.key]), !1)
        : new RegExp(o.value ?? "").test(r[o.key] ?? "");
    case "host":
      return e?.host !== "" && new RegExp(o.value ?? "").test(e.host);
    default:
      return !1;
  }
};
function Mx(e, t, r = !1) {
  return t ? t.reduce((o, n) => (o === !1 ? !1 : r ? !e(n) : e(n)), !0) : !0;
}
var yXe = (e) => (t) => {
    He("value", t);
    let r = e(t);
    return r ? r.params : {};
  },
  xXe = (e, t, r) => (o) => {
    if (!o.value) return {};
    let n = new RegExp(`^${o.value}$`),
      i = (a) => a.match(n)?.groups ?? {};
    switch (o.type) {
      case "header":
        return i(e[o.key.toLowerCase()] ?? "");
      case "cookie":
        return i(t[o.key] ?? "");
      case "query":
        return Array.isArray(r[o.key])
          ? i(r[o.key].join(","))
          : i(r[o.key] ?? "");
      case "host":
        return i(e.host ?? "");
    }
  };
function gV(e, t, r) {
  if (!e) return r;
  let { params: o } = e;
  return Object.keys(o).length > 0 ? t(o) : r;
}
function xV(e, t) {
  if (!t) return {};
  let r = yV(e.headers, e.cookies, e.query),
    o = {},
    n = Ui(e);
  for (let {
    headers: i,
    has: a,
    missing: c,
    regex: d,
    source: m,
    locale: f,
  } of t) {
    let l = f === !1 ? e.rawPath : n;
    if (new RegExp(d).test(l) && Mx(r, a) && Mx(r, c, !0)) {
      let h = yO(m)(l);
      i.forEach((y) => {
        try {
          let S = gV(h, tl(y.key), y.key),
            E = gV(h, tl(y.value), y.value);
          o[S] = E;
        } catch {
          He(`Error matching header ${y.key} with value ${y.value}`),
            (o[y.key] = y.value);
        }
      });
    }
  }
  return o;
}
function Rh(e, t) {
  let { rawPath: r, headers: o, query: n, cookies: i, url: a } = e,
    c = Ui(e),
    d = yV(o, i, n),
    m = xXe(o, i, n),
    f = t.find((y) => {
      let S = y.locale === !1 ? r : c;
      return (
        new RegExp(y.regex).test(S) && Mx(d, y.has) && Mx(d, y.missing, !0)
      );
    }),
    l = n,
    u = a,
    h = Dx(f?.destination);
  if ((He("isExternalRewrite", h), f)) {
    let {
        pathname: y,
        protocol: S,
        hostname: E,
        queryString: b,
      } = oV(f.destination, h),
      v = f.locale === !1 ? r : c;
    He("urlParts", { pathname: y, protocol: S, hostname: E, queryString: b });
    let I = tl(_h(y, { isPath: !0 })),
      O = tl(_h(E)),
      ge = tl(_h(b)),
      Fe = {
        ...yXe(yO(_h(f.source, { isPath: !0 })))(v),
        ...f.has?.reduce((wo, Wc) => Object.assign(wo, m(Wc)), {}),
        ...f.missing?.reduce((wo, Wc) => Object.assign(wo, m(Wc)), {}),
      },
      Vt = Object.keys(Fe).length > 0,
      yt = b,
      No = E,
      _r = y;
    if (
      (Vt && ((_r = Bx(I(Fe))), (No = Bx(O(Fe))), (yt = Bx(ge(Fe)))),
      it.i18n && !h)
    ) {
      let wo = _r.replace(new RegExp(`^/(${it.i18n.locales.join("|")})`), "");
      wo.startsWith("/api/") && (_r = wo);
    }
    (u = h ? `${S}//${No}${_r}` : new URL(_r, e.url).href),
      (l = { ...n, ...rV(yt) }),
      (u += hO(l)),
      He("rewrittenUrl", { rewrittenUrl: u, finalQuery: l, isUsingParams: Vt });
  }
  return {
    internalEvent: { ...e, query: l, rawPath: new URL(u).pathname, url: u },
    __rewrite: f,
    isExternalRewrite: h,
  };
}
function EXe(e) {
  return e.rawPath.match(/(\\|\/\/)/)
    ? {
        type: e.type,
        statusCode: 308,
        headers: { Location: pV(new URL(e.url)) },
        body: Ds(),
        isBase64Encoded: !1,
      }
    : !1;
}
function SXe(e) {
  if (
    new URL(e.rawPath, "http://localhost").host !== "localhost" ||
    it.skipTrailingSlashRedirect ||
    e.rawPath.startsWith("/api/")
  )
    return !1;
  let r = Ds();
  if (
    it.trailingSlash &&
    !e.headers["x-nextjs-data"] &&
    !e.rawPath.endsWith("/") &&
    !e.rawPath.match(/[\w-]+\.[\w]+$/g)
  ) {
    let o = e.url.split("?");
    return {
      type: e.type,
      statusCode: 308,
      headers: { Location: `${o[0]}/${o[1] ? `?${o[1]}` : ""}` },
      body: r,
      isBase64Encoded: !1,
    };
  }
  if (!it.trailingSlash && e.rawPath.endsWith("/") && e.rawPath !== "/") {
    let o = e.url.split("?");
    return {
      type: e.type,
      statusCode: 308,
      headers: {
        Location: `${o[0].replace(/\/$/, "")}${o[1] ? `?${o[1]}` : ""}`,
      },
      body: r,
      isBase64Encoded: !1,
    };
  }
  return !1;
}
function EV(e, t) {
  let r = EXe(e);
  if (r) return r;
  let o = SXe(e);
  if (o) return o;
  let n = eV(e);
  if (n) return n;
  let { internalEvent: i, __rewrite: a } = Rh(
    e,
    t.filter((c) => !c.internal)
  );
  if (a && !a.internal)
    return {
      type: e.type,
      statusCode: a.statusCode ?? 308,
      headers: { Location: i.url },
      body: Ds(),
      isBase64Encoded: !1,
    };
}
function SV(e, t) {
  let { rawPath: r, query: o } = e,
    n = `${it.basePath ?? ""}/_next/data/${t}`;
  if (r.startsWith("/_next/data") && !r.startsWith(n))
    return {
      type: e.type,
      statusCode: 404,
      body: Ox("{}"),
      headers: { "Content-Type": "application/json" },
      isBase64Encoded: !1,
    };
  if (r.startsWith(n) && r.endsWith(".json")) {
    let i = r.slice(n.length, -5).replace(/^\/index$/, "/");
    return (
      (o.__nextDataReq = "1"),
      { ...e, rawPath: i, query: o, url: new URL(`${i}${hO(o)}`, e.url).href }
    );
  }
  return e;
}
function CV(e, t) {
  let { rawPath: r } = e,
    { dynamicRoutes: o, routes: n } = t,
    i = Object.entries(o).filter(([, { fallback: y }]) => y === !1),
    a = i.some(([, { routeRegex: y }]) => new RegExp(y).test(r)),
    c = it.i18n?.locales,
    m =
      c?.includes(r.split("/")[1]) || c === void 0
        ? r
        : `/${it.i18n?.defaultLocale}${r}`;
  m !== "/" && it.trailingSlash && m.endsWith("/") && (m = m.slice(0, -1));
  let f = Th(m),
    l = i.map(([y]) => y),
    u = Ah(m).filter(({ route: y }) => !l.includes(y)),
    h = Object.keys(n).includes(m);
  return a && !h && f.length === 0 && u.length === 0
    ? {
        event: {
          ...e,
          rawPath: "/404",
          url: $i(e.url, "/404"),
          headers: { ...e.headers, "x-invoke-status": "404" },
        },
        isISR: !1,
      }
    : { event: e, isISR: a || h };
}
ks();
Zm();
EO();
el();
Qc();
var CXe = W4,
  bXe = K4,
  _Xe = sV(CXe, bXe);
function wXe() {
  return import("./middleware.mjs");
}
async function TV(e, t, r = wXe) {
  let o = e.headers;
  if (o["x-isr"] && o["x-prerender-revalidate"] === Fi.preview.previewModeId)
    return e;
  let n = Ui(e);
  if (!_Xe.some((O) => O.test(n))) return e;
  let a = new URL(n, e.url);
  a.search = t;
  let c = a.href,
    m = await (
      await r()
    ).default({
      geo: {
        city: decodeURIComponent(o["x-open-next-city"]),
        country: o["x-open-next-country"],
        region: o["x-open-next-region"],
        latitude: o["x-open-next-latitude"],
        longitude: o["x-open-next-longitude"],
      },
      headers: o,
      method: e.method || "GET",
      nextConfig: {
        basePath: it.basePath,
        i18n: it.i18n,
        trailingSlash: it.trailingSlash,
      },
      url: c,
      body: iV(e.method, e.body),
    }),
    f = m.status,
    l = m.headers,
    u = {},
    h = {},
    y = [
      "x-middleware-override-headers",
      "x-middleware-next",
      "x-middleware-rewrite",
      "content-encoding",
    ],
    S = "x-middleware-request-";
  l.forEach((O, ge) => {
    if (ge.startsWith(S)) {
      let Fe = ge.substring(S.length);
      u[Fe] = O;
    } else {
      if (y.includes(ge.toLowerCase())) return;
      ge.toLowerCase() === "set-cookie"
        ? (h[ge] = h[ge] ? [...h[ge], O] : [O])
        : (h[ge] = O);
    }
  });
  let E = l.get("x-middleware-rewrite"),
    b = !1,
    v = e.query,
    I = e.url;
  if (E)
    if (((I = E), Dx(I, e.headers.host))) b = !0;
    else {
      let O = new URL(E);
      (v = wV(O.searchParams)),
        "__nextDataReq" in e.query && (v.__nextDataReq = e.query.__nextDataReq);
    }
  if (!E && !l.get("x-middleware-next")) {
    let O = m.body ?? Ds();
    return {
      type: e.type,
      statusCode: f,
      headers: h,
      body: O,
      isBase64Encoded: !1,
    };
  }
  return {
    responseHeaders: h,
    url: I,
    rawPath: new URL(I).pathname,
    type: e.type,
    headers: { ...e.headers, ...u },
    body: e.body,
    method: e.method,
    query: v,
    cookies: e.cookies,
    remoteAddress: e.remoteAddress,
    isExternalRewrite: b,
  };
}
Qc();
var Ih = "x-middleware-response-",
  RV = Ih.length,
  Lx = "x-opennext-",
  IV = `${Lx}initial-url`,
  xvt = `${Lx}locale`,
  SO = `${Lx}resolved-routes`,
  TXe = {
    "x-open-next-city": "x-vercel-ip-city",
    "x-open-next-country": "x-vercel-ip-country",
    "x-open-next-region": "x-vercel-ip-country-region",
    "x-open-next-latitude": "x-vercel-ip-latitude",
    "x-open-next-longitude": "x-vercel-ip-longitude",
  };
function AV(e, t, r = !0) {
  let o = r ? Ih : "";
  Object.entries(t).forEach(([n, i]) => {
    i && (e[o + n] = Array.isArray(i) ? i.join(",") : i);
  });
}
async function CO(e) {
  try {
    for (let [E, b] of Object.entries(TXe)) {
      let v = e.headers[E];
      v && (e.headers[b] = v);
    }
    for (let E of Object.keys(e.headers))
      (E.startsWith(Lx) || E.startsWith(Ih)) && delete e.headers[E];
    let t = xV(e, G4),
      r = SV(e, Xm);
    if ("statusCode" in r) return r;
    let o = EV(r, vn.redirects);
    if (o)
      return (
        (o.headers.Location = new URL(o.headers.Location).href),
        He("redirect", o),
        o
      );
    let n = await TV(r, new URL(e.url).search);
    if ("statusCode" in n) return n;
    let a = n.responseHeaders,
      c = n.isExternalRewrite ?? !1;
    if (((r = n), !c)) {
      let E = Rh(r, vn.rewrites.beforeFiles);
      (r = E.internalEvent), (c = E.isExternalRewrite);
    }
    let d = Th(r.rawPath),
      m = !c && d.length > 0;
    if (!(m || c)) {
      let E = Rh(r, vn.rewrites.afterFiles);
      (r = E.internalEvent), (c = E.isExternalRewrite);
    }
    let f = !1;
    if (!c) {
      let E = CV(r, Fi);
      (r = E.event), (f = E.isISR);
    }
    let l = Ah(r.rawPath),
      u = !c && l.length > 0;
    if (!(u || m || c)) {
      let E = Rh(r, vn.rewrites.fallback);
      (r = E.internalEvent), (c = E.isExternalRewrite);
    }
    let h = r.rawPath.startsWith("/_next/image");
    if (
      (m ||
        u ||
        c ||
        h ||
        Th(r.rawPath).length > 0 ||
        Ah(r.rawPath).length > 0 ||
        (r = {
          ...r,
          rawPath: "/404",
          url: $i(r.url, "/404"),
          headers: {
            ...r.headers,
            "x-middleware-response-cache-control":
              "private, no-cache, no-store, max-age=0, must-revalidate",
          },
        }),
      globalThis.openNextConfig.dangerous?.enableCacheInterception &&
        !("statusCode" in r) &&
        (He("Cache interception enabled"),
        (r = await lV(r)),
        "statusCode" in r))
    )
      return AV(r.headers, { ...a, ...t }, !1), r;
    AV(r.headers, { ...a, ...t });
    let S = [...d, ...l];
    return (
      He("resolvedRoutes", S),
      {
        internalEvent: r,
        isExternalRewrite: c,
        origin: !1,
        isISR: f,
        resolvedRoutes: S,
        initialURL: e.url,
        locale: it.i18n ? bh(r, it.i18n) : void 0,
      }
    );
  } catch (t) {
    return (
      kr("Error in routingHandler", t),
      {
        internalEvent: {
          type: "core",
          method: "GET",
          rawPath: "/500",
          url: $i(e.url, "/500"),
          headers: { ...e.headers },
          query: e.query,
          cookies: e.cookies,
          remoteAddress: e.remoteAddress,
        },
        isExternalRewrite: !1,
        origin: !1,
        isISR: !1,
        resolvedRoutes: [],
        initialURL: e.url,
        locale: it.i18n ? bh(e, it.i18n) : void 0,
      }
    );
  }
}
ks();
mo();
import RXe from "next/dist/server/next-server.js";
mo();
var AXe = Mi("node:module"),
  Cvt = AXe._resolveFilename;
var IXe = Mi.resolve("./cache.cjs"),
  PXe = Mi.resolve("./composable-cache.cjs"),
  ol = new RXe.default({
    conf: {
      ...it,
      compress: !1,
      cacheHandler: IXe,
      cacheMaxMemorySize: 0,
      experimental: {
        ...it.experimental,
        trustHostHeader: !0,
        cacheHandlers: { default: PXe },
      },
    },
    customServer: !1,
    dev: !1,
    dir: __dirname,
  }),
  rl = !1;
globalThis.__next_route_preloader = async (e) => {
  if (rl) return;
  let r =
    (globalThis.fnName
      ? globalThis.openNextConfig.functions[globalThis.fnName]
      : globalThis.openNextConfig.default
    )?.routePreloadingBehavior ?? "none";
  if (r === "none") {
    rl = !0;
    return;
  }
  if (!("unstable_preloadEntries" in ol)) {
    He(
      "The current version of Next.js does not support route preloading. Skipping route preloading."
    ),
      (rl = !0);
    return;
  }
  if (e === "waitUntil" && r === "withWaitUntil") {
    let o = globalThis.__openNextAls.getStore()?.waitUntil;
    if (!o) {
      kr(
        "You've tried to use the 'withWaitUntil' route preloading behavior, but the 'waitUntil' function is not available."
      ),
        (rl = !0);
      return;
    }
    He("Preloading entries with waitUntil"),
      o?.(ol.unstable_preloadEntries()),
      (rl = !0);
  } else if (
    (e === "start" && r === "onStart") ||
    (e === "warmerEvent" && r === "onWarmerEvent") ||
    e === "onDemand"
  ) {
    let o = Date.now();
    He("Preloading entries"),
      await ol.unstable_preloadEntries(),
      He("Preloading entries took", Date.now() - o, "ms"),
      (rl = !0);
  }
};
var Fx = (e) =>
  "getRequestHandlerWithMetadata" in ol
    ? ol.getRequestHandlerWithMetadata(e)
    : ol.getRequestHandler();
globalThis.__openNextAls = new vXe();
async function PV(e, t) {
  let r = e.headers;
  return X4(
    { isISRRevalidation: r["x-isr"] === "1", waitUntil: t?.waitUntil },
    async () => {
      await globalThis.__next_route_preloader("waitUntil"),
        r["x-forwarded-host"] && (r.host = r["x-forwarded-host"]),
        He("internalEvent", e);
      let o = {
          initialPath: r[IV] ?? e.rawPath,
          resolvedRoutes: r[SO] ? JSON.parse(r[SO]) : [],
        },
        n = {
          internalEvent: e,
          isExternalRewrite: !1,
          origin: !1,
          isISR: !1,
          initialURL: e.url,
          ...o,
        };
      n = await CO(e);
      let i = "type" in n ? n.headers : n.internalEvent.headers,
        a = {};
      for (let [ge, Fe] of Object.entries(i)) {
        if (!ge.startsWith(Ih)) continue;
        let Vt = ge.slice(RV);
        Vt !== "x-middleware-set-cookie" && (a[Vt] = Fe),
          (i[Vt] = Fe),
          delete i[ge];
      }
      if ("isExternalRewrite" in n && n.isExternalRewrite === !0)
        try {
          n = await globalThis.proxyExternalRequest.proxy(n.internalEvent);
        } catch (ge) {
          kr("External request failed.", ge),
            (n = {
              internalEvent: {
                type: "core",
                rawPath: "/500",
                method: "GET",
                headers: {},
                url: $i(e.url, "/500"),
                query: {},
                cookies: {},
                remoteAddress: "",
              },
              isExternalRewrite: !1,
              isISR: !1,
              origin: !1,
              initialURL: e.url,
              resolvedRoutes: [{ route: "/500", type: "page" }],
            });
        }
      if ("type" in n) {
        if (t?.streamCreator) {
          let ge = gO(
            {
              internalEvent: e,
              isExternalRewrite: !1,
              isISR: !1,
              resolvedRoutes: [],
              origin: !1,
              initialURL: e.url,
            },
            n.headers,
            t.streamCreator
          );
          (ge.statusCode = n.statusCode), ge.flushHeaders();
          let [Fe, Vt] = n.body.tee();
          for await (let yt of Fe) ge.write(yt);
          ge.end(), (n.body = Vt);
        }
        return n;
      }
      let c = n.internalEvent;
      He("preprocessedEvent", c);
      let { search: d, pathname: m, hash: f } = new URL(c.url),
        l = {
          method: c.method,
          url: `${m}${d}${f}`,
          headers: { ...i },
          body: c.body,
          remoteAddress: c.remoteAddress,
        },
        u = globalThis.openNextConfig.dangerous?.headersAndCookiesPriority
          ? globalThis.openNextConfig.dangerous.headersAndCookiesPriority(c)
          : "middleware",
        h = globalThis.__openNextAls.getStore();
      h && (h.mergeHeadersPriority = u);
      let y = new Ch(l),
        S = gO(n, a, t?.streamCreator);
      await OXe(y, S, n);
      let { statusCode: E, headers: b, isBase64Encoded: v, body: I } = nV(S);
      return {
        type: e.type,
        statusCode: E,
        headers: b,
        body: I,
        isBase64Encoded: v,
      };
    }
  );
}
async function OXe(e, t, r) {
  delete e.body;
  let o = new URL(r.initialURL),
    n;
  r.internalEvent.rawPath === "/500"
    ? (n = 500)
    : r.internalEvent.rawPath === "/404" && (n = 404);
  let i = {
    isNextDataReq: r.internalEvent.query.__nextDataReq === "1",
    initURL: r.initialURL,
    initQuery: Nx(o.search),
    initProtocol: o.protocol,
    defaultLocale: it.i18n?.defaultLocale,
    locale: r.locale,
    middlewareInvoke: !1,
    invokePath: r.internalEvent.rawPath,
    invokeQuery: r.internalEvent.query,
    invokeStatus: n,
  };
  try {
    await Fx(i)(e, t);
  } catch (a) {
    a.constructor.name === "NoFallbackError"
      ? await vV(e, t, r, i)
      : (kr("NextJS request failed.", a), await Ux("500", t, r.internalEvent));
  }
}
async function vV(e, t, r, o, n = 1) {
  if (n >= 5) {
    await Ux("500", t, r.internalEvent);
    return;
  }
  if (n >= r.resolvedRoutes.length) {
    await Ux("404", t, r.internalEvent);
    return;
  }
  try {
    await Fx({ ...r, invokeOutput: r.resolvedRoutes[n].route, ...o })(e, t);
  } catch (i) {
    i.constructor.name === "NoFallbackError"
      ? await vV(e, t, r, o, n + 1)
      : (kr("NextJS request failed.", i), await Ux("500", t, r.internalEvent));
  }
}
async function Ux(e, t, r) {
  try {
    let o = new Ch({
      method: "GET",
      url: `/${e}`,
      headers: r.headers,
      body: r.body,
      remoteAddress: r.remoteAddress,
    });
    await Fx({
      invokePath: e === "404" ? "/404" : "/500",
      invokeStatus: e === "404" ? 404 : 500,
      middlewareInvoke: !1,
    })(o, t);
  } catch (o) {
    kr("NextJS request failed.", o),
      t.setHeader("Content-Type", "application/json"),
      t.end(
        JSON.stringify(
          { message: "Server failed to respond.", details: o },
          null,
          2
        )
      );
  }
}
async function x7e(e) {
  return typeof e == "function"
    ? e()
    : (await Promise.resolve().then(() => (kV(), OV))).default;
}
async function E7e(e) {
  return typeof e == "function"
    ? e()
    : (await Promise.resolve().then(() => (BV(), NV))).default;
}
async function S7e(e) {
  return typeof e == "function"
    ? e()
    : (await Promise.resolve().then(() => (Ibe(), Rbe))).default;
}
async function C7e(e) {
  return typeof e == "function"
    ? e()
    : (await Promise.resolve().then(() => (vke(), Pke))).default;
}
async function b7e(e) {
  return typeof e == "function"
    ? e()
    : (await Promise.resolve().then(() => (f7e(), l7e))).default;
}
async function _7e(e) {
  return typeof e == "function"
    ? e()
    : (await Promise.resolve().then(() => (h7e(), p7e))).default;
}
async function w7e(e) {
  return typeof e == "function"
    ? e()
    : (await Promise.resolve().then(() => (y7e(), g7e))).default;
}
async function T7e() {
  let e = await import("./open-next.config.mjs").then((i) => i.default),
    t = globalThis.fnName ? e.functions[globalThis.fnName] : e.default;
  (globalThis.serverId = Q4()),
    (globalThis.openNextConfig = e),
    await globalThis.__next_route_preloader("start"),
    (globalThis.queue = await C7e(t.override?.queue)),
    (globalThis.incrementalCache = await b7e(t.override?.incrementalCache)),
    (globalThis.tagCache = await S7e(t.override?.tagCache)),
    (globalThis.proxyExternalRequest = await _7e(
      t.override?.proxyExternalRequest
    )),
    (globalThis.cdnInvalidationHandler = await w7e(
      t.override?.cdnInvalidation
    ));
  let r = await x7e(t.override?.converter),
    { wrapper: o, name: n } = await E7e(t.override?.wrapper);
  return He("Using wrapper", n), o(PV, r);
}
Eh();
Y4();
LIt();
MIt();
globalThis.internalFetch = fetch;
var TQo = await T7e();
function MIt() {
  process.chdir(__dirname);
}
function LIt() {
  process.env.NEXT_BUILD_ID = Xm;
}
export { TQo as handler };

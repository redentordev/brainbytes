"use strict";
(exports.id = 680),
  (exports.ids = [680]),
  (exports.modules = {
    257: (e, t, r) => {
      r.d(t, { f: () => s });
      var i = r(96051);
      let n = (0, i.CN)({
        is: (e) => "TopNode" === e.kind,
        create: (e, t) =>
          (0, i.CN)({ kind: "TopNode", expression: e, modifiers: t }),
      });
      function s(e, t) {
        var r;
        if (!(0, i.Et)(e) && !(0, i.sI)(e))
          throw Error(`Invalid top expression: ${e}`);
        if (
          !(0, i.b0)(t) &&
          "percent" !== (r = t) &&
          "with ties" !== r &&
          "percent with ties" !== r
        )
          throw Error(`Invalid top modifiers: ${t}`);
        return n.create(e, t);
      }
    },
    293: (e, t, r) => {
      r.d(t, { c: () => n });
      var i = r(96051);
      let n = (0, i.CN)({
        is: (e) => "JSONPathNode" === e.kind,
        create: (e) =>
          (0, i.CN)({
            kind: "JSONPathNode",
            inOperator: e,
            pathLegs: (0, i.CN)([]),
          }),
        cloneWithLeg: (e, t) =>
          (0, i.CN)({ ...e, pathLegs: (0, i.CN)([...e.pathLegs, t]) }),
      });
    },
    666: (e, t, r) => {
      r.d(t, {
        $O: () => g,
        DT: () => v,
        NF: () => w,
        Ow: () => x,
        RY: () => N,
        kU: () => y,
        q5: () => b,
        vd: () => m,
      });
      var i = r(83755),
        n = r(77255),
        s = r(81712),
        o = r(82099),
        a = r(96051),
        l = r(75423),
        c = r(67872),
        d = r(93403),
        u = r(36357),
        h = r(6711),
        p = r(2520),
        f = r(293);
      function m(e) {
        return (0, a.Kg)(e) ? b(e) : e.toOperationNode();
      }
      function y(e) {
        return (0, a.MH)(e) ? e.map((e) => g(e)) : [g(e)];
      }
      function g(e) {
        return (0, l.SS)(e) ? (0, l.YK)(e) : m(e);
      }
      function w(e, t) {
        let r = b(e);
        if ((0, u.Xm)(t)) return h.Q.create(r, p.k.create(u.zX.create(t)));
        let i = t.slice(0, -1);
        if ((0, u.Xm)(i)) return h.Q.create(r, f.c.create(u.zX.create(i)));
        throw Error(`Invalid JSON operator: ${t}`);
      }
      function b(e) {
        if (!e.includes(".")) return s.q.create(n.Z.create(e));
        let t = e.split(".").map(_);
        if (3 === t.length) {
          var r = t;
          let [e, i, a] = r;
          return s.q.create(n.Z.create(a), o.H.createWithSchema(e, i));
        }
        if (2 === t.length) {
          var i = t;
          let [e, r] = i;
          return s.q.create(n.Z.create(r), o.H.create(e));
        }
        throw Error(`invalid column reference ${e}`);
      }
      function v(e) {
        let t = " as ";
        if (!e.includes(t)) return b(e);
        {
          let [r, n] = e.split(t).map(_);
          return i.N.create(b(r), c.O.create(n));
        }
      }
      function N(e) {
        return n.Z.create(e);
      }
      function x(e) {
        if (!e.includes(" ")) return N(e);
        {
          let [t, r] = e.split(" ").map(_);
          if (!(0, d.bE)(r))
            throw Error(`invalid order direction "${r}" next to "${t}"`);
          return (0, d.xk)([t, r])[0];
        }
      }
      function _(e) {
        return e.trim();
      }
    },
    1045: (e, t, r) => {
      r.d(t, { z: () => n });
      var i = r(96051);
      let n = (0, i.CN)({
        is: (e) => "RawNode" === e.kind,
        create: (e, t) =>
          (0, i.CN)({
            kind: "RawNode",
            sqlFragments: (0, i.CN)(e),
            parameters: (0, i.CN)(t),
          }),
        createWithSql: (e) => n.create([e], []),
        createWithChild: (e) => n.create(["", ""], [e]),
        createWithChildren: (e) => n.create(Array(e.length + 1).fill(""), e),
      });
    },
    1081: (e, t, r) => {
      r.d(t, { mu: () => eV, cJ: () => eK });
      var i = r(90211),
        n = r(47590),
        s = r(72259),
        o = r(64055);
      class a extends o.pe {
        static [i.i] = "PgIntColumnBaseBuilder";
        generatedAlwaysAsIdentity(e) {
          if (e) {
            let { name: t, ...r } = e;
            this.config.generatedIdentity = {
              type: "always",
              sequenceName: t,
              sequenceOptions: r,
            };
          } else this.config.generatedIdentity = { type: "always" };
          return (
            (this.config.hasDefault = !0), (this.config.notNull = !0), this
          );
        }
        generatedByDefaultAsIdentity(e) {
          if (e) {
            let { name: t, ...r } = e;
            this.config.generatedIdentity = {
              type: "byDefault",
              sequenceName: t,
              sequenceOptions: r,
            };
          } else this.config.generatedIdentity = { type: "byDefault" };
          return (
            (this.config.hasDefault = !0), (this.config.notNull = !0), this
          );
        }
      }
      class l extends a {
        static [i.i] = "PgBigInt53Builder";
        constructor(e) {
          super(e, "number", "PgBigInt53");
        }
        build(e) {
          return new c(e, this.config);
        }
      }
      class c extends o.Kl {
        static [i.i] = "PgBigInt53";
        getSQLType() {
          return "bigint";
        }
        mapFromDriverValue(e) {
          return "number" == typeof e ? e : Number(e);
        }
      }
      class d extends a {
        static [i.i] = "PgBigInt64Builder";
        constructor(e) {
          super(e, "bigint", "PgBigInt64");
        }
        build(e) {
          return new u(e, this.config);
        }
      }
      class u extends o.Kl {
        static [i.i] = "PgBigInt64";
        getSQLType() {
          return "bigint";
        }
        mapFromDriverValue(e) {
          return BigInt(e);
        }
      }
      function h(e, t) {
        let { name: r, config: i } = (0, s.Ll)(e, t);
        return "number" === i.mode ? new l(r) : new d(r);
      }
      class p extends o.pe {
        static [i.i] = "PgBigSerial53Builder";
        constructor(e) {
          super(e, "number", "PgBigSerial53"),
            (this.config.hasDefault = !0),
            (this.config.notNull = !0);
        }
        build(e) {
          return new f(e, this.config);
        }
      }
      class f extends o.Kl {
        static [i.i] = "PgBigSerial53";
        getSQLType() {
          return "bigserial";
        }
        mapFromDriverValue(e) {
          return "number" == typeof e ? e : Number(e);
        }
      }
      class m extends o.pe {
        static [i.i] = "PgBigSerial64Builder";
        constructor(e) {
          super(e, "bigint", "PgBigSerial64"), (this.config.hasDefault = !0);
        }
        build(e) {
          return new y(e, this.config);
        }
      }
      class y extends o.Kl {
        static [i.i] = "PgBigSerial64";
        getSQLType() {
          return "bigserial";
        }
        mapFromDriverValue(e) {
          return BigInt(e);
        }
      }
      function g(e, t) {
        let { name: r, config: i } = (0, s.Ll)(e, t);
        return "number" === i.mode ? new p(r) : new m(r);
      }
      var w = r(82658);
      class b extends o.pe {
        static [i.i] = "PgCharBuilder";
        constructor(e, t) {
          super(e, "string", "PgChar"),
            (this.config.length = t.length),
            (this.config.enumValues = t.enum);
        }
        build(e) {
          return new v(e, this.config);
        }
      }
      class v extends o.Kl {
        static [i.i] = "PgChar";
        length = this.config.length;
        enumValues = this.config.enumValues;
        getSQLType() {
          return void 0 === this.length ? "char" : `char(${this.length})`;
        }
      }
      function N(e, t = {}) {
        let { name: r, config: i } = (0, s.Ll)(e, t);
        return new b(r, i);
      }
      class x extends o.pe {
        static [i.i] = "PgCidrBuilder";
        constructor(e) {
          super(e, "string", "PgCidr");
        }
        build(e) {
          return new _(e, this.config);
        }
      }
      class _ extends o.Kl {
        static [i.i] = "PgCidr";
        getSQLType() {
          return "cidr";
        }
      }
      function S(e) {
        return new x(e ?? "");
      }
      class T extends o.pe {
        static [i.i] = "PgCustomColumnBuilder";
        constructor(e, t, r) {
          super(e, "custom", "PgCustomColumn"),
            (this.config.fieldConfig = t),
            (this.config.customTypeParams = r);
        }
        build(e) {
          return new k(e, this.config);
        }
      }
      class k extends o.Kl {
        static [i.i] = "PgCustomColumn";
        sqlName;
        mapTo;
        mapFrom;
        constructor(e, t) {
          super(e, t),
            (this.sqlName = t.customTypeParams.dataType(t.fieldConfig)),
            (this.mapTo = t.customTypeParams.toDriver),
            (this.mapFrom = t.customTypeParams.fromDriver);
        }
        getSQLType() {
          return this.sqlName;
        }
        mapFromDriverValue(e) {
          return "function" == typeof this.mapFrom ? this.mapFrom(e) : e;
        }
        mapToDriverValue(e) {
          return "function" == typeof this.mapTo ? this.mapTo(e) : e;
        }
      }
      function A(e) {
        return (t, r) => {
          let { name: i, config: n } = (0, s.Ll)(t, r);
          return new T(i, n, e);
        };
      }
      var E = r(93136);
      class C extends o.pe {
        static [i.i] = "PgDoublePrecisionBuilder";
        constructor(e) {
          super(e, "number", "PgDoublePrecision");
        }
        build(e) {
          return new I(e, this.config);
        }
      }
      class I extends o.Kl {
        static [i.i] = "PgDoublePrecision";
        getSQLType() {
          return "double precision";
        }
        mapFromDriverValue(e) {
          return "string" == typeof e ? Number.parseFloat(e) : e;
        }
      }
      function O(e) {
        return new C(e ?? "");
      }
      class L extends o.pe {
        static [i.i] = "PgInetBuilder";
        constructor(e) {
          super(e, "string", "PgInet");
        }
        build(e) {
          return new R(e, this.config);
        }
      }
      class R extends o.Kl {
        static [i.i] = "PgInet";
        getSQLType() {
          return "inet";
        }
      }
      function P(e) {
        return new L(e ?? "");
      }
      class D extends a {
        static [i.i] = "PgIntegerBuilder";
        constructor(e) {
          super(e, "number", "PgInteger");
        }
        build(e) {
          return new q(e, this.config);
        }
      }
      class q extends o.Kl {
        static [i.i] = "PgInteger";
        getSQLType() {
          return "integer";
        }
        mapFromDriverValue(e) {
          return "string" == typeof e ? Number.parseInt(e) : e;
        }
      }
      function U(e) {
        return new D(e ?? "");
      }
      class $ extends o.pe {
        static [i.i] = "PgIntervalBuilder";
        constructor(e, t) {
          super(e, "string", "PgInterval"), (this.config.intervalConfig = t);
        }
        build(e) {
          return new B(e, this.config);
        }
      }
      class B extends o.Kl {
        static [i.i] = "PgInterval";
        fields = this.config.intervalConfig.fields;
        precision = this.config.intervalConfig.precision;
        getSQLType() {
          let e = this.fields ? ` ${this.fields}` : "",
            t = this.precision ? `(${this.precision})` : "";
          return `interval${e}${t}`;
        }
      }
      function M(e, t = {}) {
        let { name: r, config: i } = (0, s.Ll)(e, t);
        return new $(r, i);
      }
      var j = r(26514),
        W = r(60218);
      class F extends o.pe {
        static [i.i] = "PgLineBuilder";
        constructor(e) {
          super(e, "array", "PgLine");
        }
        build(e) {
          return new Q(e, this.config);
        }
      }
      class Q extends o.Kl {
        static [i.i] = "PgLine";
        getSQLType() {
          return "line";
        }
        mapFromDriverValue(e) {
          let [t, r, i] = e.slice(1, -1).split(",");
          return [
            Number.parseFloat(t),
            Number.parseFloat(r),
            Number.parseFloat(i),
          ];
        }
        mapToDriverValue(e) {
          return `{${e[0]},${e[1]},${e[2]}}`;
        }
      }
      class z extends o.pe {
        static [i.i] = "PgLineABCBuilder";
        constructor(e) {
          super(e, "json", "PgLineABC");
        }
        build(e) {
          return new V(e, this.config);
        }
      }
      class V extends o.Kl {
        static [i.i] = "PgLineABC";
        getSQLType() {
          return "line";
        }
        mapFromDriverValue(e) {
          let [t, r, i] = e.slice(1, -1).split(",");
          return {
            a: Number.parseFloat(t),
            b: Number.parseFloat(r),
            c: Number.parseFloat(i),
          };
        }
        mapToDriverValue(e) {
          return `{${e.a},${e.b},${e.c}}`;
        }
      }
      function K(e, t) {
        let { name: r, config: i } = (0, s.Ll)(e, t);
        return i?.mode && "tuple" !== i.mode ? new z(r) : new F(r);
      }
      class G extends o.pe {
        static [i.i] = "PgMacaddrBuilder";
        constructor(e) {
          super(e, "string", "PgMacaddr");
        }
        build(e) {
          return new H(e, this.config);
        }
      }
      class H extends o.Kl {
        static [i.i] = "PgMacaddr";
        getSQLType() {
          return "macaddr";
        }
      }
      function J(e) {
        return new G(e ?? "");
      }
      class Z extends o.pe {
        static [i.i] = "PgMacaddr8Builder";
        constructor(e) {
          super(e, "string", "PgMacaddr8");
        }
        build(e) {
          return new Y(e, this.config);
        }
      }
      class Y extends o.Kl {
        static [i.i] = "PgMacaddr8";
        getSQLType() {
          return "macaddr8";
        }
      }
      function X(e) {
        return new Z(e ?? "");
      }
      var ee = r(40469);
      class et extends o.pe {
        static [i.i] = "PgPointTupleBuilder";
        constructor(e) {
          super(e, "array", "PgPointTuple");
        }
        build(e) {
          return new er(e, this.config);
        }
      }
      class er extends o.Kl {
        static [i.i] = "PgPointTuple";
        getSQLType() {
          return "point";
        }
        mapFromDriverValue(e) {
          if ("string" == typeof e) {
            let [t, r] = e.slice(1, -1).split(",");
            return [Number.parseFloat(t), Number.parseFloat(r)];
          }
          return [e.x, e.y];
        }
        mapToDriverValue(e) {
          return `(${e[0]},${e[1]})`;
        }
      }
      class ei extends o.pe {
        static [i.i] = "PgPointObjectBuilder";
        constructor(e) {
          super(e, "json", "PgPointObject");
        }
        build(e) {
          return new en(e, this.config);
        }
      }
      class en extends o.Kl {
        static [i.i] = "PgPointObject";
        getSQLType() {
          return "point";
        }
        mapFromDriverValue(e) {
          if ("string" == typeof e) {
            let [t, r] = e.slice(1, -1).split(",");
            return { x: Number.parseFloat(t), y: Number.parseFloat(r) };
          }
          return e;
        }
        mapToDriverValue(e) {
          return `(${e.x},${e.y})`;
        }
      }
      function es(e, t) {
        let { name: r, config: i } = (0, s.Ll)(e, t);
        return i?.mode && "tuple" !== i.mode ? new ei(r) : new et(r);
      }
      function eo(e, t) {
        let r = new DataView(new ArrayBuffer(8));
        for (let i = 0; i < 8; i++) r.setUint8(i, e[t + i]);
        return r.getFloat64(0, !0);
      }
      function ea(e) {
        let t = (function (e) {
            let t = [];
            for (let r = 0; r < e.length; r += 2)
              t.push(Number.parseInt(e.slice(r, r + 2), 16));
            return new Uint8Array(t);
          })(e),
          r = 0,
          i = t[0];
        r += 1;
        let n = new DataView(t.buffer),
          s = n.getUint32(r, 1 === i);
        if (
          ((r += 4),
          0x20000000 & s && (n.getUint32(r, 1 === i), (r += 4)),
          (65535 & s) == 1)
        ) {
          let e = eo(t, r),
            i = eo(t, (r += 8));
          return (r += 8), [e, i];
        }
        throw Error("Unsupported geometry type");
      }
      class el extends o.pe {
        static [i.i] = "PgGeometryBuilder";
        constructor(e) {
          super(e, "array", "PgGeometry");
        }
        build(e) {
          return new ec(e, this.config);
        }
      }
      class ec extends o.Kl {
        static [i.i] = "PgGeometry";
        getSQLType() {
          return "geometry(point)";
        }
        mapFromDriverValue(e) {
          return ea(e);
        }
        mapToDriverValue(e) {
          return `point(${e[0]} ${e[1]})`;
        }
      }
      class ed extends o.pe {
        static [i.i] = "PgGeometryObjectBuilder";
        constructor(e) {
          super(e, "json", "PgGeometryObject");
        }
        build(e) {
          return new eu(e, this.config);
        }
      }
      class eu extends o.Kl {
        static [i.i] = "PgGeometryObject";
        getSQLType() {
          return "geometry(point)";
        }
        mapFromDriverValue(e) {
          let t = ea(e);
          return { x: t[0], y: t[1] };
        }
        mapToDriverValue(e) {
          return `point(${e.x} ${e.y})`;
        }
      }
      function eh(e, t) {
        let { name: r, config: i } = (0, s.Ll)(e, t);
        return i?.mode && "tuple" !== i.mode ? new ed(r) : new el(r);
      }
      class ep extends o.pe {
        static [i.i] = "PgRealBuilder";
        constructor(e, t) {
          super(e, "number", "PgReal"), (this.config.length = t);
        }
        build(e) {
          return new ef(e, this.config);
        }
      }
      class ef extends o.Kl {
        static [i.i] = "PgReal";
        constructor(e, t) {
          super(e, t);
        }
        getSQLType() {
          return "real";
        }
        mapFromDriverValue = (e) =>
          "string" == typeof e ? Number.parseFloat(e) : e;
      }
      function em(e) {
        return new ep(e ?? "");
      }
      class ey extends o.pe {
        static [i.i] = "PgSerialBuilder";
        constructor(e) {
          super(e, "number", "PgSerial"),
            (this.config.hasDefault = !0),
            (this.config.notNull = !0);
        }
        build(e) {
          return new eg(e, this.config);
        }
      }
      class eg extends o.Kl {
        static [i.i] = "PgSerial";
        getSQLType() {
          return "serial";
        }
      }
      function ew(e) {
        return new ey(e ?? "");
      }
      class eb extends a {
        static [i.i] = "PgSmallIntBuilder";
        constructor(e) {
          super(e, "number", "PgSmallInt");
        }
        build(e) {
          return new ev(e, this.config);
        }
      }
      class ev extends o.Kl {
        static [i.i] = "PgSmallInt";
        getSQLType() {
          return "smallint";
        }
        mapFromDriverValue = (e) => ("string" == typeof e ? Number(e) : e);
      }
      function eN(e) {
        return new eb(e ?? "");
      }
      class ex extends o.pe {
        static [i.i] = "PgSmallSerialBuilder";
        constructor(e) {
          super(e, "number", "PgSmallSerial"),
            (this.config.hasDefault = !0),
            (this.config.notNull = !0);
        }
        build(e) {
          return new e_(e, this.config);
        }
      }
      class e_ extends o.Kl {
        static [i.i] = "PgSmallSerial";
        getSQLType() {
          return "smallserial";
        }
      }
      function eS(e) {
        return new ex(e ?? "");
      }
      var eT = r(27819),
        ek = r(89649),
        eA = r(11618),
        eE = r(17463);
      class eC extends o.pe {
        static [i.i] = "PgVarcharBuilder";
        constructor(e, t) {
          super(e, "string", "PgVarchar"),
            (this.config.length = t.length),
            (this.config.enumValues = t.enum);
        }
        build(e) {
          return new eI(e, this.config);
        }
      }
      class eI extends o.Kl {
        static [i.i] = "PgVarchar";
        length = this.config.length;
        enumValues = this.config.enumValues;
        getSQLType() {
          return void 0 === this.length ? "varchar" : `varchar(${this.length})`;
        }
      }
      function eO(e, t = {}) {
        let { name: r, config: i } = (0, s.Ll)(e, t);
        return new eC(r, i);
      }
      class eL extends o.pe {
        static [i.i] = "PgBinaryVectorBuilder";
        constructor(e, t) {
          super(e, "string", "PgBinaryVector"),
            (this.config.dimensions = t.dimensions);
        }
        build(e) {
          return new eR(e, this.config);
        }
      }
      class eR extends o.Kl {
        static [i.i] = "PgBinaryVector";
        dimensions = this.config.dimensions;
        getSQLType() {
          return `bit(${this.dimensions})`;
        }
      }
      function eP(e, t) {
        let { name: r, config: i } = (0, s.Ll)(e, t);
        return new eL(r, i);
      }
      class eD extends o.pe {
        static [i.i] = "PgHalfVectorBuilder";
        constructor(e, t) {
          super(e, "array", "PgHalfVector"),
            (this.config.dimensions = t.dimensions);
        }
        build(e) {
          return new eq(e, this.config);
        }
      }
      class eq extends o.Kl {
        static [i.i] = "PgHalfVector";
        dimensions = this.config.dimensions;
        getSQLType() {
          return `halfvec(${this.dimensions})`;
        }
        mapToDriverValue(e) {
          return JSON.stringify(e);
        }
        mapFromDriverValue(e) {
          return e
            .slice(1, -1)
            .split(",")
            .map((e) => Number.parseFloat(e));
        }
      }
      function eU(e, t) {
        let { name: r, config: i } = (0, s.Ll)(e, t);
        return new eD(r, i);
      }
      class e$ extends o.pe {
        static [i.i] = "PgSparseVectorBuilder";
        constructor(e, t) {
          super(e, "string", "PgSparseVector"),
            (this.config.dimensions = t.dimensions);
        }
        build(e) {
          return new eB(e, this.config);
        }
      }
      class eB extends o.Kl {
        static [i.i] = "PgSparseVector";
        dimensions = this.config.dimensions;
        getSQLType() {
          return `sparsevec(${this.dimensions})`;
        }
      }
      function eM(e, t) {
        let { name: r, config: i } = (0, s.Ll)(e, t);
        return new e$(r, i);
      }
      class ej extends o.pe {
        static [i.i] = "PgVectorBuilder";
        constructor(e, t) {
          super(e, "array", "PgVector"),
            (this.config.dimensions = t.dimensions);
        }
        build(e) {
          return new eW(e, this.config);
        }
      }
      class eW extends o.Kl {
        static [i.i] = "PgVector";
        dimensions = this.config.dimensions;
        getSQLType() {
          return `vector(${this.dimensions})`;
        }
        mapToDriverValue(e) {
          return JSON.stringify(e);
        }
        mapFromDriverValue(e) {
          return e
            .slice(1, -1)
            .split(",")
            .map((e) => Number.parseFloat(e));
        }
      }
      function eF(e, t) {
        let { name: r, config: i } = (0, s.Ll)(e, t);
        return new ej(r, i);
      }
      let eQ = Symbol.for("drizzle:PgInlineForeignKeys"),
        ez = Symbol.for("drizzle:EnableRLS");
      class eV extends n.XI {
        static [i.i] = "PgTable";
        static Symbol = Object.assign({}, n.XI.Symbol, {
          InlineForeignKeys: eQ,
          EnableRLS: ez,
        });
        [eQ] = [];
        [ez] = !1;
        [n.XI.Symbol.ExtraConfigBuilder] = void 0;
        [n.XI.Symbol.ExtraConfigColumns] = {};
      }
      let eK = (e, t, r) =>
        (function (e, t, r, i, s = e) {
          let o = new eV(e, i, s),
            a =
              "function" == typeof t
                ? t({
                    bigint: h,
                    bigserial: g,
                    boolean: w.zM,
                    char: N,
                    cidr: S,
                    customType: A,
                    date: E.p6,
                    doublePrecision: O,
                    inet: P,
                    integer: U,
                    interval: M,
                    json: j.Pq,
                    jsonb: W.Fx,
                    line: K,
                    macaddr: J,
                    macaddr8: X,
                    numeric: ee.sH,
                    point: es,
                    geometry: eh,
                    real: em,
                    serial: ew,
                    smallint: eN,
                    smallserial: eS,
                    text: eT.Qq,
                    time: ek.kB,
                    timestamp: eA.vE,
                    uuid: eE.uR,
                    varchar: eO,
                    bit: eP,
                    halfvec: eU,
                    sparsevec: eM,
                    vector: eF,
                  })
                : t,
            l = Object.fromEntries(
              Object.entries(a).map(([e, t]) => {
                t.setName(e);
                let r = t.build(o);
                return o[eQ].push(...t.buildForeignKeys(r, o)), [e, r];
              })
            ),
            c = Object.fromEntries(
              Object.entries(a).map(
                ([e, t]) => (t.setName(e), [e, t.buildExtraConfigColumn(o)])
              )
            ),
            d = Object.assign(o, l);
          return (
            (d[n.XI.Symbol.Columns] = l),
            (d[n.XI.Symbol.ExtraConfigColumns] = c),
            r && (d[eV.Symbol.ExtraConfigBuilder] = r),
            Object.assign(d, {
              enableRLS: () => ((d[eV.Symbol.EnableRLS] = !0), d),
            })
          );
        })(e, t, r, void 0);
    },
    1116: (e, t, r) => {
      r.d(t, { OU: () => c });
      var i = r(93298),
        n = r(96051),
        s = r(35665),
        o = r(74465),
        a = r(74850),
        l = r(11750);
      class c {
        #e;
        constructor(e) {
          this.#e = (0, n.CN)(e);
        }
        when(...e) {
          return new d({
            ...this.#e,
            node: s.P.cloneWithWhen(this.#e.node, o.t.create((0, a.GB)(e))),
          });
        }
      }
      class d {
        #e;
        constructor(e) {
          this.#e = (0, n.CN)(e);
        }
        then(e) {
          return new u({
            ...this.#e,
            node: s.P.cloneWithThen(
              this.#e.node,
              (0, l.qH)(e) ? (0, l.dJ)(e) : (0, l.$s)(e)
            ),
          });
        }
      }
      class u {
        #e;
        constructor(e) {
          this.#e = (0, n.CN)(e);
        }
        when(...e) {
          return new d({
            ...this.#e,
            node: s.P.cloneWithWhen(this.#e.node, o.t.create((0, a.GB)(e))),
          });
        }
        else(e) {
          return new h({
            ...this.#e,
            node: s.P.cloneWith(this.#e.node, {
              else: (0, l.qH)(e) ? (0, l.dJ)(e) : (0, l.$s)(e),
            }),
          });
        }
        end() {
          return new i.Is(s.P.cloneWith(this.#e.node, { isStatement: !1 }));
        }
        endCase() {
          return new i.Is(s.P.cloneWith(this.#e.node, { isStatement: !0 }));
        }
      }
      class h {
        #e;
        constructor(e) {
          this.#e = (0, n.CN)(e);
        }
        end() {
          return new i.Is(s.P.cloneWith(this.#e.node, { isStatement: !1 }));
        }
        endCase() {
          return new i.Is(s.P.cloneWith(this.#e.node, { isStatement: !0 }));
        }
      }
    },
    1518: (e, t, r) => {
      r.d(t, { K: () => n });
      var i = r(96051);
      let n = (0, i.CN)({
        is: (e) => "OrNode" === e.kind,
        create: (e, t) => (0, i.CN)({ kind: "OrNode", left: e, right: t }),
      });
    },
    1793: (e, t, r) => {
      r.d(t, { E: () => i });
      let i = Symbol.for("drizzle:Name");
    },
    1815: (e, t, r) => {
      r.d(t, { c: () => C });
      var i = r(83755),
        n = r(96051);
      let s = (0, n.CN)({
        is: (e) => "SelectModifierNode" === e.kind,
        create: (e, t) =>
          (0, n.CN)({ kind: "SelectModifierNode", modifier: e, of: t }),
        createWithExpression: (e) =>
          (0, n.CN)({ kind: "SelectModifierNode", rawModifier: e }),
      });
      var o = r(80525),
        a = r(33669),
        l = r(43005),
        c = r(666),
        d = r(53668),
        u = r(64992),
        h = r(93403),
        p = r(50698);
      let f = (0, n.CN)({
          is: (e) => "OffsetNode" === e.kind,
          create: (e) => (0, n.CN)({ kind: "OffsetNode", offset: e }),
        }),
        m = (0, n.CN)({
          is: (e) => "GroupByItemNode" === e.kind,
          create: (e) => (0, n.CN)({ kind: "GroupByItemNode", groupBy: e }),
        });
      var y = r(95235),
        g = r(38508),
        w = r(67872),
        b = r(82779),
        v = r(75423);
      function N(e, t, r) {
        return (
          (0, n.Tn)(t) && (t = t((0, y.O)())),
          (0, n.MH)(t) || (t = [t]),
          t.map((t) => b.i.create(e, (0, v.YK)(t), r))
        );
      }
      var x = r(74850),
        _ = r(93298),
        S = r(11750),
        T = r(89400);
      let k = {
        create: (e, t) => ({
          kind: "FetchNode",
          rowCount: T.q.create(e),
          modifier: t,
        }),
      };
      var A = r(257);
      class E {
        #e;
        constructor(e) {
          this.#e = (0, n.CN)(e);
        }
        get expressionType() {}
        get isSelectQueryBuilder() {
          return !0;
        }
        where(...e) {
          return new E({
            ...this.#e,
            queryNode: u.L.cloneWithWhere(this.#e.queryNode, (0, x.GB)(e)),
          });
        }
        whereRef(e, t, r) {
          return new E({
            ...this.#e,
            queryNode: u.L.cloneWithWhere(
              this.#e.queryNode,
              (0, x.vC)(e, t, r)
            ),
          });
        }
        having(...e) {
          return new E({
            ...this.#e,
            queryNode: d.L.cloneWithHaving(this.#e.queryNode, (0, x.GB)(e)),
          });
        }
        havingRef(e, t, r) {
          return new E({
            ...this.#e,
            queryNode: d.L.cloneWithHaving(
              this.#e.queryNode,
              (0, x.vC)(e, t, r)
            ),
          });
        }
        select(e) {
          return new E({
            ...this.#e,
            queryNode: d.L.cloneWithSelections(this.#e.queryNode, (0, l.G)(e)),
          });
        }
        distinctOn(e) {
          return new E({
            ...this.#e,
            queryNode: d.L.cloneWithDistinctOn(this.#e.queryNode, (0, c.kU)(e)),
          });
        }
        modifyFront(e) {
          return new E({
            ...this.#e,
            queryNode: d.L.cloneWithFrontModifier(
              this.#e.queryNode,
              s.createWithExpression(e.toOperationNode())
            ),
          });
        }
        modifyEnd(e) {
          return new E({
            ...this.#e,
            queryNode: u.L.cloneWithEndModifier(
              this.#e.queryNode,
              s.createWithExpression(e.toOperationNode())
            ),
          });
        }
        distinct() {
          return new E({
            ...this.#e,
            queryNode: d.L.cloneWithFrontModifier(
              this.#e.queryNode,
              s.create("Distinct")
            ),
          });
        }
        forUpdate(e) {
          return new E({
            ...this.#e,
            queryNode: u.L.cloneWithEndModifier(
              this.#e.queryNode,
              s.create("ForUpdate", e ? (0, n._j)(e).map(a.M$) : void 0)
            ),
          });
        }
        forShare(e) {
          return new E({
            ...this.#e,
            queryNode: u.L.cloneWithEndModifier(
              this.#e.queryNode,
              s.create("ForShare", e ? (0, n._j)(e).map(a.M$) : void 0)
            ),
          });
        }
        forKeyShare(e) {
          return new E({
            ...this.#e,
            queryNode: u.L.cloneWithEndModifier(
              this.#e.queryNode,
              s.create("ForKeyShare", e ? (0, n._j)(e).map(a.M$) : void 0)
            ),
          });
        }
        forNoKeyUpdate(e) {
          return new E({
            ...this.#e,
            queryNode: u.L.cloneWithEndModifier(
              this.#e.queryNode,
              s.create("ForNoKeyUpdate", e ? (0, n._j)(e).map(a.M$) : void 0)
            ),
          });
        }
        skipLocked() {
          return new E({
            ...this.#e,
            queryNode: u.L.cloneWithEndModifier(
              this.#e.queryNode,
              s.create("SkipLocked")
            ),
          });
        }
        noWait() {
          return new E({
            ...this.#e,
            queryNode: u.L.cloneWithEndModifier(
              this.#e.queryNode,
              s.create("NoWait")
            ),
          });
        }
        selectAll(e) {
          return new E({
            ...this.#e,
            queryNode: d.L.cloneWithSelections(this.#e.queryNode, (0, l.J)(e)),
          });
        }
        innerJoin(...e) {
          return this.#t("InnerJoin", e);
        }
        leftJoin(...e) {
          return this.#t("LeftJoin", e);
        }
        rightJoin(...e) {
          return this.#t("RightJoin", e);
        }
        fullJoin(...e) {
          return this.#t("FullJoin", e);
        }
        crossJoin(...e) {
          return this.#t("CrossJoin", e);
        }
        innerJoinLateral(...e) {
          return this.#t("LateralInnerJoin", e);
        }
        leftJoinLateral(...e) {
          return this.#t("LateralLeftJoin", e);
        }
        crossJoinLateral(...e) {
          return this.#t("LateralCrossJoin", e);
        }
        crossApply(...e) {
          return this.#t("CrossApply", e);
        }
        outerApply(...e) {
          return this.#t("OuterApply", e);
        }
        #t(e, t) {
          return new E({
            ...this.#e,
            queryNode: u.L.cloneWithJoin(this.#e.queryNode, (0, o.a)(e, t)),
          });
        }
        orderBy(...e) {
          return new E({
            ...this.#e,
            queryNode: u.L.cloneWithOrderByItems(
              this.#e.queryNode,
              (0, h.xk)(e)
            ),
          });
        }
        groupBy(e) {
          var t;
          return new E({
            ...this.#e,
            queryNode: d.L.cloneWithGroupByItems(
              this.#e.queryNode,
              ((t = e),
              (t = (0, n.Tn)(t) ? t((0, y.A)()) : t),
              (0, c.kU)(t).map(m.create))
            ),
          });
        }
        limit(e) {
          return new E({
            ...this.#e,
            queryNode: d.L.cloneWithLimit(
              this.#e.queryNode,
              p.a.create((0, S.$s)(e))
            ),
          });
        }
        offset(e) {
          return new E({
            ...this.#e,
            queryNode: d.L.cloneWithOffset(
              this.#e.queryNode,
              f.create((0, S.$s)(e))
            ),
          });
        }
        fetch(e, t = "only") {
          return new E({
            ...this.#e,
            queryNode: d.L.cloneWithFetch(
              this.#e.queryNode,
              (function (e, t) {
                var r;
                if (!(0, n.Et)(e) && !(0, n.sI)(e))
                  throw Error(`Invalid fetch row count: ${e}`);
                if ("only" !== (r = t) && "with ties" !== r)
                  throw Error(`Invalid fetch modifier: ${t}`);
                return k.create(e, t);
              })(e, t)
            ),
          });
        }
        top(e, t) {
          return new E({
            ...this.#e,
            queryNode: u.L.cloneWithTop(this.#e.queryNode, (0, A.f)(e, t)),
          });
        }
        union(e) {
          return new E({
            ...this.#e,
            queryNode: d.L.cloneWithSetOperations(
              this.#e.queryNode,
              N("union", e, !1)
            ),
          });
        }
        unionAll(e) {
          return new E({
            ...this.#e,
            queryNode: d.L.cloneWithSetOperations(
              this.#e.queryNode,
              N("union", e, !0)
            ),
          });
        }
        intersect(e) {
          return new E({
            ...this.#e,
            queryNode: d.L.cloneWithSetOperations(
              this.#e.queryNode,
              N("intersect", e, !1)
            ),
          });
        }
        intersectAll(e) {
          return new E({
            ...this.#e,
            queryNode: d.L.cloneWithSetOperations(
              this.#e.queryNode,
              N("intersect", e, !0)
            ),
          });
        }
        except(e) {
          return new E({
            ...this.#e,
            queryNode: d.L.cloneWithSetOperations(
              this.#e.queryNode,
              N("except", e, !1)
            ),
          });
        }
        exceptAll(e) {
          return new E({
            ...this.#e,
            queryNode: d.L.cloneWithSetOperations(
              this.#e.queryNode,
              N("except", e, !0)
            ),
          });
        }
        as(e) {
          return new I(this, e);
        }
        clearSelect() {
          return new E({
            ...this.#e,
            queryNode: d.L.cloneWithoutSelections(this.#e.queryNode),
          });
        }
        clearWhere() {
          return new E({
            ...this.#e,
            queryNode: u.L.cloneWithoutWhere(this.#e.queryNode),
          });
        }
        clearLimit() {
          return new E({
            ...this.#e,
            queryNode: d.L.cloneWithoutLimit(this.#e.queryNode),
          });
        }
        clearOffset() {
          return new E({
            ...this.#e,
            queryNode: d.L.cloneWithoutOffset(this.#e.queryNode),
          });
        }
        clearOrderBy() {
          return new E({
            ...this.#e,
            queryNode: u.L.cloneWithoutOrderBy(this.#e.queryNode),
          });
        }
        clearGroupBy() {
          return new E({
            ...this.#e,
            queryNode: d.L.cloneWithoutGroupBy(this.#e.queryNode),
          });
        }
        $call(e) {
          return e(this);
        }
        $if(e, t) {
          return e ? t(this) : new E({ ...this.#e });
        }
        $castTo() {
          return new E(this.#e);
        }
        $narrowType() {
          return new E(this.#e);
        }
        $assertType() {
          return new E(this.#e);
        }
        $asTuple() {
          return new _.Is(this.toOperationNode());
        }
        $asScalar() {
          return new _.Is(this.toOperationNode());
        }
        withPlugin(e) {
          return new E({
            ...this.#e,
            executor: this.#e.executor.withPlugin(e),
          });
        }
        toOperationNode() {
          return this.#e.executor.transformQuery(
            this.#e.queryNode,
            this.#e.queryId
          );
        }
        compile() {
          return this.#e.executor.compileQuery(
            this.toOperationNode(),
            this.#e.queryId
          );
        }
        async execute() {
          let e = this.compile();
          return (await this.#e.executor.executeQuery(e, this.#e.queryId)).rows;
        }
        async executeTakeFirst() {
          let [e] = await this.execute();
          return e;
        }
        async executeTakeFirstOrThrow(e = g.F) {
          let t = await this.executeTakeFirst();
          if (void 0 === t)
            throw (0, g.x)(e)
              ? new e(this.toOperationNode())
              : e(this.toOperationNode());
          return t;
        }
        async *stream(e = 100) {
          let t = this.compile();
          for await (let r of this.#e.executor.stream(t, e, this.#e.queryId))
            yield* r.rows;
        }
        async explain(e, t) {
          let r = new E({
            ...this.#e,
            queryNode: u.L.cloneWithExplain(this.#e.queryNode, e, t),
          });
          return await r.execute();
        }
      }
      function C(e) {
        return new E(e);
      }
      class I {
        #r;
        #i;
        constructor(e, t) {
          (this.#r = e), (this.#i = t);
        }
        get expression() {
          return this.#r;
        }
        get alias() {
          return this.#i;
        }
        get isAliasedSelectQueryBuilder() {
          return !0;
        }
        toOperationNode() {
          return i.N.create(this.#r.toOperationNode(), w.O.create(this.#i));
        }
      }
    },
    2444: (e, t, r) => {
      r.d(t, { u: () => n });
      let i = new Set();
      function n(e) {
        i.has(e) || (i.add(e), console.log(e));
      }
    },
    2520: (e, t, r) => {
      r.d(t, { k: () => n });
      var i = r(96051);
      let n = (0, i.CN)({
        is: (e) => "JSONOperatorChainNode" === e.kind,
        create: (e) =>
          (0, i.CN)({
            kind: "JSONOperatorChainNode",
            operator: e,
            values: (0, i.CN)([]),
          }),
        cloneWithValue: (e, t) =>
          (0, i.CN)({ ...e, values: (0, i.CN)([...e.values, t]) }),
      });
    },
    2595: (e, t, r) => {
      r.d(t, { b: () => l, c: () => c, g: () => a, r: () => u, v: () => d });
      var i = r(51875),
        n = r(55094),
        s = r(7846),
        o = r(12486);
      async function a(e) {
        let t = await (0, o.n)("SHA-256").digest(e);
        return i.z.encode(new Uint8Array(t), { padding: !1 });
      }
      function l(e) {
        return {
          tokenType: e.token_type,
          accessToken: e.access_token,
          refreshToken: e.refresh_token,
          accessTokenExpiresAt: e.expires_in
            ? (0, s.g)(e.expires_in, "sec")
            : void 0,
          scopes: e?.scope
            ? "string" == typeof e.scope
              ? e.scope.split(" ")
              : e.scope
            : [],
          idToken: e.id_token,
        };
      }
      async function c({
        id: e,
        options: t,
        authorizationEndpoint: r,
        state: i,
        codeVerifier: n,
        scopes: s,
        claims: o,
        redirectURI: l,
        duration: c,
        prompt: d,
        accessType: u,
        responseType: h,
        display: p,
        loginHint: f,
        hd: m,
        responseMode: y,
        additionalParams: g,
        scopeJoiner: w,
      }) {
        let b = new URL(r);
        if (
          (b.searchParams.set("response_type", h || "code"),
          b.searchParams.set("client_id", t.clientId),
          b.searchParams.set("state", i),
          b.searchParams.set("scope", s.join(w || " ")),
          b.searchParams.set("redirect_uri", t.redirectURI || l),
          c && b.searchParams.set("duration", c),
          p && b.searchParams.set("display", p),
          f && b.searchParams.set("login_hint", f),
          d && b.searchParams.set("prompt", d),
          m && b.searchParams.set("hd", m),
          u && b.searchParams.set("access_type", u),
          y && b.searchParams.set("response_mode", y),
          n)
        ) {
          let e = await a(n);
          b.searchParams.set("code_challenge_method", "S256"),
            b.searchParams.set("code_challenge", e);
        }
        if (o) {
          let e = o.reduce((e, t) => ((e[t] = null), e), {});
          b.searchParams.set(
            "claims",
            JSON.stringify({
              id_token: { email: null, email_verified: null, ...e },
            })
          );
        }
        return (
          g &&
            Object.entries(g).forEach(([e, t]) => {
              b.searchParams.set(e, t);
            }),
          b
        );
      }
      async function d({
        code: e,
        codeVerifier: t,
        redirectURI: r,
        options: s,
        tokenEndpoint: o,
        authentication: a,
        deviceId: c,
        headers: d,
      }) {
        let u = new URLSearchParams(),
          h = {
            "content-type": "application/x-www-form-urlencoded",
            accept: "application/json",
            "user-agent": "better-auth",
            ...d,
          };
        if (
          (u.set("grant_type", "authorization_code"),
          u.set("code", e),
          t && u.set("code_verifier", t),
          s.clientKey && u.set("client_key", s.clientKey),
          c && u.set("device_id", c),
          u.set("redirect_uri", s.redirectURI || r),
          "basic" === a)
        ) {
          let e = i.z.encode(`${s.clientId}:${s.clientSecret}`);
          h.authorization = `Basic ${e}`;
        } else
          u.set("client_id", s.clientId),
            u.set("client_secret", s.clientSecret);
        let { data: p, error: f } = await (0, n.zZ)(o, {
          method: "POST",
          body: u,
          headers: h,
        });
        if (f) throw f;
        return l(p);
      }
      async function u({
        refreshToken: e,
        options: t,
        tokenEndpoint: r,
        authentication: s,
        extraParams: o,
        grantType: a = "refresh_token",
      }) {
        let l = new URLSearchParams(),
          c = {
            "content-type": "application/x-www-form-urlencoded",
            accept: "application/json",
          };
        if (
          (l.set("grant_type", a), l.set("refresh_token", e), "basic" === s)
        ) {
          let e = i.z.encode(`${t.clientId}:${t.clientSecret}`);
          c.authorization = `Basic ${e}`;
        } else
          l.set("client_id", t.clientId),
            l.set("client_secret", t.clientSecret);
        if (o) for (let [e, t] of Object.entries(o)) l.set(e, t);
        let { data: d, error: u } = await (0, n.zZ)(r, {
          method: "POST",
          body: l,
          headers: c,
        });
        if (u) throw u;
        let h = {
          accessToken: d.access_token,
          refreshToken: d.refresh_token,
          tokenType: d.token_type,
          scopes: d.scope?.split(" "),
          idToken: d.id_token,
        };
        return (
          d.expires_in &&
            (h.accessTokenExpiresAt = new Date(
              new Date().getTime() + 1e3 * d.expires_in
            )),
          h
        );
      }
    },
    3415: (e, t, r) => {
      r.d(t, { D0: () => n, Rd: () => i, xW: () => s });
      let i = new TextEncoder(),
        n = new TextDecoder();
      function s(...e) {
        let t = new Uint8Array(e.reduce((e, { length: t }) => e + t, 0)),
          r = 0;
        for (let i of e) t.set(i, r), (r += i.length);
        return t;
      }
    },
    3520: (e, t, r) => {
      r.d(t, { A: () => u });
      var i = r(77598),
        n = r(72623);
      function s(e, t = "algorithm.name") {
        return TypeError(
          `CryptoKey does not support this operation, its ${t} must be ${e}`
        );
      }
      function o(e, t) {
        return e.name === t;
      }
      function a(e) {
        return parseInt(e.name.slice(4), 10);
      }
      var l = r(93247),
        c = r(29194),
        d = r(75456);
      function u(e, t, r) {
        if (t instanceof Uint8Array) {
          if (!e.startsWith("HS")) throw TypeError((0, l.A)(t, ...c.g));
          return (0, i.createSecretKey)(t);
        }
        if (t instanceof i.KeyObject) return t;
        if ((0, n.R)(t))
          return (
            !(function (e, t, ...r) {
              switch (t) {
                case "HS256":
                case "HS384":
                case "HS512": {
                  if (!o(e.algorithm, "HMAC")) throw s("HMAC");
                  let r = parseInt(t.slice(2), 10);
                  if (a(e.algorithm.hash) !== r)
                    throw s(`SHA-${r}`, "algorithm.hash");
                  break;
                }
                case "RS256":
                case "RS384":
                case "RS512": {
                  if (!o(e.algorithm, "RSASSA-PKCS1-v1_5"))
                    throw s("RSASSA-PKCS1-v1_5");
                  let r = parseInt(t.slice(2), 10);
                  if (a(e.algorithm.hash) !== r)
                    throw s(`SHA-${r}`, "algorithm.hash");
                  break;
                }
                case "PS256":
                case "PS384":
                case "PS512": {
                  if (!o(e.algorithm, "RSA-PSS")) throw s("RSA-PSS");
                  let r = parseInt(t.slice(2), 10);
                  if (a(e.algorithm.hash) !== r)
                    throw s(`SHA-${r}`, "algorithm.hash");
                  break;
                }
                case "EdDSA":
                  if (
                    "Ed25519" !== e.algorithm.name &&
                    "Ed448" !== e.algorithm.name
                  )
                    throw s("Ed25519 or Ed448");
                  break;
                case "Ed25519":
                  if (!o(e.algorithm, "Ed25519")) throw s("Ed25519");
                  break;
                case "ES256":
                case "ES384":
                case "ES512": {
                  if (!o(e.algorithm, "ECDSA")) throw s("ECDSA");
                  let r = (function (e) {
                    switch (e) {
                      case "ES256":
                        return "P-256";
                      case "ES384":
                        return "P-384";
                      case "ES512":
                        return "P-521";
                      default:
                        throw Error("unreachable");
                    }
                  })(t);
                  if (e.algorithm.namedCurve !== r)
                    throw s(r, "algorithm.namedCurve");
                  break;
                }
                default:
                  throw TypeError("CryptoKey does not support this operation");
              }
              var i = e,
                n = r;
              if (n.length && !n.some((e) => i.usages.includes(e))) {
                let e =
                  "CryptoKey does not support this operation, its usages must include ";
                if (n.length > 2) {
                  let t = n.pop();
                  e += `one of ${n.join(", ")}, or ${t}.`;
                } else
                  2 === n.length
                    ? (e += `one of ${n[0]} or ${n[1]}.`)
                    : (e += `${n[0]}.`);
                throw TypeError(e);
              }
            })(t, e, r),
            i.KeyObject.from(t)
          );
        if (d.ll(t))
          return e.startsWith("HS")
            ? (0, i.createSecretKey)(Buffer.from(t.k, "base64url"))
            : t;
        throw TypeError((0, l.A)(t, ...c.g, "Uint8Array", "JSON Web Key"));
      }
    },
    3536: (e, t, r) => {
      r.d(t, {
        A: () => ef,
        B: () => Q,
        C: () => eh,
        D: () => em,
        E: () => ev,
        F: () => eb,
        G: () => ew,
        I: () => ex,
        J: () => er,
        K: () => ei,
        L: () => ey,
        M: () => ep,
        N: () => ea,
        O: () => ed,
        P: () => ec,
        Q: () => eo,
        R: () => G,
        a: () => $,
        b: () => z,
        c: () => U,
        e: () => ee,
        g: () => V,
        i: () => W,
        j: () => eS,
        k: () => eT,
        l: () => J,
        m: () => eO,
        n: () => eC,
        p: () => eE,
        q: () => eN,
        r: () => eI,
        s: () => K,
        t: () => ek,
        u: () => eg,
        v: () => eA,
        w: () => j,
        x: () => X,
        y: () => Y,
        z: () => Z,
      });
      var i = r(16151),
        n = r(33746),
        s = r(30060),
        o = r(45391),
        a = r(37991),
        l = r(7125),
        c = r(93818),
        d = r(7846),
        u = r(94349);
      r(12486);
      var h = r(51875),
        p = r(46742);
      r(84941);
      var f = r(30377),
        m = r(54036),
        y = r(49442),
        g = r(62055),
        w = r(61229);
      r(55094), r(39773);
      var b = r(19984),
        v = r(76221),
        N = r(74338),
        x = r(41321),
        _ = r(3415),
        S = r(79338),
        T = r(30052);
      class k {
        _payload;
        _protectedHeader;
        _unprotectedHeader;
        constructor(e) {
          if (!(e instanceof Uint8Array))
            throw TypeError("payload must be an instance of Uint8Array");
          this._payload = e;
        }
        setProtectedHeader(e) {
          if (this._protectedHeader)
            throw TypeError("setProtectedHeader can only be called once");
          return (this._protectedHeader = e), this;
        }
        setUnprotectedHeader(e) {
          if (this._unprotectedHeader)
            throw TypeError("setUnprotectedHeader can only be called once");
          return (this._unprotectedHeader = e), this;
        }
        async sign(e, t) {
          let r;
          if (!this._protectedHeader && !this._unprotectedHeader)
            throw new x.Ye(
              "either setProtectedHeader or setUnprotectedHeader must be called before #sign()"
            );
          if (!(0, N.A)(this._protectedHeader, this._unprotectedHeader))
            throw new x.Ye(
              "JWS Protected and JWS Unprotected Header Parameter names must be disjoint"
            );
          let i = { ...this._protectedHeader, ...this._unprotectedHeader },
            n = (0, T.A)(
              x.Ye,
              new Map([["b64", !0]]),
              t?.crit,
              this._protectedHeader,
              i
            ),
            s = !0;
          if (
            n.has("b64") &&
            "boolean" != typeof (s = this._protectedHeader.b64)
          )
            throw new x.Ye(
              'The "b64" (base64url-encode payload) Header Parameter must be a boolean'
            );
          let { alg: o } = i;
          if ("string" != typeof o || !o)
            throw new x.Ye(
              'JWS "alg" (Algorithm) Header Parameter missing or invalid'
            );
          (0, S.I)(o, e, "sign");
          let a = this._payload;
          s && (a = _.Rd.encode((0, b.lF)(a))),
            (r = this._protectedHeader
              ? _.Rd.encode((0, b.lF)(JSON.stringify(this._protectedHeader)))
              : _.Rd.encode(""));
          let l = (0, _.xW)(r, _.Rd.encode("."), a),
            c = await (0, v.A)(o, e, l),
            d = { signature: (0, b.lF)(c), payload: "" };
          return (
            s && (d.payload = _.D0.decode(a)),
            this._unprotectedHeader && (d.header = this._unprotectedHeader),
            this._protectedHeader && (d.protected = _.D0.decode(r)),
            d
          );
        }
      }
      class A {
        _flattened;
        constructor(e) {
          this._flattened = new k(e);
        }
        setProtectedHeader(e) {
          return this._flattened.setProtectedHeader(e), this;
        }
        async sign(e, t) {
          let r = await this._flattened.sign(e, t);
          if (void 0 === r.payload)
            throw TypeError(
              "use the flattened module for creating JWS with b64: false"
            );
          return `${r.protected}.${r.payload}.${r.signature}`;
        }
      }
      var E = r(88990),
        C = r(81385),
        I = r(77345);
      function O(e, t) {
        if (!Number.isFinite(t)) throw TypeError(`Invalid ${e} input`);
        return t;
      }
      class L {
        _payload;
        constructor(e = {}) {
          if (!(0, C.A)(e)) throw TypeError("JWT Claims Set MUST be an object");
          this._payload = e;
        }
        setIssuer(e) {
          return (this._payload = { ...this._payload, iss: e }), this;
        }
        setSubject(e) {
          return (this._payload = { ...this._payload, sub: e }), this;
        }
        setAudience(e) {
          return (this._payload = { ...this._payload, aud: e }), this;
        }
        setJti(e) {
          return (this._payload = { ...this._payload, jti: e }), this;
        }
        setNotBefore(e) {
          return (
            "number" == typeof e
              ? (this._payload = {
                  ...this._payload,
                  nbf: O("setNotBefore", e),
                })
              : e instanceof Date
                ? (this._payload = {
                    ...this._payload,
                    nbf: O("setNotBefore", (0, E.A)(e)),
                  })
                : (this._payload = {
                    ...this._payload,
                    nbf: (0, E.A)(new Date()) + (0, I.A)(e),
                  }),
            this
          );
        }
        setExpirationTime(e) {
          return (
            "number" == typeof e
              ? (this._payload = {
                  ...this._payload,
                  exp: O("setExpirationTime", e),
                })
              : e instanceof Date
                ? (this._payload = {
                    ...this._payload,
                    exp: O("setExpirationTime", (0, E.A)(e)),
                  })
                : (this._payload = {
                    ...this._payload,
                    exp: (0, E.A)(new Date()) + (0, I.A)(e),
                  }),
            this
          );
        }
        setIssuedAt(e) {
          return (
            void 0 === e
              ? (this._payload = {
                  ...this._payload,
                  iat: (0, E.A)(new Date()),
                })
              : e instanceof Date
                ? (this._payload = {
                    ...this._payload,
                    iat: O("setIssuedAt", (0, E.A)(e)),
                  })
                : "string" == typeof e
                  ? (this._payload = {
                      ...this._payload,
                      iat: O("setIssuedAt", (0, E.A)(new Date()) + (0, I.A)(e)),
                    })
                  : (this._payload = {
                      ...this._payload,
                      iat: O("setIssuedAt", e),
                    }),
            this
          );
        }
      }
      class R extends L {
        _protectedHeader;
        setProtectedHeader(e) {
          return (this._protectedHeader = e), this;
        }
        async sign(e, t) {
          let r = new A(_.Rd.encode(JSON.stringify(this._payload)));
          if (
            (r.setProtectedHeader(this._protectedHeader),
            Array.isArray(this._protectedHeader?.crit) &&
              this._protectedHeader.crit.includes("b64") &&
              !1 === this._protectedHeader.b64)
          )
            throw new x.Dp("JWTs MUST NOT use unencoded payload");
          return r.sign(e, t);
        }
      }
      async function P(e, t, r = 3600) {
        return await new R(e)
          .setProtectedHeader({ alg: "HS256" })
          .setIssuedAt()
          .setExpirationTime(Math.floor(Date.now() / 1e3) + r)
          .sign(new TextEncoder().encode(t));
      }
      var D = r(98196);
      let q = (0, s.Ny)(async () => ({})),
        U = s.Ny.create({ use: [q, (0, s.Ny)(async () => ({}))] }),
        $ = s.UD.create({ use: [q] });
      function B(e) {
        return "-" === e ||
          "^" === e ||
          "$" === e ||
          "+" === e ||
          "." === e ||
          "(" === e ||
          ")" === e ||
          "|" === e ||
          "[" === e ||
          "]" === e ||
          "{" === e ||
          "}" === e ||
          "*" === e ||
          "?" === e ||
          "\\" === e
          ? `\\${e}`
          : e;
      }
      function M(e, t) {
        if ("string" != typeof t)
          throw TypeError(`Sample must be a string, but ${typeof t} given`);
        return e.test(t);
      }
      function j(e, t) {
        if ("string" != typeof e && !Array.isArray(e))
          throw TypeError(
            `The first argument must be a single pattern string or an array of patterns, but ${typeof e} given`
          );
        if (
          (("string" == typeof t || "boolean" == typeof t) &&
            (t = { separator: t }),
          2 == arguments.length &&
            !(
              void 0 === t ||
              ("object" == typeof t && null !== t && !Array.isArray(t))
            ))
        )
          throw TypeError(
            `The second argument must be an options object or a string/boolean separator, but ${typeof t} given`
          );
        if ("\\" === (t = t || {}).separator)
          throw Error(
            "\\ is not a valid separator because it is used for escaping. Try setting the separator to `true` instead"
          );
        let r = (function e(t, r = !0) {
            if (Array.isArray(t)) {
              let i = t.map((t) => `^${e(t, r)}$`);
              return `(?:${i.join("|")})`;
            }
            let i = "",
              n = "",
              s = ".";
            !0 === r
              ? ((i = "/"), (n = "[/\\\\]"), (s = "[^/\\\\]"))
              : r &&
                ((n = (function (e) {
                  let t = "";
                  for (let r = 0; r < e.length; r++) t += B(e[r]);
                  return t;
                })((i = r))).length > 1
                  ? ((n = `(?:${n})`), (s = `((?!${n}).)`))
                  : (s = `[^${n}]`));
            let o = r ? `${n}+?` : "",
              a = r ? `${n}*?` : "",
              l = r ? t.split(i) : [t],
              c = "";
            for (let e = 0; e < l.length; e++) {
              let t = l[e],
                i = l[e + 1],
                n = "";
              if (t || !(e > 0)) {
                if (
                  (r && (n = e === l.length - 1 ? a : "**" !== i ? o : ""),
                  r && "**" === t)
                ) {
                  n && ((c += 0 === e ? "" : n), (c += `(?:${s}*?${n})*?`));
                  continue;
                }
                for (let e = 0; e < t.length; e++) {
                  let r = t[e];
                  "\\" === r
                    ? e < t.length - 1 && ((c += B(t[e + 1])), e++)
                    : "?" === r
                      ? (c += s)
                      : "*" === r
                        ? (c += `${s}*?`)
                        : (c += B(r));
                }
                c += n;
              }
            }
            return c;
          })(e, t.separator),
          i = RegExp(`^${r}$`, t.flags),
          n = M.bind(null, i);
        return (n.options = t), (n.pattern = e), (n.regexp = i), n;
      }
      let W = U(async (e) => {
          if (e.request?.method !== "POST" || !e.request) return;
          let { body: t, query: r, context: i } = e,
            n = e.headers?.get("origin") || e.headers?.get("referer") || "",
            o = t?.callbackURL || r?.callbackURL,
            a = t?.redirectTo,
            l = t?.errorCallbackURL,
            c = t?.newUserCallbackURL,
            d = Array.isArray(i.options.trustedOrigins)
              ? i.trustedOrigins
              : [
                  ...i.trustedOrigins,
                  ...((await i.options.trustedOrigins?.(e.request)) || []),
                ],
            u = e.headers?.has("cookie"),
            h = (e, t) => {
              if (e.startsWith("/")) return !1;
              if (t.includes("*")) return j(t)((0, D.b)(e));
              let r = (0, D.c)(e);
              return "http:" !== r && "https:" !== r && r
                ? e.startsWith(t)
                : t === (0, D.g)(e);
            },
            p = (t, r) => {
              if (
                t &&
                !d.some(
                  (e) =>
                    h(t, e) ||
                    (t?.startsWith("/") &&
                      "origin" !== r &&
                      /^\/(?!\/|\\|%2f|%5c)[\w\-.\+/@]*(?:\?[\w\-.\+/=&%@]*)?$/.test(
                        t
                      ))
                )
              )
                throw (
                  (e.context.logger.error(`Invalid ${r}: ${t}`),
                  e.context.logger.info(
                    `If it's a valid URL, please add ${t} to trustedOrigins in your auth config
`,
                    `Current list of trustedOrigins: ${d}`
                  ),
                  new s.LG("FORBIDDEN", { message: `Invalid ${r}` }))
                );
            };
          u && !e.context.options.advanced?.disableCSRFCheck && p(n, "origin"),
            o && p(o, "callbackURL"),
            a && p(a, "redirectURL"),
            l && p(l, "errorCallbackURL"),
            c && p(c, "newUserCallbackURL");
        }),
        F = (e) =>
          U(async (t) => {
            if (!t.request) return;
            let { context: r } = t,
              i = e(t),
              n = Array.isArray(r.options.trustedOrigins)
                ? r.trustedOrigins
                : [
                    ...r.trustedOrigins,
                    ...((await r.options.trustedOrigins?.(t.request)) || []),
                  ],
              o = (e, t) =>
                !e.startsWith("/") &&
                (t.includes("*") ? j(t)((0, D.b)(e)) : e.startsWith(t)),
              a = (e, r) => {
                if (
                  e &&
                  !n.some(
                    (t) =>
                      o(e, t) ||
                      (e?.startsWith("/") &&
                        "origin" !== r &&
                        /^\/(?!\/|\\|%2f|%5c)[\w\-.\+/@]*(?:\?[\w\-.\+/=&%@]*)?$/.test(
                          e
                        ))
                  )
                )
                  throw (
                    (t.context.logger.error(`Invalid ${r}: ${e}`),
                    t.context.logger.info(
                      `If it's a valid URL, please add ${e} to trustedOrigins in your auth config
`,
                      `Current list of trustedOrigins: ${n}`
                    ),
                    new s.LG("FORBIDDEN", { message: `Invalid ${r}` }))
                  );
              };
            for (let e of Array.isArray(i) ? i : [i]) a(e, "callbackURL");
          }),
        Q = {
          USER_NOT_FOUND: "User not found",
          FAILED_TO_CREATE_USER: "Failed to create user",
          FAILED_TO_CREATE_SESSION: "Failed to create session",
          FAILED_TO_UPDATE_USER: "Failed to update user",
          FAILED_TO_GET_SESSION: "Failed to get session",
          INVALID_PASSWORD: "Invalid password",
          INVALID_EMAIL: "Invalid email",
          INVALID_EMAIL_OR_PASSWORD: "Invalid email or password",
          SOCIAL_ACCOUNT_ALREADY_LINKED: "Social account already linked",
          PROVIDER_NOT_FOUND: "Provider not found",
          INVALID_TOKEN: "invalid token",
          ID_TOKEN_NOT_SUPPORTED: "id_token not supported",
          FAILED_TO_GET_USER_INFO: "Failed to get user info",
          USER_EMAIL_NOT_FOUND: "User email not found",
          EMAIL_NOT_VERIFIED: "Email not verified",
          PASSWORD_TOO_SHORT: "Password too short",
          PASSWORD_TOO_LONG: "Password too long",
          USER_ALREADY_EXISTS: "User already exists",
          EMAIL_CAN_NOT_BE_UPDATED: "Email can not be updated",
          CREDENTIAL_ACCOUNT_NOT_FOUND: "Credential account not found",
          SESSION_EXPIRED:
            "Session expired. Re-authenticate to perform this action.",
          FAILED_TO_UNLINK_LAST_ACCOUNT: "You can't unlink your last account",
          ACCOUNT_NOT_FOUND: "Account not found",
          USER_ALREADY_HAS_PASSWORD:
            "User already has a password. Provide that to delete the account.",
        },
        z = () =>
          $(
            "/get-session",
            {
              method: "GET",
              query: i.z.optional(
                i.z.object({
                  disableCookieCache: i.z
                    .optional(
                      i.z
                        .boolean({
                          description:
                            "Disable cookie cache and fetch session from database",
                        })
                        .or(i.z.string().transform((e) => "true" === e))
                    )
                    .optional(),
                  disableRefresh: i.z
                    .boolean({
                      description:
                        "Disable session refresh. Useful for checking session status, without updating the session",
                    })
                    .or(i.z.string().transform((e) => "true" === e))
                    .optional(),
                })
              ),
              requireHeaders: !0,
              metadata: {
                openapi: {
                  description: "Get the current session",
                  responses: {
                    200: {
                      description: "Success",
                      content: {
                        "application/json": {
                          schema: {
                            type: "object",
                            properties: {
                              session: { $ref: "#/components/schemas/Session" },
                              user: { $ref: "#/components/schemas/User" },
                            },
                            required: ["session", "user"],
                          },
                        },
                      },
                    },
                  },
                },
              },
            },
            async (e) => {
              try {
                let t = await e.getSignedCookie(
                  e.context.authCookies.sessionToken.name,
                  e.context.secret
                );
                if (!t) return null;
                let r = e.getCookie(e.context.authCookies.sessionData.name),
                  i = r ? (0, c.s)(w.a.decode(h.K.decode(r))) : null;
                if (
                  i &&
                  !(await (0, g.s)("SHA-256", "base64urlnopad").verify(
                    e.context.secret,
                    JSON.stringify({ ...i.session, expiresAt: i.expiresAt }),
                    i.signature
                  ))
                ) {
                  let t = e.context.authCookies.sessionData.name;
                  return e.setCookie(t, "", { maxAge: 0 }), e.json(null);
                }
                let s = await e.getSignedCookie(
                  e.context.authCookies.dontRememberToken.name,
                  e.context.secret
                );
                if (
                  i?.session &&
                  e.context.options.session?.cookieCache?.enabled &&
                  !e.query?.disableCookieCache
                ) {
                  let t = i.session;
                  if (
                    !(
                      i.expiresAt < Date.now() ||
                      t.session.expiresAt < new Date()
                    )
                  )
                    return e.json(t);
                  {
                    let t = e.context.authCookies.sessionData.name;
                    e.setCookie(t, "", { maxAge: 0 });
                  }
                }
                let o = await e.context.internalAdapter.findSession(t);
                if (
                  ((e.context.session = o),
                  !o || o.session.expiresAt < new Date())
                )
                  return (
                    (0, n.eC)(e),
                    o &&
                      (await e.context.internalAdapter.deleteSession(
                        o.session.token
                      )),
                    e.json(null)
                  );
                if (s || e.query?.disableRefresh) return e.json(o);
                let a = e.context.sessionConfig.expiresIn,
                  l = e.context.sessionConfig.updateAge;
                if (
                  o.session.expiresAt.valueOf() - 1e3 * a + 1e3 * l <=
                    Date.now() &&
                  (!e.query?.disableRefresh ||
                    !e.context.options.session?.disableSessionRefresh)
                ) {
                  let t = await e.context.internalAdapter.updateSession(
                    o.session.token,
                    {
                      expiresAt: (0, d.g)(
                        e.context.sessionConfig.expiresIn,
                        "sec"
                      ),
                      updatedAt: new Date(),
                    }
                  );
                  if (!t) return (0, n.eC)(e), e.json(null, { status: 401 });
                  let r = (t.expiresAt.valueOf() - Date.now()) / 1e3;
                  return (
                    await (0, n.$G)(e, { session: t, user: o.user }, !1, {
                      maxAge: r,
                    }),
                    e.json({ session: t, user: o.user })
                  );
                }
                return await (0, n.vt)(e, o), e.json(o);
              } catch (t) {
                throw (
                  (e.context.logger.error("INTERNAL_SERVER_ERROR", t),
                  new s.LG("INTERNAL_SERVER_ERROR", {
                    message: Q.FAILED_TO_GET_SESSION,
                  }))
                );
              }
            }
          ),
        V = async (e, t) => {
          if (e.context.session) return e.context.session;
          let r = await z()({
            ...e,
            asResponse: !1,
            headers: e.headers,
            returnHeaders: !1,
            query: { ...t, ...e.query },
          }).catch((e) => null);
          return (e.context.session = r), r;
        },
        K = U(async (e) => {
          let t = await V(e);
          if (!t?.session) throw new s.LG("UNAUTHORIZED");
          return { session: t };
        }),
        G = U(async (e) => {
          let t = await V(e);
          if (!t?.session && (e.request || e.headers))
            throw new s.LG("UNAUTHORIZED");
          return { session: t };
        }),
        H = U(async (e) => {
          let t = await V(e);
          if (!t?.session) throw new s.LG("UNAUTHORIZED");
          if (0 === e.context.sessionConfig.freshAge) return { session: t };
          let r = e.context.sessionConfig.freshAge,
            i = t.session.updatedAt?.valueOf() || t.session.createdAt.valueOf();
          if (!(Date.now() - i < 1e3 * r))
            throw new s.LG("FORBIDDEN", { message: "Session is not fresh" });
          return { session: t };
        }),
        J = () =>
          $(
            "/list-sessions",
            {
              method: "GET",
              use: [K],
              requireHeaders: !0,
              metadata: {
                openapi: {
                  description: "List all active sessions for the user",
                  responses: {
                    200: {
                      description: "Success",
                      content: {
                        "application/json": {
                          schema: {
                            type: "array",
                            items: { $ref: "#/components/schemas/Session" },
                          },
                        },
                      },
                    },
                  },
                },
              },
            },
            async (e) => {
              try {
                let t = (
                  await e.context.internalAdapter.listSessions(
                    e.context.session.user.id
                  )
                ).filter((e) => e.expiresAt > new Date());
                return e.json(t);
              } catch (t) {
                throw (
                  (e.context.logger.error(t), e.error("INTERNAL_SERVER_ERROR"))
                );
              }
            }
          ),
        Z = $(
          "/revoke-session",
          {
            method: "POST",
            body: i.z.object({
              token: i.z.string({ description: "The token to revoke" }),
            }),
            use: [K],
            requireHeaders: !0,
            metadata: {
              openapi: {
                description: "Revoke a single session",
                requestBody: {
                  content: {
                    "application/json": {
                      schema: {
                        type: "object",
                        properties: {
                          token: {
                            type: "string",
                            description: "The token to revoke",
                          },
                        },
                        required: ["token"],
                      },
                    },
                  },
                },
                responses: {
                  200: {
                    description: "Success",
                    content: {
                      "application/json": {
                        schema: {
                          type: "object",
                          properties: {
                            status: {
                              type: "boolean",
                              description:
                                "Indicates if the session was revoked successfully",
                            },
                          },
                          required: ["status"],
                        },
                      },
                    },
                  },
                },
              },
            },
          },
          async (e) => {
            let t = e.body.token,
              r = await e.context.internalAdapter.findSession(t);
            if (!r)
              throw new s.LG("BAD_REQUEST", { message: "Session not found" });
            if (r.session.userId !== e.context.session.user.id)
              throw new s.LG("UNAUTHORIZED");
            try {
              await e.context.internalAdapter.deleteSession(t);
            } catch (t) {
              throw (
                (e.context.logger.error(
                  t && "object" == typeof t && "name" in t ? t.name : "",
                  t
                ),
                new s.LG("INTERNAL_SERVER_ERROR"))
              );
            }
            return e.json({ status: !0 });
          }
        ),
        Y = $(
          "/revoke-sessions",
          {
            method: "POST",
            use: [K],
            requireHeaders: !0,
            metadata: {
              openapi: {
                description: "Revoke all sessions for the user",
                responses: {
                  200: {
                    description: "Success",
                    content: {
                      "application/json": {
                        schema: {
                          type: "object",
                          properties: {
                            status: {
                              type: "boolean",
                              description:
                                "Indicates if all sessions were revoked successfully",
                            },
                          },
                          required: ["status"],
                        },
                      },
                    },
                  },
                },
              },
            },
          },
          async (e) => {
            try {
              await e.context.internalAdapter.deleteSessions(
                e.context.session.user.id
              );
            } catch (t) {
              throw (
                (e.context.logger.error(
                  t && "object" == typeof t && "name" in t ? t.name : "",
                  t
                ),
                new s.LG("INTERNAL_SERVER_ERROR"))
              );
            }
            return e.json({ status: !0 });
          }
        ),
        X = $(
          "/revoke-other-sessions",
          {
            method: "POST",
            requireHeaders: !0,
            use: [K],
            metadata: {
              openapi: {
                description:
                  "Revoke all other sessions for the user except the current one",
                responses: {
                  200: {
                    description: "Success",
                    content: {
                      "application/json": {
                        schema: {
                          type: "object",
                          properties: {
                            status: {
                              type: "boolean",
                              description:
                                "Indicates if all other sessions were revoked successfully",
                            },
                          },
                          required: ["status"],
                        },
                      },
                    },
                  },
                },
              },
            },
          },
          async (e) => {
            let t = e.context.session;
            if (!t.user) throw new s.LG("UNAUTHORIZED");
            let r = (await e.context.internalAdapter.listSessions(t.user.id))
              .filter((e) => e.expiresAt > new Date())
              .filter((t) => t.token !== e.context.session.session.token);
            return (
              await Promise.all(
                r.map((t) => e.context.internalAdapter.deleteSession(t.token))
              ),
              e.json({ status: !0 })
            );
          }
        );
      async function ee(e, t, r, i = 3600) {
        return await P({ email: t.toLowerCase(), updateTo: r }, e, i);
      }
      async function et(e, t) {
        if (!e.context.options.emailVerification?.sendVerificationEmail)
          throw (
            (e.context.logger.error("Verification email isn't enabled."),
            new s.LG("BAD_REQUEST", {
              message: "Verification email isn't enabled",
            }))
          );
        let r = await ee(
            e.context.secret,
            t.email,
            void 0,
            e.context.options.emailVerification?.expiresIn
          ),
          i = `${e.context.baseURL}/verify-email?token=${r}&callbackURL=${e.body.callbackURL || "/"}`;
        await e.context.options.emailVerification.sendVerificationEmail(
          { user: t, url: i, token: r },
          e.request
        );
      }
      let er = $(
          "/send-verification-email",
          {
            method: "POST",
            body: i.z.object({
              email: i.z
                .string({
                  description: "The email to send the verification email to",
                })
                .email(),
              callbackURL: i.z
                .string({
                  description: "The URL to use for email verification callback",
                })
                .optional(),
            }),
            metadata: {
              openapi: {
                description: "Send a verification email to the user",
                requestBody: {
                  content: {
                    "application/json": {
                      schema: {
                        type: "object",
                        properties: {
                          email: {
                            type: "string",
                            description:
                              "The email to send the verification email to",
                            example: "user@example.com",
                          },
                          callbackURL: {
                            type: "string",
                            description:
                              "The URL to use for email verification callback",
                            example: "https://example.com/callback",
                            nullable: !0,
                          },
                        },
                        required: ["email"],
                      },
                    },
                  },
                },
                responses: {
                  200: {
                    description: "Success",
                    content: {
                      "application/json": {
                        schema: {
                          type: "object",
                          properties: {
                            status: {
                              type: "boolean",
                              description:
                                "Indicates if the email was sent successfully",
                              example: !0,
                            },
                          },
                        },
                      },
                    },
                  },
                  400: {
                    description: "Bad Request",
                    content: {
                      "application/json": {
                        schema: {
                          type: "object",
                          properties: {
                            message: {
                              type: "string",
                              description: "Error message",
                              example: "Verification email isn't enabled",
                            },
                          },
                        },
                      },
                    },
                  },
                },
              },
            },
          },
          async (e) => {
            if (!e.context.options.emailVerification?.sendVerificationEmail)
              throw (
                (e.context.logger.error("Verification email isn't enabled."),
                new s.LG("BAD_REQUEST", {
                  message: "Verification email isn't enabled",
                }))
              );
            let { email: t } = e.body,
              r = await V(e);
            if (!r) {
              let r = await e.context.internalAdapter.findUserByEmail(t);
              return r && (await et(e, r.user)), e.json({ status: !0 });
            }
            if (r?.user.emailVerified)
              throw new s.LG("BAD_REQUEST", {
                message:
                  "You can only send a verification email to an unverified email",
              });
            if (r?.user.email !== t)
              throw new s.LG("BAD_REQUEST", {
                message:
                  "You can only send a verification email to your own email",
              });
            return await et(e, r.user), e.json({ status: !0 });
          }
        ),
        ei = $(
          "/verify-email",
          {
            method: "GET",
            query: i.z.object({
              token: i.z.string({
                description: "The token to verify the email",
              }),
              callbackURL: i.z
                .string({
                  description:
                    "The URL to redirect to after email verification",
                })
                .optional(),
            }),
            use: [F((e) => e.query.callbackURL)],
            metadata: {
              openapi: {
                description: "Verify the email of the user",
                parameters: [
                  {
                    name: "token",
                    in: "query",
                    description: "The token to verify the email",
                    required: !0,
                    schema: { type: "string" },
                  },
                  {
                    name: "callbackURL",
                    in: "query",
                    description:
                      "The URL to redirect to after email verification",
                    required: !1,
                    schema: { type: "string" },
                  },
                ],
                responses: {
                  200: {
                    description: "Success",
                    content: {
                      "application/json": {
                        schema: {
                          type: "object",
                          properties: {
                            user: {
                              type: "object",
                              properties: {
                                id: { type: "string", description: "User ID" },
                                email: {
                                  type: "string",
                                  description: "User email",
                                },
                                name: {
                                  type: "string",
                                  description: "User name",
                                },
                                image: {
                                  type: "string",
                                  description: "User image URL",
                                },
                                emailVerified: {
                                  type: "boolean",
                                  description:
                                    "Indicates if the user email is verified",
                                },
                                createdAt: {
                                  type: "string",
                                  description: "User creation date",
                                },
                                updatedAt: {
                                  type: "string",
                                  description: "User update date",
                                },
                              },
                              required: [
                                "id",
                                "email",
                                "name",
                                "image",
                                "emailVerified",
                                "createdAt",
                                "updatedAt",
                              ],
                            },
                            status: {
                              type: "boolean",
                              description:
                                "Indicates if the email was verified successfully",
                            },
                          },
                          required: ["user", "status"],
                        },
                      },
                    },
                  },
                },
              },
            },
          },
          async (e) => {
            let t;
            function r(t) {
              if (e.query.callbackURL) {
                if (e.query.callbackURL.includes("?"))
                  throw e.redirect(`${e.query.callbackURL}&error=${t}`);
                throw e.redirect(`${e.query.callbackURL}?error=${t}`);
              }
              throw new s.LG("UNAUTHORIZED", { message: t });
            }
            let { token: o } = e.query;
            try {
              t = await (0, p.V)(
                o,
                new TextEncoder().encode(e.context.secret),
                { algorithms: ["HS256"] }
              );
            } catch (e) {
              if (e instanceof x.n) return r("token_expired");
              return r("invalid_token");
            }
            let a = i.z
                .object({
                  email: i.z.string().email(),
                  updateTo: i.z.string().optional(),
                })
                .parse(t.payload),
              l = await e.context.internalAdapter.findUserByEmail(a.email);
            if (!l) return r("user_not_found");
            if (a.updateTo) {
              let t = await V(e);
              if (!t || t.user.email !== a.email) {
                if (e.query.callbackURL)
                  throw e.redirect(`${e.query.callbackURL}?error=unauthorized`);
                return r("unauthorized");
              }
              let i = await e.context.internalAdapter.updateUserByEmail(
                  a.email,
                  { email: a.updateTo, emailVerified: !1 },
                  e
                ),
                s = await ee(e.context.secret, a.updateTo);
              if (
                (await e.context.options.emailVerification?.sendVerificationEmail?.(
                  {
                    user: i,
                    url: `${e.context.baseURL}/verify-email?token=${s}&callbackURL=${e.query.callbackURL || "/"}`,
                    token: s,
                  },
                  e.request
                ),
                await (0, n.$G)(e, {
                  session: t.session,
                  user: { ...t.user, email: a.updateTo, emailVerified: !1 },
                }),
                e.query.callbackURL)
              )
                throw e.redirect(e.query.callbackURL);
              return e.json({
                status: !0,
                user: {
                  id: i.id,
                  email: i.email,
                  name: i.name,
                  image: i.image,
                  emailVerified: i.emailVerified,
                  createdAt: i.createdAt,
                  updatedAt: i.updatedAt,
                },
              });
            }
            if (
              (await e.context.options.emailVerification?.onEmailVerification?.(
                l.user,
                e.request
              ),
              await e.context.internalAdapter.updateUserByEmail(
                a.email,
                { emailVerified: !0 },
                e
              ),
              e.context.options.emailVerification?.autoSignInAfterVerification)
            ) {
              let t = await V(e);
              if (t && t.user.email === a.email)
                await (0, n.$G)(e, {
                  session: t.session,
                  user: { ...t.user, emailVerified: !0 },
                });
              else {
                let t = await e.context.internalAdapter.createSession(
                  l.user.id,
                  e
                );
                if (!t)
                  throw new s.LG("INTERNAL_SERVER_ERROR", {
                    message: "Failed to create session",
                  });
                await (0, n.$G)(e, {
                  session: t,
                  user: { ...l.user, emailVerified: !0 },
                });
              }
            }
            if (e.query.callbackURL) throw e.redirect(e.query.callbackURL);
            return e.json({ status: !0, user: null });
          }
        ),
        en = { isAction: !1 };
      async function es(
        e,
        {
          userInfo: t,
          account: r,
          callbackURL: i,
          disableSignUp: n,
          overrideUserInfo: o,
        }
      ) {
        let l = await e.context.internalAdapter
            .findOAuthUser(t.email.toLowerCase(), r.accountId, r.providerId)
            .catch((t) => {
              a.l.error(
                "Better auth was unable to query your database.\nError: ",
                t
              );
              let r =
                e.context.options.onAPIError?.errorURL ||
                `${e.context.baseURL}/error`;
              throw e.redirect(`${r}?error=internal_server_error`);
            }),
          c = l?.user,
          d = !c;
        if (l) {
          let i = l.accounts.find(
            (e) => e.providerId === r.providerId && e.accountId === r.accountId
          );
          if (i) {
            if (e.context.options.account?.updateAccountOnSignIn !== !1) {
              let t = Object.fromEntries(
                Object.entries({
                  accessToken: r.accessToken,
                  idToken: r.idToken,
                  refreshToken: r.refreshToken,
                  accessTokenExpiresAt: r.accessTokenExpiresAt,
                  refreshTokenExpiresAt: r.refreshTokenExpiresAt,
                  scope: r.scope,
                }).filter(([e, t]) => void 0 !== t)
              );
              Object.keys(t).length > 0 &&
                (await e.context.internalAdapter.updateAccount(i.id, t, e));
            }
          } else {
            let i = e.context.options.account?.accountLinking?.trustedProviders;
            if (
              (!i?.includes(r.providerId) && !t.emailVerified) ||
              e.context.options.account?.accountLinking?.enabled === !1
            )
              return (
                y.b &&
                  a.l.warn(
                    `User already exist but account isn't linked to ${r.providerId}. To read more about how account linking works in Better Auth see https://www.better-auth.com/docs/concepts/users-accounts#account-linking.`
                  ),
                { error: "account not linked", data: null }
              );
            try {
              await e.context.internalAdapter.linkAccount(
                {
                  providerId: r.providerId,
                  accountId: t.id.toString(),
                  userId: l.user.id,
                  accessToken: r.accessToken,
                  idToken: r.idToken,
                  refreshToken: r.refreshToken,
                  accessTokenExpiresAt: r.accessTokenExpiresAt,
                  refreshTokenExpiresAt: r.refreshTokenExpiresAt,
                  scope: r.scope,
                },
                e
              );
            } catch (e) {
              return (
                a.l.error("Unable to link account", e),
                { error: "unable to link account", data: null }
              );
            }
          }
          if (o) {
            let { id: r, ...i } = t;
            await e.context.internalAdapter.updateUser(l.user.id, {
              ...i,
              email: t.email.toLowerCase(),
              emailVerified:
                (t.email.toLowerCase() === l.user.email &&
                  l.user.emailVerified) ||
                t.emailVerified,
            });
          }
        } else {
          if (n)
            return { error: "signup disabled", data: null, isRegister: !1 };
          try {
            let { id: n, ...s } = t;
            if (
              ((c = await e.context.internalAdapter
                .createOAuthUser(
                  { ...s, email: t.email.toLowerCase() },
                  {
                    accessToken: r.accessToken,
                    idToken: r.idToken,
                    refreshToken: r.refreshToken,
                    accessTokenExpiresAt: r.accessTokenExpiresAt,
                    refreshTokenExpiresAt: r.refreshTokenExpiresAt,
                    scope: r.scope,
                    providerId: r.providerId,
                    accountId: t.id.toString(),
                  },
                  e
                )
                .then((e) => e?.user)),
              !t.emailVerified &&
                c &&
                e.context.options.emailVerification?.sendOnSignUp)
            ) {
              let t = await ee(
                  e.context.secret,
                  c.email,
                  void 0,
                  e.context.options.emailVerification?.expiresIn
                ),
                r = `${e.context.baseURL}/verify-email?token=${t}&callbackURL=${i}`;
              await e.context.options.emailVerification?.sendVerificationEmail?.(
                { user: c, url: r, token: t },
                e.request
              );
            }
          } catch (e) {
            if ((a.l.error(e), e instanceof s.LG))
              return { error: e.message, data: null, isRegister: !1 };
            return {
              error: "unable to create user",
              data: null,
              isRegister: !1,
            };
          }
        }
        if (!c)
          return { error: "unable to create user", data: null, isRegister: !1 };
        let u = await e.context.internalAdapter.createSession(c.id, e);
        return u
          ? { data: { session: u, user: c }, error: null, isRegister: d }
          : { error: "unable to create session", data: null, isRegister: !1 };
      }
      let eo = $(
          "/sign-in/social",
          {
            method: "POST",
            body: i.z.object({
              callbackURL: i.z
                .string({
                  description:
                    "Callback URL to redirect to after the user has signed in",
                })
                .optional(),
              newUserCallbackURL: i.z.string().optional(),
              errorCallbackURL: i.z
                .string({
                  description:
                    "Callback URL to redirect to if an error happens",
                })
                .optional(),
              provider: l.w_,
              disableRedirect: i.z
                .boolean({
                  description:
                    "Disable automatic redirection to the provider. Useful for handling the redirection yourself",
                })
                .optional(),
              idToken: i.z.optional(
                i.z.object({
                  token: i.z.string({
                    description: "ID token from the provider",
                  }),
                  nonce: i.z
                    .string({ description: "Nonce used to generate the token" })
                    .optional(),
                  accessToken: i.z
                    .string({ description: "Access token from the provider" })
                    .optional(),
                  refreshToken: i.z
                    .string({ description: "Refresh token from the provider" })
                    .optional(),
                  expiresAt: i.z
                    .number({ description: "Expiry date of the token" })
                    .optional(),
                }),
                {
                  description:
                    "ID token from the provider to sign in the user with id token",
                }
              ),
              scopes: i.z
                .array(i.z.string(), {
                  description:
                    "Array of scopes to request from the provider. This will override the default scopes passed.",
                })
                .optional(),
              requestSignUp: i.z
                .boolean({
                  description:
                    "Explicitly request sign-up. Useful when disableImplicitSignUp is true for this provider",
                })
                .optional(),
              loginHint: i.z
                .string({
                  description:
                    "The login hint to use for the authorization code request",
                })
                .optional(),
            }),
            metadata: {
              openapi: {
                description: "Sign in with a social provider",
                operationId: "socialSignIn",
                responses: {
                  200: {
                    description:
                      "Success - Returns either session details or redirect URL",
                    content: {
                      "application/json": {
                        schema: {
                          type: "object",
                          description:
                            "Session response when idToken is provided",
                          properties: {
                            redirect: { type: "boolean", enum: [!1] },
                            token: {
                              type: "string",
                              description: "Session token",
                              url: { type: "null", nullable: !0 },
                              user: {
                                type: "object",
                                properties: {
                                  id: { type: "string" },
                                  email: { type: "string" },
                                  name: { type: "string", nullable: !0 },
                                  image: { type: "string", nullable: !0 },
                                  emailVerified: { type: "boolean" },
                                  createdAt: {
                                    type: "string",
                                    format: "date-time",
                                  },
                                  updatedAt: {
                                    type: "string",
                                    format: "date-time",
                                  },
                                },
                                required: [
                                  "id",
                                  "email",
                                  "emailVerified",
                                  "createdAt",
                                  "updatedAt",
                                ],
                              },
                            },
                          },
                          required: ["redirect", "token", "user"],
                        },
                      },
                    },
                  },
                },
              },
            },
          },
          async (e) => {
            let t = e.context.socialProviders.find(
              (t) => t.id === e.body.provider
            );
            if (!t)
              throw (
                (e.context.logger.error(
                  "Provider not found. Make sure to add the provider in your auth config",
                  { provider: e.body.provider }
                ),
                new s.LG("NOT_FOUND", { message: Q.PROVIDER_NOT_FOUND }))
              );
            if (e.body.idToken) {
              if (!t.verifyIdToken)
                throw (
                  (e.context.logger.error(
                    "Provider does not support id token verification",
                    { provider: e.body.provider }
                  ),
                  new s.LG("NOT_FOUND", { message: Q.ID_TOKEN_NOT_SUPPORTED }))
                );
              let { token: r, nonce: i } = e.body.idToken;
              if (!(await t.verifyIdToken(r, i)))
                throw (
                  (e.context.logger.error("Invalid id token", {
                    provider: e.body.provider,
                  }),
                  new s.LG("UNAUTHORIZED", { message: Q.INVALID_TOKEN }))
                );
              let o = await t.getUserInfo({
                idToken: r,
                accessToken: e.body.idToken.accessToken,
                refreshToken: e.body.idToken.refreshToken,
              });
              if (!o || !o?.user)
                throw (
                  (e.context.logger.error("Failed to get user info", {
                    provider: e.body.provider,
                  }),
                  new s.LG("UNAUTHORIZED", {
                    message: Q.FAILED_TO_GET_USER_INFO,
                  }))
                );
              if (!o.user.email)
                throw (
                  (e.context.logger.error("User email not found", {
                    provider: e.body.provider,
                  }),
                  new s.LG("UNAUTHORIZED", { message: Q.USER_EMAIL_NOT_FOUND }))
                );
              let a = await es(e, {
                userInfo: {
                  ...o.user,
                  email: o.user.email,
                  id: o.user.id,
                  name: o.user.name || "",
                  image: o.user.image,
                  emailVerified: o.user.emailVerified || !1,
                },
                account: {
                  providerId: t.id,
                  accountId: o.user.id,
                  accessToken: e.body.idToken.accessToken,
                },
                callbackURL: e.body.callbackURL,
                disableSignUp:
                  (t.disableImplicitSignUp && !e.body.requestSignUp) ||
                  t.disableSignUp,
              });
              if (a.error) throw new s.LG("UNAUTHORIZED", { message: a.error });
              return (
                await (0, n.$G)(e, a.data),
                e.json({
                  redirect: !1,
                  token: a.data.session.token,
                  url: void 0,
                  user: {
                    id: a.data.user.id,
                    email: a.data.user.email,
                    name: a.data.user.name,
                    image: a.data.user.image,
                    emailVerified: a.data.user.emailVerified,
                    createdAt: a.data.user.createdAt,
                    updatedAt: a.data.user.updatedAt,
                  },
                })
              );
            }
            let { codeVerifier: r, state: i } = await (0, o.g)(e),
              a = await t.createAuthorizationURL({
                state: i,
                codeVerifier: r,
                redirectURI: `${e.context.baseURL}/callback/${t.id}`,
                scopes: e.body.scopes,
                loginHint: e.body.loginHint,
              });
            return e.json({
              url: a.toString(),
              redirect: !e.body.disableRedirect,
            });
          }
        ),
        ea = $(
          "/sign-in/email",
          {
            method: "POST",
            body: i.z.object({
              email: i.z.string({ description: "Email of the user" }),
              password: i.z.string({ description: "Password of the user" }),
              callbackURL: i.z
                .string({
                  description:
                    "Callback URL to use as a redirect for email verification",
                })
                .optional(),
              rememberMe: i.z
                .boolean({
                  description:
                    "If this is false, the session will not be remembered. Default is `true`.",
                })
                .default(!0)
                .optional(),
            }),
            metadata: {
              openapi: {
                description: "Sign in with email and password",
                responses: {
                  200: {
                    description:
                      "Success - Returns either session details or redirect URL",
                    content: {
                      "application/json": {
                        schema: {
                          type: "object",
                          description:
                            "Session response when idToken is provided",
                          properties: {
                            redirect: { type: "boolean", enum: [!1] },
                            token: {
                              type: "string",
                              description: "Session token",
                            },
                            url: { type: "null", nullable: !0 },
                            user: {
                              type: "object",
                              properties: {
                                id: { type: "string" },
                                email: { type: "string" },
                                name: { type: "string", nullable: !0 },
                                image: { type: "string", nullable: !0 },
                                emailVerified: { type: "boolean" },
                                createdAt: {
                                  type: "string",
                                  format: "date-time",
                                },
                                updatedAt: {
                                  type: "string",
                                  format: "date-time",
                                },
                              },
                              required: [
                                "id",
                                "email",
                                "emailVerified",
                                "createdAt",
                                "updatedAt",
                              ],
                            },
                          },
                          required: ["redirect", "token", "user"],
                        },
                      },
                    },
                  },
                },
              },
            },
          },
          async (e) => {
            if (!e.context.options?.emailAndPassword?.enabled)
              throw (
                (e.context.logger.error(
                  "Email and password is not enabled. Make sure to enable it in the options on you `auth.ts` file. Check `https://better-auth.com/docs/authentication/email-password` for more!"
                ),
                new s.LG("BAD_REQUEST", {
                  message: "Email and password is not enabled",
                }))
              );
            let { email: t, password: r } = e.body;
            if (!i.z.string().email().safeParse(t).success)
              throw new s.LG("BAD_REQUEST", { message: Q.INVALID_EMAIL });
            let o = await e.context.internalAdapter.findUserByEmail(t, {
              includeAccounts: !0,
            });
            if (!o)
              throw (
                (await e.context.password.hash(r),
                e.context.logger.error("User not found", { email: t }),
                new s.LG("UNAUTHORIZED", {
                  message: Q.INVALID_EMAIL_OR_PASSWORD,
                }))
              );
            let a = o.accounts.find((e) => "credential" === e.providerId);
            if (!a)
              throw (
                (e.context.logger.error("Credential account not found", {
                  email: t,
                }),
                new s.LG("UNAUTHORIZED", {
                  message: Q.INVALID_EMAIL_OR_PASSWORD,
                }))
              );
            let l = a?.password;
            if (!l)
              throw (
                (e.context.logger.error("Password not found", { email: t }),
                new s.LG("UNAUTHORIZED", {
                  message: Q.INVALID_EMAIL_OR_PASSWORD,
                }))
              );
            if (!(await e.context.password.verify({ hash: l, password: r })))
              throw (
                (e.context.logger.error("Invalid password"),
                new s.LG("UNAUTHORIZED", {
                  message: Q.INVALID_EMAIL_OR_PASSWORD,
                }))
              );
            if (
              e.context.options?.emailAndPassword?.requireEmailVerification &&
              !o.user.emailVerified
            ) {
              if (!e.context.options?.emailVerification?.sendVerificationEmail)
                throw new s.LG("FORBIDDEN", { message: Q.EMAIL_NOT_VERIFIED });
              let t = await ee(
                  e.context.secret,
                  o.user.email,
                  void 0,
                  e.context.options.emailVerification?.expiresIn
                ),
                r = `${e.context.baseURL}/verify-email?token=${t}&callbackURL=${e.body.callbackURL || "/"}`;
              throw (
                (await e.context.options.emailVerification.sendVerificationEmail(
                  { user: o.user, url: r, token: t },
                  e.request
                ),
                new s.LG("FORBIDDEN", { message: Q.EMAIL_NOT_VERIFIED }))
              );
            }
            let c = await e.context.internalAdapter.createSession(
              o.user.id,
              e,
              !1 === e.body.rememberMe
            );
            if (!c)
              throw (
                (e.context.logger.error("Failed to create session"),
                new s.LG("UNAUTHORIZED", {
                  message: Q.FAILED_TO_CREATE_SESSION,
                }))
              );
            return (
              await (0, n.$G)(
                e,
                { session: c, user: o.user },
                !1 === e.body.rememberMe
              ),
              e.json({
                redirect: !!e.body.callbackURL,
                token: c.token,
                url: e.body.callbackURL,
                user: {
                  id: o.user.id,
                  email: o.user.email,
                  name: o.user.name,
                  image: o.user.image,
                  emailVerified: o.user.emailVerified,
                  createdAt: o.user.createdAt,
                  updatedAt: o.user.updatedAt,
                },
              })
            );
          }
        ),
        el = i.z.object({
          code: i.z.string().optional(),
          error: i.z.string().optional(),
          device_id: i.z.string().optional(),
          error_description: i.z.string().optional(),
          state: i.z.string().optional(),
          user: i.z.string().optional(),
        }),
        ec = $(
          "/callback/:id",
          {
            method: ["GET", "POST"],
            body: el.optional(),
            query: el.optional(),
            metadata: en,
          },
          async (e) => {
            let t,
              r,
              i,
              s =
                e.context.options.onAPIError?.errorURL ||
                `${e.context.baseURL}/error`;
            try {
              if ("GET" === e.method) t = el.parse(e.query);
              else if ("POST" === e.method) t = el.parse(e.body);
              else throw Error("Unsupported method");
            } catch (t) {
              throw (
                (e.context.logger.error("INVALID_CALLBACK_REQUEST", t),
                e.redirect(`${s}?error=invalid_callback_request`))
              );
            }
            let {
              code: a,
              error: l,
              state: d,
              error_description: u,
              device_id: h,
            } = t;
            if (l) throw e.redirect(`${s}?error=${l}&error_description=${u}`);
            if (!d)
              throw (
                (e.context.logger.error("State not found", l),
                e.redirect(`${s}?error=state_not_found`))
              );
            let {
              codeVerifier: p,
              callbackURL: f,
              link: m,
              errorURL: y,
              newUserURL: g,
              requestSignUp: w,
            } = await (0, o.p)(e);
            function b(t) {
              let r = y || s;
              throw (
                ((r = r.includes("?") ? `${r}&error=${t}` : `${r}?error=${t}`),
                e.redirect(r))
              );
            }
            if (!a)
              throw (e.context.logger.error("Code not found"), b("no_code"));
            let v = e.context.socialProviders.find((t) => t.id === e.params.id);
            if (!v)
              throw (
                (e.context.logger.error(
                  "Oauth provider with id",
                  e.params.id,
                  "not found"
                ),
                b("oauth_provider_not_found"))
              );
            try {
              r = await v.validateAuthorizationCode({
                code: a,
                codeVerifier: p,
                deviceId: h,
                redirectURI: `${e.context.baseURL}/callback/${v.id}`,
              });
            } catch (t) {
              throw (e.context.logger.error("", t), b("invalid_code"));
            }
            let N = await v
              .getUserInfo({
                ...r,
                user: e.body?.user ? (0, c.s)(e.body.user) : void 0,
              })
              .then((e) => e?.user);
            if (!N)
              return (
                e.context.logger.error("Unable to get user info"),
                b("unable_to_get_user_info")
              );
            if (!N.email)
              return (
                e.context.logger.error(
                  "Provider did not return email. This could be due to misconfiguration in the provider settings."
                ),
                b("email_not_found")
              );
            if (!f)
              throw (
                (e.context.logger.error("No callback URL found"),
                b("no_callback_url"))
              );
            if (m) {
              let t,
                i = e.context.options.account?.accountLinking?.trustedProviders;
              if (
                (!i?.includes(v.id) && !N.emailVerified) ||
                e.context.options.account?.accountLinking?.enabled === !1
              )
                return (
                  e.context.logger.error(
                    "Unable to link account - untrusted provider"
                  ),
                  b("unable_to_link_account")
                );
              let n = await e.context.internalAdapter.findAccount(N.id);
              if (n) {
                if (n.userId.toString() !== m.userId.toString())
                  return b("account_already_linked_to_different_user");
                let t = Object.fromEntries(
                  Object.entries({
                    accessToken: r.accessToken,
                    idToken: r.idToken,
                    refreshToken: r.refreshToken,
                    accessTokenExpiresAt: r.accessTokenExpiresAt,
                    refreshTokenExpiresAt: r.refreshTokenExpiresAt,
                    scope: r.scopes?.join(","),
                  }).filter(([e, t]) => void 0 !== t)
                );
                await e.context.internalAdapter.updateAccount(n.id, t);
              } else if (
                !(await e.context.internalAdapter.createAccount(
                  {
                    userId: m.userId,
                    providerId: v.id,
                    accountId: N.id,
                    ...r,
                    scope: r.scopes?.join(","),
                  },
                  e
                ))
              )
                return b("unable_to_link_account");
              try {
                t = f.toString();
              } catch {
                t = f;
              }
              throw e.redirect(t);
            }
            let x = await es(e, {
              userInfo: { ...N, email: N.email, name: N.name || N.email },
              account: {
                providerId: v.id,
                accountId: N.id,
                ...r,
                scope: r.scopes?.join(","),
              },
              callbackURL: f,
              disableSignUp:
                (v.disableImplicitSignUp && !w) || v.options?.disableSignUp,
              overrideUserInfo: v.options?.overrideUserInfoOnSignIn,
            });
            if (x.error)
              return (
                e.context.logger.error(x.error.split(" ").join("_")),
                b(x.error.split(" ").join("_"))
              );
            let { session: _, user: S } = x.data;
            await (0, n.$G)(e, { session: _, user: S });
            try {
              i = ((x.isRegister && g) || f).toString();
            } catch {
              i = (x.isRegister && g) || f;
            }
            throw e.redirect(i);
          }
        ),
        ed = $(
          "/sign-out",
          {
            method: "POST",
            requireHeaders: !0,
            metadata: {
              openapi: {
                description: "Sign out the current user",
                responses: {
                  200: {
                    description: "Success",
                    content: {
                      "application/json": {
                        schema: {
                          type: "object",
                          properties: { success: { type: "boolean" } },
                        },
                      },
                    },
                  },
                },
              },
            },
          },
          async (e) => {
            let t = await e.getSignedCookie(
              e.context.authCookies.sessionToken.name,
              e.context.secret
            );
            if (!t)
              throw (
                ((0, n.eC)(e),
                new s.LG("BAD_REQUEST", { message: Q.FAILED_TO_GET_SESSION }))
              );
            return (
              await e.context.internalAdapter.deleteSession(t),
              (0, n.eC)(e),
              e.json({ success: !0 })
            );
          }
        );
      function eu(e, t, r) {
        let i = t ? new URL(t, e.baseURL) : new URL(`${e.baseURL}/error`);
        return (
          r && Object.entries(r).forEach(([e, t]) => i.searchParams.set(e, t)),
          i.href
        );
      }
      let eh = $(
          "/request-password-reset",
          {
            method: "POST",
            body: i.z.object({
              email: i.z
                .string({
                  description:
                    "The email address of the user to send a password reset email to",
                })
                .email(),
              redirectTo: i.z
                .string({
                  description:
                    "The URL to redirect the user to reset their password. If the token isn't valid or expired, it'll be redirected with a query parameter `?error=INVALID_TOKEN`. If the token is valid, it'll be redirected with a query parameter `?token=VALID_TOKEN",
                })
                .optional(),
            }),
            metadata: {
              openapi: {
                description: "Send a password reset email to the user",
                responses: {
                  200: {
                    description: "Success",
                    content: {
                      "application/json": {
                        schema: {
                          type: "object",
                          properties: {
                            status: { type: "boolean" },
                            message: { type: "string" },
                          },
                        },
                      },
                    },
                  },
                },
              },
            },
          },
          async (e) => {
            if (!e.context.options.emailAndPassword?.sendResetPassword)
              throw (
                (e.context.logger.error(
                  "Reset password isn't enabled.Please pass an emailAndPassword.sendResetPassword function in your auth config!"
                ),
                new s.LG("BAD_REQUEST", {
                  message: "Reset password isn't enabled",
                }))
              );
            let { email: t, redirectTo: r } = e.body,
              i = await e.context.internalAdapter.findUserByEmail(t, {
                includeAccounts: !0,
              });
            if (!i)
              return (
                e.context.logger.error("Reset Password: User not found", {
                  email: t,
                }),
                e.json({
                  status: !0,
                  message:
                    "If this email exists in our system, check your email for the reset link",
                })
              );
            let n = (0, d.g)(
                e.context.options.emailAndPassword
                  .resetPasswordTokenExpiresIn || 3600,
                "sec"
              ),
              o = (0, u.g)(24);
            await e.context.internalAdapter.createVerificationValue(
              {
                value: i.user.id,
                identifier: `reset-password:${o}`,
                expiresAt: n,
              },
              e
            );
            let a = r ? encodeURIComponent(r) : "",
              l = `${e.context.baseURL}/reset-password/${o}?callbackURL=${a}`;
            return (
              await e.context.options.emailAndPassword.sendResetPassword(
                { user: i.user, url: l, token: o },
                e.request
              ),
              e.json({ status: !0 })
            );
          }
        ),
        ep = $(
          "/forget-password",
          {
            method: "POST",
            body: i.z.object({
              email: i.z
                .string({
                  description:
                    "The email address of the user to send a password reset email to",
                })
                .email(),
              redirectTo: i.z
                .string({
                  description:
                    "The URL to redirect the user to reset their password. If the token isn't valid or expired, it'll be redirected with a query parameter `?error=INVALID_TOKEN`. If the token is valid, it'll be redirected with a query parameter `?token=VALID_TOKEN",
                })
                .optional(),
            }),
            metadata: {
              openapi: {
                description: "Send a password reset email to the user",
                responses: {
                  200: {
                    description: "Success",
                    content: {
                      "application/json": {
                        schema: {
                          type: "object",
                          properties: {
                            status: { type: "boolean" },
                            message: { type: "string" },
                          },
                        },
                      },
                    },
                  },
                },
              },
            },
          },
          async (e) => {
            if (!e.context.options.emailAndPassword?.sendResetPassword)
              throw (
                (e.context.logger.error(
                  "Reset password isn't enabled.Please pass an emailAndPassword.sendResetPassword function in your auth config!"
                ),
                new s.LG("BAD_REQUEST", {
                  message: "Reset password isn't enabled",
                }))
              );
            let { email: t, redirectTo: r } = e.body,
              i = await e.context.internalAdapter.findUserByEmail(t, {
                includeAccounts: !0,
              });
            if (!i)
              return (
                e.context.logger.error("Reset Password: User not found", {
                  email: t,
                }),
                e.json({
                  status: !0,
                  message:
                    "If this email exists in our system, check your email for the reset link",
                })
              );
            let n = (0, d.g)(
                e.context.options.emailAndPassword
                  .resetPasswordTokenExpiresIn || 3600,
                "sec"
              ),
              o = (0, u.g)(24);
            await e.context.internalAdapter.createVerificationValue(
              {
                value: i.user.id,
                identifier: `reset-password:${o}`,
                expiresAt: n,
              },
              e
            );
            let a = r ? encodeURIComponent(r) : "",
              l = `${e.context.baseURL}/reset-password/${o}?callbackURL=${a}`;
            return (
              await e.context.options.emailAndPassword.sendResetPassword(
                { user: i.user, url: l, token: o },
                e.request
              ),
              e.json({ status: !0 })
            );
          }
        ),
        ef = $(
          "/reset-password/:token",
          {
            method: "GET",
            query: i.z.object({
              callbackURL: i.z.string({
                description:
                  "The URL to redirect the user to reset their password",
              }),
            }),
            use: [F((e) => e.query.callbackURL)],
            metadata: {
              openapi: {
                description:
                  "Redirects the user to the callback URL with the token",
                responses: {
                  200: {
                    description: "Success",
                    content: {
                      "application/json": {
                        schema: {
                          type: "object",
                          properties: { token: { type: "string" } },
                        },
                      },
                    },
                  },
                },
              },
            },
          },
          async (e) => {
            let { token: t } = e.params,
              { callbackURL: r } = e.query;
            if (!t || !r)
              throw e.redirect(eu(e.context, r, { error: "INVALID_TOKEN" }));
            let i = await e.context.internalAdapter.findVerificationValue(
              `reset-password:${t}`
            );
            if (!i || i.expiresAt < new Date())
              throw e.redirect(eu(e.context, r, { error: "INVALID_TOKEN" }));
            throw e.redirect(
              (function (e, t, r) {
                let i = new URL(t, e.baseURL);
                return (
                  r &&
                    Object.entries(r).forEach(([e, t]) =>
                      i.searchParams.set(e, t)
                    ),
                  i.href
                );
              })(e.context, r, { token: t })
            );
          }
        ),
        em = ef,
        ey = $(
          "/reset-password",
          {
            method: "POST",
            query: i.z.object({ token: i.z.string().optional() }).optional(),
            body: i.z.object({
              newPassword: i.z.string({
                description: "The new password to set",
              }),
              token: i.z
                .string({ description: "The token to reset the password" })
                .optional(),
            }),
            metadata: {
              openapi: {
                description: "Reset the password for a user",
                responses: {
                  200: {
                    description: "Success",
                    content: {
                      "application/json": {
                        schema: {
                          type: "object",
                          properties: { status: { type: "boolean" } },
                        },
                      },
                    },
                  },
                },
              },
            },
          },
          async (e) => {
            let t = e.body.token || e.query?.token;
            if (!t) throw new s.LG("BAD_REQUEST", { message: Q.INVALID_TOKEN });
            let { newPassword: r } = e.body,
              i = e.context.password?.config.minPasswordLength,
              n = e.context.password?.config.maxPasswordLength;
            if (r.length < i)
              throw new s.LG("BAD_REQUEST", { message: Q.PASSWORD_TOO_SHORT });
            if (r.length > n)
              throw new s.LG("BAD_REQUEST", { message: Q.PASSWORD_TOO_LONG });
            let o = `reset-password:${t}`,
              a = await e.context.internalAdapter.findVerificationValue(o);
            if (!a || a.expiresAt < new Date())
              throw new s.LG("BAD_REQUEST", { message: Q.INVALID_TOKEN });
            let l = a.value,
              c = await e.context.password.hash(r);
            return (
              (await e.context.internalAdapter.findAccounts(l)).find(
                (e) => "credential" === e.providerId
              )
                ? (await e.context.internalAdapter.updatePassword(l, c, e),
                  await e.context.internalAdapter.deleteVerificationValue(a.id),
                  e.context.options.emailAndPassword
                    ?.revokeSessionsOnPasswordReset &&
                    (await e.context.internalAdapter.deleteSessions(l)))
                : (await e.context.internalAdapter.createAccount(
                    {
                      userId: l,
                      providerId: "credential",
                      password: c,
                      accountId: l,
                    },
                    e
                  ),
                  await e.context.internalAdapter.deleteVerificationValue(
                    a.id
                  )),
              e.json({ status: !0 })
            );
          }
        ),
        eg = () =>
          $(
            "/update-user",
            {
              method: "POST",
              body: i.z.record(i.z.string(), i.z.any()),
              use: [K],
              metadata: {
                $Infer: { body: {} },
                openapi: {
                  description: "Update the current user",
                  requestBody: {
                    content: {
                      "application/json": {
                        schema: {
                          type: "object",
                          properties: {
                            name: {
                              type: "string",
                              description: "The name of the user",
                            },
                            image: {
                              type: "string",
                              description: "The image of the user",
                            },
                          },
                        },
                      },
                    },
                  },
                  responses: {
                    200: {
                      description: "Success",
                      content: {
                        "application/json": {
                          schema: {
                            type: "object",
                            properties: {
                              status: {
                                type: "boolean",
                                description:
                                  "Indicates if the update was successful",
                              },
                            },
                          },
                        },
                      },
                    },
                  },
                },
              },
            },
            async (e) => {
              let t = e.body;
              if (t.email)
                throw new s.LG("BAD_REQUEST", {
                  message: Q.EMAIL_CAN_NOT_BE_UPDATED,
                });
              let { name: r, image: i, ...o } = t,
                a = e.context.session;
              if (void 0 === i && void 0 === r && 0 === Object.keys(o).length)
                return e.json({ status: !0 });
              let l = (0, m.f)(e.context.options, o, "update"),
                c = await e.context.internalAdapter.updateUser(
                  a.user.id,
                  { name: r, image: i, ...l },
                  e
                );
              return (
                await (0, n.$G)(e, { session: a.session, user: c }),
                e.json({ status: !0 })
              );
            }
          ),
        ew = $(
          "/change-password",
          {
            method: "POST",
            body: i.z.object({
              newPassword: i.z.string({
                description: "The new password to set",
              }),
              currentPassword: i.z.string({
                description: "The current password",
              }),
              revokeOtherSessions: i.z
                .boolean({ description: "Revoke all other sessions" })
                .optional(),
            }),
            use: [K],
            metadata: {
              openapi: {
                description: "Change the password of the user",
                responses: {
                  200: {
                    description: "Password successfully changed",
                    content: {
                      "application/json": {
                        schema: {
                          type: "object",
                          properties: {
                            token: {
                              type: "string",
                              nullable: !0,
                              description:
                                "New session token if other sessions were revoked",
                            },
                            user: {
                              type: "object",
                              properties: {
                                id: {
                                  type: "string",
                                  description:
                                    "The unique identifier of the user",
                                },
                                email: {
                                  type: "string",
                                  format: "email",
                                  description: "The email address of the user",
                                },
                                name: {
                                  type: "string",
                                  description: "The name of the user",
                                },
                                image: {
                                  type: "string",
                                  format: "uri",
                                  nullable: !0,
                                  description:
                                    "The profile image URL of the user",
                                },
                                emailVerified: {
                                  type: "boolean",
                                  description:
                                    "Whether the email has been verified",
                                },
                                createdAt: {
                                  type: "string",
                                  format: "date-time",
                                  description: "When the user was created",
                                },
                                updatedAt: {
                                  type: "string",
                                  format: "date-time",
                                  description: "When the user was last updated",
                                },
                              },
                              required: [
                                "id",
                                "email",
                                "name",
                                "emailVerified",
                                "createdAt",
                                "updatedAt",
                              ],
                            },
                          },
                          required: ["user"],
                        },
                      },
                    },
                  },
                },
              },
            },
          },
          async (e) => {
            let {
                newPassword: t,
                currentPassword: r,
                revokeOtherSessions: i,
              } = e.body,
              o = e.context.session,
              a = e.context.password.config.minPasswordLength;
            if (t.length < a)
              throw (
                (e.context.logger.error("Password is too short"),
                new s.LG("BAD_REQUEST", { message: Q.PASSWORD_TOO_SHORT }))
              );
            let l = e.context.password.config.maxPasswordLength;
            if (t.length > l)
              throw (
                (e.context.logger.error("Password is too long"),
                new s.LG("BAD_REQUEST", { message: Q.PASSWORD_TOO_LONG }))
              );
            let c = (
              await e.context.internalAdapter.findAccounts(o.user.id)
            ).find((e) => "credential" === e.providerId && e.password);
            if (!c || !c.password)
              throw new s.LG("BAD_REQUEST", {
                message: Q.CREDENTIAL_ACCOUNT_NOT_FOUND,
              });
            let d = await e.context.password.hash(t);
            if (
              !(await e.context.password.verify({
                hash: c.password,
                password: r,
              }))
            )
              throw new s.LG("BAD_REQUEST", { message: Q.INVALID_PASSWORD });
            await e.context.internalAdapter.updateAccount(c.id, {
              password: d,
            });
            let u = null;
            if (i) {
              await e.context.internalAdapter.deleteSessions(o.user.id);
              let t = await e.context.internalAdapter.createSession(
                o.user.id,
                e
              );
              if (!t)
                throw new s.LG("INTERNAL_SERVER_ERROR", {
                  message: Q.FAILED_TO_GET_SESSION,
                });
              await (0, n.$G)(e, { session: t, user: o.user }), (u = t.token);
            }
            return e.json({
              token: u,
              user: {
                id: o.user.id,
                email: o.user.email,
                name: o.user.name,
                image: o.user.image,
                emailVerified: o.user.emailVerified,
                createdAt: o.user.createdAt,
                updatedAt: o.user.updatedAt,
              },
            });
          }
        ),
        eb = $(
          "/set-password",
          {
            method: "POST",
            body: i.z.object({ newPassword: i.z.string() }),
            metadata: { SERVER_ONLY: !0 },
            use: [K],
          },
          async (e) => {
            let { newPassword: t } = e.body,
              r = e.context.session,
              i = e.context.password.config.minPasswordLength;
            if (t.length < i)
              throw (
                (e.context.logger.error("Password is too short"),
                new s.LG("BAD_REQUEST", { message: Q.PASSWORD_TOO_SHORT }))
              );
            let n = e.context.password.config.maxPasswordLength;
            if (t.length > n)
              throw (
                (e.context.logger.error("Password is too long"),
                new s.LG("BAD_REQUEST", { message: Q.PASSWORD_TOO_LONG }))
              );
            let o = (
                await e.context.internalAdapter.findAccounts(r.user.id)
              ).find((e) => "credential" === e.providerId && e.password),
              a = await e.context.password.hash(t);
            if (!o)
              return (
                await e.context.internalAdapter.linkAccount(
                  {
                    userId: r.user.id,
                    providerId: "credential",
                    accountId: r.user.id,
                    password: a,
                  },
                  e
                ),
                e.json({ status: !0 })
              );
            throw new s.LG("BAD_REQUEST", {
              message: "user already has a password",
            });
          }
        ),
        ev = $(
          "/delete-user",
          {
            method: "POST",
            use: [K],
            body: i.z.object({
              callbackURL: i.z.string().optional(),
              password: i.z.string().optional(),
              token: i.z.string().optional(),
            }),
            metadata: {
              openapi: {
                description: "Delete the user",
                responses: {
                  200: {
                    description: "User deletion processed successfully",
                    content: {
                      "application/json": {
                        schema: {
                          type: "object",
                          properties: {
                            success: {
                              type: "boolean",
                              description:
                                "Indicates if the operation was successful",
                            },
                            message: {
                              type: "string",
                              enum: ["User deleted", "Verification email sent"],
                              description:
                                "Status message of the deletion process",
                            },
                          },
                          required: ["success", "message"],
                        },
                      },
                    },
                  },
                },
              },
            },
          },
          async (e) => {
            if (!e.context.options.user?.deleteUser?.enabled)
              throw (
                (e.context.logger.error(
                  "Delete user is disabled. Enable it in the options",
                  { session: e.context.session }
                ),
                new s.LG("NOT_FOUND"))
              );
            let t = e.context.session;
            if (e.body.password) {
              let r = (
                await e.context.internalAdapter.findAccounts(t.user.id)
              ).find((e) => "credential" === e.providerId && e.password);
              if (!r || !r.password)
                throw new s.LG("BAD_REQUEST", {
                  message: Q.CREDENTIAL_ACCOUNT_NOT_FOUND,
                });
              if (
                !(await e.context.password.verify({
                  hash: r.password,
                  password: e.body.password,
                }))
              )
                throw new s.LG("BAD_REQUEST", { message: Q.INVALID_PASSWORD });
            }
            if (e.body.token)
              return (
                await eN({ ...e, query: { token: e.body.token } }),
                e.json({ success: !0, message: "User deleted" })
              );
            if (
              e.context.options.user.deleteUser?.sendDeleteAccountVerification
            ) {
              let r = (0, f.g)(32, "0-9", "a-z");
              await e.context.internalAdapter.createVerificationValue(
                {
                  value: t.user.id,
                  identifier: `delete-account-${r}`,
                  expiresAt: new Date(
                    Date.now() +
                      1e3 *
                        (e.context.options.user.deleteUser
                          ?.deleteTokenExpiresIn || 86400)
                  ),
                },
                e
              );
              let i = `${e.context.baseURL}/delete-user/callback?token=${r}&callbackURL=${e.body.callbackURL || "/"}`;
              return (
                await e.context.options.user.deleteUser.sendDeleteAccountVerification(
                  { user: t.user, url: i, token: r },
                  e.request
                ),
                e.json({ success: !0, message: "Verification email sent" })
              );
            }
            if (!e.body.password && 0 !== e.context.sessionConfig.freshAge) {
              let r = t.session.createdAt.getTime(),
                i = 1e3 * e.context.sessionConfig.freshAge;
              if (Date.now() - r > 1e3 * i)
                throw new s.LG("BAD_REQUEST", { message: Q.SESSION_EXPIRED });
            }
            let r = e.context.options.user.deleteUser?.beforeDelete;
            r && (await r(t.user, e.request)),
              await e.context.internalAdapter.deleteUser(t.user.id),
              await e.context.internalAdapter.deleteSessions(t.user.id),
              await e.context.internalAdapter.deleteAccounts(t.user.id),
              (0, n.eC)(e);
            let i = e.context.options.user.deleteUser?.afterDelete;
            return (
              i && (await i(t.user, e.request)),
              e.json({ success: !0, message: "User deleted" })
            );
          }
        ),
        eN = $(
          "/delete-user/callback",
          {
            method: "GET",
            query: i.z.object({
              token: i.z.string(),
              callbackURL: i.z.string().optional(),
            }),
            use: [F((e) => e.query.callbackURL)],
            metadata: {
              openapi: {
                description:
                  "Callback to complete user deletion with verification token",
                responses: {
                  200: {
                    description: "User successfully deleted",
                    content: {
                      "application/json": {
                        schema: {
                          type: "object",
                          properties: {
                            success: {
                              type: "boolean",
                              description:
                                "Indicates if the deletion was successful",
                            },
                            message: {
                              type: "string",
                              enum: ["User deleted"],
                              description: "Confirmation message",
                            },
                          },
                          required: ["success", "message"],
                        },
                      },
                    },
                  },
                },
              },
            },
          },
          async (e) => {
            if (!e.context.options.user?.deleteUser?.enabled)
              throw (
                (e.context.logger.error(
                  "Delete user is disabled. Enable it in the options"
                ),
                new s.LG("NOT_FOUND"))
              );
            let t = await V(e);
            if (!t)
              throw new s.LG("NOT_FOUND", {
                message: Q.FAILED_TO_GET_USER_INFO,
              });
            let r = await e.context.internalAdapter.findVerificationValue(
              `delete-account-${e.query.token}`
            );
            if (!r || r.expiresAt < new Date() || r.value !== t.user.id)
              throw new s.LG("NOT_FOUND", { message: Q.INVALID_TOKEN });
            let i = e.context.options.user.deleteUser?.beforeDelete;
            i && (await i(t.user, e.request)),
              await e.context.internalAdapter.deleteUser(t.user.id),
              await e.context.internalAdapter.deleteSessions(t.user.id),
              await e.context.internalAdapter.deleteAccounts(t.user.id),
              await e.context.internalAdapter.deleteVerificationValue(r.id),
              (0, n.eC)(e);
            let o = e.context.options.user.deleteUser?.afterDelete;
            if ((o && (await o(t.user, e.request)), e.query.callbackURL))
              throw e.redirect(e.query.callbackURL || "/");
            return e.json({ success: !0, message: "User deleted" });
          }
        ),
        ex = $(
          "/change-email",
          {
            method: "POST",
            body: i.z.object({
              newEmail: i.z
                .string({ description: "The new email to set" })
                .email(),
              callbackURL: i.z
                .string({
                  description:
                    "The URL to redirect to after email verification",
                })
                .optional(),
            }),
            use: [K],
            metadata: {
              openapi: {
                responses: {
                  200: {
                    description: "Email change request processed successfully",
                    content: {
                      "application/json": {
                        schema: {
                          type: "object",
                          properties: {
                            status: {
                              type: "boolean",
                              description:
                                "Indicates if the request was successful",
                            },
                            message: {
                              type: "string",
                              enum: [
                                "Email updated",
                                "Verification email sent",
                              ],
                              description:
                                "Status message of the email change process",
                              nullable: !0,
                            },
                          },
                          required: ["status"],
                        },
                      },
                    },
                  },
                },
              },
            },
          },
          async (e) => {
            if (!e.context.options.user?.changeEmail?.enabled)
              throw (
                (e.context.logger.error("Change email is disabled."),
                new s.LG("BAD_REQUEST", {
                  message: "Change email is disabled",
                }))
              );
            let t = e.body.newEmail.toLowerCase();
            if (t === e.context.session.user.email)
              throw (
                (e.context.logger.error("Email is the same"),
                new s.LG("BAD_REQUEST", { message: "Email is the same" }))
              );
            if (await e.context.internalAdapter.findUserByEmail(t))
              throw (
                (e.context.logger.error("Email already exists"),
                new s.LG("BAD_REQUEST", {
                  message: "Couldn't update your email",
                }))
              );
            if (!0 !== e.context.session.user.emailVerified) {
              if (await e.context.internalAdapter.findUserByEmail(t))
                throw new s.LG("UNPROCESSABLE_ENTITY", {
                  message: Q.USER_ALREADY_EXISTS,
                });
              if (
                (await e.context.internalAdapter.updateUserByEmail(
                  e.context.session.user.email,
                  { email: t },
                  e
                ),
                await (0, n.$G)(e, {
                  session: e.context.session.session,
                  user: { ...e.context.session.user, email: t },
                }),
                e.context.options.emailVerification?.sendVerificationEmail)
              ) {
                let r = await ee(
                    e.context.secret,
                    t,
                    void 0,
                    e.context.options.emailVerification?.expiresIn
                  ),
                  i = `${e.context.baseURL}/verify-email?token=${r}&callbackURL=${e.body.callbackURL || "/"}`;
                await e.context.options.emailVerification.sendVerificationEmail(
                  {
                    user: { ...e.context.session.user, email: t },
                    url: i,
                    token: r,
                  },
                  e.request
                );
              }
              return e.json({ status: !0 });
            }
            if (!e.context.options.user.changeEmail.sendChangeEmailVerification)
              throw (
                (e.context.logger.error("Verification email isn't enabled."),
                new s.LG("BAD_REQUEST", {
                  message: "Verification email isn't enabled",
                }))
              );
            let r = await ee(
                e.context.secret,
                e.context.session.user.email,
                t,
                e.context.options.emailVerification?.expiresIn
              ),
              i = `${e.context.baseURL}/verify-email?token=${r}&callbackURL=${e.body.callbackURL || "/"}`;
            return (
              await e.context.options.user.changeEmail.sendChangeEmailVerification(
                { user: e.context.session.user, newEmail: t, url: i, token: r },
                e.request
              ),
              e.json({ status: !0 })
            );
          }
        ),
        e_ = (e = "Unknown") => `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Authentication Error</title>
    <style>
        :root {
            --bg-color: #f8f9fa;
            --text-color: #212529;
            --accent-color: #000000;
            --error-color: #dc3545;
            --border-color: #e9ecef;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            line-height: 1.5;
        }
        .error-container {
            background-color: #ffffff;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
            padding: 2.5rem;
            text-align: center;
            max-width: 90%;
            width: 400px;
        }
        h1 {
            color: var(--error-color);
            font-size: 1.75rem;
            margin-bottom: 1rem;
            font-weight: 600;
        }
        p {
            margin-bottom: 1.5rem;
            color: #495057;
        }
        .btn {
            background-color: var(--accent-color);
            color: #ffffff;
            text-decoration: none;
            padding: 0.75rem 1.5rem;
            border-radius: 6px;
            transition: all 0.3s ease;
            display: inline-block;
            font-weight: 500;
            border: 2px solid var(--accent-color);
        }
        .btn:hover {
            background-color: #131721;
        }
        .error-code {
            font-size: 0.875rem;
            color: #6c757d;
            margin-top: 1.5rem;
            padding-top: 1.5rem;
            border-top: 1px solid var(--border-color);
        }
        .icon {
            font-size: 3rem;
            margin-bottom: 1rem;
        }
    </style>
</head>
<body>
    <div class="error-container">
        <div class="icon">\u26A0\uFE0F</div>
        <h1>Better Auth Error</h1>
        <p>We encountered an issue while processing your request. Please try again or contact the application owner if the problem persists.</p>
        <a href="/" id="returnLink" class="btn">Return to Application</a>
        <div class="error-code">Error Code: <span id="errorCode">${e.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#39;")}</span></div>
    </div>
</body>
</html>`,
        eS = $(
          "/error",
          {
            method: "GET",
            metadata: {
              ...en,
              openapi: {
                description: "Displays an error page",
                responses: {
                  200: {
                    description: "Success",
                    content: {
                      "text/html": {
                        schema: {
                          type: "string",
                          description: "The HTML content of the error page",
                        },
                      },
                    },
                  },
                },
              },
            },
          },
          async (e) =>
            new Response(
              e_(
                new URL(e.request?.url || "").searchParams.get("error") ||
                  "Unknown"
              ),
              { headers: { "Content-Type": "text/html" } }
            )
        ),
        eT = $(
          "/ok",
          {
            method: "GET",
            metadata: {
              ...en,
              openapi: {
                description: "Check if the API is working",
                responses: {
                  200: {
                    description: "API is working",
                    content: {
                      "application/json": {
                        schema: {
                          type: "object",
                          properties: {
                            ok: {
                              type: "boolean",
                              description: "Indicates if the API is working",
                            },
                          },
                          required: ["ok"],
                        },
                      },
                    },
                  },
                },
              },
            },
          },
          async (e) => e.json({ ok: !0 })
        ),
        ek = $(
          "/list-accounts",
          {
            method: "GET",
            use: [K],
            metadata: {
              openapi: {
                description: "List all accounts linked to the user",
                responses: {
                  200: {
                    description: "Success",
                    content: {
                      "application/json": {
                        schema: {
                          type: "array",
                          items: {
                            type: "object",
                            properties: {
                              id: { type: "string" },
                              provider: { type: "string" },
                              createdAt: {
                                type: "string",
                                format: "date-time",
                              },
                              updatedAt: {
                                type: "string",
                                format: "date-time",
                              },
                            },
                            accountId: { type: "string" },
                            scopes: {
                              type: "array",
                              items: { type: "string" },
                            },
                          },
                          required: [
                            "id",
                            "provider",
                            "createdAt",
                            "updatedAt",
                            "accountId",
                            "scopes",
                          ],
                        },
                      },
                    },
                  },
                },
              },
            },
          },
          async (e) => {
            let t = e.context.session,
              r = await e.context.internalAdapter.findAccounts(t.user.id);
            return e.json(
              r.map((e) => ({
                id: e.id,
                provider: e.providerId,
                createdAt: e.createdAt,
                updatedAt: e.updatedAt,
                accountId: e.accountId,
                scopes: e.scope?.split(",") || [],
              }))
            );
          }
        ),
        eA = $(
          "/link-social",
          {
            method: "POST",
            requireHeaders: !0,
            body: i.z.object({
              callbackURL: i.z
                .string({
                  description:
                    "The URL to redirect to after the user has signed in",
                })
                .optional(),
              provider: l.w_,
              idToken: i.z
                .object({
                  token: i.z.string(),
                  nonce: i.z.string().optional(),
                  accessToken: i.z.string().optional(),
                  refreshToken: i.z.string().optional(),
                  scopes: i.z.array(i.z.string()).optional(),
                })
                .optional(),
              requestSignUp: i.z.boolean().optional(),
              scopes: i.z
                .array(i.z.string(), {
                  description: "Additional scopes to request from the provider",
                })
                .optional(),
              errorCallbackURL: i.z
                .string({
                  description:
                    "The URL to redirect to if there is an error during the link process",
                })
                .optional(),
            }),
            use: [K],
            metadata: {
              openapi: {
                description: "Link a social account to the user",
                responses: {
                  200: {
                    description: "Success",
                    content: {
                      "application/json": {
                        schema: {
                          type: "object",
                          properties: {
                            url: {
                              type: "string",
                              description:
                                "The authorization URL to redirect the user to",
                            },
                            redirect: {
                              type: "boolean",
                              description:
                                "Indicates if the user should be redirected to the authorization URL",
                            },
                            status: { type: "boolean" },
                          },
                          required: ["redirect"],
                        },
                      },
                    },
                  },
                },
              },
            },
          },
          async (e) => {
            let t = e.context.session,
              r = e.context.socialProviders.find(
                (t) => t.id === e.body.provider
              );
            if (!r)
              throw (
                (e.context.logger.error(
                  "Provider not found. Make sure to add the provider in your auth config",
                  { provider: e.body.provider }
                ),
                new s.LG("NOT_FOUND", { message: Q.PROVIDER_NOT_FOUND }))
              );
            if (e.body.idToken) {
              if (!r.verifyIdToken)
                throw (
                  (e.context.logger.error(
                    "Provider does not support id token verification",
                    { provider: e.body.provider }
                  ),
                  new s.LG("NOT_FOUND", { message: Q.ID_TOKEN_NOT_SUPPORTED }))
                );
              let { token: i, nonce: n } = e.body.idToken;
              if (!(await r.verifyIdToken(i, n)))
                throw (
                  (e.context.logger.error("Invalid id token", {
                    provider: e.body.provider,
                  }),
                  new s.LG("UNAUTHORIZED", { message: Q.INVALID_TOKEN }))
                );
              let o = await r.getUserInfo({
                idToken: i,
                accessToken: e.body.idToken.accessToken,
                refreshToken: e.body.idToken.refreshToken,
              });
              if (!o || !o?.user)
                throw (
                  (e.context.logger.error("Failed to get user info", {
                    provider: e.body.provider,
                  }),
                  new s.LG("UNAUTHORIZED", {
                    message: Q.FAILED_TO_GET_USER_INFO,
                  }))
                );
              if (!o.user.email)
                throw (
                  (e.context.logger.error("User email not found", {
                    provider: e.body.provider,
                  }),
                  new s.LG("UNAUTHORIZED", { message: Q.USER_EMAIL_NOT_FOUND }))
                );
              if (
                (await e.context.internalAdapter.findAccounts(t.user.id)).find(
                  (e) => e.providerId === r.id && e.accountId === o.user.id
                )
              )
                return e.json({ redirect: !1, status: !0 });
              let a =
                e.context.options.account?.accountLinking?.trustedProviders;
              if (
                (!a?.includes(r.id) && !o.user.emailVerified) ||
                e.context.options.account?.accountLinking?.enabled === !1
              )
                throw new s.LG("UNAUTHORIZED", {
                  message: "Account not linked - linking not allowed",
                });
              if (
                o.user.email !== t.user.email &&
                e.context.options.account?.accountLinking
                  ?.allowDifferentEmails !== !0
              )
                throw new s.LG("UNAUTHORIZED", {
                  message: "Account not linked - different emails not allowed",
                });
              try {
                await e.context.internalAdapter.createAccount(
                  {
                    userId: t.user.id,
                    providerId: r.id,
                    accountId: o.user.id.toString(),
                    accessToken: e.body.idToken.accessToken,
                    idToken: i,
                    refreshToken: e.body.idToken.refreshToken,
                    scope: e.body.idToken.scopes?.join(","),
                  },
                  e
                );
              } catch (e) {
                throw new s.LG("EXPECTATION_FAILED", {
                  message: "Account not linked - unable to create account",
                });
              }
              if (
                e.context.options.account?.accountLinking
                  ?.updateUserInfoOnLink === !0
              )
                try {
                  await e.context.internalAdapter.updateUser(t.user.id, {
                    name: o.user?.name,
                    image: o.user?.image,
                  });
                } catch (e) {
                  console.warn("Could not update user - " + e.toString());
                }
              return e.json({ redirect: !1, status: !0 });
            }
            let i = await (0, o.g)(e, {
                userId: t.user.id,
                email: t.user.email,
              }),
              n = await r.createAuthorizationURL({
                state: i.state,
                codeVerifier: i.codeVerifier,
                redirectURI: `${e.context.baseURL}/callback/${r.id}`,
                scopes: e.body.scopes,
              });
            return e.json({ url: n.toString(), redirect: !0 });
          }
        ),
        eE = $(
          "/unlink-account",
          {
            method: "POST",
            body: i.z.object({
              providerId: i.z.string(),
              accountId: i.z.string().optional(),
            }),
            use: [H],
            metadata: {
              openapi: {
                description: "Unlink an account",
                responses: {
                  200: {
                    description: "Success",
                    content: {
                      "application/json": {
                        schema: {
                          type: "object",
                          properties: { status: { type: "boolean" } },
                        },
                      },
                    },
                  },
                },
              },
            },
          },
          async (e) => {
            let { providerId: t, accountId: r } = e.body,
              i = await e.context.internalAdapter.findAccounts(
                e.context.session.user.id
              );
            if (
              1 === i.length &&
              !e.context.options.account?.accountLinking?.allowUnlinkingAll
            )
              throw new s.LG("BAD_REQUEST", {
                message: Q.FAILED_TO_UNLINK_LAST_ACCOUNT,
              });
            let n = i.find((e) =>
              r ? e.accountId === r && e.providerId === t : e.providerId === t
            );
            if (!n)
              throw new s.LG("BAD_REQUEST", { message: Q.ACCOUNT_NOT_FOUND });
            return (
              await e.context.internalAdapter.deleteAccount(n.id),
              e.json({ status: !0 })
            );
          }
        ),
        eC = $(
          "/get-access-token",
          {
            method: "POST",
            body: i.z.object({
              providerId: i.z.string({
                description: "The provider ID for the OAuth provider",
              }),
              accountId: i.z
                .string({
                  description:
                    "The account ID associated with the refresh token",
                })
                .optional(),
              userId: i.z
                .string({
                  description: "The user ID associated with the account",
                })
                .optional(),
            }),
            metadata: {
              openapi: {
                description:
                  "Get a valid access token, doing a refresh if needed",
                responses: {
                  200: {
                    description: "A Valid access token",
                    content: {
                      "application/json": {
                        schema: {
                          type: "object",
                          properties: {
                            tokenType: { type: "string" },
                            idToken: { type: "string" },
                            accessToken: { type: "string" },
                            refreshToken: { type: "string" },
                            accessTokenExpiresAt: {
                              type: "string",
                              format: "date-time",
                            },
                            refreshTokenExpiresAt: {
                              type: "string",
                              format: "date-time",
                            },
                          },
                        },
                      },
                    },
                  },
                  400: {
                    description:
                      "Invalid refresh token or provider configuration",
                  },
                },
              },
            },
          },
          async (e) => {
            let { providerId: t, accountId: r, userId: i } = e.body,
              n = e.request,
              o = await V(e);
            if (n && !o) throw e.error("UNAUTHORIZED");
            let a = o?.user?.id || i;
            if (!a)
              throw new s.LG("BAD_REQUEST", {
                message: "Either userId or session is required",
              });
            if (!e.context.socialProviders.find((e) => e.id === t))
              throw new s.LG("BAD_REQUEST", {
                message: `Provider ${t} is not supported.`,
              });
            let l = (await e.context.internalAdapter.findAccounts(a)).find(
              (e) => (r ? e.id === r && e.providerId === t : e.providerId === t)
            );
            if (!l)
              throw new s.LG("BAD_REQUEST", { message: "Account not found" });
            let c = e.context.socialProviders.find((e) => e.id === t);
            if (!c)
              throw new s.LG("BAD_REQUEST", {
                message: `Provider ${t} not found.`,
              });
            try {
              let t = null;
              l.refreshToken &&
                (!l.accessTokenExpiresAt ||
                  l.accessTokenExpiresAt.getTime() - Date.now() < 5e3) &&
                c.refreshAccessToken &&
                ((t = await c.refreshAccessToken(l.refreshToken)),
                await e.context.internalAdapter.updateAccount(l.id, {
                  accessToken: t.accessToken,
                  accessTokenExpiresAt: t.accessTokenExpiresAt,
                  refreshToken: t.refreshToken,
                  refreshTokenExpiresAt: t.refreshTokenExpiresAt,
                }));
              let r = {
                accessToken: t?.accessToken ?? l.accessToken ?? void 0,
                accessTokenExpiresAt:
                  t?.accessTokenExpiresAt ?? l.accessTokenExpiresAt ?? void 0,
                scopes: l.scope?.split(",") ?? [],
                idToken: t?.idToken ?? l.idToken ?? void 0,
              };
              return e.json(r);
            } catch (e) {
              throw new s.LG("BAD_REQUEST", {
                message: "Failed to get a valid access token",
                cause: e,
              });
            }
          }
        ),
        eI = $(
          "/refresh-token",
          {
            method: "POST",
            body: i.z.object({
              providerId: i.z.string({
                description: "The provider ID for the OAuth provider",
              }),
              accountId: i.z
                .string({
                  description:
                    "The account ID associated with the refresh token",
                })
                .optional(),
              userId: i.z
                .string({
                  description: "The user ID associated with the account",
                })
                .optional(),
            }),
            metadata: {
              openapi: {
                description: "Refresh the access token using a refresh token",
                responses: {
                  200: {
                    description: "Access token refreshed successfully",
                    content: {
                      "application/json": {
                        schema: {
                          type: "object",
                          properties: {
                            tokenType: { type: "string" },
                            idToken: { type: "string" },
                            accessToken: { type: "string" },
                            refreshToken: { type: "string" },
                            accessTokenExpiresAt: {
                              type: "string",
                              format: "date-time",
                            },
                            refreshTokenExpiresAt: {
                              type: "string",
                              format: "date-time",
                            },
                          },
                        },
                      },
                    },
                  },
                  400: {
                    description:
                      "Invalid refresh token or provider configuration",
                  },
                },
              },
            },
          },
          async (e) => {
            let { providerId: t, accountId: r, userId: i } = e.body,
              n = e.request,
              o = await V(e);
            if (n && !o) throw e.error("UNAUTHORIZED");
            let a = o?.user?.id || i;
            if (!a)
              throw new s.LG("BAD_REQUEST", {
                message: "Either userId or session is required",
              });
            if (!e.context.socialProviders.find((e) => e.id === t))
              throw new s.LG("BAD_REQUEST", {
                message: `Provider ${t} is not supported.`,
              });
            let l = (await e.context.internalAdapter.findAccounts(a)).find(
              (e) => (r ? e.id === r && e.providerId === t : e.providerId === t)
            );
            if (!l)
              throw new s.LG("BAD_REQUEST", { message: "Account not found" });
            let c = e.context.socialProviders.find((e) => e.id === t);
            if (!c)
              throw new s.LG("BAD_REQUEST", {
                message: `Provider ${t} not found.`,
              });
            if (!c.refreshAccessToken)
              throw new s.LG("BAD_REQUEST", {
                message: `Provider ${t} does not support token refreshing.`,
              });
            try {
              let t = await c.refreshAccessToken(l.refreshToken);
              return (
                await e.context.internalAdapter.updateAccount(l.id, {
                  accessToken: t.accessToken,
                  accessTokenExpiresAt: t.accessTokenExpiresAt,
                  refreshToken: t.refreshToken,
                  refreshTokenExpiresAt: t.refreshTokenExpiresAt,
                }),
                e.json(t)
              );
            } catch (e) {
              throw new s.LG("BAD_REQUEST", {
                message: "Failed to refresh access token",
                cause: e,
              });
            }
          }
        ),
        eO = $(
          "/account-info",
          {
            method: "POST",
            use: [K],
            metadata: {
              openapi: {
                description: "Get the account info provided by the provider",
                responses: {
                  200: {
                    description: "Success",
                    content: {
                      "application/json": {
                        schema: {
                          type: "object",
                          properties: {
                            user: {
                              type: "object",
                              properties: {
                                id: { type: "string" },
                                name: { type: "string" },
                                email: { type: "string" },
                                image: { type: "string" },
                                emailVerified: { type: "boolean" },
                              },
                              required: ["id", "emailVerified"],
                            },
                            data: {
                              type: "object",
                              properties: {},
                              additionalProperties: !0,
                            },
                          },
                          required: ["user", "data"],
                          additionalProperties: !1,
                        },
                      },
                    },
                  },
                },
              },
            },
            body: i.z.object({
              accountId: i.z.string({
                description:
                  "The provider given account id for which to get the account info",
              }),
            }),
          },
          async (e) => {
            let t = await e.context.internalAdapter.findAccount(
              e.body.accountId
            );
            if (!t || t.userId !== e.context.session.user.id)
              throw new s.LG("BAD_REQUEST", { message: "Account not found" });
            let r = e.context.socialProviders.find(
              (e) => e.id === t.providerId
            );
            if (!r)
              throw new s.LG("INTERNAL_SERVER_ERROR", {
                message: `Provider account provider is ${t.providerId} but it is not configured`,
              });
            let i = await eC({
                ...e,
                body: { accountId: t.id, providerId: t.providerId },
                returnHeaders: !1,
              }),
              n = await r.getUserInfo(i);
            return e.json(n);
          }
        );
    },
    4304: (e, t, r) => {
      r.d(t, { i: () => i });
      function i(e, ...t) {
        return e(...t);
      }
    },
    5807: (e, t, r) => {
      r.d(t, { c: () => i });
      class i {
        #n;
        #s;
        #o;
        constructor() {
          this.#n = new Promise((e, t) => {
            (this.#o = t), (this.#s = e);
          });
        }
        get promise() {
          return this.#n;
        }
        resolve = (e) => {
          this.#s && this.#s(e);
        };
        reject = (e) => {
          this.#o && this.#o(e);
        };
      }
    },
    6193: (e, t, r) => {
      r.d(t, { bj: () => l, uc: () => d });
      var i = r(83755),
        n = r(67872),
        s = r(10132),
        o = r(33669),
        a = r(96051);
      class l {
        #a;
        get table() {
          return this.#a;
        }
        constructor(e) {
          this.#a = e;
        }
        as(e) {
          return new c(this.#a, e);
        }
      }
      class c {
        #a;
        #i;
        get table() {
          return this.#a;
        }
        get alias() {
          return this.#i;
        }
        constructor(e, t) {
          (this.#a = e), (this.#i = t);
        }
        toOperationNode() {
          return i.N.create((0, o.M$)(this.#a), n.O.create(this.#i));
        }
      }
      function d(e) {
        return (
          (0, a.Gv)(e) &&
          (0, s.N)(e) &&
          (0, a.Kg)(e.table) &&
          (0, a.Kg)(e.alias)
        );
      }
    },
    6710: (e, t, r) => {
      r.d(t, { a: () => n });
      var i = r(9625);
      function n() {
        return new s();
      }
      class s {
        #l;
        get queryId() {
          return void 0 === this.#l && (this.#l = (0, i.D)(8)), this.#l;
        }
      }
    },
    6711: (e, t, r) => {
      r.d(t, { Q: () => n });
      var i = r(96051);
      let n = (0, i.CN)({
        is: (e) => "JSONReferenceNode" === e.kind,
        create: (e, t) =>
          (0, i.CN)({ kind: "JSONReferenceNode", reference: e, traversal: t }),
        cloneWithTraversal: (e, t) => (0, i.CN)({ ...e, traversal: t }),
      });
    },
    7125: (e, t, r) => {
      let i;
      r.d(t, { w_: () => q, GY: () => P });
      var n = r(55094),
        s = r(30060),
        o = r(19984);
      o.lF;
      let a = o.D4;
      var l = r(3415),
        c = r(81385),
        d = r(46742),
        u = r(41321);
      function h(e) {
        let t, r;
        if ("string" != typeof e)
          throw new u.Dp(
            "JWTs must use Compact JWS serialization, JWT must be a string"
          );
        let { 1: i, length: n } = e.split(".");
        if (5 === n)
          throw new u.Dp(
            "Only JWTs using Compact JWS serialization can be decoded"
          );
        if (3 !== n) throw new u.Dp("Invalid JWT");
        if (!i) throw new u.Dp("JWTs must contain a payload");
        try {
          t = a(i);
        } catch {
          throw new u.Dp("Failed to base64url decode the payload");
        }
        try {
          r = JSON.parse(l.D0.decode(t));
        } catch {
          throw new u.Dp("Failed to parse the decoded payload as JSON");
        }
        if (!(0, c.A)(r)) throw new u.Dp("Invalid JWT Claims Set");
        return r;
      }
      var p = r(56394),
        f = r(37067),
        m = r(44708),
        y = r(78474);
      let g = async (e, t, r) => {
        let i;
        switch (e.protocol) {
          case "https:":
            i = m.get;
            break;
          case "http:":
            i = f.get;
            break;
          default:
            throw TypeError("Unsupported URL protocol.");
        }
        let { agent: n, headers: s } = r,
          o = i(e.href, { agent: n, timeout: t, headers: s }),
          [a] = await Promise.race([
            (0, y.once)(o, "response"),
            (0, y.once)(o, "timeout"),
          ]);
        if (!a) throw (o.destroy(), new u.xb());
        if (200 !== a.statusCode)
          throw new u.i4(
            "Expected 200 OK from the JSON Web Key Set HTTP response"
          );
        let c = [];
        for await (let e of a) c.push(e);
        try {
          return JSON.parse(l.D0.decode((0, l.xW)(...c)));
        } catch {
          throw new u.i4(
            "Failed to parse the JSON Web Key Set HTTP response as JSON"
          );
        }
      };
      function w(e) {
        return (0, c.A)(e);
      }
      function b(e) {
        return "function" == typeof structuredClone
          ? structuredClone(e)
          : JSON.parse(JSON.stringify(e));
      }
      class v {
        _jwks;
        _cached = new WeakMap();
        constructor(e) {
          if (
            !(function (e) {
              return (
                e &&
                "object" == typeof e &&
                Array.isArray(e.keys) &&
                e.keys.every(w)
              );
            })(e)
          )
            throw new u.Dm("JSON Web Key Set malformed");
          this._jwks = b(e);
        }
        async getKey(e, t) {
          let { alg: r, kid: i } = { ...e, ...t?.header },
            n = (function (e) {
              switch ("string" == typeof e && e.slice(0, 2)) {
                case "RS":
                case "PS":
                  return "RSA";
                case "ES":
                  return "EC";
                case "Ed":
                  return "OKP";
                default:
                  throw new u.T0(
                    'Unsupported "alg" value for a JSON Web Key Set'
                  );
              }
            })(r),
            s = this._jwks.keys.filter((e) => {
              let t = n === e.kty;
              if (
                (t && "string" == typeof i && (t = i === e.kid),
                t && "string" == typeof e.alg && (t = r === e.alg),
                t && "string" == typeof e.use && (t = "sig" === e.use),
                t &&
                  Array.isArray(e.key_ops) &&
                  (t = e.key_ops.includes("verify")),
                t)
              )
                switch (r) {
                  case "ES256":
                    t = "P-256" === e.crv;
                    break;
                  case "ES256K":
                    t = "secp256k1" === e.crv;
                    break;
                  case "ES384":
                    t = "P-384" === e.crv;
                    break;
                  case "ES512":
                    t = "P-521" === e.crv;
                    break;
                  case "Ed25519":
                    t = "Ed25519" === e.crv;
                    break;
                  case "EdDSA":
                    t = "Ed25519" === e.crv || "Ed448" === e.crv;
                }
              return t;
            }),
            { 0: o, length: a } = s;
          if (0 === a) throw new u.BT();
          if (1 !== a) {
            let e = new u.$4(),
              { _cached: t } = this;
            throw (
              ((e[Symbol.asyncIterator] = async function* () {
                for (let e of s)
                  try {
                    yield await N(t, e, r);
                  } catch {}
              }),
              e)
            );
          }
          return N(this._cached, o, r);
        }
      }
      async function N(e, t, r) {
        let i = e.get(t) || e.set(t, {}).get(t);
        if (void 0 === i[r]) {
          let e = await (0, p.Og)({ ...t, ext: !0 }, r);
          if (e instanceof Uint8Array || "public" !== e.type)
            throw new u.Dm("JSON Web Key Set members must be public keys");
          i[r] = e;
        }
        return i[r];
      }
      function x(e) {
        let t = new v(e),
          r = async (e, r) => t.getKey(e, r);
        return (
          Object.defineProperties(r, {
            jwks: {
              value: () => b(t._jwks),
              enumerable: !0,
              configurable: !1,
              writable: !1,
            },
          }),
          r
        );
      }
      ("undefined" != typeof navigator &&
        navigator.userAgent?.startsWith?.("Mozilla/5.0 ")) ||
        (i = "jose/v5.10.0");
      let _ = Symbol();
      class S {
        _url;
        _timeoutDuration;
        _cooldownDuration;
        _cacheMaxAge;
        _jwksTimestamp;
        _pendingFetch;
        _options;
        _local;
        _cache;
        constructor(e, t) {
          if (!(e instanceof URL))
            throw TypeError("url must be an instance of URL");
          (this._url = new URL(e.href)),
            (this._options = { agent: t?.agent, headers: t?.headers }),
            (this._timeoutDuration =
              "number" == typeof t?.timeoutDuration ? t?.timeoutDuration : 5e3),
            (this._cooldownDuration =
              "number" == typeof t?.cooldownDuration
                ? t?.cooldownDuration
                : 3e4),
            (this._cacheMaxAge =
              "number" == typeof t?.cacheMaxAge ? t?.cacheMaxAge : 6e5),
            t?.[_] !== void 0 &&
              ((this._cache = t?.[_]),
              (function (e, t) {
                return (
                  !(
                    "object" != typeof e ||
                    null === e ||
                    !("uat" in e) ||
                    "number" != typeof e.uat ||
                    Date.now() - e.uat >= t
                  ) &&
                  "jwks" in e &&
                  !!(0, c.A)(e.jwks) &&
                  !!Array.isArray(e.jwks.keys) &&
                  !!Array.prototype.every.call(e.jwks.keys, c.A)
                );
              })(t?.[_], this._cacheMaxAge) &&
                ((this._jwksTimestamp = this._cache.uat),
                (this._local = x(this._cache.jwks))));
        }
        coolingDown() {
          return (
            "number" == typeof this._jwksTimestamp &&
            Date.now() < this._jwksTimestamp + this._cooldownDuration
          );
        }
        fresh() {
          return (
            "number" == typeof this._jwksTimestamp &&
            Date.now() < this._jwksTimestamp + this._cacheMaxAge
          );
        }
        async getKey(e, t) {
          (this._local && this.fresh()) || (await this.reload());
          try {
            return await this._local(e, t);
          } catch (r) {
            if (r instanceof u.BT && !1 === this.coolingDown())
              return await this.reload(), this._local(e, t);
            throw r;
          }
        }
        async reload() {
          this._pendingFetch &&
            ("undefined" != typeof WebSocketPair ||
              ("undefined" != typeof navigator &&
                "Cloudflare-Workers" === navigator.userAgent) ||
              ("undefined" != typeof EdgeRuntime &&
                "vercel" === EdgeRuntime)) &&
            (this._pendingFetch = void 0);
          let e = new Headers(this._options.headers);
          i &&
            !e.has("User-Agent") &&
            (e.set("User-Agent", i),
            (this._options.headers = Object.fromEntries(e.entries()))),
            (this._pendingFetch ||= g(
              this._url,
              this._timeoutDuration,
              this._options
            )
              .then((e) => {
                (this._local = x(e)),
                  this._cache &&
                    ((this._cache.uat = Date.now()), (this._cache.jwks = e)),
                  (this._jwksTimestamp = Date.now()),
                  (this._pendingFetch = void 0);
              })
              .catch((e) => {
                throw ((this._pendingFetch = void 0), e);
              })),
            await this._pendingFetch;
        }
      }
      var T = r(2595);
      r(12486);
      var k = r(51875),
        A = r(16151);
      r(84941), r(30377);
      var E = r(10257),
        C = r(37991);
      let I = async (e) => {
          let { data: t } = await (0, n.zZ)(
            "https://appleid.apple.com/auth/keys"
          );
          if (!t?.keys)
            throw new s.LG("BAD_REQUEST", { message: "Keys not found" });
          let r = t.keys.find((t) => t.kid === e);
          if (!r) throw Error(`JWK with kid ${e} not found`);
          return await (0, p.Og)(r, r.alg);
        },
        O = (e = "") =>
          e
            .split("://")
            .map((e) => e.replace(/\/{2,}/g, "/"))
            .join("://"),
        L = (e) => {
          let t = e || "https://gitlab.com";
          return {
            authorizationEndpoint: O(`${t}/oauth/authorize`),
            tokenEndpoint: O(`${t}/oauth/token`),
            userinfoEndpoint: O(`${t}/api/v4/user`),
          };
        };
      var R = ((e) => (
        (e[(e.RUS = 0)] = "RUS"),
        (e[(e.UKR = 1)] = "UKR"),
        (e[(e.ENG = 3)] = "ENG"),
        (e[(e.SPA = 4)] = "SPA"),
        (e[(e.GERMAN = 6)] = "GERMAN"),
        (e[(e.POL = 15)] = "POL"),
        (e[(e.FRA = 16)] = "FRA"),
        (e[(e.TURKEY = 82)] = "TURKEY"),
        e
      ))(R || {});
      let P = {
          apple: (e) => ({
            id: "apple",
            name: "Apple",
            async createAuthorizationURL({
              state: t,
              scopes: r,
              redirectURI: i,
            }) {
              let n = e.disableDefaultScope ? [] : ["email", "name"];
              return (
                e.scope && n.push(...e.scope),
                r && n.push(...r),
                await (0, T.c)({
                  id: "apple",
                  options: e,
                  authorizationEndpoint:
                    "https://appleid.apple.com/auth/authorize",
                  scopes: n,
                  state: t,
                  redirectURI: i,
                  responseMode: "form_post",
                  responseType: "code id_token",
                })
              );
            },
            validateAuthorizationCode: async ({
              code: t,
              codeVerifier: r,
              redirectURI: i,
            }) =>
              (0, T.v)({
                code: t,
                codeVerifier: r,
                redirectURI: i,
                options: e,
                tokenEndpoint: "https://appleid.apple.com/auth/token",
              }),
            async verifyIdToken(t, r) {
              if (e.disableIdTokenSignIn) return !1;
              if (e.verifyIdToken) return e.verifyIdToken(t, r);
              let { kid: i, alg: n } = (function (e) {
                let t;
                if ("string" == typeof e) {
                  let r = e.split(".");
                  (3 === r.length || 5 === r.length) && ([t] = r);
                } else if ("object" == typeof e && e)
                  if ("protected" in e) t = e.protected;
                  else
                    throw TypeError(
                      "Token does not contain a Protected Header"
                    );
                try {
                  if ("string" != typeof t || !t) throw Error();
                  let e = JSON.parse(l.D0.decode(a(t)));
                  if (!(0, c.A)(e)) throw Error();
                  return e;
                } catch {
                  throw TypeError(
                    "Invalid Token or Protected Header formatting"
                  );
                }
              })(t);
              if (!i || !n) return !1;
              let s = await I(i),
                { payload: o } = await (0, d.V)(t, s, {
                  algorithms: [n],
                  issuer: "https://appleid.apple.com",
                  audience: e.appBundleIdentifier || e.clientId,
                  maxTokenAge: "1h",
                });
              return (
                ["email_verified", "is_private_email"].forEach((e) => {
                  void 0 !== o[e] && (o[e] = !!o[e]);
                }),
                (!r || o.nonce === r) && !!o
              );
            },
            refreshAccessToken: e.refreshAccessToken
              ? e.refreshAccessToken
              : async (t) =>
                  (0, T.r)({
                    refreshToken: t,
                    options: {
                      clientId: e.clientId,
                      clientKey: e.clientKey,
                      clientSecret: e.clientSecret,
                    },
                    tokenEndpoint: "https://appleid.apple.com/auth/token",
                  }),
            async getUserInfo(t) {
              if (e.getUserInfo) return e.getUserInfo(t);
              if (!t.idToken) return null;
              let r = h(t.idToken);
              if (!r) return null;
              let i = t.user
                  ? `${t.user.name?.firstName} ${t.user.name?.lastName}`
                  : r.name || r.email,
                n =
                  "boolean" == typeof r.email_verified
                    ? r.email_verified
                    : "true" === r.email_verified,
                s = await e.mapProfileToUser?.(r);
              return {
                user: {
                  id: r.sub,
                  name: i,
                  emailVerified: n,
                  email: r.email,
                  ...s,
                },
                data: r,
              };
            },
            options: e,
          }),
          discord: (e) => ({
            id: "discord",
            name: "Discord",
            createAuthorizationURL({ state: t, scopes: r, redirectURI: i }) {
              let n = e.disableDefaultScope ? [] : ["identify", "email"];
              return (
                r && n.push(...r),
                e.scope && n.push(...e.scope),
                new URL(
                  `https://discord.com/api/oauth2/authorize?scope=${n.join("+")}&response_type=code&client_id=${e.clientId}&redirect_uri=${encodeURIComponent(e.redirectURI || i)}&state=${t}&prompt=${e.prompt || "none"}`
                )
              );
            },
            validateAuthorizationCode: async ({ code: t, redirectURI: r }) =>
              (0, T.v)({
                code: t,
                redirectURI: r,
                options: e,
                tokenEndpoint: "https://discord.com/api/oauth2/token",
              }),
            refreshAccessToken: e.refreshAccessToken
              ? e.refreshAccessToken
              : async (t) =>
                  (0, T.r)({
                    refreshToken: t,
                    options: {
                      clientId: e.clientId,
                      clientKey: e.clientKey,
                      clientSecret: e.clientSecret,
                    },
                    tokenEndpoint: "https://discord.com/api/oauth2/token",
                  }),
            async getUserInfo(t) {
              if (e.getUserInfo) return e.getUserInfo(t);
              let { data: r, error: i } = await (0, n.zZ)(
                "https://discord.com/api/users/@me",
                { headers: { authorization: `Bearer ${t.accessToken}` } }
              );
              if (i) return null;
              if (null === r.avatar) {
                let e =
                  "0" === r.discriminator
                    ? Number(BigInt(r.id) >> BigInt(22)) % 6
                    : parseInt(r.discriminator) % 5;
                r.image_url = `https://cdn.discordapp.com/embed/avatars/${e}.png`;
              } else {
                let e = r.avatar.startsWith("a_") ? "gif" : "png";
                r.image_url = `https://cdn.discordapp.com/avatars/${r.id}/${r.avatar}.${e}`;
              }
              let s = await e.mapProfileToUser?.(r);
              return {
                user: {
                  id: r.id,
                  name: r.global_name || r.username || "",
                  email: r.email,
                  emailVerified: r.verified,
                  image: r.image_url,
                  ...s,
                },
                data: r,
              };
            },
            options: e,
          }),
          facebook: (e) => ({
            id: "facebook",
            name: "Facebook",
            async createAuthorizationURL({
              state: t,
              scopes: r,
              redirectURI: i,
              loginHint: n,
            }) {
              let s = e.disableDefaultScope ? [] : ["email", "public_profile"];
              return (
                e.scope && s.push(...e.scope),
                r && s.push(...r),
                await (0, T.c)({
                  id: "facebook",
                  options: e,
                  authorizationEndpoint:
                    "https://www.facebook.com/v21.0/dialog/oauth",
                  scopes: s,
                  state: t,
                  redirectURI: i,
                  loginHint: n,
                  additionalParams: e.configId ? { config_id: e.configId } : {},
                })
              );
            },
            validateAuthorizationCode: async ({ code: t, redirectURI: r }) =>
              (0, T.v)({
                code: t,
                redirectURI: r,
                options: e,
                tokenEndpoint: "https://graph.facebook.com/oauth/access_token",
              }),
            async verifyIdToken(t, r) {
              if (e.disableIdTokenSignIn) return !1;
              if (e.verifyIdToken) return e.verifyIdToken(t, r);
              if (t.split(".").length)
                try {
                  let { payload: i } = await (0, d.V)(
                    t,
                    (function (e, t) {
                      let r = new S(e, void 0),
                        i = async (e, t) => r.getKey(e, t);
                      return (
                        Object.defineProperties(i, {
                          coolingDown: {
                            get: () => r.coolingDown(),
                            enumerable: !0,
                            configurable: !1,
                          },
                          fresh: {
                            get: () => r.fresh(),
                            enumerable: !0,
                            configurable: !1,
                          },
                          reload: {
                            value: () => r.reload(),
                            enumerable: !0,
                            configurable: !1,
                            writable: !1,
                          },
                          reloading: {
                            get: () => !!r._pendingFetch,
                            enumerable: !0,
                            configurable: !1,
                          },
                          jwks: {
                            value: () => r._local?.jwks(),
                            enumerable: !0,
                            configurable: !1,
                            writable: !1,
                          },
                        }),
                        i
                      );
                    })(
                      new URL(
                        "https://www.facebook.com/.well-known/oauth/openid/jwks"
                      )
                    ),
                    {
                      algorithms: ["RS256"],
                      audience: e.clientId,
                      issuer: "https://www.facebook.com",
                    }
                  );
                  if (r && i.nonce !== r) return !1;
                  return !!i;
                } catch (e) {
                  return !1;
                }
              return !0;
            },
            refreshAccessToken: e.refreshAccessToken
              ? e.refreshAccessToken
              : async (t) =>
                  (0, T.r)({
                    refreshToken: t,
                    options: {
                      clientId: e.clientId,
                      clientKey: e.clientKey,
                      clientSecret: e.clientSecret,
                    },
                    tokenEndpoint:
                      "https://graph.facebook.com/v18.0/oauth/access_token",
                  }),
            async getUserInfo(t) {
              if (e.getUserInfo) return e.getUserInfo(t);
              if (t.idToken) {
                let r = h(t.idToken),
                  i = {
                    id: r.sub,
                    name: r.name,
                    email: r.email,
                    picture: {
                      data: {
                        url: r.picture,
                        height: 100,
                        width: 100,
                        is_silhouette: !1,
                      },
                    },
                  },
                  n = await e.mapProfileToUser?.({ ...i, email_verified: !0 });
                return { user: { ...i, emailVerified: !0, ...n }, data: r };
              }
              let r = ["id", "name", "email", "picture", ...(e?.fields || [])],
                { data: i, error: s } = await (0, n.zZ)(
                  "https://graph.facebook.com/me?fields=" + r.join(","),
                  { auth: { type: "Bearer", token: t.accessToken } }
                );
              if (s) return null;
              let o = await e.mapProfileToUser?.(i);
              return {
                user: {
                  id: i.id,
                  name: i.name,
                  email: i.email,
                  image: i.picture.data.url,
                  emailVerified: i.email_verified,
                  ...o,
                },
                data: i,
              };
            },
            options: e,
          }),
          github: (e) => ({
            id: "github",
            name: "GitHub",
            createAuthorizationURL({
              state: t,
              scopes: r,
              loginHint: i,
              redirectURI: n,
            }) {
              let s = e.disableDefaultScope ? [] : ["read:user", "user:email"];
              return (
                e.scope && s.push(...e.scope),
                r && s.push(...r),
                (0, T.c)({
                  id: "github",
                  options: e,
                  authorizationEndpoint:
                    "https://github.com/login/oauth/authorize",
                  scopes: s,
                  state: t,
                  redirectURI: n,
                  loginHint: i,
                  prompt: e.prompt,
                })
              );
            },
            validateAuthorizationCode: async ({ code: t, redirectURI: r }) =>
              (0, T.v)({
                code: t,
                redirectURI: r,
                options: e,
                tokenEndpoint: "https://github.com/login/oauth/access_token",
              }),
            refreshAccessToken: e.refreshAccessToken
              ? e.refreshAccessToken
              : async (t) =>
                  (0, T.r)({
                    refreshToken: t,
                    options: {
                      clientId: e.clientId,
                      clientKey: e.clientKey,
                      clientSecret: e.clientSecret,
                    },
                    tokenEndpoint:
                      "https://github.com/login/oauth/access_token",
                  }),
            async getUserInfo(t) {
              if (e.getUserInfo) return e.getUserInfo(t);
              let { data: r, error: i } = await (0, n.zZ)(
                "https://api.github.com/user",
                {
                  headers: {
                    "User-Agent": "better-auth",
                    authorization: `Bearer ${t.accessToken}`,
                  },
                }
              );
              if (i) return null;
              let { data: s } = await (0, n.zZ)(
                "https://api.github.com/user/emails",
                {
                  headers: {
                    Authorization: `Bearer ${t.accessToken}`,
                    "User-Agent": "better-auth",
                  },
                }
              );
              !r.email &&
                s &&
                (r.email = (s.find((e) => e.primary) ?? s[0])?.email);
              let o = s?.find((e) => e.email === r.email)?.verified ?? !1,
                a = await e.mapProfileToUser?.(r);
              return {
                user: {
                  id: r.id.toString(),
                  name: r.name || r.login,
                  email: r.email,
                  image: r.avatar_url,
                  emailVerified: o,
                  ...a,
                },
                data: r,
              };
            },
            options: e,
          }),
          microsoft: (e) => {
            let t = e.tenantId || "common",
              r = `https://login.microsoftonline.com/${t}/oauth2/v2.0/authorize`,
              i = `https://login.microsoftonline.com/${t}/oauth2/v2.0/token`;
            return {
              id: "microsoft",
              name: "Microsoft EntraID",
              createAuthorizationURL(t) {
                let i = e.disableDefaultScope
                  ? []
                  : [
                      "openid",
                      "profile",
                      "email",
                      "User.Read",
                      "offline_access",
                    ];
                return (
                  e.scope && i.push(...e.scope),
                  t.scopes && i.push(...t.scopes),
                  (0, T.c)({
                    id: "microsoft",
                    options: e,
                    authorizationEndpoint: r,
                    state: t.state,
                    codeVerifier: t.codeVerifier,
                    scopes: i,
                    redirectURI: t.redirectURI,
                    prompt: e.prompt,
                  })
                );
              },
              validateAuthorizationCode: ({
                code: t,
                codeVerifier: r,
                redirectURI: n,
              }) =>
                (0, T.v)({
                  code: t,
                  codeVerifier: r,
                  redirectURI: n,
                  options: e,
                  tokenEndpoint: i,
                }),
              async getUserInfo(t) {
                if (e.getUserInfo) return e.getUserInfo(t);
                if (!t.idToken) return null;
                let r = h(t.idToken),
                  i = e.profilePhotoSize || 48;
                await (0, n.zZ)(
                  `https://graph.microsoft.com/v1.0/me/photos/${i}x${i}/$value`,
                  {
                    headers: { Authorization: `Bearer ${t.accessToken}` },
                    async onResponse(t) {
                      if (!e.disableProfilePhoto && t.response.ok)
                        try {
                          let e = t.response.clone(),
                            i = await e.arrayBuffer(),
                            n = k.K.encode(i);
                          r.picture = `data:image/jpeg;base64, ${n}`;
                        } catch (e) {
                          C.l.error(
                            e && "object" == typeof e && "name" in e
                              ? e.name
                              : "",
                            e
                          );
                        }
                    },
                  }
                );
                let s = await e.mapProfileToUser?.(r);
                return {
                  user: {
                    id: r.sub,
                    name: r.name,
                    email: r.email,
                    image: r.picture,
                    emailVerified: !0,
                    ...s,
                  },
                  data: r,
                };
              },
              refreshAccessToken: e.refreshAccessToken
                ? e.refreshAccessToken
                : async (t) => {
                    let r = e.disableDefaultScope
                      ? []
                      : [
                          "openid",
                          "profile",
                          "email",
                          "User.Read",
                          "offline_access",
                        ];
                    return (
                      e.scope && r.push(...e.scope),
                      (0, T.r)({
                        refreshToken: t,
                        options: {
                          clientId: e.clientId,
                          clientSecret: e.clientSecret,
                        },
                        extraParams: { scope: r.join(" ") },
                        tokenEndpoint: i,
                      })
                    );
                  },
              options: e,
            };
          },
          google: (e) => ({
            id: "google",
            name: "Google",
            async createAuthorizationURL({
              state: t,
              scopes: r,
              codeVerifier: i,
              redirectURI: n,
              loginHint: s,
              display: o,
            }) {
              if (!e.clientId || !e.clientSecret)
                throw (
                  (C.l.error(
                    "Client Id and Client Secret is required for Google. Make sure to provide them in the options."
                  ),
                  new E.B("CLIENT_ID_AND_SECRET_REQUIRED"))
                );
              if (!i) throw new E.B("codeVerifier is required for Google");
              let a = e.disableDefaultScope
                ? []
                : ["email", "profile", "openid"];
              return (
                e.scope && a.push(...e.scope),
                r && a.push(...r),
                await (0, T.c)({
                  id: "google",
                  options: e,
                  authorizationEndpoint:
                    "https://accounts.google.com/o/oauth2/auth",
                  scopes: a,
                  state: t,
                  codeVerifier: i,
                  redirectURI: n,
                  prompt: e.prompt,
                  accessType: e.accessType,
                  display: o || e.display,
                  loginHint: s,
                  hd: e.hd,
                  additionalParams: { include_granted_scopes: "true" },
                })
              );
            },
            validateAuthorizationCode: async ({
              code: t,
              codeVerifier: r,
              redirectURI: i,
            }) =>
              (0, T.v)({
                code: t,
                codeVerifier: r,
                redirectURI: i,
                options: e,
                tokenEndpoint: "https://oauth2.googleapis.com/token",
              }),
            refreshAccessToken: e.refreshAccessToken
              ? e.refreshAccessToken
              : async (t) =>
                  (0, T.r)({
                    refreshToken: t,
                    options: {
                      clientId: e.clientId,
                      clientKey: e.clientKey,
                      clientSecret: e.clientSecret,
                    },
                    tokenEndpoint: "https://www.googleapis.com/oauth2/v4/token",
                  }),
            async verifyIdToken(t, r) {
              if (e.disableIdTokenSignIn) return !1;
              if (e.verifyIdToken) return e.verifyIdToken(t, r);
              let i = `https://www.googleapis.com/oauth2/v3/tokeninfo?id_token=${t}`,
                { data: s } = await (0, n.zZ)(i);
              return (
                !!s &&
                s.aud === e.clientId &&
                ("https://accounts.google.com" === s.iss ||
                  "accounts.google.com" === s.iss)
              );
            },
            async getUserInfo(t) {
              if (e.getUserInfo) return e.getUserInfo(t);
              if (!t.idToken) return null;
              let r = h(t.idToken),
                i = await e.mapProfileToUser?.(r);
              return {
                user: {
                  id: r.sub,
                  name: r.name,
                  email: r.email,
                  image: r.picture,
                  emailVerified: r.email_verified,
                  ...i,
                },
                data: r,
              };
            },
            options: e,
          }),
          huggingface: (e) => ({
            id: "huggingface",
            name: "Hugging Face",
            createAuthorizationURL({
              state: t,
              scopes: r,
              codeVerifier: i,
              redirectURI: n,
            }) {
              let s = e.disableDefaultScope
                ? []
                : ["openid", "profile", "email"];
              return (
                e.scope && s.push(...e.scope),
                r && s.push(...r),
                (0, T.c)({
                  id: "huggingface",
                  options: e,
                  authorizationEndpoint:
                    "https://huggingface.co/oauth/authorize",
                  scopes: s,
                  state: t,
                  codeVerifier: i,
                  redirectURI: n,
                })
              );
            },
            validateAuthorizationCode: async ({
              code: t,
              codeVerifier: r,
              redirectURI: i,
            }) =>
              (0, T.v)({
                code: t,
                codeVerifier: r,
                redirectURI: i,
                options: e,
                tokenEndpoint: "https://huggingface.co/oauth/token",
              }),
            refreshAccessToken: e.refreshAccessToken
              ? e.refreshAccessToken
              : async (t) =>
                  (0, T.r)({
                    refreshToken: t,
                    options: {
                      clientId: e.clientId,
                      clientKey: e.clientKey,
                      clientSecret: e.clientSecret,
                    },
                    tokenEndpoint: "https://huggingface.co/oauth/token",
                  }),
            async getUserInfo(t) {
              if (e.getUserInfo) return e.getUserInfo(t);
              let { data: r, error: i } = await (0, n.zZ)(
                "https://huggingface.co/oauth/userinfo",
                {
                  method: "GET",
                  headers: { Authorization: `Bearer ${t.accessToken}` },
                }
              );
              if (i) return null;
              let s = await e.mapProfileToUser?.(r);
              return {
                user: {
                  id: r.sub,
                  name: r.name || r.preferred_username,
                  email: r.email,
                  image: r.picture,
                  emailVerified: r.email_verified ?? !1,
                  ...s,
                },
                data: r,
              };
            },
            options: e,
          }),
          spotify: (e) => ({
            id: "spotify",
            name: "Spotify",
            createAuthorizationURL({
              state: t,
              scopes: r,
              codeVerifier: i,
              redirectURI: n,
            }) {
              let s = e.disableDefaultScope ? [] : ["user-read-email"];
              return (
                e.scope && s.push(...e.scope),
                r && s.push(...r),
                (0, T.c)({
                  id: "spotify",
                  options: e,
                  authorizationEndpoint:
                    "https://accounts.spotify.com/authorize",
                  scopes: s,
                  state: t,
                  codeVerifier: i,
                  redirectURI: n,
                })
              );
            },
            validateAuthorizationCode: async ({
              code: t,
              codeVerifier: r,
              redirectURI: i,
            }) =>
              (0, T.v)({
                code: t,
                codeVerifier: r,
                redirectURI: i,
                options: e,
                tokenEndpoint: "https://accounts.spotify.com/api/token",
              }),
            refreshAccessToken: e.refreshAccessToken
              ? e.refreshAccessToken
              : async (t) =>
                  (0, T.r)({
                    refreshToken: t,
                    options: {
                      clientId: e.clientId,
                      clientKey: e.clientKey,
                      clientSecret: e.clientSecret,
                    },
                    tokenEndpoint: "https://accounts.spotify.com/api/token",
                  }),
            async getUserInfo(t) {
              if (e.getUserInfo) return e.getUserInfo(t);
              let { data: r, error: i } = await (0, n.zZ)(
                "https://api.spotify.com/v1/me",
                {
                  method: "GET",
                  headers: { Authorization: `Bearer ${t.accessToken}` },
                }
              );
              if (i) return null;
              let s = await e.mapProfileToUser?.(r);
              return {
                user: {
                  id: r.id,
                  name: r.display_name,
                  email: r.email,
                  image: r.images[0]?.url,
                  emailVerified: !1,
                  ...s,
                },
                data: r,
              };
            },
            options: e,
          }),
          twitch: (e) => ({
            id: "twitch",
            name: "Twitch",
            createAuthorizationURL({ state: t, scopes: r, redirectURI: i }) {
              let n = e.disableDefaultScope
                ? []
                : ["user:read:email", "openid"];
              return (
                e.scope && n.push(...e.scope),
                r && n.push(...r),
                (0, T.c)({
                  id: "twitch",
                  redirectURI: i,
                  options: e,
                  authorizationEndpoint:
                    "https://id.twitch.tv/oauth2/authorize",
                  scopes: n,
                  state: t,
                  claims: e.claims || [
                    "email",
                    "email_verified",
                    "preferred_username",
                    "picture",
                  ],
                })
              );
            },
            validateAuthorizationCode: async ({ code: t, redirectURI: r }) =>
              (0, T.v)({
                code: t,
                redirectURI: r,
                options: e,
                tokenEndpoint: "https://id.twitch.tv/oauth2/token",
              }),
            refreshAccessToken: e.refreshAccessToken
              ? e.refreshAccessToken
              : async (t) =>
                  (0, T.r)({
                    refreshToken: t,
                    options: {
                      clientId: e.clientId,
                      clientKey: e.clientKey,
                      clientSecret: e.clientSecret,
                    },
                    tokenEndpoint: "https://id.twitch.tv/oauth2/token",
                  }),
            async getUserInfo(t) {
              if (e.getUserInfo) return e.getUserInfo(t);
              let r = t.idToken;
              if (!r) return C.l.error("No idToken found in token"), null;
              let i = h(r),
                n = await e.mapProfileToUser?.(i);
              return {
                user: {
                  id: i.sub,
                  name: i.preferred_username,
                  email: i.email,
                  image: i.picture,
                  emailVerified: !1,
                  ...n,
                },
                data: i,
              };
            },
            options: e,
          }),
          twitter: (e) => ({
            id: "twitter",
            name: "Twitter",
            createAuthorizationURL(t) {
              let r = e.disableDefaultScope
                ? []
                : ["users.read", "tweet.read", "offline.access", "users.email"];
              return (
                e.scope && r.push(...e.scope),
                t.scopes && r.push(...t.scopes),
                (0, T.c)({
                  id: "twitter",
                  options: e,
                  authorizationEndpoint: "https://x.com/i/oauth2/authorize",
                  scopes: r,
                  state: t.state,
                  codeVerifier: t.codeVerifier,
                  redirectURI: t.redirectURI,
                })
              );
            },
            validateAuthorizationCode: async ({
              code: t,
              codeVerifier: r,
              redirectURI: i,
            }) =>
              (0, T.v)({
                code: t,
                codeVerifier: r,
                authentication: "basic",
                redirectURI: i,
                options: e,
                tokenEndpoint: "https://api.x.com/2/oauth2/token",
              }),
            refreshAccessToken: e.refreshAccessToken
              ? e.refreshAccessToken
              : async (t) =>
                  (0, T.r)({
                    refreshToken: t,
                    options: {
                      clientId: e.clientId,
                      clientKey: e.clientKey,
                      clientSecret: e.clientSecret,
                    },
                    tokenEndpoint: "https://api.x.com/2/oauth2/token",
                  }),
            async getUserInfo(t) {
              if (e.getUserInfo) return e.getUserInfo(t);
              let { data: r, error: i } = await (0, n.zZ)(
                "https://api.x.com/2/users/me?user.fields=profile_image_url",
                {
                  method: "GET",
                  headers: { Authorization: `Bearer ${t.accessToken}` },
                }
              );
              if (i) return null;
              let { data: s, error: o } = await (0, n.zZ)(
                  "https://api.x.com/2/users/me?user.fields=confirmed_email",
                  {
                    method: "GET",
                    headers: { Authorization: `Bearer ${t.accessToken}` },
                  }
                ),
                a = !1;
              !o &&
                s?.data?.confirmed_email &&
                ((r.data.email = s.data.confirmed_email), (a = !0));
              let l = await e.mapProfileToUser?.(r);
              return {
                user: {
                  id: r.data.id,
                  name: r.data.name,
                  email: r.data.email || r.data.username || null,
                  image: r.data.profile_image_url,
                  emailVerified: a,
                  ...l,
                },
                data: r,
              };
            },
            options: e,
          }),
          dropbox: (e) => ({
            id: "dropbox",
            name: "Dropbox",
            createAuthorizationURL: async ({
              state: t,
              scopes: r,
              codeVerifier: i,
              redirectURI: n,
            }) => {
              let s = e.disableDefaultScope ? [] : ["account_info.read"];
              return (
                e.scope && s.push(...e.scope),
                r && s.push(...r),
                await (0, T.c)({
                  id: "dropbox",
                  options: e,
                  authorizationEndpoint:
                    "https://www.dropbox.com/oauth2/authorize",
                  scopes: s,
                  state: t,
                  redirectURI: n,
                  codeVerifier: i,
                })
              );
            },
            validateAuthorizationCode: async ({
              code: t,
              codeVerifier: r,
              redirectURI: i,
            }) =>
              await (0, T.v)({
                code: t,
                codeVerifier: r,
                redirectURI: i,
                options: e,
                tokenEndpoint: "https://api.dropboxapi.com/oauth2/token",
              }),
            refreshAccessToken: e.refreshAccessToken
              ? e.refreshAccessToken
              : async (t) =>
                  (0, T.r)({
                    refreshToken: t,
                    options: {
                      clientId: e.clientId,
                      clientKey: e.clientKey,
                      clientSecret: e.clientSecret,
                    },
                    tokenEndpoint: "https://api.dropbox.com/oauth2/token",
                  }),
            async getUserInfo(t) {
              if (e.getUserInfo) return e.getUserInfo(t);
              let { data: r, error: i } = await (0, n.zZ)(
                "https://api.dropboxapi.com/2/users/get_current_account",
                {
                  method: "POST",
                  headers: { Authorization: `Bearer ${t.accessToken}` },
                }
              );
              if (i) return null;
              let s = await e.mapProfileToUser?.(r);
              return {
                user: {
                  id: r.account_id,
                  name: r.name?.display_name,
                  email: r.email,
                  emailVerified: r.email_verified || !1,
                  image: r.profile_photo_url,
                  ...s,
                },
                data: r,
              };
            },
            options: e,
          }),
          kick: (e) => ({
            id: "kick",
            name: "Kick",
            createAuthorizationURL({
              state: t,
              scopes: r,
              redirectURI: i,
              codeVerifier: n,
            }) {
              let s = e.disableDefaultScope ? [] : ["user:read"];
              return (
                e.scope && s.push(...e.scope),
                r && s.push(...r),
                (0, T.c)({
                  id: "kick",
                  redirectURI: i,
                  options: e,
                  authorizationEndpoint: "https://id.kick.com/oauth/authorize",
                  scopes: s,
                  codeVerifier: n,
                  state: t,
                })
              );
            },
            validateAuthorizationCode: async ({
              code: t,
              redirectURI: r,
              codeVerifier: i,
            }) =>
              (0, T.v)({
                code: t,
                redirectURI: r,
                options: e,
                tokenEndpoint: "https://id.kick.com/oauth/token",
                codeVerifier: i,
              }),
            async getUserInfo(t) {
              if (e.getUserInfo) return e.getUserInfo(t);
              let { data: r, error: i } = await (0, n.zZ)(
                "https://api.kick.com/public/v1/users",
                {
                  method: "GET",
                  headers: { Authorization: `Bearer ${t.accessToken}` },
                }
              );
              if (i) return null;
              let s = r.data[0],
                o = await e.mapProfileToUser?.(s);
              return {
                user: {
                  id: s.user_id,
                  name: s.name,
                  email: s.email,
                  image: s.profile_picture,
                  emailVerified: !0,
                  ...o,
                },
                data: s,
              };
            },
            options: e,
          }),
          linkedin: (e) => {
            let t = "https://www.linkedin.com/oauth/v2/accessToken";
            return {
              id: "linkedin",
              name: "Linkedin",
              createAuthorizationURL: async ({
                state: t,
                scopes: r,
                redirectURI: i,
                loginHint: n,
              }) => {
                let s = e.disableDefaultScope
                  ? []
                  : ["profile", "email", "openid"];
                return (
                  e.scope && s.push(...e.scope),
                  r && s.push(...r),
                  await (0, T.c)({
                    id: "linkedin",
                    options: e,
                    authorizationEndpoint:
                      "https://www.linkedin.com/oauth/v2/authorization",
                    scopes: s,
                    state: t,
                    loginHint: n,
                    redirectURI: i,
                  })
                );
              },
              validateAuthorizationCode: async ({ code: r, redirectURI: i }) =>
                await (0, T.v)({
                  code: r,
                  redirectURI: i,
                  options: e,
                  tokenEndpoint: t,
                }),
              refreshAccessToken: e.refreshAccessToken
                ? e.refreshAccessToken
                : async (r) =>
                    (0, T.r)({
                      refreshToken: r,
                      options: {
                        clientId: e.clientId,
                        clientKey: e.clientKey,
                        clientSecret: e.clientSecret,
                      },
                      tokenEndpoint: t,
                    }),
              async getUserInfo(t) {
                if (e.getUserInfo) return e.getUserInfo(t);
                let { data: r, error: i } = await (0, n.zZ)(
                  "https://api.linkedin.com/v2/userinfo",
                  {
                    method: "GET",
                    headers: { Authorization: `Bearer ${t.accessToken}` },
                  }
                );
                if (i) return null;
                let s = await e.mapProfileToUser?.(r);
                return {
                  user: {
                    id: r.sub,
                    name: r.name,
                    email: r.email,
                    emailVerified: r.email_verified || !1,
                    image: r.picture,
                    ...s,
                  },
                  data: r,
                };
              },
              options: e,
            };
          },
          gitlab: (e) => {
            let {
                authorizationEndpoint: t,
                tokenEndpoint: r,
                userinfoEndpoint: i,
              } = L(e.issuer),
              s = "gitlab";
            return {
              id: s,
              name: "Gitlab",
              createAuthorizationURL: async ({
                state: r,
                scopes: i,
                codeVerifier: n,
                loginHint: o,
                redirectURI: a,
              }) => {
                let l = e.disableDefaultScope ? [] : ["read_user"];
                return (
                  e.scope && l.push(...e.scope),
                  i && l.push(...i),
                  await (0, T.c)({
                    id: s,
                    options: e,
                    authorizationEndpoint: t,
                    scopes: l,
                    state: r,
                    redirectURI: a,
                    codeVerifier: n,
                    loginHint: o,
                  })
                );
              },
              validateAuthorizationCode: async ({
                code: t,
                redirectURI: i,
                codeVerifier: n,
              }) =>
                (0, T.v)({
                  code: t,
                  redirectURI: i,
                  options: e,
                  codeVerifier: n,
                  tokenEndpoint: r,
                }),
              refreshAccessToken: e.refreshAccessToken
                ? e.refreshAccessToken
                : async (t) =>
                    (0, T.r)({
                      refreshToken: t,
                      options: {
                        clientId: e.clientId,
                        clientKey: e.clientKey,
                        clientSecret: e.clientSecret,
                      },
                      tokenEndpoint: "https://gitlab.com/oauth/token",
                    }),
              async getUserInfo(t) {
                if (e.getUserInfo) return e.getUserInfo(t);
                let { data: r, error: s } = await (0, n.zZ)(i, {
                  headers: { authorization: `Bearer ${t.accessToken}` },
                });
                if (s || "active" !== r.state || r.locked) return null;
                let o = await e.mapProfileToUser?.(r);
                return {
                  user: {
                    id: r.id.toString(),
                    name: r.name ?? r.username,
                    email: r.email,
                    image: r.avatar_url,
                    emailVerified: !0,
                    ...o,
                  },
                  data: r,
                };
              },
              options: e,
            };
          },
          tiktok: (e) => ({
            id: "tiktok",
            name: "TikTok",
            createAuthorizationURL({ state: t, scopes: r, redirectURI: i }) {
              let n = e.disableDefaultScope ? [] : ["user.info.profile"];
              return (
                e.scope && n.push(...e.scope),
                r && n.push(...r),
                new URL(
                  `https://www.tiktok.com/v2/auth/authorize?scope=${n.join(",")}&response_type=code&client_key=${e.clientKey}&client_secret=${e.clientSecret}&redirect_uri=${encodeURIComponent(e.redirectURI || i)}&state=${t}`
                )
              );
            },
            validateAuthorizationCode: async ({ code: t, redirectURI: r }) =>
              (0, T.v)({
                code: t,
                redirectURI: e.redirectURI || r,
                options: e,
                tokenEndpoint: "https://open.tiktokapis.com/v2/oauth/token/",
              }),
            refreshAccessToken: e.refreshAccessToken
              ? e.refreshAccessToken
              : async (t) =>
                  (0, T.r)({
                    refreshToken: t,
                    options: {
                      clientId: e.clientId,
                      clientKey: e.clientKey,
                      clientSecret: e.clientSecret,
                    },
                    tokenEndpoint:
                      "https://open.tiktokapis.com/v2/oauth/token/",
                  }),
            async getUserInfo(t) {
              if (e.getUserInfo) return e.getUserInfo(t);
              let { data: r, error: i } = await (0, n.zZ)(
                "https://open.tiktokapis.com/v2/user/info/?fields=open_id,avatar_large_url,display_name,username",
                { headers: { authorization: `Bearer ${t.accessToken}` } }
              );
              return i
                ? null
                : {
                    user: {
                      email: r.data.user.email || r.data.user.username,
                      id: r.data.user.open_id,
                      name: r.data.user.display_name || r.data.user.username,
                      image: r.data.user.avatar_large_url,
                      emailVerified: !!r.data.user.email,
                    },
                    data: r,
                  };
            },
            options: e,
          }),
          reddit: (e) => ({
            id: "reddit",
            name: "Reddit",
            createAuthorizationURL({ state: t, scopes: r, redirectURI: i }) {
              let n = e.disableDefaultScope ? [] : ["identity"];
              return (
                e.scope && n.push(...e.scope),
                r && n.push(...r),
                (0, T.c)({
                  id: "reddit",
                  options: e,
                  authorizationEndpoint:
                    "https://www.reddit.com/api/v1/authorize",
                  scopes: n,
                  state: t,
                  redirectURI: i,
                  duration: e.duration,
                })
              );
            },
            validateAuthorizationCode: async ({ code: t, redirectURI: r }) => {
              let i = new URLSearchParams({
                  grant_type: "authorization_code",
                  code: t,
                  redirect_uri: e.redirectURI || r,
                }),
                s = {
                  "content-type": "application/x-www-form-urlencoded",
                  accept: "text/plain",
                  "user-agent": "better-auth",
                  Authorization: `Basic ${k.K.encode(`${e.clientId}:${e.clientSecret}`)}`,
                },
                { data: o, error: a } = await (0, n.zZ)(
                  "https://www.reddit.com/api/v1/access_token",
                  { method: "POST", headers: s, body: i.toString() }
                );
              if (a) throw a;
              return (0, T.b)(o);
            },
            refreshAccessToken: e.refreshAccessToken
              ? e.refreshAccessToken
              : async (t) =>
                  (0, T.r)({
                    refreshToken: t,
                    options: {
                      clientId: e.clientId,
                      clientKey: e.clientKey,
                      clientSecret: e.clientSecret,
                    },
                    tokenEndpoint: "https://www.reddit.com/api/v1/access_token",
                  }),
            async getUserInfo(t) {
              if (e.getUserInfo) return e.getUserInfo(t);
              let { data: r, error: i } = await (0, n.zZ)(
                "https://oauth.reddit.com/api/v1/me",
                {
                  headers: {
                    Authorization: `Bearer ${t.accessToken}`,
                    "User-Agent": "better-auth",
                  },
                }
              );
              if (i) return null;
              let s = await e.mapProfileToUser?.(r);
              return {
                user: {
                  id: r.id,
                  name: r.name,
                  email: r.oauth_client_id,
                  emailVerified: r.has_verified_email,
                  image: r.icon_img?.split("?")[0],
                  ...s,
                },
                data: r,
              };
            },
            options: e,
          }),
          roblox: (e) => ({
            id: "roblox",
            name: "Roblox",
            createAuthorizationURL({ state: t, scopes: r, redirectURI: i }) {
              let n = e.disableDefaultScope ? [] : ["openid", "profile"];
              return (
                e.scope && n.push(...e.scope),
                r && n.push(...r),
                new URL(
                  `https://apis.roblox.com/oauth/v1/authorize?scope=${n.join("+")}&response_type=code&client_id=${e.clientId}&redirect_uri=${encodeURIComponent(e.redirectURI || i)}&state=${t}&prompt=${e.prompt || "select_account+consent"}`
                )
              );
            },
            validateAuthorizationCode: async ({ code: t, redirectURI: r }) =>
              (0, T.v)({
                code: t,
                redirectURI: e.redirectURI || r,
                options: e,
                tokenEndpoint: "https://apis.roblox.com/oauth/v1/token",
                authentication: "post",
              }),
            refreshAccessToken: e.refreshAccessToken
              ? e.refreshAccessToken
              : async (t) =>
                  (0, T.r)({
                    refreshToken: t,
                    options: {
                      clientId: e.clientId,
                      clientKey: e.clientKey,
                      clientSecret: e.clientSecret,
                    },
                    tokenEndpoint: "https://apis.roblox.com/oauth/v1/token",
                  }),
            async getUserInfo(t) {
              if (e.getUserInfo) return e.getUserInfo(t);
              let { data: r, error: i } = await (0, n.zZ)(
                "https://apis.roblox.com/oauth/v1/userinfo",
                { headers: { authorization: `Bearer ${t.accessToken}` } }
              );
              if (i) return null;
              let s = await e.mapProfileToUser?.(r);
              return {
                user: {
                  id: r.sub,
                  name: r.nickname || r.preferred_username || "",
                  image: r.picture,
                  email: r.preferred_username || null,
                  emailVerified: !0,
                  ...s,
                },
                data: { ...r },
              };
            },
            options: e,
          }),
          vk: (e) => ({
            id: "vk",
            name: "VK",
            async createAuthorizationURL({
              state: t,
              scopes: r,
              codeVerifier: i,
              redirectURI: n,
            }) {
              let s = e.disableDefaultScope ? [] : ["email", "phone"];
              return (
                e.scope && s.push(...e.scope),
                r && s.push(...r),
                (0, T.c)({
                  id: "vk",
                  options: e,
                  authorizationEndpoint: "https://id.vk.com/authorize",
                  scopes: s,
                  state: t,
                  redirectURI: n,
                  codeVerifier: i,
                })
              );
            },
            validateAuthorizationCode: async ({
              code: t,
              codeVerifier: r,
              redirectURI: i,
              deviceId: n,
            }) =>
              (0, T.v)({
                code: t,
                codeVerifier: r,
                redirectURI: e.redirectURI || i,
                options: e,
                deviceId: n,
                tokenEndpoint: "https://id.vk.com/oauth2/auth",
              }),
            refreshAccessToken: e.refreshAccessToken
              ? e.refreshAccessToken
              : async (t) =>
                  (0, T.r)({
                    refreshToken: t,
                    options: {
                      clientId: e.clientId,
                      clientKey: e.clientKey,
                      clientSecret: e.clientSecret,
                    },
                    tokenEndpoint: "https://id.vk.com/oauth2/auth",
                  }),
            async getUserInfo(t) {
              if (e.getUserInfo) return e.getUserInfo(t);
              if (!t.accessToken) return null;
              let r = new URLSearchParams({
                  access_token: t.accessToken,
                  client_id: e.clientId,
                }).toString(),
                { data: i, error: s } = await (0, n.zZ)(
                  "https://id.vk.com/oauth2/user_info",
                  {
                    method: "POST",
                    headers: {
                      "Content-Type": "application/x-www-form-urlencoded",
                    },
                    body: r,
                  }
                );
              if (s || !i.user.email) return null;
              let o = await e.mapProfileToUser?.(i);
              return {
                user: {
                  id: i.user.user_id,
                  first_name: i.user.first_name,
                  last_name: i.user.last_name,
                  email: i.user.email,
                  image: i.user.avatar,
                  emailVerified: !!i.user.email,
                  birthday: i.user.birthday,
                  sex: i.user.sex,
                  ...o,
                },
                data: i,
              };
            },
            options: e,
          }),
          zoom: (e) => {
            let t = { pkce: !0, ...e };
            return {
              id: "zoom",
              name: "Zoom",
              createAuthorizationURL: async ({
                state: e,
                redirectURI: r,
                codeVerifier: i,
              }) => {
                let n = new URLSearchParams({
                  response_type: "code",
                  redirect_uri: t.redirectURI ? t.redirectURI : r,
                  client_id: t.clientId,
                  state: e,
                });
                if (t.pkce) {
                  let e = await (0, T.g)(i);
                  n.set("code_challenge_method", "S256"),
                    n.set("code_challenge", e);
                }
                let s = new URL("https://zoom.us/oauth/authorize");
                return (s.search = n.toString()), s;
              },
              validateAuthorizationCode: async ({
                code: e,
                redirectURI: r,
                codeVerifier: i,
              }) =>
                (0, T.v)({
                  code: e,
                  redirectURI: t.redirectURI || r,
                  codeVerifier: i,
                  options: t,
                  tokenEndpoint: "https://zoom.us/oauth/token",
                  authentication: "post",
                }),
              async getUserInfo(e) {
                if (t.getUserInfo) return t.getUserInfo(e);
                let { data: r, error: i } = await (0, n.zZ)(
                  "https://api.zoom.us/v2/users/me",
                  { headers: { authorization: `Bearer ${e.accessToken}` } }
                );
                if (i) return null;
                let s = await t.mapProfileToUser?.(r);
                return {
                  user: {
                    id: r.id,
                    name: r.display_name,
                    image: r.pic_url,
                    email: r.email,
                    emailVerified: !!r.verified,
                    ...s,
                  },
                  data: { ...r },
                };
              },
            };
          },
        },
        D = Object.keys(P),
        q = A.z.enum(D).or(A.z.string());
    },
    7846: (e, t, r) => {
      r.d(t, { g: () => i });
      let i = (e, t = "ms") =>
        new Date(Date.now() + ("sec" === t ? 1e3 * e : e));
    },
    8036: (e, t, r) => {
      r.d(t, { GQ: () => v, EQ: () => N, bl: () => b });
      var i = r(48675),
        n = r(96051),
        s = r(44851);
      let o = (0, n.CN)({
          is: (e) => "PartitionByNode" === e.kind,
          create: (e) =>
            (0, n.CN)({ kind: "PartitionByNode", items: (0, n.CN)(e) }),
          cloneWithItems: (e, t) =>
            (0, n.CN)({ ...e, items: (0, n.CN)([...e.items, ...t]) }),
        }),
        a = (0, n.CN)({
          is: (e) => "OverNode" === e.kind,
          create: () => (0, n.CN)({ kind: "OverNode" }),
          cloneWithOrderByItems: (e, t) =>
            (0, n.CN)({
              ...e,
              orderBy: e.orderBy
                ? s.O.cloneWithItems(e.orderBy, t)
                : s.O.create(t),
            }),
          cloneWithPartitionByItems: (e, t) =>
            (0, n.CN)({
              ...e,
              partitionBy: e.partitionBy
                ? o.cloneWithItems(e.partitionBy, t)
                : o.create(t),
            }),
        });
      var l = r(1045),
        c = r(74850);
      class d {
        #e;
        constructor(e) {
          this.#e = (0, n.CN)(e);
        }
        on(...e) {
          return new d({
            ...this.#e,
            joinNode: i.b.cloneWithOn(this.#e.joinNode, (0, c.GB)(e)),
          });
        }
        onRef(e, t, r) {
          return new d({
            ...this.#e,
            joinNode: i.b.cloneWithOn(this.#e.joinNode, (0, c.vC)(e, t, r)),
          });
        }
        onTrue() {
          return new d({
            ...this.#e,
            joinNode: i.b.cloneWithOn(
              this.#e.joinNode,
              l.z.createWithSql("true")
            ),
          });
        }
        $call(e) {
          return e(this);
        }
        toOperationNode() {
          return this.#e.joinNode;
        }
      }
      var u = r(64992),
        h = r(93403);
      let p = (0, n.CN)({
        is: (e) => "PartitionByItemNode" === e.kind,
        create: (e) =>
          (0, n.CN)({ kind: "PartitionByItemNode", partitionBy: e }),
      });
      var f = r(666);
      class m {
        #e;
        constructor(e) {
          this.#e = (0, n.CN)(e);
        }
        orderBy(...e) {
          return new m({
            overNode: a.cloneWithOrderByItems(this.#e.overNode, (0, h.xk)(e)),
          });
        }
        clearOrderBy() {
          return new m({ overNode: u.L.cloneWithoutOrderBy(this.#e.overNode) });
        }
        partitionBy(e) {
          return new m({
            overNode: a.cloneWithPartitionByItems(
              this.#e.overNode,
              (0, f.kU)(e).map(p.create)
            ),
          });
        }
        $call(e) {
          return e(this);
        }
        toOperationNode() {
          return this.#e.overNode;
        }
      }
      var y = r(96350),
        g = r(87201),
        w = r(33669);
      function b() {
        return new y.n({ executor: g.W });
      }
      function v(e, t) {
        return new d({ joinNode: i.b.create(e, (0, w.uJ)(t)) });
      }
      function N() {
        return new m({ overNode: a.create() });
      }
    },
    8126: (e, t, r) => {
      r.d(t, { UY: () => s, aK: () => n });
      var i = r(77598);
      let n = i.webcrypto?.subtle || {},
        s = (e) => i.webcrypto.getRandomValues(e);
    },
    9490: (e, t, r) => {
      r.d(t, { t: () => v });
      var i = r(93298),
        n = r(96051),
        s = r(52630),
        o = r(44851);
      let a = (0, n.CN)({
          is: (e) => "AggregateFunctionNode" === e.kind,
          create: (e, t = []) =>
            (0, n.CN)({
              kind: "AggregateFunctionNode",
              func: e,
              aggregated: t,
            }),
          cloneWithDistinct: (e) => (0, n.CN)({ ...e, distinct: !0 }),
          cloneWithOrderBy(e, t, r = !1) {
            let i = r ? "withinGroup" : "orderBy";
            return (0, n.CN)({
              ...e,
              [i]: e[i] ? o.O.cloneWithItems(e[i], t) : o.O.create(t),
            });
          },
          cloneWithFilter: (e, t) =>
            (0, n.CN)({
              ...e,
              filter: e.filter
                ? s.o.cloneWithOperation(e.filter, "And", t)
                : s.o.create(t),
            }),
          cloneWithOrFilter: (e, t) =>
            (0, n.CN)({
              ...e,
              filter: e.filter
                ? s.o.cloneWithOperation(e.filter, "Or", t)
                : s.o.create(t),
            }),
          cloneWithOver: (e, t) => (0, n.CN)({ ...e, over: t }),
        }),
        l = (0, n.CN)({
          is: (e) => "FunctionNode" === e.kind,
          create: (e, t) =>
            (0, n.CN)({ kind: "FunctionNode", func: e, arguments: t }),
        });
      var c = r(666),
        d = r(43005),
        u = r(83755),
        h = r(67872),
        p = r(8036),
        f = r(74850),
        m = r(93403),
        y = r(64992);
      class g {
        #e;
        constructor(e) {
          this.#e = (0, n.CN)(e);
        }
        get expressionType() {}
        as(e) {
          return new w(this, e);
        }
        distinct() {
          return new g({
            ...this.#e,
            aggregateFunctionNode: a.cloneWithDistinct(
              this.#e.aggregateFunctionNode
            ),
          });
        }
        orderBy(...e) {
          return new g({
            ...this.#e,
            aggregateFunctionNode: y.L.cloneWithOrderByItems(
              this.#e.aggregateFunctionNode,
              (0, m.xk)(e)
            ),
          });
        }
        clearOrderBy() {
          return new g({
            ...this.#e,
            aggregateFunctionNode: y.L.cloneWithoutOrderBy(
              this.#e.aggregateFunctionNode
            ),
          });
        }
        withinGroupOrderBy(...e) {
          return new g({
            ...this.#e,
            aggregateFunctionNode: a.cloneWithOrderBy(
              this.#e.aggregateFunctionNode,
              (0, m.xk)(e),
              !0
            ),
          });
        }
        filterWhere(...e) {
          return new g({
            ...this.#e,
            aggregateFunctionNode: a.cloneWithFilter(
              this.#e.aggregateFunctionNode,
              (0, f.GB)(e)
            ),
          });
        }
        filterWhereRef(e, t, r) {
          return new g({
            ...this.#e,
            aggregateFunctionNode: a.cloneWithFilter(
              this.#e.aggregateFunctionNode,
              (0, f.vC)(e, t, r)
            ),
          });
        }
        over(e) {
          let t = (0, p.EQ)();
          return new g({
            ...this.#e,
            aggregateFunctionNode: a.cloneWithOver(
              this.#e.aggregateFunctionNode,
              (e ? e(t) : t).toOperationNode()
            ),
          });
        }
        $call(e) {
          return e(this);
        }
        $castTo() {
          return new g(this.#e);
        }
        $notNull() {
          return new g(this.#e);
        }
        toOperationNode() {
          return this.#e.aggregateFunctionNode;
        }
      }
      class w {
        #c;
        #i;
        constructor(e, t) {
          (this.#c = e), (this.#i = t);
        }
        get expression() {
          return this.#c;
        }
        get alias() {
          return this.#i;
        }
        toOperationNode() {
          return u.N.create(this.#c.toOperationNode(), h.O.create(this.#i));
        }
      }
      var b = r(33669);
      function v() {
        let e = (e, t) => new i.Is(l.create(e, (0, c.kU)(t ?? []))),
          t = (e, t) =>
            new g({
              aggregateFunctionNode: a.create(e, t ? (0, c.kU)(t) : void 0),
            });
        return Object.assign(e, {
          agg: t,
          avg: (e) => t("avg", [e]),
          coalesce: (...t) => e("coalesce", t),
          count: (e) => t("count", [e]),
          countAll: (e) =>
            new g({ aggregateFunctionNode: a.create("count", (0, d.J)(e)) }),
          max: (e) => t("max", [e]),
          min: (e) => t("min", [e]),
          sum: (e) => t("sum", [e]),
          any: (t) => e("any", [t]),
          jsonAgg: (e) =>
            new g({
              aggregateFunctionNode: a.create("json_agg", [
                (0, n.Kg)(e) ? (0, b.M$)(e) : e.toOperationNode(),
              ]),
            }),
          toJson: (e) =>
            new i.Is(
              l.create("to_json", [
                (0, n.Kg)(e) ? (0, b.M$)(e) : e.toOperationNode(),
              ])
            ),
        });
      }
    },
    9625: (e, t, r) => {
      r.d(t, { D: () => n });
      let i = [
        "A",
        "B",
        "C",
        "D",
        "E",
        "F",
        "G",
        "H",
        "I",
        "J",
        "K",
        "L",
        "M",
        "N",
        "O",
        "P",
        "Q",
        "R",
        "S",
        "T",
        "U",
        "V",
        "W",
        "X",
        "Y",
        "Z",
        "a",
        "b",
        "c",
        "d",
        "e",
        "f",
        "g",
        "h",
        "i",
        "j",
        "k",
        "l",
        "m",
        "n",
        "o",
        "p",
        "q",
        "r",
        "s",
        "t",
        "u",
        "v",
        "w",
        "x",
        "y",
        "z",
        "0",
        "1",
        "2",
        "3",
        "4",
        "5",
        "6",
        "7",
        "8",
        "9",
      ];
      function n(e) {
        let t = "";
        for (let r = 0; r < e; ++r) t += i[~~(Math.random() * i.length)];
        return t;
      }
    },
    10132: (e, t, r) => {
      r.d(t, { N: () => n });
      var i = r(96051);
      function n(e) {
        return (0, i.Gv)(e) && (0, i.Tn)(e.toOperationNode);
      }
    },
    10257: (e, t, r) => {
      r.d(t, { B: () => i });
      class i extends Error {
        constructor(e, t) {
          super(e),
            (this.name = "BetterAuthError"),
            (this.message = e),
            (this.cause = t),
            (this.stack = "");
        }
      }
    },
    11618: (e, t, r) => {
      r.d(t, { KM: () => l, vE: () => u, xQ: () => d });
      var i = r(90211),
        n = r(72259),
        s = r(64055),
        o = r(74945);
      class a extends o.u {
        static [i.i] = "PgTimestampBuilder";
        constructor(e, t, r) {
          super(e, "date", "PgTimestamp"),
            (this.config.withTimezone = t),
            (this.config.precision = r);
        }
        build(e) {
          return new l(e, this.config);
        }
      }
      class l extends s.Kl {
        static [i.i] = "PgTimestamp";
        withTimezone;
        precision;
        constructor(e, t) {
          super(e, t),
            (this.withTimezone = t.withTimezone),
            (this.precision = t.precision);
        }
        getSQLType() {
          let e = void 0 === this.precision ? "" : ` (${this.precision})`;
          return `timestamp${e}${this.withTimezone ? " with time zone" : ""}`;
        }
        mapFromDriverValue = (e) =>
          new Date(this.withTimezone ? e : e + "+0000");
        mapToDriverValue = (e) => e.toISOString();
      }
      class c extends o.u {
        static [i.i] = "PgTimestampStringBuilder";
        constructor(e, t, r) {
          super(e, "string", "PgTimestampString"),
            (this.config.withTimezone = t),
            (this.config.precision = r);
        }
        build(e) {
          return new d(e, this.config);
        }
      }
      class d extends s.Kl {
        static [i.i] = "PgTimestampString";
        withTimezone;
        precision;
        constructor(e, t) {
          super(e, t),
            (this.withTimezone = t.withTimezone),
            (this.precision = t.precision);
        }
        getSQLType() {
          let e = void 0 === this.precision ? "" : `(${this.precision})`;
          return `timestamp${e}${this.withTimezone ? " with time zone" : ""}`;
        }
      }
      function u(e, t = {}) {
        let { name: r, config: i } = (0, n.Ll)(e, t);
        return i?.mode === "string"
          ? new c(r, i.withTimezone ?? !1, i.precision)
          : new a(r, i?.withTimezone ?? !1, i?.precision);
      }
    },
    11750: (e, t, r) => {
      r.d(t, { $s: () => c, U2: () => l, dJ: () => u, qH: () => d });
      var i = r(31437),
        n = r(99313),
        s = r(89400),
        o = r(96051),
        a = r(75423);
      function l(e) {
        var t;
        return (0, o.MH)(e)
          ? (t = e).some(a.SS)
            ? n.s.create(t.map((e) => c(e)))
            : i.h.create(t)
          : c(e);
      }
      function c(e) {
        return (0, a.SS)(e) ? (0, a.YK)(e) : s.q.create(e);
      }
      function d(e) {
        return (0, o.Et)(e) || (0, o.Lm)(e) || (0, o.kZ)(e);
      }
      function u(e) {
        if (!d(e)) throw Error(`unsafe immediate value ${JSON.stringify(e)}`);
        return s.q.createImmediate(e);
      }
    },
    11916: (e, t, r) => {
      r.d(t, {
        Iw: () => _,
        Or: () => T,
        Xs: () => w,
        DJ: () => g,
        Ss: () => E,
        Ct: () => k,
        eG: () => v,
        qt: () => y,
        ll: () => S,
      });
      var i = r(90211),
        n = r(64055);
      class s extends n.pe {
        static [i.i] = "PgEnumObjectColumnBuilder";
        constructor(e, t) {
          super(e, "string", "PgEnumObjectColumn"), (this.config.enum = t);
        }
        build(e) {
          return new o(e, this.config);
        }
      }
      class o extends n.Kl {
        static [i.i] = "PgEnumObjectColumn";
        enum;
        enumValues = this.config.enum.enumValues;
        constructor(e, t) {
          super(e, t), (this.enum = t.enum);
        }
        getSQLType() {
          return this.enum.enumName;
        }
      }
      let a = Symbol.for("drizzle:isPgEnum");
      class l extends n.pe {
        static [i.i] = "PgEnumColumnBuilder";
        constructor(e, t) {
          super(e, "string", "PgEnumColumn"), (this.config.enum = t);
        }
        build(e) {
          return new c(e, this.config);
        }
      }
      class c extends n.Kl {
        static [i.i] = "PgEnumColumn";
        enum = this.config.enum;
        enumValues = this.config.enum.enumValues;
        constructor(e, t) {
          super(e, t), (this.enum = t.enum);
        }
        getSQLType() {
          return this.enum.enumName;
        }
      }
      var d = r(80382),
        u = r(41286),
        h = r(91631),
        p = r(93994),
        f = r(47590);
      class m {
        static [i.i] = null;
      }
      function y(e) {
        return null != e && "function" == typeof e.getSQL;
      }
      class g {
        static [i.i] = "StringChunk";
        value;
        constructor(e) {
          this.value = Array.isArray(e) ? e : [e];
        }
        getSQL() {
          return new w([this]);
        }
      }
      class w {
        constructor(e) {
          for (let t of ((this.queryChunks = e), e))
            if ((0, i.is)(t, f.XI)) {
              let e = t[f.XI.Symbol.Schema];
              this.usedTables.push(
                void 0 === e
                  ? t[f.XI.Symbol.Name]
                  : e + "." + t[f.XI.Symbol.Name]
              );
            }
        }
        static [i.i] = "SQL";
        decoder = N;
        shouldInlineParams = !1;
        usedTables = [];
        append(e) {
          return this.queryChunks.push(...e.queryChunks), this;
        }
        toQuery(e) {
          return u.k.startActiveSpan("drizzle.buildSQL", (t) => {
            let r = this.buildQueryFromSourceParams(this.queryChunks, e);
            return (
              t?.setAttributes({
                "drizzle.query.text": r.sql,
                "drizzle.query.params": JSON.stringify(r.params),
              }),
              r
            );
          });
        }
        buildQueryFromSourceParams(e, t) {
          let r = Object.assign({}, t, {
              inlineParams: t.inlineParams || this.shouldInlineParams,
              paramStartIndex: t.paramStartIndex || { value: 0 },
            }),
            {
              casing: n,
              escapeName: s,
              escapeParam: o,
              prepareTyping: l,
              inlineParams: c,
              paramStartIndex: u,
            } = r;
          var m = e.map((e) => {
            if ((0, i.is)(e, g)) return { sql: e.value.join(""), params: [] };
            if ((0, i.is)(e, b)) return { sql: s(e.value), params: [] };
            if (void 0 === e) return { sql: "", params: [] };
            if (Array.isArray(e)) {
              let t = [new g("(")];
              for (let [r, i] of e.entries())
                t.push(i), r < e.length - 1 && t.push(new g(", "));
              return t.push(new g(")")), this.buildQueryFromSourceParams(t, r);
            }
            if ((0, i.is)(e, w))
              return this.buildQueryFromSourceParams(e.queryChunks, {
                ...r,
                inlineParams: c || e.shouldInlineParams,
              });
            if ((0, i.is)(e, f.XI)) {
              let t = e[f.XI.Symbol.Schema],
                r = e[f.XI.Symbol.Name];
              return {
                sql: void 0 === t || e[f.HE] ? s(r) : s(t) + "." + s(r),
                params: [],
              };
            }
            if ((0, i.is)(e, p.V)) {
              let r = n.getColumnCasing(e);
              if ("indexes" === t.invokeSource)
                return { sql: s(r), params: [] };
              let i = e.table[f.XI.Symbol.Schema];
              return {
                sql:
                  e.table[f.HE] || void 0 === i
                    ? s(e.table[f.XI.Symbol.Name]) + "." + s(r)
                    : s(i) + "." + s(e.table[f.XI.Symbol.Name]) + "." + s(r),
                params: [],
              };
            }
            if ((0, i.is)(e, E)) {
              let t = e[h.n].schema,
                r = e[h.n].name;
              return {
                sql: void 0 === t || e[h.n].isAlias ? s(r) : s(t) + "." + s(r),
                params: [],
              };
            }
            if ((0, i.is)(e, _)) {
              if ((0, i.is)(e.value, T))
                return { sql: o(u.value++, e), params: [e], typings: ["none"] };
              let t =
                null === e.value ? null : e.encoder.mapToDriverValue(e.value);
              if ((0, i.is)(t, w))
                return this.buildQueryFromSourceParams([t], r);
              if (c) return { sql: this.mapInlineParam(t, r), params: [] };
              let n = ["none"];
              return (
                l && (n = [l(e.encoder)]),
                { sql: o(u.value++, t), params: [t], typings: n }
              );
            }
            return (0, i.is)(e, T)
              ? { sql: o(u.value++, e), params: [e], typings: ["none"] }
              : (0, i.is)(e, w.Aliased) && void 0 !== e.fieldAlias
                ? { sql: s(e.fieldAlias), params: [] }
                : (0, i.is)(e, d.n)
                  ? e._.isWith
                    ? { sql: s(e._.alias), params: [] }
                    : this.buildQueryFromSourceParams(
                        [new g("("), e._.sql, new g(") "), new b(e._.alias)],
                        r
                      )
                  : e && "function" == typeof e && a in e && !0 === e[a]
                    ? e.schema
                      ? { sql: s(e.schema) + "." + s(e.enumName), params: [] }
                      : { sql: s(e.enumName), params: [] }
                    : y(e)
                      ? e.shouldOmitSQLParens?.()
                        ? this.buildQueryFromSourceParams([e.getSQL()], r)
                        : this.buildQueryFromSourceParams(
                            [new g("("), e.getSQL(), new g(")")],
                            r
                          )
                      : c
                        ? { sql: this.mapInlineParam(e, r), params: [] }
                        : {
                            sql: o(u.value++, e),
                            params: [e],
                            typings: ["none"],
                          };
          });
          let v = { sql: "", params: [] };
          for (let e of m)
            (v.sql += e.sql),
              v.params.push(...e.params),
              e.typings?.length &&
                (v.typings || (v.typings = []), v.typings.push(...e.typings));
          return v;
        }
        mapInlineParam(e, { escapeString: t }) {
          if (null === e) return "null";
          if ("number" == typeof e || "boolean" == typeof e)
            return e.toString();
          if ("string" == typeof e) return t(e);
          if ("object" == typeof e) {
            let r = e.toString();
            return "[object Object]" === r ? t(JSON.stringify(e)) : t(r);
          }
          throw Error("Unexpected param value: " + e);
        }
        getSQL() {
          return this;
        }
        as(e) {
          return void 0 === e ? this : new w.Aliased(this, e);
        }
        mapWith(e) {
          return (
            (this.decoder =
              "function" == typeof e ? { mapFromDriverValue: e } : e),
            this
          );
        }
        inlineParams() {
          return (this.shouldInlineParams = !0), this;
        }
        if(e) {
          return e ? this : void 0;
        }
      }
      class b {
        constructor(e) {
          this.value = e;
        }
        static [i.i] = "Name";
        brand;
        getSQL() {
          return new w([this]);
        }
      }
      function v(e) {
        return (
          "object" == typeof e &&
          null !== e &&
          "mapToDriverValue" in e &&
          "function" == typeof e.mapToDriverValue
        );
      }
      let N = { mapFromDriverValue: (e) => e },
        x = { mapToDriverValue: (e) => e };
      ({ ...N, ...x });
      class _ {
        constructor(e, t = x) {
          (this.value = e), (this.encoder = t);
        }
        static [i.i] = "Param";
        brand;
        getSQL() {
          return new w([this]);
        }
      }
      function S(e, ...t) {
        let r = [];
        for (let [i, n] of ((t.length > 0 || (e.length > 0 && "" !== e[0])) &&
          r.push(new g(e[0])),
        t.entries()))
          r.push(n, new g(e[i + 1]));
        return new w(r);
      }
      ((e) => {
        (e.empty = function () {
          return new w([]);
        }),
          (e.fromList = function (e) {
            return new w(e);
          }),
          (e.raw = function (e) {
            return new w([new g(e)]);
          }),
          (e.join = function (e, t) {
            let r = [];
            for (let [i, n] of e.entries())
              i > 0 && void 0 !== t && r.push(t), r.push(n);
            return new w(r);
          }),
          (e.identifier = function (e) {
            return new b(e);
          }),
          (e.placeholder = function (e) {
            return new T(e);
          }),
          (e.param = function (e, t) {
            return new _(e, t);
          });
      })(S || (S = {})),
        ((e) => {
          class t {
            constructor(e, t) {
              (this.sql = e), (this.fieldAlias = t);
            }
            static [i.i] = "SQL.Aliased";
            isSelectionField = !1;
            getSQL() {
              return this.sql;
            }
            clone() {
              return new t(this.sql, this.fieldAlias);
            }
          }
          e.Aliased = t;
        })(w || (w = {}));
      class T {
        constructor(e) {
          this.name = e;
        }
        static [i.i] = "Placeholder";
        getSQL() {
          return new w([this]);
        }
      }
      function k(e, t) {
        return e.map((e) => {
          if ((0, i.is)(e, T)) {
            if (!(e.name in t))
              throw Error(`No value for placeholder "${e.name}" was provided`);
            return t[e.name];
          }
          if ((0, i.is)(e, _) && (0, i.is)(e.value, T)) {
            if (!(e.value.name in t))
              throw Error(
                `No value for placeholder "${e.value.name}" was provided`
              );
            return e.encoder.mapToDriverValue(t[e.value.name]);
          }
          return e;
        });
      }
      let A = Symbol.for("drizzle:IsDrizzleView");
      class E {
        static [i.i] = "View";
        [h.n];
        [A] = !0;
        constructor({ name: e, schema: t, selectedFields: r, query: i }) {
          this[h.n] = {
            name: e,
            originalName: e,
            schema: t,
            selectedFields: r,
            query: i,
            isExisting: !i,
            isAlias: !1,
          };
        }
        getSQL() {
          return new w([this]);
        }
      }
      (p.V.prototype.getSQL = function () {
        return new w([this]);
      }),
        (f.XI.prototype.getSQL = function () {
          return new w([this]);
        }),
        (d.n.prototype.getSQL = function () {
          return new w([this]);
        });
    },
    12455: (e, t, r) => {
      r.d(t, { A: () => n });
      var i = r(41321);
      function n(e) {
        switch (e) {
          case "PS256":
          case "RS256":
          case "ES256":
          case "ES256K":
            return "sha256";
          case "PS384":
          case "RS384":
          case "ES384":
            return "sha384";
          case "PS512":
          case "RS512":
          case "ES512":
            return "sha512";
          case "Ed25519":
          case "EdDSA":
            return;
          default:
            throw new i.T0(
              `alg ${e} is not supported either by JOSE or your javascript runtime`
            );
        }
      }
    },
    12486: (e, t, r) => {
      r.d(t, { n: () => s });
      var i = r(8126),
        n = r(51875);
      function s(e, t) {
        return {
          digest: async (r) => {
            let s = new TextEncoder(),
              o = "string" == typeof r ? s.encode(r) : r,
              a = await i.aK.digest(e, o);
            return "hex" === t
              ? Array.from(new Uint8Array(a))
                  .map((e) => e.toString(16).padStart(2, "0"))
                  .join("")
              : "base64" === t || "base64url" === t || "base64urlnopad" === t
                ? t.includes("url")
                  ? n.z.encode(a, { padding: "base64urlnopad" !== t })
                  : n.K.encode(a)
                : a;
          },
        };
      }
    },
    16459: (e, t, r) => {
      r.d(t, { q: () => s });
      var i = r(8126);
      function n(e) {
        switch (e) {
          case "a-z":
            return "abcdefghijklmnopqrstuvwxyz";
          case "A-Z":
            return "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
          case "0-9":
            return "0123456789";
          case "-_":
            return "-_";
          default:
            throw Error(`Unsupported alphabet: ${e}`);
        }
      }
      function s(...e) {
        let t = e.map(n).join("");
        if (0 === t.length)
          throw Error(
            "No valid characters provided for random string generation."
          );
        let r = t.length;
        return (e, ...s) => {
          let o;
          if (e <= 0) throw Error("Length must be a positive integer.");
          let a = t,
            l = r;
          s.length > 0 && (l = (a = s.map(n).join("")).length);
          let c = Math.floor(256 / l) * l,
            d = new Uint8Array(2 * e),
            u = d.length,
            h = "",
            p = u;
          for (; h.length < e; )
            p >= u && ((0, i.UY)(d), (p = 0)),
              (o = d[p++]) < c && (h += a[o % l]);
          return h;
        };
      }
    },
    16533: (e, t, r) => {
      r.d(t, { g: () => i });
      let i = (e) => {
        let t = e.plugins?.reduce((e, t) => {
            let r = t.schema;
            if (!r) return e;
            for (let [t, i] of Object.entries(r))
              e[t] = {
                fields: { ...e[t]?.fields, ...i.fields },
                modelName: i.modelName || t,
              };
            return e;
          }, {}),
          r = e.rateLimit?.storage === "database",
          i = {
            rateLimit: {
              modelName: e.rateLimit?.modelName || "rateLimit",
              fields: {
                key: {
                  type: "string",
                  fieldName: e.rateLimit?.fields?.key || "key",
                },
                count: {
                  type: "number",
                  fieldName: e.rateLimit?.fields?.count || "count",
                },
                lastRequest: {
                  type: "number",
                  bigint: !0,
                  fieldName: e.rateLimit?.fields?.lastRequest || "lastRequest",
                },
              },
            },
          },
          { user: n, session: s, account: o, ...a } = t || {},
          l = {
            session: {
              modelName: e.session?.modelName || "session",
              fields: {
                expiresAt: {
                  type: "date",
                  required: !0,
                  fieldName: e.session?.fields?.expiresAt || "expiresAt",
                },
                token: {
                  type: "string",
                  required: !0,
                  fieldName: e.session?.fields?.token || "token",
                  unique: !0,
                },
                createdAt: {
                  type: "date",
                  required: !0,
                  fieldName: e.session?.fields?.createdAt || "createdAt",
                },
                updatedAt: {
                  type: "date",
                  required: !0,
                  fieldName: e.session?.fields?.updatedAt || "updatedAt",
                },
                ipAddress: {
                  type: "string",
                  required: !1,
                  fieldName: e.session?.fields?.ipAddress || "ipAddress",
                },
                userAgent: {
                  type: "string",
                  required: !1,
                  fieldName: e.session?.fields?.userAgent || "userAgent",
                },
                userId: {
                  type: "string",
                  fieldName: e.session?.fields?.userId || "userId",
                  references: {
                    model: e.user?.modelName || "user",
                    field: "id",
                    onDelete: "cascade",
                  },
                  required: !0,
                },
                ...s?.fields,
                ...e.session?.additionalFields,
              },
              order: 2,
            },
          };
        return {
          user: {
            modelName: e.user?.modelName || "user",
            fields: {
              name: {
                type: "string",
                required: !0,
                fieldName: e.user?.fields?.name || "name",
                sortable: !0,
              },
              email: {
                type: "string",
                unique: !0,
                required: !0,
                fieldName: e.user?.fields?.email || "email",
                sortable: !0,
              },
              emailVerified: {
                type: "boolean",
                defaultValue: () => !1,
                required: !0,
                fieldName: e.user?.fields?.emailVerified || "emailVerified",
              },
              image: {
                type: "string",
                required: !1,
                fieldName: e.user?.fields?.image || "image",
              },
              createdAt: {
                type: "date",
                defaultValue: () => new Date(),
                required: !0,
                fieldName: e.user?.fields?.createdAt || "createdAt",
              },
              updatedAt: {
                type: "date",
                defaultValue: () => new Date(),
                required: !0,
                fieldName: e.user?.fields?.updatedAt || "updatedAt",
              },
              ...n?.fields,
              ...e.user?.additionalFields,
            },
            order: 1,
          },
          ...(!e.secondaryStorage || e.session?.storeSessionInDatabase
            ? l
            : {}),
          account: {
            modelName: e.account?.modelName || "account",
            fields: {
              accountId: {
                type: "string",
                required: !0,
                fieldName: e.account?.fields?.accountId || "accountId",
              },
              providerId: {
                type: "string",
                required: !0,
                fieldName: e.account?.fields?.providerId || "providerId",
              },
              userId: {
                type: "string",
                references: {
                  model: e.user?.modelName || "user",
                  field: "id",
                  onDelete: "cascade",
                },
                required: !0,
                fieldName: e.account?.fields?.userId || "userId",
              },
              accessToken: {
                type: "string",
                required: !1,
                fieldName: e.account?.fields?.accessToken || "accessToken",
              },
              refreshToken: {
                type: "string",
                required: !1,
                fieldName: e.account?.fields?.refreshToken || "refreshToken",
              },
              idToken: {
                type: "string",
                required: !1,
                fieldName: e.account?.fields?.idToken || "idToken",
              },
              accessTokenExpiresAt: {
                type: "date",
                required: !1,
                fieldName:
                  e.account?.fields?.accessTokenExpiresAt ||
                  "accessTokenExpiresAt",
              },
              refreshTokenExpiresAt: {
                type: "date",
                required: !1,
                fieldName:
                  e.account?.fields?.accessTokenExpiresAt ||
                  "refreshTokenExpiresAt",
              },
              scope: {
                type: "string",
                required: !1,
                fieldName: e.account?.fields?.scope || "scope",
              },
              password: {
                type: "string",
                required: !1,
                fieldName: e.account?.fields?.password || "password",
              },
              createdAt: {
                type: "date",
                required: !0,
                fieldName: e.account?.fields?.createdAt || "createdAt",
              },
              updatedAt: {
                type: "date",
                required: !0,
                fieldName: e.account?.fields?.updatedAt || "updatedAt",
              },
              ...o?.fields,
            },
            order: 3,
          },
          verification: {
            modelName: e.verification?.modelName || "verification",
            fields: {
              identifier: {
                type: "string",
                required: !0,
                fieldName: e.verification?.fields?.identifier || "identifier",
              },
              value: {
                type: "string",
                required: !0,
                fieldName: e.verification?.fields?.value || "value",
              },
              expiresAt: {
                type: "date",
                required: !0,
                fieldName: e.verification?.fields?.expiresAt || "expiresAt",
              },
              createdAt: {
                type: "date",
                required: !1,
                defaultValue: () => new Date(),
                fieldName: e.verification?.fields?.createdAt || "createdAt",
              },
              updatedAt: {
                type: "date",
                required: !1,
                defaultValue: () => new Date(),
                fieldName: e.verification?.fields?.updatedAt || "updatedAt",
              },
            },
            order: 4,
          },
          ...a,
          ...(r ? i : {}),
        };
      };
    },
    17445: (e, t, r) => {
      r.d(t, { y: () => s });
      var i = r(96051),
        n = r(67872);
      let s = (0, i.CN)({
        is: (e) => "SchemableIdentifierNode" === e.kind,
        create: (e) =>
          (0, i.CN)({
            kind: "SchemableIdentifierNode",
            identifier: n.O.create(e),
          }),
        createWithSchema: (e, t) =>
          (0, i.CN)({
            kind: "SchemableIdentifierNode",
            schema: n.O.create(e),
            identifier: n.O.create(t),
          }),
      });
    },
    17463: (e, t, r) => {
      r.d(t, { dL: () => a, uR: () => l });
      var i = r(90211),
        n = r(11916),
        s = r(64055);
      class o extends s.pe {
        static [i.i] = "PgUUIDBuilder";
        constructor(e) {
          super(e, "string", "PgUUID");
        }
        defaultRandom() {
          return this.default((0, n.ll)`gen_random_uuid()`);
        }
        build(e) {
          return new a(e, this.config);
        }
      }
      class a extends s.Kl {
        static [i.i] = "PgUUID";
        getSQLType() {
          return "uuid";
        }
      }
      function l(e) {
        return new o(e ?? "");
      }
    },
    19334: (e, t, r) => {
      r.d(t, { k: () => n });
      var i = r(96051);
      let n = (0, i.CN)({
        is: (e) => "ParensNode" === e.kind,
        create: (e) => (0, i.CN)({ kind: "ParensNode", node: e }),
      });
    },
    19984: (e, t, r) => {
      r.d(t, { D4: () => o, lF: () => s });
      var i = r(4573),
        n = r(3415);
      let s = (e) => i.Buffer.from(e).toString("base64url"),
        o = (e) =>
          new Uint8Array(
            i.Buffer.from(
              (function (e) {
                let t = e;
                return t instanceof Uint8Array && (t = n.D0.decode(t)), t;
              })(e),
              "base64url"
            )
          );
    },
    22047: (e, t, r) => {
      r.d(t, {
        AU: () => h,
        B3: () => A,
        KJ: () => x,
        KL: () => w,
        Pe: () => v,
        RK: () => k,
        RO: () => f,
        RV: () => g,
        Tq: () => _,
        Uo: () => d,
        eq: () => l,
        gt: () => p,
        kZ: () => b,
        lt: () => m,
        mj: () => T,
        ne: () => c,
        o8: () => S,
        or: () => u,
        q1: () => E,
        t2: () => N,
        wJ: () => y,
      });
      var i = r(93994),
        n = r(90211),
        s = r(47590),
        o = r(11916);
      function a(e, t) {
        return !(0, o.eG)(t) ||
          (0, o.qt)(e) ||
          (0, n.is)(e, o.Iw) ||
          (0, n.is)(e, o.Or) ||
          (0, n.is)(e, i.V) ||
          (0, n.is)(e, s.XI) ||
          (0, n.is)(e, o.Ss)
          ? e
          : new o.Iw(e, t);
      }
      let l = (e, t) => (0, o.ll)`${e} = ${a(t, e)}`,
        c = (e, t) => (0, o.ll)`${e} <> ${a(t, e)}`;
      function d(...e) {
        let t = e.filter((e) => void 0 !== e);
        if (0 !== t.length)
          return new o.Xs(
            1 === t.length
              ? t
              : [new o.DJ("("), o.ll.join(t, new o.DJ(" and ")), new o.DJ(")")]
          );
      }
      function u(...e) {
        let t = e.filter((e) => void 0 !== e);
        if (0 !== t.length)
          return new o.Xs(
            1 === t.length
              ? t
              : [new o.DJ("("), o.ll.join(t, new o.DJ(" or ")), new o.DJ(")")]
          );
      }
      function h(e) {
        return (0, o.ll)`not ${e}`;
      }
      let p = (e, t) => (0, o.ll)`${e} > ${a(t, e)}`,
        f = (e, t) => (0, o.ll)`${e} >= ${a(t, e)}`,
        m = (e, t) => (0, o.ll)`${e} < ${a(t, e)}`,
        y = (e, t) => (0, o.ll)`${e} <= ${a(t, e)}`;
      function g(e, t) {
        return Array.isArray(t)
          ? 0 === t.length
            ? (0, o.ll)`false`
            : (0, o.ll)`${e} in ${t.map((t) => a(t, e))}`
          : (0, o.ll)`${e} in ${a(t, e)}`;
      }
      function w(e, t) {
        return Array.isArray(t)
          ? 0 === t.length
            ? (0, o.ll)`true`
            : (0, o.ll)`${e} not in ${t.map((t) => a(t, e))}`
          : (0, o.ll)`${e} not in ${a(t, e)}`;
      }
      function b(e) {
        return (0, o.ll)`${e} is null`;
      }
      function v(e) {
        return (0, o.ll)`${e} is not null`;
      }
      function N(e) {
        return (0, o.ll)`exists ${e}`;
      }
      function x(e) {
        return (0, o.ll)`not exists ${e}`;
      }
      function _(e, t, r) {
        return (0, o.ll)`${e} between ${a(t, e)} and ${a(r, e)}`;
      }
      function S(e, t, r) {
        return (0, o.ll)`${e} not between ${a(t, e)} and ${a(r, e)}`;
      }
      function T(e, t) {
        return (0, o.ll)`${e} like ${t}`;
      }
      function k(e, t) {
        return (0, o.ll)`${e} not like ${t}`;
      }
      function A(e, t) {
        return (0, o.ll)`${e} ilike ${t}`;
      }
      function E(e, t) {
        return (0, o.ll)`${e} not ilike ${t}`;
      }
    },
    26514: (e, t, r) => {
      r.d(t, { Pq: () => a, iX: () => o });
      var i = r(90211),
        n = r(64055);
      class s extends n.pe {
        static [i.i] = "PgJsonBuilder";
        constructor(e) {
          super(e, "json", "PgJson");
        }
        build(e) {
          return new o(e, this.config);
        }
      }
      class o extends n.Kl {
        static [i.i] = "PgJson";
        constructor(e, t) {
          super(e, t);
        }
        getSQLType() {
          return "json";
        }
        mapToDriverValue(e) {
          return JSON.stringify(e);
        }
        mapFromDriverValue(e) {
          if ("string" == typeof e)
            try {
              return JSON.parse(e);
            } catch {}
          return e;
        }
      }
      function a(e) {
        return new s(e ?? "");
      }
    },
    27759: (e, t, r) => {
      r.d(t, { U: () => n });
      var i = r(96051);
      let n = (0, i.CN)({
        is: (e) => "SelectAllNode" === e.kind,
        create: () => (0, i.CN)({ kind: "SelectAllNode" }),
      });
    },
    27819: (e, t, r) => {
      r.d(t, { Qq: () => l });
      var i = r(90211),
        n = r(72259),
        s = r(64055);
      class o extends s.pe {
        static [i.i] = "PgTextBuilder";
        constructor(e, t) {
          super(e, "string", "PgText"), (this.config.enumValues = t.enum);
        }
        build(e) {
          return new a(e, this.config);
        }
      }
      class a extends s.Kl {
        static [i.i] = "PgText";
        enumValues = this.config.enumValues;
        getSQLType() {
          return "text";
        }
      }
      function l(e, t = {}) {
        let { name: r, config: i } = (0, n.Ll)(e, t);
        return new o(r, i);
      }
    },
    28341: (e, t, r) => {
      r.d(t, { fd: () => rK });
      var i,
        n,
        s,
        o,
        a,
        l,
        c = Object.create,
        d = Object.defineProperty,
        u = Object.getOwnPropertyDescriptor,
        h = Object.getOwnPropertyNames,
        p = Object.getPrototypeOf,
        f = Object.prototype.hasOwnProperty,
        m = (e, t, r) =>
          t in e
            ? d(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        y = (e, t) => d(e, "name", { value: t, configurable: !0 }),
        g = (e, t) => () => (e && (t = e((e = 0))), t),
        w = (e, t) => () => (
          t || e((t = { exports: {} }).exports, t), t.exports
        ),
        b = (e, t) => {
          for (var r in t) d(e, r, { get: t[r], enumerable: !0 });
        },
        v = (e, t, r, i) => {
          if ((t && "object" == typeof t) || "function" == typeof t)
            for (let n of h(t))
              f.call(e, n) ||
                n === r ||
                d(e, n, {
                  get: () => t[n],
                  enumerable: !(i = u(t, n)) || i.enumerable,
                });
          return e;
        },
        N = (e, t, r) => (
          (r = null != e ? c(p(e)) : {}),
          v(
            !t && e && e.__esModule
              ? r
              : d(r, "default", { value: e, enumerable: !0 }),
            e
          )
        ),
        x = (e) => v(d({}, "__esModule", { value: !0 }), e),
        _ = (e, t, r) => m(e, "symbol" != typeof t ? t + "" : t, r),
        S = w((e) => {
          A(), (e.byteLength = l), (e.toByteArray = d), (e.fromByteArray = p);
          var t,
            r,
            i = [],
            n = [],
            s = "u" > typeof Uint8Array ? Uint8Array : Array,
            o =
              "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
          for (t = 0, r = o.length; t < r; ++t)
            (i[t] = o[t]), (n[o.charCodeAt(t)] = t);
          function a(e) {
            var t = e.length;
            if (t % 4 > 0)
              throw Error("Invalid string. Length must be a multiple of 4");
            var r = e.indexOf("=");
            -1 === r && (r = t);
            var i = r === t ? 0 : 4 - (r % 4);
            return [r, i];
          }
          function l(e) {
            var t = a(e),
              r = t[0],
              i = t[1];
            return ((r + i) * 3) / 4 - i;
          }
          function c(e, t, r) {
            return ((t + r) * 3) / 4 - r;
          }
          function d(e) {
            var t,
              r,
              i = a(e),
              o = i[0],
              l = i[1],
              d = new s(c(e, o, l)),
              u = 0,
              h = l > 0 ? o - 4 : o;
            for (r = 0; r < h; r += 4)
              (t =
                (n[e.charCodeAt(r)] << 18) |
                (n[e.charCodeAt(r + 1)] << 12) |
                (n[e.charCodeAt(r + 2)] << 6) |
                n[e.charCodeAt(r + 3)]),
                (d[u++] = (t >> 16) & 255),
                (d[u++] = (t >> 8) & 255),
                (d[u++] = 255 & t);
            return (
              2 === l &&
                ((t =
                  (n[e.charCodeAt(r)] << 2) | (n[e.charCodeAt(r + 1)] >> 4)),
                (d[u++] = 255 & t)),
              1 === l &&
                ((t =
                  (n[e.charCodeAt(r)] << 10) |
                  (n[e.charCodeAt(r + 1)] << 4) |
                  (n[e.charCodeAt(r + 2)] >> 2)),
                (d[u++] = (t >> 8) & 255),
                (d[u++] = 255 & t)),
              d
            );
          }
          function u(e) {
            return (
              i[(e >> 18) & 63] +
              i[(e >> 12) & 63] +
              i[(e >> 6) & 63] +
              i[63 & e]
            );
          }
          function h(e, t, r) {
            for (var i = [], n = t; n < r; n += 3)
              i.push(
                u(
                  ((e[n] << 16) & 0xff0000) +
                    ((e[n + 1] << 8) & 65280) +
                    (255 & e[n + 2])
                )
              );
            return i.join("");
          }
          function p(e) {
            for (
              var t, r = e.length, n = r % 3, s = [], o = 0, a = r - n;
              o < a;
              o += 16383
            )
              s.push(h(e, o, o + 16383 > a ? a : o + 16383));
            return (
              1 === n
                ? s.push(i[(t = e[r - 1]) >> 2] + i[(t << 4) & 63] + "==")
                : 2 === n &&
                  s.push(
                    i[(t = (e[r - 2] << 8) + e[r - 1]) >> 10] +
                      i[(t >> 4) & 63] +
                      i[(t << 2) & 63] +
                      "="
                  ),
              s.join("")
            );
          }
          (n[45] = 62),
            (n[95] = 63),
            y(a, "getLens"),
            y(l, "byteLength"),
            y(c, "_byteLength"),
            y(d, "toByteArray"),
            y(u, "tripletToBase64"),
            y(h, "encodeChunk"),
            y(p, "fromByteArray");
        }),
        T = w((e) => {
          A(),
            (e.read = function (e, t, r, i, n) {
              var s,
                o,
                a = 8 * n - i - 1,
                l = (1 << a) - 1,
                c = l >> 1,
                d = -7,
                u = r ? n - 1 : 0,
                h = r ? -1 : 1,
                p = e[t + u];
              for (
                u += h, s = p & ((1 << -d) - 1), p >>= -d, d += a;
                d > 0;
                s = 256 * s + e[t + u], u += h, d -= 8
              );
              for (
                o = s & ((1 << -d) - 1), s >>= -d, d += i;
                d > 0;
                o = 256 * o + e[t + u], u += h, d -= 8
              );
              if (0 === s) s = 1 - c;
              else {
                if (s === l) return o ? NaN : (1 / 0) * (p ? -1 : 1);
                (o += Math.pow(2, i)), (s -= c);
              }
              return (p ? -1 : 1) * o * Math.pow(2, s - i);
            }),
            (e.write = function (e, t, r, i, n, s) {
              var o,
                a,
                l,
                c = 8 * s - n - 1,
                d = (1 << c) - 1,
                u = d >> 1,
                h = 5960464477539062e-23 * (23 === n),
                p = i ? 0 : s - 1,
                f = i ? 1 : -1,
                m = +(t < 0 || (0 === t && 1 / t < 0));
              for (
                isNaN((t = Math.abs(t))) || t === 1 / 0
                  ? ((a = +!!isNaN(t)), (o = d))
                  : ((o = Math.floor(Math.log(t) / Math.LN2)),
                    t * (l = Math.pow(2, -o)) < 1 && (o--, (l *= 2)),
                    o + u >= 1 ? (t += h / l) : (t += h * Math.pow(2, 1 - u)),
                    t * l >= 2 && (o++, (l /= 2)),
                    o + u >= d
                      ? ((a = 0), (o = d))
                      : o + u >= 1
                        ? ((a = (t * l - 1) * Math.pow(2, n)), (o += u))
                        : ((a = t * Math.pow(2, u - 1) * Math.pow(2, n)),
                          (o = 0)));
                n >= 8;
                e[r + p] = 255 & a, p += f, a /= 256, n -= 8
              );
              for (
                o = (o << n) | a, c += n;
                c > 0;
                e[r + p] = 255 & o, p += f, o /= 256, c -= 8
              );
              e[r + p - f] |= 128 * m;
            });
        }),
        k = w((e) => {
          A();
          var t = S(),
            r = T(),
            i =
              "function" == typeof Symbol && "function" == typeof Symbol.for
                ? Symbol.for("nodejs.util.inspect.custom")
                : null;
          function n() {
            try {
              let e = new Uint8Array(1),
                t = {
                  foo: y(function () {
                    return 42;
                  }, "foo"),
                };
              return (
                Object.setPrototypeOf(t, Uint8Array.prototype),
                Object.setPrototypeOf(e, t),
                42 === e.foo()
              );
            } catch {
              return !1;
            }
          }
          function s(e) {
            if (e > 0x7fffffff)
              throw RangeError(
                'The value "' + e + '" is invalid for option "size"'
              );
            let t = new Uint8Array(e);
            return Object.setPrototypeOf(t, o.prototype), t;
          }
          function o(e, t, r) {
            if ("number" == typeof e) {
              if ("string" == typeof t)
                throw TypeError(
                  'The "string" argument must be of type string. Received type number'
                );
              return d(e);
            }
            return a(e, t, r);
          }
          function a(e, t, r) {
            if ("string" == typeof e) return u(e, t);
            if (ArrayBuffer.isView(e)) return p(e);
            if (null == e)
              throw TypeError(
                "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " +
                  typeof e
              );
            if (
              eo(e, ArrayBuffer) ||
              (e && eo(e.buffer, ArrayBuffer)) ||
              ("u" > typeof SharedArrayBuffer &&
                (eo(e, SharedArrayBuffer) ||
                  (e && eo(e.buffer, SharedArrayBuffer))))
            )
              return f(e, t, r);
            if ("number" == typeof e)
              throw TypeError(
                'The "value" argument must not be of type number. Received type number'
              );
            let i = e.valueOf && e.valueOf();
            if (null != i && i !== e) return o.from(i, t, r);
            let n = m(e);
            if (n) return n;
            if (
              "u" > typeof Symbol &&
              null != Symbol.toPrimitive &&
              "function" == typeof e[Symbol.toPrimitive]
            )
              return o.from(e[Symbol.toPrimitive]("string"), t, r);
            throw TypeError(
              "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " +
                typeof e
            );
          }
          function l(e) {
            if ("number" != typeof e)
              throw TypeError('"size" argument must be of type number');
            if (e < 0)
              throw RangeError(
                'The value "' + e + '" is invalid for option "size"'
              );
          }
          function c(e, t, r) {
            return (
              l(e),
              e <= 0
                ? s(e)
                : void 0 !== t
                  ? "string" == typeof r
                    ? s(e).fill(t, r)
                    : s(e).fill(t)
                  : s(e)
            );
          }
          function d(e) {
            return l(e), s(e < 0 ? 0 : 0 | g(e));
          }
          function u(e, t) {
            if (
              (("string" != typeof t || "" === t) && (t = "utf8"),
              !o.isEncoding(t))
            )
              throw TypeError("Unknown encoding: " + t);
            let r = 0 | b(e, t),
              i = s(r),
              n = i.write(e, t);
            return n !== r && (i = i.slice(0, n)), i;
          }
          function h(e) {
            let t = e.length < 0 ? 0 : 0 | g(e.length),
              r = s(t);
            for (let i = 0; i < t; i += 1) r[i] = 255 & e[i];
            return r;
          }
          function p(e) {
            if (eo(e, Uint8Array)) {
              let t = new Uint8Array(e);
              return f(t.buffer, t.byteOffset, t.byteLength);
            }
            return h(e);
          }
          function f(e, t, r) {
            let i;
            if (t < 0 || e.byteLength < t)
              throw RangeError('"offset" is outside of buffer bounds');
            if (e.byteLength < t + (r || 0))
              throw RangeError('"length" is outside of buffer bounds');
            return (
              Object.setPrototypeOf(
                (i =
                  void 0 === t && void 0 === r
                    ? new Uint8Array(e)
                    : void 0 === r
                      ? new Uint8Array(e, t)
                      : new Uint8Array(e, t, r)),
                o.prototype
              ),
              i
            );
          }
          function m(e) {
            if (o.isBuffer(e)) {
              let t = 0 | g(e.length),
                r = s(t);
              return 0 === r.length || e.copy(r, 0, 0, t), r;
            }
            return void 0 !== e.length
              ? "number" != typeof e.length || ea(e.length)
                ? s(0)
                : h(e)
              : "Buffer" === e.type && Array.isArray(e.data)
                ? h(e.data)
                : void 0;
          }
          function g(e) {
            if (e >= 0x7fffffff)
              throw RangeError(
                "Attempt to allocate Buffer larger than maximum size: 0x7fffffff bytes"
              );
            return 0 | e;
          }
          function w(e) {
            return +e != e && (e = 0), o.alloc(+e);
          }
          function b(e, t) {
            if (o.isBuffer(e)) return e.length;
            if (ArrayBuffer.isView(e) || eo(e, ArrayBuffer))
              return e.byteLength;
            if ("string" != typeof e)
              throw TypeError(
                'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' +
                  typeof e
              );
            let r = e.length,
              i = arguments.length > 2 && !0 === arguments[2];
            if (!i && 0 === r) return 0;
            let n = !1;
            for (;;)
              switch (t) {
                case "ascii":
                case "latin1":
                case "binary":
                  return r;
                case "utf8":
                case "utf-8":
                  return et(e).length;
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                  return 2 * r;
                case "hex":
                  return r >>> 1;
                case "base64":
                  return en(e).length;
                default:
                  if (n) return i ? -1 : et(e).length;
                  (t = ("" + t).toLowerCase()), (n = !0);
              }
          }
          function v(e, t, r) {
            let i = !1;
            if (
              ((void 0 === t || t < 0) && (t = 0),
              t > this.length ||
                ((void 0 === r || r > this.length) && (r = this.length),
                r <= 0) ||
                (r >>>= 0) <= (t >>>= 0))
            )
              return "";
            for (e || (e = "utf8"); ; )
              switch (e) {
                case "hex":
                  return U(this, t, r);
                case "utf8":
                case "utf-8":
                  return R(this, t, r);
                case "ascii":
                  return D(this, t, r);
                case "latin1":
                case "binary":
                  return q(this, t, r);
                case "base64":
                  return L(this, t, r);
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                  return $(this, t, r);
                default:
                  if (i) throw TypeError("Unknown encoding: " + e);
                  (e = (e + "").toLowerCase()), (i = !0);
              }
          }
          function N(e, t, r) {
            let i = e[t];
            (e[t] = e[r]), (e[r] = i);
          }
          function x(e, t, r, i, n) {
            if (0 === e.length) return -1;
            if (
              ("string" == typeof r
                ? ((i = r), (r = 0))
                : r > 0x7fffffff
                  ? (r = 0x7fffffff)
                  : r < -0x80000000 && (r = -0x80000000),
              ea((r *= 1)) && (r = n ? 0 : e.length - 1),
              r < 0 && (r = e.length + r),
              r >= e.length)
            ) {
              if (n) return -1;
              r = e.length - 1;
            } else if (r < 0)
              if (!n) return -1;
              else r = 0;
            if (("string" == typeof t && (t = o.from(t, i)), o.isBuffer(t)))
              return 0 === t.length ? -1 : _(e, t, r, i, n);
            if ("number" == typeof t)
              return (
                (t &= 255),
                "function" == typeof Uint8Array.prototype.indexOf
                  ? n
                    ? Uint8Array.prototype.indexOf.call(e, t, r)
                    : Uint8Array.prototype.lastIndexOf.call(e, t, r)
                  : _(e, [t], r, i, n)
              );
            throw TypeError("val must be string, number or Buffer");
          }
          function _(e, t, r, i, n) {
            let s,
              o = 1,
              a = e.length,
              l = t.length;
            if (
              void 0 !== i &&
              ("ucs2" === (i = String(i).toLowerCase()) ||
                "ucs-2" === i ||
                "utf16le" === i ||
                "utf-16le" === i)
            ) {
              if (e.length < 2 || t.length < 2) return -1;
              (o = 2), (a /= 2), (l /= 2), (r /= 2);
            }
            function c(e, t) {
              return 1 === o ? e[t] : e.readUInt16BE(t * o);
            }
            if ((y(c, "read"), n)) {
              let i = -1;
              for (s = r; s < a; s++)
                if (c(e, s) === c(t, -1 === i ? 0 : s - i)) {
                  if ((-1 === i && (i = s), s - i + 1 === l)) return i * o;
                } else -1 !== i && (s -= s - i), (i = -1);
            } else
              for (r + l > a && (r = a - l), s = r; s >= 0; s--) {
                let r = !0;
                for (let i = 0; i < l; i++)
                  if (c(e, s + i) !== c(t, i)) {
                    r = !1;
                    break;
                  }
                if (r) return s;
              }
            return -1;
          }
          function k(e, t, r, i) {
            let n;
            r = Number(r) || 0;
            let s = e.length - r;
            i ? (i = Number(i)) > s && (i = s) : (i = s);
            let o = t.length;
            for (i > o / 2 && (i = o / 2), n = 0; n < i; ++n) {
              let i = parseInt(t.substr(2 * n, 2), 16);
              if (ea(i)) break;
              e[r + n] = i;
            }
            return n;
          }
          function E(e, t, r, i) {
            return es(et(t, e.length - r), e, r, i);
          }
          function C(e, t, r, i) {
            return es(er(t), e, r, i);
          }
          function I(e, t, r, i) {
            return es(en(t), e, r, i);
          }
          function O(e, t, r, i) {
            return es(ei(t, e.length - r), e, r, i);
          }
          function L(e, r, i) {
            return 0 === r && i === e.length
              ? t.fromByteArray(e)
              : t.fromByteArray(e.slice(r, i));
          }
          function R(e, t, r) {
            r = Math.min(e.length, r);
            let i = [],
              n = t;
            for (; n < r; ) {
              let t = e[n],
                s = null,
                o = t > 239 ? 4 : t > 223 ? 3 : t > 191 ? 2 : 1;
              if (n + o <= r) {
                let r, i, a, l;
                switch (o) {
                  case 1:
                    t < 128 && (s = t);
                    break;
                  case 2:
                    (192 & (r = e[n + 1])) == 128 &&
                      (l = ((31 & t) << 6) | (63 & r)) > 127 &&
                      (s = l);
                    break;
                  case 3:
                    (r = e[n + 1]),
                      (i = e[n + 2]),
                      (192 & r) == 128 &&
                        (192 & i) == 128 &&
                        (l = ((15 & t) << 12) | ((63 & r) << 6) | (63 & i)) >
                          2047 &&
                        (l < 55296 || l > 57343) &&
                        (s = l);
                    break;
                  case 4:
                    (r = e[n + 1]),
                      (i = e[n + 2]),
                      (a = e[n + 3]),
                      (192 & r) == 128 &&
                        (192 & i) == 128 &&
                        (192 & a) == 128 &&
                        (l =
                          ((15 & t) << 18) |
                          ((63 & r) << 12) |
                          ((63 & i) << 6) |
                          (63 & a)) > 65535 &&
                        l < 1114112 &&
                        (s = l);
                }
              }
              null === s
                ? ((s = 65533), (o = 1))
                : s > 65535 &&
                  ((s -= 65536),
                  i.push(((s >>> 10) & 1023) | 55296),
                  (s = 56320 | (1023 & s))),
                i.push(s),
                (n += o);
            }
            return P(i);
          }
          function P(e) {
            let t = e.length;
            if (t <= 4096) return String.fromCharCode.apply(String, e);
            let r = "",
              i = 0;
            for (; i < t; )
              r += String.fromCharCode.apply(String, e.slice(i, (i += 4096)));
            return r;
          }
          function D(e, t, r) {
            let i = "";
            r = Math.min(e.length, r);
            for (let n = t; n < r; ++n) i += String.fromCharCode(127 & e[n]);
            return i;
          }
          function q(e, t, r) {
            let i = "";
            r = Math.min(e.length, r);
            for (let n = t; n < r; ++n) i += String.fromCharCode(e[n]);
            return i;
          }
          function U(e, t, r) {
            let i = e.length;
            (!t || t < 0) && (t = 0), (!r || r < 0 || r > i) && (r = i);
            let n = "";
            for (let i = t; i < r; ++i) n += el[e[i]];
            return n;
          }
          function $(e, t, r) {
            let i = e.slice(t, r),
              n = "";
            for (let e = 0; e < i.length - 1; e += 2)
              n += String.fromCharCode(i[e] + 256 * i[e + 1]);
            return n;
          }
          function B(e, t, r) {
            if (e % 1 != 0 || e < 0) throw RangeError("offset is not uint");
            if (e + t > r)
              throw RangeError("Trying to access beyond buffer length");
          }
          function M(e, t, r, i, n, s) {
            if (!o.isBuffer(e))
              throw TypeError('"buffer" argument must be a Buffer instance');
            if (t > n || t < s)
              throw RangeError('"value" argument is out of bounds');
            if (r + i > e.length) throw RangeError("Index out of range");
          }
          function j(e, t, r, i, n) {
            J(t, i, n, e, r, 7);
            let s = Number(t & BigInt(0xffffffff));
            (e[r++] = s),
              (s >>= 8),
              (e[r++] = s),
              (s >>= 8),
              (e[r++] = s),
              (s >>= 8),
              (e[r++] = s);
            let o = Number((t >> BigInt(32)) & BigInt(0xffffffff));
            return (
              (e[r++] = o),
              (o >>= 8),
              (e[r++] = o),
              (o >>= 8),
              (e[r++] = o),
              (o >>= 8),
              (e[r++] = o),
              r
            );
          }
          function W(e, t, r, i, n) {
            J(t, i, n, e, r, 7);
            let s = Number(t & BigInt(0xffffffff));
            (e[r + 7] = s),
              (s >>= 8),
              (e[r + 6] = s),
              (s >>= 8),
              (e[r + 5] = s),
              (s >>= 8),
              (e[r + 4] = s);
            let o = Number((t >> BigInt(32)) & BigInt(0xffffffff));
            return (
              (e[r + 3] = o),
              (o >>= 8),
              (e[r + 2] = o),
              (o >>= 8),
              (e[r + 1] = o),
              (o >>= 8),
              (e[r] = o),
              r + 8
            );
          }
          function F(e, t, r, i, n, s) {
            if (r + i > e.length || r < 0)
              throw RangeError("Index out of range");
          }
          function Q(e, t, i, n, s) {
            return (
              (t *= 1),
              (i >>>= 0),
              s || F(e, t, i, 4, 34028234663852886e22, -34028234663852886e22),
              r.write(e, t, i, n, 23, 4),
              i + 4
            );
          }
          function z(e, t, i, n, s) {
            return (
              (t *= 1),
              (i >>>= 0),
              s || F(e, t, i, 8, 17976931348623157e292, -17976931348623157e292),
              r.write(e, t, i, n, 52, 8),
              i + 8
            );
          }
          (e.Buffer = o),
            (e.SlowBuffer = w),
            (e.INSPECT_MAX_BYTES = 50),
            (e.kMaxLength = 0x7fffffff),
            (o.TYPED_ARRAY_SUPPORT = n()),
            !o.TYPED_ARRAY_SUPPORT &&
              "u" > typeof console &&
              "function" == typeof console.error &&
              console.error(
                "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
              ),
            y(n, "typedArraySupport"),
            Object.defineProperty(o.prototype, "parent", {
              enumerable: !0,
              get: y(function () {
                if (o.isBuffer(this)) return this.buffer;
              }, "get"),
            }),
            Object.defineProperty(o.prototype, "offset", {
              enumerable: !0,
              get: y(function () {
                if (o.isBuffer(this)) return this.byteOffset;
              }, "get"),
            }),
            y(s, "createBuffer"),
            y(o, "Buffer"),
            (o.poolSize = 8192),
            y(a, "from"),
            (o.from = function (e, t, r) {
              return a(e, t, r);
            }),
            Object.setPrototypeOf(o.prototype, Uint8Array.prototype),
            Object.setPrototypeOf(o, Uint8Array),
            y(l, "assertSize"),
            y(c, "alloc"),
            (o.alloc = function (e, t, r) {
              return c(e, t, r);
            }),
            y(d, "allocUnsafe"),
            (o.allocUnsafe = function (e) {
              return d(e);
            }),
            (o.allocUnsafeSlow = function (e) {
              return d(e);
            }),
            y(u, "fromString"),
            y(h, "fromArrayLike"),
            y(p, "fromArrayView"),
            y(f, "fromArrayBuffer"),
            y(m, "fromObject"),
            y(g, "checked"),
            y(w, "SlowBuffer"),
            (o.isBuffer = y(function (e) {
              return null != e && !0 === e._isBuffer && e !== o.prototype;
            }, "isBuffer")),
            (o.compare = y(function (e, t) {
              if (
                (eo(e, Uint8Array) && (e = o.from(e, e.offset, e.byteLength)),
                eo(t, Uint8Array) && (t = o.from(t, t.offset, t.byteLength)),
                !o.isBuffer(e) || !o.isBuffer(t))
              )
                throw TypeError(
                  'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
                );
              if (e === t) return 0;
              let r = e.length,
                i = t.length;
              for (let n = 0, s = Math.min(r, i); n < s; ++n)
                if (e[n] !== t[n]) {
                  (r = e[n]), (i = t[n]);
                  break;
                }
              return r < i ? -1 : +(i < r);
            }, "compare")),
            (o.isEncoding = y(function (e) {
              switch (String(e).toLowerCase()) {
                case "hex":
                case "utf8":
                case "utf-8":
                case "ascii":
                case "latin1":
                case "binary":
                case "base64":
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                  return !0;
                default:
                  return !1;
              }
            }, "isEncoding")),
            (o.concat = y(function (e, t) {
              let r;
              if (!Array.isArray(e))
                throw TypeError('"list" argument must be an Array of Buffers');
              if (0 === e.length) return o.alloc(0);
              if (void 0 === t)
                for (t = 0, r = 0; r < e.length; ++r) t += e[r].length;
              let i = o.allocUnsafe(t),
                n = 0;
              for (r = 0; r < e.length; ++r) {
                let t = e[r];
                if (eo(t, Uint8Array))
                  n + t.length > i.length
                    ? (o.isBuffer(t) || (t = o.from(t)), t.copy(i, n))
                    : Uint8Array.prototype.set.call(i, t, n);
                else if (o.isBuffer(t)) t.copy(i, n);
                else
                  throw TypeError(
                    '"list" argument must be an Array of Buffers'
                  );
                n += t.length;
              }
              return i;
            }, "concat")),
            y(b, "byteLength"),
            (o.byteLength = b),
            y(v, "slowToString"),
            (o.prototype._isBuffer = !0),
            y(N, "swap"),
            (o.prototype.swap16 = y(function () {
              let e = this.length;
              if (e % 2 != 0)
                throw RangeError("Buffer size must be a multiple of 16-bits");
              for (let t = 0; t < e; t += 2) N(this, t, t + 1);
              return this;
            }, "swap16")),
            (o.prototype.swap32 = y(function () {
              let e = this.length;
              if (e % 4 != 0)
                throw RangeError("Buffer size must be a multiple of 32-bits");
              for (let t = 0; t < e; t += 4)
                N(this, t, t + 3), N(this, t + 1, t + 2);
              return this;
            }, "swap32")),
            (o.prototype.swap64 = y(function () {
              let e = this.length;
              if (e % 8 != 0)
                throw RangeError("Buffer size must be a multiple of 64-bits");
              for (let t = 0; t < e; t += 8)
                N(this, t, t + 7),
                  N(this, t + 1, t + 6),
                  N(this, t + 2, t + 5),
                  N(this, t + 3, t + 4);
              return this;
            }, "swap64")),
            (o.prototype.toString = y(function () {
              let e = this.length;
              return 0 === e
                ? ""
                : 0 == arguments.length
                  ? R(this, 0, e)
                  : v.apply(this, arguments);
            }, "toString")),
            (o.prototype.toLocaleString = o.prototype.toString),
            (o.prototype.equals = y(function (e) {
              if (!o.isBuffer(e)) throw TypeError("Argument must be a Buffer");
              return this === e || 0 === o.compare(this, e);
            }, "equals")),
            (o.prototype.inspect = y(function () {
              let t = "",
                r = e.INSPECT_MAX_BYTES;
              return (
                (t = this.toString("hex", 0, r)
                  .replace(/(.{2})/g, "$1 ")
                  .trim()),
                this.length > r && (t += " ... "),
                "<Buffer " + t + ">"
              );
            }, "inspect")),
            i && (o.prototype[i] = o.prototype.inspect),
            (o.prototype.compare = y(function (e, t, r, i, n) {
              if (
                (eo(e, Uint8Array) && (e = o.from(e, e.offset, e.byteLength)),
                !o.isBuffer(e))
              )
                throw TypeError(
                  'The "target" argument must be one of type Buffer or Uint8Array. Received type ' +
                    typeof e
                );
              if (
                (void 0 === t && (t = 0),
                void 0 === r && (r = e ? e.length : 0),
                void 0 === i && (i = 0),
                void 0 === n && (n = this.length),
                t < 0 || r > e.length || i < 0 || n > this.length)
              )
                throw RangeError("out of range index");
              if (i >= n && t >= r) return 0;
              if (i >= n) return -1;
              if (t >= r) return 1;
              if (((t >>>= 0), (r >>>= 0), (i >>>= 0), (n >>>= 0), this === e))
                return 0;
              let s = n - i,
                a = r - t,
                l = Math.min(s, a),
                c = this.slice(i, n),
                d = e.slice(t, r);
              for (let e = 0; e < l; ++e)
                if (c[e] !== d[e]) {
                  (s = c[e]), (a = d[e]);
                  break;
                }
              return s < a ? -1 : +(a < s);
            }, "compare")),
            y(x, "bidirectionalIndexOf"),
            y(_, "arrayIndexOf"),
            (o.prototype.includes = y(function (e, t, r) {
              return -1 !== this.indexOf(e, t, r);
            }, "includes")),
            (o.prototype.indexOf = y(function (e, t, r) {
              return x(this, e, t, r, !0);
            }, "indexOf")),
            (o.prototype.lastIndexOf = y(function (e, t, r) {
              return x(this, e, t, r, !1);
            }, "lastIndexOf")),
            y(k, "hexWrite"),
            y(E, "utf8Write"),
            y(C, "asciiWrite"),
            y(I, "base64Write"),
            y(O, "ucs2Write"),
            (o.prototype.write = y(function (e, t, r, i) {
              if (void 0 === t) (i = "utf8"), (r = this.length), (t = 0);
              else if (void 0 === r && "string" == typeof t)
                (i = t), (r = this.length), (t = 0);
              else if (isFinite(t))
                (t >>>= 0),
                  isFinite(r)
                    ? ((r >>>= 0), void 0 === i && (i = "utf8"))
                    : ((i = r), (r = void 0));
              else
                throw Error(
                  "Buffer.write(string, encoding, offset[, length]) is no longer supported"
                );
              let n = this.length - t;
              if (
                ((void 0 === r || r > n) && (r = n),
                (e.length > 0 && (r < 0 || t < 0)) || t > this.length)
              )
                throw RangeError("Attempt to write outside buffer bounds");
              i || (i = "utf8");
              let s = !1;
              for (;;)
                switch (i) {
                  case "hex":
                    return k(this, e, t, r);
                  case "utf8":
                  case "utf-8":
                    return E(this, e, t, r);
                  case "ascii":
                  case "latin1":
                  case "binary":
                    return C(this, e, t, r);
                  case "base64":
                    return I(this, e, t, r);
                  case "ucs2":
                  case "ucs-2":
                  case "utf16le":
                  case "utf-16le":
                    return O(this, e, t, r);
                  default:
                    if (s) throw TypeError("Unknown encoding: " + i);
                    (i = ("" + i).toLowerCase()), (s = !0);
                }
            }, "write")),
            (o.prototype.toJSON = y(function () {
              return {
                type: "Buffer",
                data: Array.prototype.slice.call(this._arr || this, 0),
              };
            }, "toJSON")),
            y(L, "base64Slice"),
            y(R, "utf8Slice"),
            y(P, "decodeCodePointsArray"),
            y(D, "asciiSlice"),
            y(q, "latin1Slice"),
            y(U, "hexSlice"),
            y($, "utf16leSlice"),
            (o.prototype.slice = y(function (e, t) {
              let r = this.length;
              (e = ~~e),
                (t = void 0 === t ? r : ~~t),
                e < 0 ? (e += r) < 0 && (e = 0) : e > r && (e = r),
                t < 0 ? (t += r) < 0 && (t = 0) : t > r && (t = r),
                t < e && (t = e);
              let i = this.subarray(e, t);
              return Object.setPrototypeOf(i, o.prototype), i;
            }, "slice")),
            y(B, "checkOffset"),
            (o.prototype.readUintLE = o.prototype.readUIntLE =
              y(function (e, t, r) {
                (e >>>= 0), (t >>>= 0), r || B(e, t, this.length);
                let i = this[e],
                  n = 1,
                  s = 0;
                for (; ++s < t && (n *= 256); ) i += this[e + s] * n;
                return i;
              }, "readUIntLE")),
            (o.prototype.readUintBE = o.prototype.readUIntBE =
              y(function (e, t, r) {
                (e >>>= 0), (t >>>= 0), r || B(e, t, this.length);
                let i = this[e + --t],
                  n = 1;
                for (; t > 0 && (n *= 256); ) i += this[e + --t] * n;
                return i;
              }, "readUIntBE")),
            (o.prototype.readUint8 = o.prototype.readUInt8 =
              y(function (e, t) {
                return (e >>>= 0), t || B(e, 1, this.length), this[e];
              }, "readUInt8")),
            (o.prototype.readUint16LE = o.prototype.readUInt16LE =
              y(function (e, t) {
                return (
                  (e >>>= 0),
                  t || B(e, 2, this.length),
                  this[e] | (this[e + 1] << 8)
                );
              }, "readUInt16LE")),
            (o.prototype.readUint16BE = o.prototype.readUInt16BE =
              y(function (e, t) {
                return (
                  (e >>>= 0),
                  t || B(e, 2, this.length),
                  (this[e] << 8) | this[e + 1]
                );
              }, "readUInt16BE")),
            (o.prototype.readUint32LE = o.prototype.readUInt32LE =
              y(function (e, t) {
                return (
                  (e >>>= 0),
                  t || B(e, 4, this.length),
                  (this[e] | (this[e + 1] << 8) | (this[e + 2] << 16)) +
                    0x1000000 * this[e + 3]
                );
              }, "readUInt32LE")),
            (o.prototype.readUint32BE = o.prototype.readUInt32BE =
              y(function (e, t) {
                return (
                  (e >>>= 0),
                  t || B(e, 4, this.length),
                  0x1000000 * this[e] +
                    ((this[e + 1] << 16) | (this[e + 2] << 8) | this[e + 3])
                );
              }, "readUInt32BE")),
            (o.prototype.readBigUInt64LE = ec(
              y(function (e) {
                Z((e >>>= 0), "offset");
                let t = this[e],
                  r = this[e + 7];
                (void 0 === t || void 0 === r) && Y(e, this.length - 8);
                let i =
                    t +
                    256 * this[++e] +
                    65536 * this[++e] +
                    0x1000000 * this[++e],
                  n =
                    this[++e] +
                    256 * this[++e] +
                    65536 * this[++e] +
                    0x1000000 * r;
                return BigInt(i) + (BigInt(n) << BigInt(32));
              }, "readBigUInt64LE")
            )),
            (o.prototype.readBigUInt64BE = ec(
              y(function (e) {
                Z((e >>>= 0), "offset");
                let t = this[e],
                  r = this[e + 7];
                (void 0 === t || void 0 === r) && Y(e, this.length - 8);
                let i =
                    0x1000000 * t +
                    65536 * this[++e] +
                    256 * this[++e] +
                    this[++e],
                  n =
                    0x1000000 * this[++e] +
                    65536 * this[++e] +
                    256 * this[++e] +
                    r;
                return (BigInt(i) << BigInt(32)) + BigInt(n);
              }, "readBigUInt64BE")
            )),
            (o.prototype.readIntLE = y(function (e, t, r) {
              (e >>>= 0), (t >>>= 0), r || B(e, t, this.length);
              let i = this[e],
                n = 1,
                s = 0;
              for (; ++s < t && (n *= 256); ) i += this[e + s] * n;
              return i >= (n *= 128) && (i -= Math.pow(2, 8 * t)), i;
            }, "readIntLE")),
            (o.prototype.readIntBE = y(function (e, t, r) {
              (e >>>= 0), (t >>>= 0), r || B(e, t, this.length);
              let i = t,
                n = 1,
                s = this[e + --i];
              for (; i > 0 && (n *= 256); ) s += this[e + --i] * n;
              return s >= (n *= 128) && (s -= Math.pow(2, 8 * t)), s;
            }, "readIntBE")),
            (o.prototype.readInt8 = y(function (e, t) {
              return (
                (e >>>= 0),
                t || B(e, 1, this.length),
                128 & this[e] ? -((255 - this[e] + 1) * 1) : this[e]
              );
            }, "readInt8")),
            (o.prototype.readInt16LE = y(function (e, t) {
              (e >>>= 0), t || B(e, 2, this.length);
              let r = this[e] | (this[e + 1] << 8);
              return 32768 & r ? 0xffff0000 | r : r;
            }, "readInt16LE")),
            (o.prototype.readInt16BE = y(function (e, t) {
              (e >>>= 0), t || B(e, 2, this.length);
              let r = this[e + 1] | (this[e] << 8);
              return 32768 & r ? 0xffff0000 | r : r;
            }, "readInt16BE")),
            (o.prototype.readInt32LE = y(function (e, t) {
              return (
                (e >>>= 0),
                t || B(e, 4, this.length),
                this[e] |
                  (this[e + 1] << 8) |
                  (this[e + 2] << 16) |
                  (this[e + 3] << 24)
              );
            }, "readInt32LE")),
            (o.prototype.readInt32BE = y(function (e, t) {
              return (
                (e >>>= 0),
                t || B(e, 4, this.length),
                (this[e] << 24) |
                  (this[e + 1] << 16) |
                  (this[e + 2] << 8) |
                  this[e + 3]
              );
            }, "readInt32BE")),
            (o.prototype.readBigInt64LE = ec(
              y(function (e) {
                Z((e >>>= 0), "offset");
                let t = this[e],
                  r = this[e + 7];
                return (
                  (void 0 === t || void 0 === r) && Y(e, this.length - 8),
                  (BigInt(
                    this[e + 4] +
                      256 * this[e + 5] +
                      65536 * this[e + 6] +
                      (r << 24)
                  ) <<
                    BigInt(32)) +
                    BigInt(
                      t +
                        256 * this[++e] +
                        65536 * this[++e] +
                        0x1000000 * this[++e]
                    )
                );
              }, "readBigInt64LE")
            )),
            (o.prototype.readBigInt64BE = ec(
              y(function (e) {
                Z((e >>>= 0), "offset");
                let t = this[e],
                  r = this[e + 7];
                return (
                  (void 0 === t || void 0 === r) && Y(e, this.length - 8),
                  (BigInt(
                    (t << 24) + 65536 * this[++e] + 256 * this[++e] + this[++e]
                  ) <<
                    BigInt(32)) +
                    BigInt(
                      0x1000000 * this[++e] +
                        65536 * this[++e] +
                        256 * this[++e] +
                        r
                    )
                );
              }, "readBigInt64BE")
            )),
            (o.prototype.readFloatLE = y(function (e, t) {
              return (
                (e >>>= 0),
                t || B(e, 4, this.length),
                r.read(this, e, !0, 23, 4)
              );
            }, "readFloatLE")),
            (o.prototype.readFloatBE = y(function (e, t) {
              return (
                (e >>>= 0),
                t || B(e, 4, this.length),
                r.read(this, e, !1, 23, 4)
              );
            }, "readFloatBE")),
            (o.prototype.readDoubleLE = y(function (e, t) {
              return (
                (e >>>= 0),
                t || B(e, 8, this.length),
                r.read(this, e, !0, 52, 8)
              );
            }, "readDoubleLE")),
            (o.prototype.readDoubleBE = y(function (e, t) {
              return (
                (e >>>= 0),
                t || B(e, 8, this.length),
                r.read(this, e, !1, 52, 8)
              );
            }, "readDoubleBE")),
            y(M, "checkInt"),
            (o.prototype.writeUintLE = o.prototype.writeUIntLE =
              y(function (e, t, r, i) {
                if (((e *= 1), (t >>>= 0), (r >>>= 0), !i)) {
                  let i = Math.pow(2, 8 * r) - 1;
                  M(this, e, t, r, i, 0);
                }
                let n = 1,
                  s = 0;
                for (this[t] = 255 & e; ++s < r && (n *= 256); )
                  this[t + s] = (e / n) & 255;
                return t + r;
              }, "writeUIntLE")),
            (o.prototype.writeUintBE = o.prototype.writeUIntBE =
              y(function (e, t, r, i) {
                if (((e *= 1), (t >>>= 0), (r >>>= 0), !i)) {
                  let i = Math.pow(2, 8 * r) - 1;
                  M(this, e, t, r, i, 0);
                }
                let n = r - 1,
                  s = 1;
                for (this[t + n] = 255 & e; --n >= 0 && (s *= 256); )
                  this[t + n] = (e / s) & 255;
                return t + r;
              }, "writeUIntBE")),
            (o.prototype.writeUint8 = o.prototype.writeUInt8 =
              y(function (e, t, r) {
                return (
                  (e *= 1),
                  (t >>>= 0),
                  r || M(this, e, t, 1, 255, 0),
                  (this[t] = 255 & e),
                  t + 1
                );
              }, "writeUInt8")),
            (o.prototype.writeUint16LE = o.prototype.writeUInt16LE =
              y(function (e, t, r) {
                return (
                  (e *= 1),
                  (t >>>= 0),
                  r || M(this, e, t, 2, 65535, 0),
                  (this[t] = 255 & e),
                  (this[t + 1] = e >>> 8),
                  t + 2
                );
              }, "writeUInt16LE")),
            (o.prototype.writeUint16BE = o.prototype.writeUInt16BE =
              y(function (e, t, r) {
                return (
                  (e *= 1),
                  (t >>>= 0),
                  r || M(this, e, t, 2, 65535, 0),
                  (this[t] = e >>> 8),
                  (this[t + 1] = 255 & e),
                  t + 2
                );
              }, "writeUInt16BE")),
            (o.prototype.writeUint32LE = o.prototype.writeUInt32LE =
              y(function (e, t, r) {
                return (
                  (e *= 1),
                  (t >>>= 0),
                  r || M(this, e, t, 4, 0xffffffff, 0),
                  (this[t + 3] = e >>> 24),
                  (this[t + 2] = e >>> 16),
                  (this[t + 1] = e >>> 8),
                  (this[t] = 255 & e),
                  t + 4
                );
              }, "writeUInt32LE")),
            (o.prototype.writeUint32BE = o.prototype.writeUInt32BE =
              y(function (e, t, r) {
                return (
                  (e *= 1),
                  (t >>>= 0),
                  r || M(this, e, t, 4, 0xffffffff, 0),
                  (this[t] = e >>> 24),
                  (this[t + 1] = e >>> 16),
                  (this[t + 2] = e >>> 8),
                  (this[t + 3] = 255 & e),
                  t + 4
                );
              }, "writeUInt32BE")),
            y(j, "wrtBigUInt64LE"),
            y(W, "wrtBigUInt64BE"),
            (o.prototype.writeBigUInt64LE = ec(
              y(function (e, t = 0) {
                return j(this, e, t, BigInt(0), BigInt("0xffffffffffffffff"));
              }, "writeBigUInt64LE")
            )),
            (o.prototype.writeBigUInt64BE = ec(
              y(function (e, t = 0) {
                return W(this, e, t, BigInt(0), BigInt("0xffffffffffffffff"));
              }, "writeBigUInt64BE")
            )),
            (o.prototype.writeIntLE = y(function (e, t, r, i) {
              if (((e *= 1), (t >>>= 0), !i)) {
                let i = Math.pow(2, 8 * r - 1);
                M(this, e, t, r, i - 1, -i);
              }
              let n = 0,
                s = 1,
                o = 0;
              for (this[t] = 255 & e; ++n < r && (s *= 256); )
                e < 0 && 0 === o && 0 !== this[t + n - 1] && (o = 1),
                  (this[t + n] = (((e / s) | 0) - o) & 255);
              return t + r;
            }, "writeIntLE")),
            (o.prototype.writeIntBE = y(function (e, t, r, i) {
              if (((e *= 1), (t >>>= 0), !i)) {
                let i = Math.pow(2, 8 * r - 1);
                M(this, e, t, r, i - 1, -i);
              }
              let n = r - 1,
                s = 1,
                o = 0;
              for (this[t + n] = 255 & e; --n >= 0 && (s *= 256); )
                e < 0 && 0 === o && 0 !== this[t + n + 1] && (o = 1),
                  (this[t + n] = (((e / s) | 0) - o) & 255);
              return t + r;
            }, "writeIntBE")),
            (o.prototype.writeInt8 = y(function (e, t, r) {
              return (
                (e *= 1),
                (t >>>= 0),
                r || M(this, e, t, 1, 127, -128),
                e < 0 && (e = 255 + e + 1),
                (this[t] = 255 & e),
                t + 1
              );
            }, "writeInt8")),
            (o.prototype.writeInt16LE = y(function (e, t, r) {
              return (
                (e *= 1),
                (t >>>= 0),
                r || M(this, e, t, 2, 32767, -32768),
                (this[t] = 255 & e),
                (this[t + 1] = e >>> 8),
                t + 2
              );
            }, "writeInt16LE")),
            (o.prototype.writeInt16BE = y(function (e, t, r) {
              return (
                (e *= 1),
                (t >>>= 0),
                r || M(this, e, t, 2, 32767, -32768),
                (this[t] = e >>> 8),
                (this[t + 1] = 255 & e),
                t + 2
              );
            }, "writeInt16BE")),
            (o.prototype.writeInt32LE = y(function (e, t, r) {
              return (
                (e *= 1),
                (t >>>= 0),
                r || M(this, e, t, 4, 0x7fffffff, -0x80000000),
                (this[t] = 255 & e),
                (this[t + 1] = e >>> 8),
                (this[t + 2] = e >>> 16),
                (this[t + 3] = e >>> 24),
                t + 4
              );
            }, "writeInt32LE")),
            (o.prototype.writeInt32BE = y(function (e, t, r) {
              return (
                (e *= 1),
                (t >>>= 0),
                r || M(this, e, t, 4, 0x7fffffff, -0x80000000),
                e < 0 && (e = 0xffffffff + e + 1),
                (this[t] = e >>> 24),
                (this[t + 1] = e >>> 16),
                (this[t + 2] = e >>> 8),
                (this[t + 3] = 255 & e),
                t + 4
              );
            }, "writeInt32BE")),
            (o.prototype.writeBigInt64LE = ec(
              y(function (e, t = 0) {
                return j(
                  this,
                  e,
                  t,
                  -BigInt("0x8000000000000000"),
                  BigInt("0x7fffffffffffffff")
                );
              }, "writeBigInt64LE")
            )),
            (o.prototype.writeBigInt64BE = ec(
              y(function (e, t = 0) {
                return W(
                  this,
                  e,
                  t,
                  -BigInt("0x8000000000000000"),
                  BigInt("0x7fffffffffffffff")
                );
              }, "writeBigInt64BE")
            )),
            y(F, "checkIEEE754"),
            y(Q, "writeFloat"),
            (o.prototype.writeFloatLE = y(function (e, t, r) {
              return Q(this, e, t, !0, r);
            }, "writeFloatLE")),
            (o.prototype.writeFloatBE = y(function (e, t, r) {
              return Q(this, e, t, !1, r);
            }, "writeFloatBE")),
            y(z, "writeDouble"),
            (o.prototype.writeDoubleLE = y(function (e, t, r) {
              return z(this, e, t, !0, r);
            }, "writeDoubleLE")),
            (o.prototype.writeDoubleBE = y(function (e, t, r) {
              return z(this, e, t, !1, r);
            }, "writeDoubleBE")),
            (o.prototype.copy = y(function (e, t, r, i) {
              if (!o.isBuffer(e))
                throw TypeError("argument should be a Buffer");
              if (
                (r || (r = 0),
                i || 0 === i || (i = this.length),
                t >= e.length && (t = e.length),
                t || (t = 0),
                i > 0 && i < r && (i = r),
                i === r || 0 === e.length || 0 === this.length)
              )
                return 0;
              if (t < 0) throw RangeError("targetStart out of bounds");
              if (r < 0 || r >= this.length)
                throw RangeError("Index out of range");
              if (i < 0) throw RangeError("sourceEnd out of bounds");
              i > this.length && (i = this.length),
                e.length - t < i - r && (i = e.length - t + r);
              let n = i - r;
              return (
                this === e &&
                "function" == typeof Uint8Array.prototype.copyWithin
                  ? this.copyWithin(t, r, i)
                  : Uint8Array.prototype.set.call(e, this.subarray(r, i), t),
                n
              );
            }, "copy")),
            (o.prototype.fill = y(function (e, t, r, i) {
              let n;
              if ("string" == typeof e) {
                if (
                  ("string" == typeof t
                    ? ((i = t), (t = 0), (r = this.length))
                    : "string" == typeof r && ((i = r), (r = this.length)),
                  void 0 !== i && "string" != typeof i)
                )
                  throw TypeError("encoding must be a string");
                if ("string" == typeof i && !o.isEncoding(i))
                  throw TypeError("Unknown encoding: " + i);
                if (1 === e.length) {
                  let t = e.charCodeAt(0);
                  (("utf8" === i && t < 128) || "latin1" === i) && (e = t);
                }
              } else
                "number" == typeof e
                  ? (e &= 255)
                  : "boolean" == typeof e && (e = Number(e));
              if (t < 0 || this.length < t || this.length < r)
                throw RangeError("Out of range index");
              if (r <= t) return this;
              if (
                ((t >>>= 0),
                (r = void 0 === r ? this.length : r >>> 0),
                e || (e = 0),
                "number" == typeof e)
              )
                for (n = t; n < r; ++n) this[n] = e;
              else {
                let s = o.isBuffer(e) ? e : o.from(e, i),
                  a = s.length;
                if (0 === a)
                  throw TypeError(
                    'The value "' + e + '" is invalid for argument "value"'
                  );
                for (n = 0; n < r - t; ++n) this[n + t] = s[n % a];
              }
              return this;
            }, "fill"));
          var V = {};
          function K(e, t, r) {
            var i;
            V[e] =
              (y(
                (i = class extends r {
                  constructor() {
                    super(),
                      Object.defineProperty(this, "message", {
                        value: t.apply(this, arguments),
                        writable: !0,
                        configurable: !0,
                      }),
                      (this.name = `${this.name} [${e}]`),
                      this.stack,
                      delete this.name;
                  }
                  get code() {
                    return e;
                  }
                  set code(e) {
                    Object.defineProperty(this, "code", {
                      configurable: !0,
                      enumerable: !0,
                      value: e,
                      writable: !0,
                    });
                  }
                  toString() {
                    return `${this.name} [${e}\
]: ${this.message}`;
                  }
                }),
                "NodeError"
              ),
              i);
          }
          function G(e) {
            let t = "",
              r = e.length,
              i = +("-" === e[0]);
            for (; r >= i + 4; r -= 3)
              t = `\
_${e.slice(r - 3, r)}${t}`;
            return `${e.slice(0, r)}${t}`;
          }
          function H(e, t, r) {
            Z(t, "offset"),
              (void 0 === e[t] || void 0 === e[t + r]) &&
                Y(t, e.length - (r + 1));
          }
          function J(e, t, r, i, n, s) {
            if (e > r || e < t) {
              let i = "bigint" == typeof t ? "n" : "",
                n;
              throw (
                ((n =
                  s > 3
                    ? 0 === t || t === BigInt(0)
                      ? `>= 0${i} and < 2${i}\
 ** ${(s + 1) * 8}${i}`
                      : `>= -(2${i} ** ${(s + 1) * 8 - 1}${i}) and < 2 ** ${(s + 1) * 8 - 1}${i}`
                    : `>= ${t}${i} a\
nd <= ${r}${i}`),
                new V.ERR_OUT_OF_RANGE("value", n, e))
              );
            }
            H(i, n, s);
          }
          function Z(e, t) {
            if ("number" != typeof e)
              throw new V.ERR_INVALID_ARG_TYPE(t, "number", e);
          }
          function Y(e, t, r) {
            throw Math.floor(e) !== e
              ? (Z(e, r),
                new V.ERR_OUT_OF_RANGE(r || "offset", "an integer", e))
              : t < 0
                ? new V.ERR_BUFFER_OUT_OF_BOUNDS()
                : new V.ERR_OUT_OF_RANGE(
                    r || "offset",
                    `>= ${+!!r} and <= ${t}`,
                    e
                  );
          }
          y(K, "E"),
            K(
              "ERR_BUFFER_OUT_OF_BOUNDS",
              function (e) {
                return e
                  ? `${e} is outside of buffer bounds`
                  : "Attempt to access memory outside buffer bounds";
              },
              RangeError
            ),
            K(
              "ERR_INVALID_ARG_TYPE",
              function (e, t) {
                return `The "${e}" argument must be of type number. Received typ\
e ${typeof t}`;
              },
              TypeError
            ),
            K(
              "ERR_OUT_OF_RANGE",
              function (e, t, r) {
                let i = `The value of "${e}" is out o\
f range.`,
                  n = r;
                return (
                  Number.isInteger(r) && Math.abs(r) > 0x100000000
                    ? (n = G(String(r)))
                    : "bigint" == typeof r &&
                      ((n = String(r)),
                      (r > BigInt(2) ** BigInt(32) ||
                        r < -(BigInt(2) ** BigInt(32))) &&
                        (n = G(n)),
                      (n += "n")),
                  (i += ` It must be ${t}. Re\
ceived ${n}`)
                );
              },
              RangeError
            ),
            y(G, "addNumericalSeparator"),
            y(H, "checkBounds"),
            y(J, "checkIntBI"),
            y(Z, "validateNumber"),
            y(Y, "boundsError");
          var X = /[^+/0-9A-Za-z-_]/g;
          function ee(e) {
            if ((e = (e = e.split("=")[0]).trim().replace(X, "")).length < 2)
              return "";
            for (; e.length % 4 != 0; ) e += "=";
            return e;
          }
          function et(e, t) {
            t = t || 1 / 0;
            let r,
              i = e.length,
              n = null,
              s = [];
            for (let o = 0; o < i; ++o) {
              if ((r = e.charCodeAt(o)) > 55295 && r < 57344) {
                if (!n) {
                  if (r > 56319 || o + 1 === i) {
                    (t -= 3) > -1 && s.push(239, 191, 189);
                    continue;
                  }
                  n = r;
                  continue;
                }
                if (r < 56320) {
                  (t -= 3) > -1 && s.push(239, 191, 189), (n = r);
                  continue;
                }
                r = (((n - 55296) << 10) | (r - 56320)) + 65536;
              } else n && (t -= 3) > -1 && s.push(239, 191, 189);
              if (((n = null), r < 128)) {
                if ((t -= 1) < 0) break;
                s.push(r);
              } else if (r < 2048) {
                if ((t -= 2) < 0) break;
                s.push((r >> 6) | 192, (63 & r) | 128);
              } else if (r < 65536) {
                if ((t -= 3) < 0) break;
                s.push((r >> 12) | 224, ((r >> 6) & 63) | 128, (63 & r) | 128);
              } else if (r < 1114112) {
                if ((t -= 4) < 0) break;
                s.push(
                  (r >> 18) | 240,
                  ((r >> 12) & 63) | 128,
                  ((r >> 6) & 63) | 128,
                  (63 & r) | 128
                );
              } else throw Error("Invalid code point");
            }
            return s;
          }
          function er(e) {
            let t = [];
            for (let r = 0; r < e.length; ++r) t.push(255 & e.charCodeAt(r));
            return t;
          }
          function ei(e, t) {
            let r,
              i,
              n = [];
            for (let s = 0; s < e.length && !((t -= 2) < 0); ++s)
              (i = (r = e.charCodeAt(s)) >> 8), n.push(r % 256), n.push(i);
            return n;
          }
          function en(e) {
            return t.toByteArray(ee(e));
          }
          function es(e, t, r, i) {
            let n;
            for (n = 0; n < i && !(n + r >= t.length || n >= e.length); ++n)
              t[n + r] = e[n];
            return n;
          }
          function eo(e, t) {
            return (
              e instanceof t ||
              (null != e &&
                null != e.constructor &&
                null != e.constructor.name &&
                e.constructor.name === t.name)
            );
          }
          function ea(e) {
            return e != e;
          }
          y(ee, "base64clean"),
            y(et, "utf8ToBytes"),
            y(er, "asciiToBytes"),
            y(ei, "utf16leToBytes"),
            y(en, "base64ToBytes"),
            y(es, "blitBuffer"),
            y(eo, "isInstance"),
            y(ea, "numberIsNaN");
          var el = (function () {
            let e = "0123456789abcdef",
              t = Array(256);
            for (let r = 0; r < 16; ++r) {
              let i = 16 * r;
              for (let n = 0; n < 16; ++n) t[i + n] = e[r] + e[n];
            }
            return t;
          })();
          function ec(e) {
            return typeof BigInt > "u" ? ed : e;
          }
          function ed() {
            throw Error("BigInt not supported");
          }
          y(ec, "defineBigIntMethod"), y(ed, "BufferBigIntNotDefined");
        }),
        A = g(() => {
          (s = globalThis),
            (o = globalThis.setImmediate ?? ((e) => setTimeout(e, 0))),
            globalThis.clearImmediate ?? ((e) => clearTimeout(e)),
            (a =
              "function" == typeof globalThis.Buffer &&
              "function" == typeof globalThis.Buffer.allocUnsafe
                ? globalThis.Buffer
                : k().Buffer),
            (l = globalThis.process ?? {}).env ?? (l.env = {});
          try {
            l.nextTick(() => {});
          } catch {
            let e = Promise.resolve();
            l.nextTick = e.then.bind(e);
          }
        }),
        E = w((e, t) => {
          A();
          var r,
            i = "object" == typeof Reflect ? Reflect : null,
            n =
              i && "function" == typeof i.apply
                ? i.apply
                : y(function (e, t, r) {
                    return Function.prototype.apply.call(e, t, r);
                  }, "ReflectApply");
          function s(e) {
            console && console.warn && console.warn(e);
          }
          (r =
            i && "function" == typeof i.ownKeys
              ? i.ownKeys
              : Object.getOwnPropertySymbols
                ? y(function (e) {
                    return Object.getOwnPropertyNames(e).concat(
                      Object.getOwnPropertySymbols(e)
                    );
                  }, "ReflectOwnKeys")
                : y(function (e) {
                    return Object.getOwnPropertyNames(e);
                  }, "ReflectOwnKeys")),
            y(s, "ProcessEmitWarning");
          var o =
            Number.isNaN ||
            y(function (e) {
              return e != e;
            }, "NumberIsNaN");
          function a() {
            a.init.call(this);
          }
          y(a, "EventEmitter"),
            (t.exports = a),
            (t.exports.once = v),
            (a.EventEmitter = a),
            (a.prototype._events = void 0),
            (a.prototype._eventsCount = 0),
            (a.prototype._maxListeners = void 0);
          var l = 10;
          function c(e) {
            if ("function" != typeof e)
              throw TypeError(
                'The "listener" argument must be of type Function. Received type ' +
                  typeof e
              );
          }
          function d(e) {
            return void 0 === e._maxListeners
              ? a.defaultMaxListeners
              : e._maxListeners;
          }
          function u(e, t, r, i) {
            var n, o, a;
            if (
              (c(r),
              void 0 === (o = e._events)
                ? ((o = e._events = Object.create(null)), (e._eventsCount = 0))
                : (void 0 !== o.newListener &&
                    (e.emit("newListener", t, r.listener ? r.listener : r),
                    (o = e._events)),
                  (a = o[t])),
              void 0 === a)
            )
              (a = o[t] = r), ++e._eventsCount;
            else if (
              ("function" == typeof a
                ? (a = o[t] = i ? [r, a] : [a, r])
                : i
                  ? a.unshift(r)
                  : a.push(r),
              (n = d(e)) > 0 && a.length > n && !a.warned)
            ) {
              a.warned = !0;
              var l = Error(
                "Possible EventEmitter memory leak detected. " +
                  a.length +
                  " " +
                  String(t) +
                  " listeners added. Use emitter.setMaxListeners() to increase limit"
              );
              (l.name = "MaxListenersExceededWarning"),
                (l.emitter = e),
                (l.type = t),
                (l.count = a.length),
                s(l);
            }
            return e;
          }
          function h() {
            if (!this.fired)
              return (
                this.target.removeListener(this.type, this.wrapFn),
                (this.fired = !0),
                0 == arguments.length
                  ? this.listener.call(this.target)
                  : this.listener.apply(this.target, arguments)
              );
          }
          function p(e, t, r) {
            var i = {
                fired: !1,
                wrapFn: void 0,
                target: e,
                type: t,
                listener: r,
              },
              n = h.bind(i);
            return (n.listener = r), (i.wrapFn = n), n;
          }
          function f(e, t, r) {
            var i = e._events;
            if (void 0 === i) return [];
            var n = i[t];
            return void 0 === n
              ? []
              : "function" == typeof n
                ? r
                  ? [n.listener || n]
                  : [n]
                : r
                  ? b(n)
                  : g(n, n.length);
          }
          function m(e) {
            var t = this._events;
            if (void 0 !== t) {
              var r = t[e];
              if ("function" == typeof r) return 1;
              if (void 0 !== r) return r.length;
            }
            return 0;
          }
          function g(e, t) {
            for (var r = Array(t), i = 0; i < t; ++i) r[i] = e[i];
            return r;
          }
          function w(e, t) {
            for (; t + 1 < e.length; t++) e[t] = e[t + 1];
            e.pop();
          }
          function b(e) {
            for (var t = Array(e.length), r = 0; r < t.length; ++r)
              t[r] = e[r].listener || e[r];
            return t;
          }
          function v(e, t) {
            return new Promise(function (r, i) {
              function n(r) {
                e.removeListener(t, s), i(r);
              }
              function s() {
                "function" == typeof e.removeListener &&
                  e.removeListener("error", n),
                  r([].slice.call(arguments));
              }
              y(n, "errorListener"),
                y(s, "resolver"),
                x(e, t, s, { once: !0 }),
                "error" !== t && N(e, n, { once: !0 });
            });
          }
          function N(e, t, r) {
            "function" == typeof e.on && x(e, "error", t, r);
          }
          function x(e, t, r, i) {
            if ("function" == typeof e.on) i.once ? e.once(t, r) : e.on(t, r);
            else if ("function" == typeof e.addEventListener)
              e.addEventListener(
                t,
                y(function n(s) {
                  i.once && e.removeEventListener(t, n), r(s);
                }, "wrapListener")
              );
            else
              throw TypeError(
                'The "emitter" argument must be of type EventEmitter. Received type ' +
                  typeof e
              );
          }
          y(c, "checkListener"),
            Object.defineProperty(a, "defaultMaxListeners", {
              enumerable: !0,
              get: y(function () {
                return l;
              }, "get"),
              set: y(function (e) {
                if ("number" != typeof e || e < 0 || o(e))
                  throw RangeError(
                    'The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' +
                      e +
                      "."
                  );
                l = e;
              }, "set"),
            }),
            (a.init = function () {
              (void 0 === this._events ||
                this._events === Object.getPrototypeOf(this)._events) &&
                ((this._events = Object.create(null)), (this._eventsCount = 0)),
                (this._maxListeners = this._maxListeners || void 0);
            }),
            (a.prototype.setMaxListeners = y(function (e) {
              if ("number" != typeof e || e < 0 || o(e))
                throw RangeError(
                  'The value of "n" is out of range. It must be a non-negative number. Received ' +
                    e +
                    "."
                );
              return (this._maxListeners = e), this;
            }, "setMaxListeners")),
            y(d, "_getMaxListeners"),
            (a.prototype.getMaxListeners = y(function () {
              return d(this);
            }, "getMaxListeners")),
            (a.prototype.emit = y(function (e) {
              for (var t = [], r = 1; r < arguments.length; r++)
                t.push(arguments[r]);
              var i = "error" === e,
                s = this._events;
              if (void 0 !== s) i = i && void 0 === s.error;
              else if (!i) return !1;
              if (i) {
                if ((t.length > 0 && (o = t[0]), o instanceof Error)) throw o;
                var o,
                  a = Error(
                    "Unhandled error." + (o ? " (" + o.message + ")" : "")
                  );
                throw ((a.context = o), a);
              }
              var l = s[e];
              if (void 0 === l) return !1;
              if ("function" == typeof l) n(l, this, t);
              else
                for (var c = l.length, d = g(l, c), r = 0; r < c; ++r)
                  n(d[r], this, t);
              return !0;
            }, "emit")),
            y(u, "_addListener"),
            (a.prototype.addListener = y(function (e, t) {
              return u(this, e, t, !1);
            }, "addListener")),
            (a.prototype.on = a.prototype.addListener),
            (a.prototype.prependListener = y(function (e, t) {
              return u(this, e, t, !0);
            }, "prependListener")),
            y(h, "onceWrapper"),
            y(p, "_onceWrap"),
            (a.prototype.once = y(function (e, t) {
              return c(t), this.on(e, p(this, e, t)), this;
            }, "once")),
            (a.prototype.prependOnceListener = y(function (e, t) {
              return c(t), this.prependListener(e, p(this, e, t)), this;
            }, "prependOnceListener")),
            (a.prototype.removeListener = y(function (e, t) {
              var r, i, n, s, o;
              if (
                (c(t), void 0 === (i = this._events) || void 0 === (r = i[e]))
              )
                return this;
              if (r === t || r.listener === t)
                0 == --this._eventsCount
                  ? (this._events = Object.create(null))
                  : (delete i[e],
                    i.removeListener &&
                      this.emit("removeListener", e, r.listener || t));
              else if ("function" != typeof r) {
                for (n = -1, s = r.length - 1; s >= 0; s--)
                  if (r[s] === t || r[s].listener === t) {
                    (o = r[s].listener), (n = s);
                    break;
                  }
                if (n < 0) return this;
                0 === n ? r.shift() : w(r, n),
                  1 === r.length && (i[e] = r[0]),
                  void 0 !== i.removeListener &&
                    this.emit("removeListener", e, o || t);
              }
              return this;
            }, "removeListener")),
            (a.prototype.off = a.prototype.removeListener),
            (a.prototype.removeAllListeners = y(function (e) {
              var t, r, i;
              if (void 0 === (r = this._events)) return this;
              if (void 0 === r.removeListener)
                return (
                  0 == arguments.length
                    ? ((this._events = Object.create(null)),
                      (this._eventsCount = 0))
                    : void 0 !== r[e] &&
                      (0 == --this._eventsCount
                        ? (this._events = Object.create(null))
                        : delete r[e]),
                  this
                );
              if (0 == arguments.length) {
                var n,
                  s = Object.keys(r);
                for (i = 0; i < s.length; ++i)
                  "removeListener" !== (n = s[i]) && this.removeAllListeners(n);
                return (
                  this.removeAllListeners("removeListener"),
                  (this._events = Object.create(null)),
                  (this._eventsCount = 0),
                  this
                );
              }
              if ("function" == typeof (t = r[e])) this.removeListener(e, t);
              else if (void 0 !== t)
                for (i = t.length - 1; i >= 0; i--)
                  this.removeListener(e, t[i]);
              return this;
            }, "removeAllListeners")),
            y(f, "_listeners"),
            (a.prototype.listeners = y(function (e) {
              return f(this, e, !0);
            }, "listeners")),
            (a.prototype.rawListeners = y(function (e) {
              return f(this, e, !1);
            }, "rawListeners")),
            (a.listenerCount = function (e, t) {
              return "function" == typeof e.listenerCount
                ? e.listenerCount(t)
                : m.call(e, t);
            }),
            (a.prototype.listenerCount = m),
            y(m, "listenerCount"),
            (a.prototype.eventNames = y(function () {
              return this._eventsCount > 0 ? r(this._events) : [];
            }, "eventNames")),
            y(g, "arrayClone"),
            y(w, "spliceOne"),
            y(b, "unwrapListeners"),
            y(v, "once"),
            y(N, "addErrorHandlerIfEventEmitter"),
            y(x, "eventTargetAgnosticAddListener");
        }),
        C = {};
      function I(e) {
        return 0;
      }
      b(C, { Socket: () => P, isIP: () => I });
      var O,
        L,
        R,
        P,
        D = g(() => {
          A(),
            (O = N(E(), 1)),
            y(I, "isIP"),
            (L = /^[^.]+\./),
            (R = class e extends O.EventEmitter {
              constructor() {
                super(...arguments),
                  _(this, "opts", {}),
                  _(this, "connecting", !1),
                  _(this, "pending", !0),
                  _(this, "writable", !0),
                  _(this, "encrypted", !1),
                  _(this, "authorized", !1),
                  _(this, "destroyed", !1),
                  _(this, "ws", null),
                  _(this, "writeBuffer"),
                  _(this, "tlsState", 0),
                  _(this, "tlsRead"),
                  _(this, "tlsWrite");
              }
              static get poolQueryViaFetch() {
                return e.opts.poolQueryViaFetch ?? e.defaults.poolQueryViaFetch;
              }
              static set poolQueryViaFetch(t) {
                e.opts.poolQueryViaFetch = t;
              }
              static get fetchEndpoint() {
                return e.opts.fetchEndpoint ?? e.defaults.fetchEndpoint;
              }
              static set fetchEndpoint(t) {
                e.opts.fetchEndpoint = t;
              }
              static get fetchConnectionCache() {
                return !0;
              }
              static set fetchConnectionCache(e) {
                console.warn(
                  "The `fetchConnectionCache` option is deprecated (now always `true`)"
                );
              }
              static get fetchFunction() {
                return e.opts.fetchFunction ?? e.defaults.fetchFunction;
              }
              static set fetchFunction(t) {
                e.opts.fetchFunction = t;
              }
              static get webSocketConstructor() {
                return (
                  e.opts.webSocketConstructor ?? e.defaults.webSocketConstructor
                );
              }
              static set webSocketConstructor(t) {
                e.opts.webSocketConstructor = t;
              }
              get webSocketConstructor() {
                return this.opts.webSocketConstructor ?? e.webSocketConstructor;
              }
              set webSocketConstructor(e) {
                this.opts.webSocketConstructor = e;
              }
              static get wsProxy() {
                return e.opts.wsProxy ?? e.defaults.wsProxy;
              }
              static set wsProxy(t) {
                e.opts.wsProxy = t;
              }
              get wsProxy() {
                return this.opts.wsProxy ?? e.wsProxy;
              }
              set wsProxy(e) {
                this.opts.wsProxy = e;
              }
              static get coalesceWrites() {
                return e.opts.coalesceWrites ?? e.defaults.coalesceWrites;
              }
              static set coalesceWrites(t) {
                e.opts.coalesceWrites = t;
              }
              get coalesceWrites() {
                return this.opts.coalesceWrites ?? e.coalesceWrites;
              }
              set coalesceWrites(e) {
                this.opts.coalesceWrites = e;
              }
              static get useSecureWebSocket() {
                return (
                  e.opts.useSecureWebSocket ?? e.defaults.useSecureWebSocket
                );
              }
              static set useSecureWebSocket(t) {
                e.opts.useSecureWebSocket = t;
              }
              get useSecureWebSocket() {
                return this.opts.useSecureWebSocket ?? e.useSecureWebSocket;
              }
              set useSecureWebSocket(e) {
                this.opts.useSecureWebSocket = e;
              }
              static get forceDisablePgSSL() {
                return e.opts.forceDisablePgSSL ?? e.defaults.forceDisablePgSSL;
              }
              static set forceDisablePgSSL(t) {
                e.opts.forceDisablePgSSL = t;
              }
              get forceDisablePgSSL() {
                return this.opts.forceDisablePgSSL ?? e.forceDisablePgSSL;
              }
              set forceDisablePgSSL(e) {
                this.opts.forceDisablePgSSL = e;
              }
              static get disableSNI() {
                return e.opts.disableSNI ?? e.defaults.disableSNI;
              }
              static set disableSNI(t) {
                e.opts.disableSNI = t;
              }
              get disableSNI() {
                return this.opts.disableSNI ?? e.disableSNI;
              }
              set disableSNI(e) {
                this.opts.disableSNI = e;
              }
              static get disableWarningInBrowsers() {
                return (
                  e.opts.disableWarningInBrowsers ??
                  e.defaults.disableWarningInBrowsers
                );
              }
              static set disableWarningInBrowsers(t) {
                e.opts.disableWarningInBrowsers = t;
              }
              get disableWarningInBrowsers() {
                return (
                  this.opts.disableWarningInBrowsers ??
                  e.disableWarningInBrowsers
                );
              }
              set disableWarningInBrowsers(e) {
                this.opts.disableWarningInBrowsers = e;
              }
              static get pipelineConnect() {
                return e.opts.pipelineConnect ?? e.defaults.pipelineConnect;
              }
              static set pipelineConnect(t) {
                e.opts.pipelineConnect = t;
              }
              get pipelineConnect() {
                return this.opts.pipelineConnect ?? e.pipelineConnect;
              }
              set pipelineConnect(e) {
                this.opts.pipelineConnect = e;
              }
              static get subtls() {
                return e.opts.subtls ?? e.defaults.subtls;
              }
              static set subtls(t) {
                e.opts.subtls = t;
              }
              get subtls() {
                return this.opts.subtls ?? e.subtls;
              }
              set subtls(e) {
                this.opts.subtls = e;
              }
              static get pipelineTLS() {
                return e.opts.pipelineTLS ?? e.defaults.pipelineTLS;
              }
              static set pipelineTLS(t) {
                e.opts.pipelineTLS = t;
              }
              get pipelineTLS() {
                return this.opts.pipelineTLS ?? e.pipelineTLS;
              }
              set pipelineTLS(e) {
                this.opts.pipelineTLS = e;
              }
              static get rootCerts() {
                return e.opts.rootCerts ?? e.defaults.rootCerts;
              }
              static set rootCerts(t) {
                e.opts.rootCerts = t;
              }
              get rootCerts() {
                return this.opts.rootCerts ?? e.rootCerts;
              }
              set rootCerts(e) {
                this.opts.rootCerts = e;
              }
              wsProxyAddrForHost(e, t) {
                let r = this.wsProxy;
                if (void 0 === r)
                  throw Error(
                    "No WebSocket proxy is configured. Please see https://github.com/neondatabase/serverless/blob/main/CONFIG.md#wsproxy-string--host-string-port-number--string--string"
                  );
                return "function" == typeof r
                  ? r(e, t)
                  : `${r}?address=${e}:${t}`;
              }
              setNoDelay() {
                return this;
              }
              setKeepAlive() {
                return this;
              }
              ref() {
                return this;
              }
              unref() {
                return this;
              }
              connect(e, t, r) {
                (this.connecting = !0), r && this.once("connect", r);
                let i = y(() => {
                    (this.connecting = !1),
                      (this.pending = !1),
                      this.emit("connect"),
                      this.emit("ready");
                  }, "handleWebSocketOpen"),
                  n = y((e, t = !1) => {
                    (e.binaryType = "arraybuffer"),
                      e.addEventListener("error", (e) => {
                        this.emit("error", e), this.emit("close");
                      }),
                      e.addEventListener("message", (e) => {
                        if (0 === this.tlsState) {
                          let t = a.from(e.data);
                          this.emit("data", t);
                        }
                      }),
                      e.addEventListener("close", () => {
                        this.emit("close");
                      }),
                      t ? i() : e.addEventListener("open", i);
                  }, "configureWebSocket"),
                  s;
                try {
                  s = this.wsProxyAddrForHost(
                    t,
                    "string" == typeof e ? parseInt(e, 10) : e
                  );
                } catch (e) {
                  this.emit("error", e), this.emit("close");
                  return;
                }
                try {
                  let e = (this.useSecureWebSocket ? "wss:" : "ws:") + "//" + s;
                  if (void 0 !== this.webSocketConstructor)
                    (this.ws = new this.webSocketConstructor(e)), n(this.ws);
                  else
                    try {
                      (this.ws = new WebSocket(e)), n(this.ws);
                    } catch {
                      (this.ws = new __unstable_WebSocket(e)), n(this.ws);
                    }
                } catch (e) {
                  fetch(
                    (this.useSecureWebSocket ? "https:" : "http:") + "//" + s,
                    { headers: { Upgrade: "websocket" } }
                  )
                    .then((t) => {
                      if (((this.ws = t.webSocket), null == this.ws)) throw e;
                      this.ws.accept(), n(this.ws, !0);
                    })
                    .catch((e) => {
                      this.emit(
                        "error",
                        Error(`All attempts to open a WebSocket to connect to the database failed. Please refer \
to https://github.com/neondatabase/serverless/blob/main/CONFIG.md#websocketconstructor-typeof-websoc\
ket--undefined. Details: ${e}`)
                      ),
                        this.emit("close");
                    });
                }
              }
              async startTls(e) {
                if (void 0 === this.subtls)
                  throw Error(
                    "For Postgres SSL connections, you must set `neonConfig.subtls` to the subtls library. See https://github.com/neondatabase/serverless/blob/main/CONFIG.md for more information."
                  );
                this.tlsState = 1;
                let t = await this.subtls.TrustedCert.databaseFromPEM(
                    this.rootCerts
                  ),
                  r = new this.subtls.WebSocketReadQueue(this.ws),
                  i = r.read.bind(r),
                  n = this.rawWrite.bind(this),
                  { read: s, write: o } = await this.subtls.startTls(
                    e,
                    t,
                    i,
                    n,
                    {
                      useSNI: !this.disableSNI,
                      expectPreData: this.pipelineTLS
                        ? new Uint8Array([83])
                        : void 0,
                    }
                  );
                (this.tlsRead = s),
                  (this.tlsWrite = o),
                  (this.tlsState = 2),
                  (this.encrypted = !0),
                  (this.authorized = !0),
                  this.emit("secureConnection", this),
                  this.tlsReadLoop();
              }
              async tlsReadLoop() {
                for (;;) {
                  let e = await this.tlsRead();
                  if (void 0 === e) break;
                  {
                    let t = a.from(e);
                    this.emit("data", t);
                  }
                }
              }
              rawWrite(e) {
                if (!this.coalesceWrites) {
                  this.ws && this.ws.send(e);
                  return;
                }
                if (void 0 === this.writeBuffer)
                  (this.writeBuffer = e),
                    setTimeout(() => {
                      this.ws && this.ws.send(this.writeBuffer),
                        (this.writeBuffer = void 0);
                    }, 0);
                else {
                  let t = new Uint8Array(this.writeBuffer.length + e.length);
                  t.set(this.writeBuffer),
                    t.set(e, this.writeBuffer.length),
                    (this.writeBuffer = t);
                }
              }
              write(e, t = "utf8", r = (e) => {}) {
                return (
                  0 === e.length
                    ? r()
                    : ("string" == typeof e && (e = a.from(e, t)),
                      0 === this.tlsState
                        ? (this.rawWrite(e), r())
                        : 1 === this.tlsState
                          ? this.once("secureConnection", () => {
                              this.write(e, t, r);
                            })
                          : (this.tlsWrite(e), r())),
                  !0
                );
              }
              end(e = a.alloc(0), t = "utf8", r = () => {}) {
                return (
                  this.write(e, t, () => {
                    this.ws.close(), r();
                  }),
                  this
                );
              }
              destroy() {
                return (this.destroyed = !0), this.end();
              }
            }),
            y(R, "Socket"),
            _(R, "defaults", {
              poolQueryViaFetch: !1,
              fetchEndpoint: y((e, t, r) => {
                let i;
                return (
                  "https://" +
                  (r?.jwtAuth
                    ? e.replace(L, "apiauth.")
                    : e.replace(L, "api.")) +
                  "/sql"
                );
              }, "fetchEndpoint"),
              fetchConnectionCache: !0,
              fetchFunction: void 0,
              webSocketConstructor: void 0,
              wsProxy: y((e) => e + "/v2", "wsProxy"),
              useSecureWebSocket: !0,
              forceDisablePgSSL: !0,
              coalesceWrites: !0,
              pipelineConnect: "password",
              subtls: void 0,
              rootCerts: "",
              pipelineTLS: !1,
              disableSNI: !1,
              disableWarningInBrowsers: !1,
            }),
            _(R, "opts", {}),
            (P = R);
        }),
        q = {};
      function U(e, t = !1) {
        let { protocol: r } = new URL(e),
          {
            username: i,
            password: n,
            host: s,
            hostname: o,
            port: a,
            pathname: l,
            search: c,
            searchParams: d,
            hash: u,
          } = new URL("http:" + e.substring(r.length));
        (n = decodeURIComponent(n)),
          (i = decodeURIComponent(i)),
          (l = decodeURIComponent(l));
        let h = i + ":" + n,
          p = t ? Object.fromEntries(d.entries()) : c;
        return {
          href: e,
          protocol: r,
          auth: h,
          username: i,
          password: n,
          host: s,
          hostname: o,
          port: a,
          pathname: l,
          search: c,
          query: p,
          hash: u,
        };
      }
      b(q, { parse: () => U });
      var $ = g(() => {
          A(), y(U, "parse");
        }),
        B = w((e) => {
          A(),
            (e.parse = function (e, t) {
              return new r(e, t).parse();
            });
          var t = class e {
            constructor(e, t) {
              (this.source = e),
                (this.transform = t || i),
                (this.position = 0),
                (this.entries = []),
                (this.recorded = []),
                (this.dimension = 0);
            }
            isEof() {
              return this.position >= this.source.length;
            }
            nextCharacter() {
              var e = this.source[this.position++];
              return "\\" === e
                ? { value: this.source[this.position++], escaped: !0 }
                : { value: e, escaped: !1 };
            }
            record(e) {
              this.recorded.push(e);
            }
            newEntry(e) {
              var t;
              (this.recorded.length > 0 || e) &&
                ("NULL" !== (t = this.recorded.join("")) || e || (t = null),
                null !== t && (t = this.transform(t)),
                this.entries.push(t),
                (this.recorded = []));
            }
            consumeDimensions() {
              if ("[" === this.source[0])
                for (; !this.isEof() && "=" !== this.nextCharacter().value; );
            }
            parse(t) {
              var r, i, n;
              for (this.consumeDimensions(); !this.isEof(); )
                if ("{" !== (r = this.nextCharacter()).value || n) {
                  if ("}" !== r.value || n)
                    '"' !== r.value || r.escaped
                      ? "," !== r.value || n
                        ? this.record(r.value)
                        : this.newEntry()
                      : (n && this.newEntry(!0), (n = !n));
                  else if (
                    (this.dimension--, !this.dimension && (this.newEntry(), t))
                  )
                    return this.entries;
                } else
                  this.dimension++,
                    this.dimension > 1 &&
                      ((i = new e(
                        this.source.substr(this.position - 1),
                        this.transform
                      )),
                      this.entries.push(i.parse(!0)),
                      (this.position += i.position - 2));
              if (0 !== this.dimension)
                throw Error("array dimension not balanced");
              return this.entries;
            }
          };
          y(t, "ArrayParser");
          var r = t;
          function i(e) {
            return e;
          }
          y(i, "identity");
        }),
        M = w((e, t) => {
          A();
          var r = B();
          t.exports = {
            create: y(function (e, t) {
              return {
                parse: y(function () {
                  return r.parse(e, t);
                }, "parse"),
              };
            }, "create"),
          };
        }),
        j = w((e, t) => {
          A();
          var r =
              /(\d{1,})-(\d{2})-(\d{2}) (\d{2}):(\d{2}):(\d{2})(\.\d{1,})?.*?( BC)?$/,
            i = /^(\d{1,})-(\d{2})-(\d{2})( BC)?$/,
            n = /([Z+-])(\d{2})?:?(\d{2})?:?(\d{2})?/,
            s = /^-?infinity$/;
          function o(e) {
            var t = i.exec(e);
            if (t) {
              var r = parseInt(t[1], 10);
              t[4] && (r = l(r));
              var n = new Date(r, parseInt(t[2], 10) - 1, t[3]);
              return c(r) && n.setFullYear(r), n;
            }
          }
          function a(e) {
            if (e.endsWith("+00")) return 0;
            var t = n.exec(e.split(" ")[1]);
            if (t) {
              var r = t[1];
              return "Z" === r
                ? 0
                : (3600 * parseInt(t[2], 10) +
                    60 * parseInt(t[3] || 0, 10) +
                    parseInt(t[4] || 0, 10)) *
                    ("-" === r ? -1 : 1) *
                    1e3;
            }
          }
          function l(e) {
            return -(e - 1);
          }
          function c(e) {
            return e >= 0 && e < 100;
          }
          (t.exports = y(function (e) {
            if (s.test(e)) return Number(e.replace("i", "I"));
            var t = r.exec(e);
            if (!t) return o(e) || null;
            var i = !!t[8],
              n = parseInt(t[1], 10);
            i && (n = l(n));
            var d = parseInt(t[2], 10) - 1,
              u = t[3],
              h = parseInt(t[4], 10),
              p = parseInt(t[5], 10),
              f = parseInt(t[6], 10),
              m = t[7];
            m = m ? 1e3 * parseFloat(m) : 0;
            var y,
              g = a(e);
            return (
              null != g
                ? ((y = new Date(Date.UTC(n, d, u, h, p, f, m))),
                  c(n) && y.setUTCFullYear(n),
                  0 !== g && y.setTime(y.getTime() - g))
                : ((y = new Date(n, d, u, h, p, f, m)),
                  c(n) && y.setFullYear(n)),
              y
            );
          }, "parseDate")),
            y(o, "getDate"),
            y(a, "timeZoneOffset"),
            y(l, "bcYearToNegativeYear"),
            y(c, "is0To99");
        }),
        W = w((e, t) => {
          A(), (t.exports = i);
          var r = Object.prototype.hasOwnProperty;
          function i(e) {
            for (var t = 1; t < arguments.length; t++) {
              var i = arguments[t];
              for (var n in i) r.call(i, n) && (e[n] = i[n]);
            }
            return e;
          }
          y(i, "extend");
        }),
        F = w((e, t) => {
          A();
          var r = W();
          function i(e) {
            if (!(this instanceof i)) return new i(e);
            r(this, p(e));
          }
          (t.exports = i), y(i, "PostgresInterval");
          var n = ["seconds", "minutes", "hours", "days", "months", "years"];
          i.prototype.toPostgres = function () {
            var e = n.filter(this.hasOwnProperty, this);
            return (
              this.milliseconds &&
                0 > e.indexOf("seconds") &&
                e.push("seconds"),
              0 === e.length
                ? "0"
                : e
                    .map(function (e) {
                      var t = this[e] || 0;
                      return (
                        "seconds" === e &&
                          this.milliseconds &&
                          (t = (t + this.milliseconds / 1e3)
                            .toFixed(6)
                            .replace(/\.?0+$/, "")),
                        t + " " + e
                      );
                    }, this)
                    .join(" ")
            );
          };
          var s = {
              years: "Y",
              months: "M",
              days: "D",
              hours: "H",
              minutes: "M",
              seconds: "S",
            },
            o = ["years", "months", "days"],
            a = ["hours", "minutes", "seconds"];
          i.prototype.toISOString = i.prototype.toISO = function () {
            return (
              "P" + o.map(e, this).join("") + "T" + a.map(e, this).join("")
            );
            function e(e) {
              var t = this[e] || 0;
              return (
                "seconds" === e &&
                  this.milliseconds &&
                  (t = (t + this.milliseconds / 1e3)
                    .toFixed(6)
                    .replace(/0+$/, "")),
                t + s[e]
              );
            }
          };
          var l = "([+-]?\\d+)",
            c = new RegExp(
              [
                l + "\\s+years?",
                l + "\\s+mons?",
                l + "\\s+days?",
                "([+-])?([\\d]*):(\\d\\d):(\\d\\d)\\.?(\\d{1,6})?",
              ]
                .map(function (e) {
                  return "(" + e + ")?";
                })
                .join("\\s*")
            ),
            d = {
              years: 2,
              months: 4,
              days: 6,
              hours: 9,
              minutes: 10,
              seconds: 11,
              milliseconds: 12,
            },
            u = ["hours", "minutes", "seconds", "milliseconds"];
          function h(e) {
            return parseInt(e + "000000".slice(e.length), 10) / 1e3;
          }
          function p(e) {
            if (!e) return {};
            var t = c.exec(e),
              r = "-" === t[8];
            return Object.keys(d).reduce(function (e, i) {
              var n = t[d[i]];
              return (
                n &&
                  (n = "milliseconds" === i ? h(n) : parseInt(n, 10)) &&
                  (r && ~u.indexOf(i) && (n *= -1), (e[i] = n)),
                e
              );
            }, {});
          }
          y(h, "parseMilliseconds"), y(p, "parse");
        }),
        Q = w((e, t) => {
          A(),
            (t.exports = y(function (e) {
              if (/^\\x/.test(e)) return new a(e.substr(2), "hex");
              for (var t = "", r = 0; r < e.length; )
                if ("\\" !== e[r]) (t += e[r]), ++r;
                else if (/[0-7]{3}/.test(e.substr(r + 1, 3)))
                  (t += String.fromCharCode(parseInt(e.substr(r + 1, 3), 8))),
                    (r += 4);
                else {
                  for (var i = 1; r + i < e.length && "\\" === e[r + i]; ) i++;
                  for (var n = 0; n < Math.floor(i / 2); ++n) t += "\\";
                  r += 2 * Math.floor(i / 2);
                }
              return new a(t, "binary");
            }, "parseBytea"));
        }),
        z = w((e, t) => {
          A();
          var r = B(),
            i = M(),
            n = j(),
            s = F(),
            o = Q();
          function a(e) {
            return y(function (t) {
              return null === t ? t : e(t);
            }, "nullAllowed");
          }
          function l(e) {
            return null === e
              ? e
              : "TRUE" === e ||
                  "t" === e ||
                  "true" === e ||
                  "y" === e ||
                  "yes" === e ||
                  "on" === e ||
                  "1" === e;
          }
          function c(e) {
            return e ? r.parse(e, l) : null;
          }
          function d(e) {
            return parseInt(e, 10);
          }
          function u(e) {
            return e ? r.parse(e, a(d)) : null;
          }
          function h(e) {
            return e
              ? r.parse(
                  e,
                  a(function (e) {
                    return N(e).trim();
                  })
                )
              : null;
          }
          y(a, "allowNull"),
            y(l, "parseBool"),
            y(c, "parseBoolArray"),
            y(d, "parseBaseTenInt"),
            y(u, "parseIntegerArray"),
            y(h, "parseBigIntegerArray");
          var p = y(function (e) {
              return e
                ? i
                    .create(e, function (e) {
                      return null !== e && (e = _(e)), e;
                    })
                    .parse()
                : null;
            }, "parsePointArray"),
            f = y(function (e) {
              return e
                ? i
                    .create(e, function (e) {
                      return null !== e && (e = parseFloat(e)), e;
                    })
                    .parse()
                : null;
            }, "parseFloatArray"),
            m = y(function (e) {
              return e ? i.create(e).parse() : null;
            }, "parseStringArray"),
            g = y(function (e) {
              return e
                ? i
                    .create(e, function (e) {
                      return null !== e && (e = n(e)), e;
                    })
                    .parse()
                : null;
            }, "parseDateArray"),
            w = y(function (e) {
              return e
                ? i
                    .create(e, function (e) {
                      return null !== e && (e = s(e)), e;
                    })
                    .parse()
                : null;
            }, "parseIntervalArray"),
            b = y(function (e) {
              return e ? r.parse(e, a(o)) : null;
            }, "parseByteAArray"),
            v = y(function (e) {
              return parseInt(e, 10);
            }, "parseInteger"),
            N = y(function (e) {
              var t = String(e);
              return /^\d+$/.test(t) ? t : e;
            }, "parseBigInteger"),
            x = y(function (e) {
              return e ? r.parse(e, a(JSON.parse)) : null;
            }, "parseJsonArray"),
            _ = y(function (e) {
              return "(" !== e[0]
                ? null
                : {
                    x: parseFloat(
                      (e = e.substring(1, e.length - 1).split(","))[0]
                    ),
                    y: parseFloat(e[1]),
                  };
            }, "parsePoint"),
            S = y(function (e) {
              if ("<" !== e[0] && "(" !== e[1]) return null;
              for (var t = "(", r = "", i = !1, n = 2; n < e.length - 1; n++) {
                if ((i || (t += e[n]), ")" === e[n])) {
                  i = !0;
                  continue;
                }
                i && "," !== e[n] && (r += e[n]);
              }
              var s = _(t);
              return (s.radius = parseFloat(r)), s;
            }, "parseCircle");
          t.exports = {
            init: y(function (e) {
              e(20, N),
                e(21, v),
                e(23, v),
                e(26, v),
                e(700, parseFloat),
                e(701, parseFloat),
                e(16, l),
                e(1082, n),
                e(1114, n),
                e(1184, n),
                e(600, _),
                e(651, m),
                e(718, S),
                e(1e3, c),
                e(1001, b),
                e(1005, u),
                e(1007, u),
                e(1028, u),
                e(1016, h),
                e(1017, p),
                e(1021, f),
                e(1022, f),
                e(1231, f),
                e(1014, m),
                e(1015, m),
                e(1008, m),
                e(1009, m),
                e(1040, m),
                e(1041, m),
                e(1115, g),
                e(1182, g),
                e(1185, g),
                e(1186, s),
                e(1187, w),
                e(17, o),
                e(114, JSON.parse.bind(JSON)),
                e(3802, JSON.parse.bind(JSON)),
                e(199, x),
                e(3807, x),
                e(3907, m),
                e(2951, m),
                e(791, m),
                e(1183, m),
                e(1270, m);
            }, "init"),
          };
        }),
        V = w((e, t) => {
          function r(e) {
            var t = e.readInt32BE(0),
              r = e.readUInt32BE(4),
              i = "";
            t < 0 && ((t = ~t + (0 === r)), (r = (~r + 1) >>> 0), (i = "-"));
            var n,
              s,
              o,
              a,
              l,
              c,
              d = "";
            if (
              ((n = t % 1e6),
              (t = (t / 1e6) >>> 0),
              (r = ((s = 0x100000000 * n + r) / 1e6) >>> 0),
              (o = "" + (s - 1e6 * r)),
              0 === r && 0 === t)
            )
              return i + o + d;
            for (a = "", l = 6 - o.length, c = 0; c < l; c++) a += "0";
            if (
              ((d = a + o + d),
              (n = t % 1e6),
              (t = (t / 1e6) >>> 0),
              (r = ((s = 0x100000000 * n + r) / 1e6) >>> 0),
              (o = "" + (s - 1e6 * r)),
              0 === r && 0 === t)
            )
              return i + o + d;
            for (a = "", l = 6 - o.length, c = 0; c < l; c++) a += "0";
            if (
              ((d = a + o + d),
              (n = t % 1e6),
              (t = (t / 1e6) >>> 0),
              (r = ((s = 0x100000000 * n + r) / 1e6) >>> 0),
              (o = "" + (s - 1e6 * r)),
              0 === r && 0 === t)
            )
              return i + o + d;
            for (a = "", l = 6 - o.length, c = 0; c < l; c++) a += "0";
            return (
              (d = a + o + d),
              i + (o = "" + ((s = 0x100000000 * (n = t % 1e6) + r) % 1e6)) + d
            );
          }
          A(), y(r, "readInt8"), (t.exports = r);
        }),
        K = w((e, t) => {
          A();
          var r = V(),
            i = y(function (e, t, r, i, n) {
              (r = r || 0),
                (i = i || !1),
                (n =
                  n ||
                  function (e, t, r) {
                    return e * Math.pow(2, r) + t;
                  });
              var s = r >> 3,
                o = y(function (e) {
                  return i ? 255 & ~e : e;
                }, "inv"),
                a = 255,
                l = 8 - (r % 8);
              t < l && ((a = (255 << (8 - t)) & 255), (l = t)),
                r && (a >>= r % 8);
              var c = 0;
              (r % 8) + t >= 8 && (c = n(0, o(e[s]) & a, l));
              for (var d = (t + r) >> 3, u = s + 1; u < d; u++)
                c = n(c, o(e[u]), 8);
              var h = (t + r) % 8;
              return h > 0 && (c = n(c, o(e[d]) >> (8 - h), h)), c;
            }, "parseBits"),
            n = y(function (e, t, r) {
              var n = Math.pow(2, r - 1) - 1,
                s = i(e, 1),
                o = i(e, r, 1);
              if (0 === o) return 0;
              var a = 1,
                l = i(
                  e,
                  t,
                  r + 1,
                  !1,
                  y(function (e, t, r) {
                    0 === e && (e = 1);
                    for (var i = 1; i <= r; i++)
                      (a /= 2), (t & (1 << (r - i))) > 0 && (e += a);
                    return e;
                  }, "parsePrecisionBits")
                );
              return o == Math.pow(2, r + 1) - 1
                ? 0 === l
                  ? 0 === s
                    ? 1 / 0
                    : -1 / 0
                  : NaN
                : (0 === s ? 1 : -1) * Math.pow(2, o - n) * l;
            }, "parseFloatFromBits"),
            s = y(function (e) {
              return 1 == i(e, 1) ? -1 * (i(e, 15, 1, !0) + 1) : i(e, 15, 1);
            }, "parseInt16"),
            o = y(function (e) {
              return 1 == i(e, 1) ? -1 * (i(e, 31, 1, !0) + 1) : i(e, 31, 1);
            }, "parseInt32"),
            a = y(function (e) {
              return n(e, 23, 8);
            }, "parseFloat32"),
            l = y(function (e) {
              return n(e, 52, 11);
            }, "parseFloat64"),
            c = y(function (e) {
              var t = i(e, 16, 32);
              if (49152 == t) return NaN;
              for (
                var r = Math.pow(1e4, i(e, 16, 16)), n = 0, s = i(e, 16), o = 0;
                o < s;
                o++
              )
                (n += i(e, 16, 64 + 16 * o) * r), (r /= 1e4);
              var a = Math.pow(10, i(e, 16, 48));
              return ((0 === t ? 1 : -1) * Math.round(n * a)) / a;
            }, "parseNumeric"),
            d = y(function (e, t) {
              var r = i(t, 1),
                n = i(t, 63, 1),
                s = new Date(((0 === r ? 1 : -1) * n) / 1e3 + 9466848e5);
              return (
                e || s.setTime(s.getTime() + 6e4 * s.getTimezoneOffset()),
                (s.usec = n % 1e3),
                (s.getMicroSeconds = function () {
                  return this.usec;
                }),
                (s.setMicroSeconds = function (e) {
                  this.usec = e;
                }),
                (s.getUTCMicroSeconds = function () {
                  return this.usec;
                }),
                s
              );
            }, "parseDate"),
            u = y(function (e) {
              for (
                var t = i(e, 32),
                  r = (i(e, 32, 32), i(e, 32, 64)),
                  n = 96,
                  s = [],
                  o = 0;
                o < t;
                o++
              )
                (s[o] = i(e, 32, n)), (n += 64);
              var a = y(function (t) {
                  var r,
                    s = i(e, 32, n);
                  return ((n += 32), 0xffffffff == s)
                    ? null
                    : 23 == t || 20 == t
                      ? ((r = i(e, 8 * s, n)), (n += 8 * s), r)
                      : 25 == t
                        ? e.toString(this.encoding, n >> 3, (n += s << 3) >> 3)
                        : void console.log(
                            "ERROR: ElementType not implemented: " + t
                          );
                }, "parseElement"),
                l = y(function (e, t) {
                  var r,
                    i = [];
                  if (e.length > 1) {
                    var n = e.shift();
                    for (r = 0; r < n; r++) i[r] = l(e, t);
                    e.unshift(n);
                  } else for (r = 0; r < e[0]; r++) i[r] = a(t);
                  return i;
                }, "parse");
              return l(s, r);
            }, "parseArray"),
            h = y(function (e) {
              return e.toString("utf8");
            }, "parseText"),
            p = y(function (e) {
              return null === e ? null : i(e, 8) > 0;
            }, "parseBool");
          t.exports = {
            init: y(function (e) {
              e(20, r),
                e(21, s),
                e(23, o),
                e(26, o),
                e(1700, c),
                e(700, a),
                e(701, l),
                e(16, p),
                e(1114, d.bind(null, !1)),
                e(1184, d.bind(null, !0)),
                e(1e3, u),
                e(1007, u),
                e(1016, u),
                e(1008, u),
                e(1009, u),
                e(25, h);
            }, "init"),
          };
        }),
        G = w((e, t) => {
          A(),
            (t.exports = {
              BOOL: 16,
              BYTEA: 17,
              CHAR: 18,
              INT8: 20,
              INT2: 21,
              INT4: 23,
              REGPROC: 24,
              TEXT: 25,
              OID: 26,
              TID: 27,
              XID: 28,
              CID: 29,
              JSON: 114,
              XML: 142,
              PG_NODE_TREE: 194,
              SMGR: 210,
              PATH: 602,
              POLYGON: 604,
              CIDR: 650,
              FLOAT4: 700,
              FLOAT8: 701,
              ABSTIME: 702,
              RELTIME: 703,
              TINTERVAL: 704,
              CIRCLE: 718,
              MACADDR8: 774,
              MONEY: 790,
              MACADDR: 829,
              INET: 869,
              ACLITEM: 1033,
              BPCHAR: 1042,
              VARCHAR: 1043,
              DATE: 1082,
              TIME: 1083,
              TIMESTAMP: 1114,
              TIMESTAMPTZ: 1184,
              INTERVAL: 1186,
              TIMETZ: 1266,
              BIT: 1560,
              VARBIT: 1562,
              NUMERIC: 1700,
              REFCURSOR: 1790,
              REGPROCEDURE: 2202,
              REGOPER: 2203,
              REGOPERATOR: 2204,
              REGCLASS: 2205,
              REGTYPE: 2206,
              UUID: 2950,
              TXID_SNAPSHOT: 2970,
              PG_LSN: 3220,
              PG_NDISTINCT: 3361,
              PG_DEPENDENCIES: 3402,
              TSVECTOR: 3614,
              TSQUERY: 3615,
              GTSVECTOR: 3642,
              REGCONFIG: 3734,
              REGDICTIONARY: 3769,
              JSONB: 3802,
              REGNAMESPACE: 4089,
              REGROLE: 4096,
            });
        }),
        H = w((e) => {
          A();
          var t = z(),
            r = K(),
            i = M(),
            n = G();
          (e.getTypeParser = a),
            (e.setTypeParser = l),
            (e.arrayParser = i),
            (e.builtins = n);
          var s = { text: {}, binary: {} };
          function o(e) {
            return String(e);
          }
          function a(e, t) {
            return (s[(t = t || "text")] && s[t][e]) || o;
          }
          function l(e, t, r) {
            "function" == typeof t && ((r = t), (t = "text")), (s[t][e] = r);
          }
          y(o, "noParse"),
            y(a, "getTypeParser"),
            y(l, "setTypeParser"),
            t.init(function (e, t) {
              s.text[e] = t;
            }),
            r.init(function (e, t) {
              s.binary[e] = t;
            });
        }),
        J = w((e, t) => {
          A();
          var r = H();
          function i(e) {
            (this._types = e || r), (this.text = {}), (this.binary = {});
          }
          y(i, "TypeOverrides"),
            (i.prototype.getOverrides = function (e) {
              switch (e) {
                case "text":
                  return this.text;
                case "binary":
                  return this.binary;
                default:
                  return {};
              }
            }),
            (i.prototype.setTypeParser = function (e, t, r) {
              "function" == typeof t && ((r = t), (t = "text")),
                (this.getOverrides(t)[e] = r);
            }),
            (i.prototype.getTypeParser = function (e, t) {
              return (
                (t = t || "text"),
                this.getOverrides(t)[e] || this._types.getTypeParser(e, t)
              );
            }),
            (t.exports = i);
        });
      function Z(e) {
        let t = 0x6a09e667,
          r = 0xbb67ae85,
          i = 0x3c6ef372,
          n = 0xa54ff53a,
          s = 0x510e527f,
          o = 0x9b05688c,
          a = 0x1f83d9ab,
          l = 0x5be0cd19,
          c = 0,
          d = 0,
          u = [
            0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b,
            0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01,
            0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7,
            0xc19bf174, 0xe49b69c1, 0xefbe4786, 0xfc19dc6, 0x240ca1cc,
            0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152,
            0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147,
            0x6ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc,
            0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
            0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819,
            0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08,
            0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f,
            0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
            0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2,
          ],
          h = y((e, t) => (e >>> t) | (e << (32 - t)), "rrot"),
          p = new Uint32Array(64),
          f = new Uint8Array(64),
          m = y(() => {
            for (let e = 0, t = 0; e < 16; e++, t += 4)
              p[e] =
                (f[t] << 24) | (f[t + 1] << 16) | (f[t + 2] << 8) | f[t + 3];
            for (let e = 16; e < 64; e++) {
              let t = h(p[e - 15], 7) ^ h(p[e - 15], 18) ^ (p[e - 15] >>> 3),
                r = h(p[e - 2], 17) ^ h(p[e - 2], 19) ^ (p[e - 2] >>> 10);
              p[e] = (p[e - 16] + t + p[e - 7] + r) | 0;
            }
            let e = t,
              c = r,
              m = i,
              y = n,
              g = s,
              w = o,
              b = a,
              v = l;
            for (let t = 0; t < 64; t++) {
              let r =
                  (v +
                    (h(g, 6) ^ h(g, 11) ^ h(g, 25)) +
                    ((g & w) ^ (~g & b)) +
                    u[t] +
                    p[t]) |
                  0,
                i =
                  ((h(e, 2) ^ h(e, 13) ^ h(e, 22)) +
                    ((e & c) ^ (e & m) ^ (c & m))) |
                  0;
              (v = b),
                (b = w),
                (w = g),
                (g = (y + r) | 0),
                (y = m),
                (m = c),
                (c = e),
                (e = (r + i) | 0);
            }
            (t = (t + e) | 0),
              (r = (r + c) | 0),
              (i = (i + m) | 0),
              (n = (n + y) | 0),
              (s = (s + g) | 0),
              (o = (o + w) | 0),
              (a = (a + b) | 0),
              (l = (l + v) | 0),
              (d = 0);
          }, "process"),
          g = y((e) => {
            "string" == typeof e && (e = new TextEncoder().encode(e));
            for (let t = 0; t < e.length; t++) (f[d++] = e[t]), 64 === d && m();
            c += e.length;
          }, "add"),
          w = y(() => {
            if (((f[d++] = 128), 64 == d && m(), d + 8 > 64)) {
              for (; d < 64; ) f[d++] = 0;
              m();
            }
            for (; d < 58; ) f[d++] = 0;
            let e = 8 * c;
            (f[d++] = (e / 0x10000000000) & 255),
              (f[d++] = (e / 0x100000000) & 255),
              (f[d++] = e >>> 24),
              (f[d++] = (e >>> 16) & 255),
              (f[d++] = (e >>> 8) & 255),
              (f[d++] = 255 & e),
              m();
            let u = new Uint8Array(32);
            return (
              (u[0] = t >>> 24),
              (u[1] = (t >>> 16) & 255),
              (u[2] = (t >>> 8) & 255),
              (u[3] = 255 & t),
              (u[4] = r >>> 24),
              (u[5] = (r >>> 16) & 255),
              (u[6] = (r >>> 8) & 255),
              (u[7] = 255 & r),
              (u[8] = i >>> 24),
              (u[9] = (i >>> 16) & 255),
              (u[10] = (i >>> 8) & 255),
              (u[11] = 255 & i),
              (u[12] = n >>> 24),
              (u[13] = (n >>> 16) & 255),
              (u[14] = (n >>> 8) & 255),
              (u[15] = 255 & n),
              (u[16] = s >>> 24),
              (u[17] = (s >>> 16) & 255),
              (u[18] = (s >>> 8) & 255),
              (u[19] = 255 & s),
              (u[20] = o >>> 24),
              (u[21] = (o >>> 16) & 255),
              (u[22] = (o >>> 8) & 255),
              (u[23] = 255 & o),
              (u[24] = a >>> 24),
              (u[25] = (a >>> 16) & 255),
              (u[26] = (a >>> 8) & 255),
              (u[27] = 255 & a),
              (u[28] = l >>> 24),
              (u[29] = (l >>> 16) & 255),
              (u[30] = (l >>> 8) & 255),
              (u[31] = 255 & l),
              u
            );
          }, "digest");
        return void 0 === e ? { add: g, digest: w } : (g(e), w());
      }
      var Y,
        X,
        ee = g(() => {
          A(), y(Z, "sha256");
        }),
        et = g(() => {
          A(),
            y(
              (Y = class e {
                constructor() {
                  _(this, "_dataLength", 0),
                    _(this, "_bufferLength", 0),
                    _(this, "_state", new Int32Array(4)),
                    _(this, "_buffer", new ArrayBuffer(68)),
                    _(this, "_buffer8"),
                    _(this, "_buffer32"),
                    (this._buffer8 = new Uint8Array(this._buffer, 0, 68)),
                    (this._buffer32 = new Uint32Array(this._buffer, 0, 17)),
                    this.start();
                }
                static hashByteArray(e, t = !1) {
                  return this.onePassHasher.start().appendByteArray(e).end(t);
                }
                static hashStr(e, t = !1) {
                  return this.onePassHasher.start().appendStr(e).end(t);
                }
                static hashAsciiStr(e, t = !1) {
                  return this.onePassHasher.start().appendAsciiStr(e).end(t);
                }
                static _hex(t) {
                  let r = e.hexChars,
                    i = e.hexOut,
                    n,
                    s,
                    o,
                    a;
                  for (a = 0; a < 4; a += 1)
                    for (s = 8 * a, n = t[a], o = 0; o < 8; o += 2)
                      (i[s + 1 + o] = r.charAt(15 & n)),
                        (n >>>= 4),
                        (i[s + 0 + o] = r.charAt(15 & n)),
                        (n >>>= 4);
                  return i.join("");
                }
                static _md5cycle(e, t) {
                  let r = e[0],
                    i = e[1],
                    n = e[2],
                    s = e[3];
                  (r += (((i & n) | (~i & s)) + t[0] - 0x28955b88) | 0),
                    (s +=
                      ((((r = (((r << 7) | (r >>> 25)) + i) | 0) & i) |
                        (~r & n)) +
                        t[1] -
                        0x173848aa) |
                      0),
                    (n +=
                      ((((s = (((s << 12) | (s >>> 20)) + r) | 0) & r) |
                        (~s & i)) +
                        t[2] +
                        0x242070db) |
                      0),
                    (i +=
                      ((((n = (((n << 17) | (n >>> 15)) + s) | 0) & s) |
                        (~n & r)) +
                        t[3] -
                        0x3e423112) |
                      0),
                    (r +=
                      ((((i = (((i << 22) | (i >>> 10)) + n) | 0) & n) |
                        (~i & s)) +
                        t[4] -
                        0xa83f051) |
                      0),
                    (s +=
                      ((((r = (((r << 7) | (r >>> 25)) + i) | 0) & i) |
                        (~r & n)) +
                        t[5] +
                        0x4787c62a) |
                      0),
                    (n +=
                      ((((s = (((s << 12) | (s >>> 20)) + r) | 0) & r) |
                        (~s & i)) +
                        t[6] -
                        0x57cfb9ed) |
                      0),
                    (i +=
                      ((((n = (((n << 17) | (n >>> 15)) + s) | 0) & s) |
                        (~n & r)) +
                        t[7] -
                        0x2b96aff) |
                      0),
                    (r +=
                      ((((i = (((i << 22) | (i >>> 10)) + n) | 0) & n) |
                        (~i & s)) +
                        t[8] +
                        0x698098d8) |
                      0),
                    (s +=
                      ((((r = (((r << 7) | (r >>> 25)) + i) | 0) & i) |
                        (~r & n)) +
                        t[9] -
                        0x74bb0851) |
                      0),
                    (n +=
                      ((((s = (((s << 12) | (s >>> 20)) + r) | 0) & r) |
                        (~s & i)) +
                        t[10] -
                        42063) |
                      0),
                    (i +=
                      ((((n = (((n << 17) | (n >>> 15)) + s) | 0) & s) |
                        (~n & r)) +
                        t[11] -
                        0x76a32842) |
                      0),
                    (r +=
                      ((((i = (((i << 22) | (i >>> 10)) + n) | 0) & n) |
                        (~i & s)) +
                        t[12] +
                        0x6b901122) |
                      0),
                    (s +=
                      ((((r = (((r << 7) | (r >>> 25)) + i) | 0) & i) |
                        (~r & n)) +
                        t[13] -
                        0x2678e6d) |
                      0),
                    (n +=
                      ((((s = (((s << 12) | (s >>> 20)) + r) | 0) & r) |
                        (~s & i)) +
                        t[14] -
                        0x5986bc72) |
                      0),
                    (i +=
                      ((((n = (((n << 17) | (n >>> 15)) + s) | 0) & s) |
                        (~n & r)) +
                        t[15] +
                        0x49b40821) |
                      0),
                    (r +=
                      ((((i = (((i << 22) | (i >>> 10)) + n) | 0) & s) |
                        (n & ~s)) +
                        t[1] -
                        0x9e1da9e) |
                      0),
                    (s +=
                      ((((r = (((r << 5) | (r >>> 27)) + i) | 0) & n) |
                        (i & ~n)) +
                        t[6] -
                        0x3fbf4cc0) |
                      0),
                    (n +=
                      ((((s = (((s << 9) | (s >>> 23)) + r) | 0) & i) |
                        (r & ~i)) +
                        t[11] +
                        0x265e5a51) |
                      0),
                    (i +=
                      ((((n = (((n << 14) | (n >>> 18)) + s) | 0) & r) |
                        (s & ~r)) +
                        t[0] -
                        0x16493856) |
                      0),
                    (r +=
                      ((((i = (((i << 20) | (i >>> 12)) + n) | 0) & s) |
                        (n & ~s)) +
                        t[5] -
                        0x29d0efa3) |
                      0),
                    (s +=
                      ((((r = (((r << 5) | (r >>> 27)) + i) | 0) & n) |
                        (i & ~n)) +
                        t[10] +
                        0x2441453) |
                      0),
                    (n +=
                      ((((s = (((s << 9) | (s >>> 23)) + r) | 0) & i) |
                        (r & ~i)) +
                        t[15] -
                        0x275e197f) |
                      0),
                    (i +=
                      ((((n = (((n << 14) | (n >>> 18)) + s) | 0) & r) |
                        (s & ~r)) +
                        t[4] -
                        0x182c0438) |
                      0),
                    (r +=
                      ((((i = (((i << 20) | (i >>> 12)) + n) | 0) & s) |
                        (n & ~s)) +
                        t[9] +
                        0x21e1cde6) |
                      0),
                    (s +=
                      ((((r = (((r << 5) | (r >>> 27)) + i) | 0) & n) |
                        (i & ~n)) +
                        t[14] -
                        0x3cc8f82a) |
                      0),
                    (n +=
                      ((((s = (((s << 9) | (s >>> 23)) + r) | 0) & i) |
                        (r & ~i)) +
                        t[3] -
                        0xb2af279) |
                      0),
                    (i +=
                      ((((n = (((n << 14) | (n >>> 18)) + s) | 0) & r) |
                        (s & ~r)) +
                        t[8] +
                        0x455a14ed) |
                      0),
                    (r +=
                      ((((i = (((i << 20) | (i >>> 12)) + n) | 0) & s) |
                        (n & ~s)) +
                        t[13] -
                        0x561c16fb) |
                      0),
                    (s +=
                      ((((r = (((r << 5) | (r >>> 27)) + i) | 0) & n) |
                        (i & ~n)) +
                        t[2] -
                        0x3105c08) |
                      0),
                    (n +=
                      ((((s = (((s << 9) | (s >>> 23)) + r) | 0) & i) |
                        (r & ~i)) +
                        t[7] +
                        0x676f02d9) |
                      0),
                    (i +=
                      ((((n = (((n << 14) | (n >>> 18)) + s) | 0) & r) |
                        (s & ~r)) +
                        t[12] -
                        0x72d5b376) |
                      0),
                    (r +=
                      (((i = (((i << 20) | (i >>> 12)) + n) | 0) ^ n ^ s) +
                        t[5] -
                        378558) |
                      0),
                    (s +=
                      (((r = (((r << 4) | (r >>> 28)) + i) | 0) ^ i ^ n) +
                        t[8] -
                        0x788e097f) |
                      0),
                    (n +=
                      (((s = (((s << 11) | (s >>> 21)) + r) | 0) ^ r ^ i) +
                        t[11] +
                        0x6d9d6122) |
                      0),
                    (i +=
                      (((n = (((n << 16) | (n >>> 16)) + s) | 0) ^ s ^ r) +
                        t[14] -
                        0x21ac7f4) |
                      0),
                    (r +=
                      (((i = (((i << 23) | (i >>> 9)) + n) | 0) ^ n ^ s) +
                        t[1] -
                        0x5b4115bc) |
                      0),
                    (s +=
                      (((r = (((r << 4) | (r >>> 28)) + i) | 0) ^ i ^ n) +
                        t[4] +
                        0x4bdecfa9) |
                      0),
                    (n +=
                      (((s = (((s << 11) | (s >>> 21)) + r) | 0) ^ r ^ i) +
                        t[7] -
                        0x944b4a0) |
                      0),
                    (i +=
                      (((n = (((n << 16) | (n >>> 16)) + s) | 0) ^ s ^ r) +
                        t[10] -
                        0x41404390) |
                      0),
                    (r +=
                      (((i = (((i << 23) | (i >>> 9)) + n) | 0) ^ n ^ s) +
                        t[13] +
                        0x289b7ec6) |
                      0),
                    (s +=
                      (((r = (((r << 4) | (r >>> 28)) + i) | 0) ^ i ^ n) +
                        t[0] -
                        0x155ed806) |
                      0),
                    (n +=
                      (((s = (((s << 11) | (s >>> 21)) + r) | 0) ^ r ^ i) +
                        t[3] -
                        0x2b10cf7b) |
                      0),
                    (i +=
                      (((n = (((n << 16) | (n >>> 16)) + s) | 0) ^ s ^ r) +
                        t[6] +
                        0x4881d05) |
                      0),
                    (r +=
                      (((i = (((i << 23) | (i >>> 9)) + n) | 0) ^ n ^ s) +
                        t[9] -
                        0x262b2fc7) |
                      0),
                    (s +=
                      (((r = (((r << 4) | (r >>> 28)) + i) | 0) ^ i ^ n) +
                        t[12] -
                        0x1924661b) |
                      0),
                    (n +=
                      (((s = (((s << 11) | (s >>> 21)) + r) | 0) ^ r ^ i) +
                        t[15] +
                        0x1fa27cf8) |
                      0),
                    (i +=
                      (((n = (((n << 16) | (n >>> 16)) + s) | 0) ^ s ^ r) +
                        t[2] -
                        0x3b53a99b) |
                      0),
                    (i = (((i << 23) | (i >>> 9)) + n) | 0),
                    (r += ((n ^ (i | ~s)) + t[0] - 0xbd6ddbc) | 0),
                    (r = (((r << 6) | (r >>> 26)) + i) | 0),
                    (s += ((i ^ (r | ~n)) + t[7] + 0x432aff97) | 0),
                    (s = (((s << 10) | (s >>> 22)) + r) | 0),
                    (n += ((r ^ (s | ~i)) + t[14] - 0x546bdc59) | 0),
                    (n = (((n << 15) | (n >>> 17)) + s) | 0),
                    (i += ((s ^ (n | ~r)) + t[5] - 0x36c5fc7) | 0),
                    (i = (((i << 21) | (i >>> 11)) + n) | 0),
                    (r += ((n ^ (i | ~s)) + t[12] + 0x655b59c3) | 0),
                    (r = (((r << 6) | (r >>> 26)) + i) | 0),
                    (s += ((i ^ (r | ~n)) + t[3] - 0x70f3336e) | 0),
                    (s = (((s << 10) | (s >>> 22)) + r) | 0),
                    (n += ((r ^ (s | ~i)) + t[10] - 1051523) | 0),
                    (n = (((n << 15) | (n >>> 17)) + s) | 0),
                    (i += ((s ^ (n | ~r)) + t[1] - 0x7a7ba22f) | 0),
                    (i = (((i << 21) | (i >>> 11)) + n) | 0),
                    (r += ((n ^ (i | ~s)) + t[8] + 0x6fa87e4f) | 0),
                    (r = (((r << 6) | (r >>> 26)) + i) | 0),
                    (s += ((i ^ (r | ~n)) + t[15] - 0x1d31920) | 0),
                    (s = (((s << 10) | (s >>> 22)) + r) | 0),
                    (n += ((r ^ (s | ~i)) + t[6] - 0x5cfebcec) | 0),
                    (n = (((n << 15) | (n >>> 17)) + s) | 0),
                    (i += ((s ^ (n | ~r)) + t[13] + 0x4e0811a1) | 0),
                    (i = (((i << 21) | (i >>> 11)) + n) | 0),
                    (r += ((n ^ (i | ~s)) + t[4] - 0x8ac817e) | 0),
                    (r = (((r << 6) | (r >>> 26)) + i) | 0),
                    (s += ((i ^ (r | ~n)) + t[11] - 0x42c50dcb) | 0),
                    (s = (((s << 10) | (s >>> 22)) + r) | 0),
                    (n += ((r ^ (s | ~i)) + t[2] + 0x2ad7d2bb) | 0),
                    (n = (((n << 15) | (n >>> 17)) + s) | 0),
                    (i += ((s ^ (n | ~r)) + t[9] - 0x14792c6f) | 0),
                    (i = (((i << 21) | (i >>> 11)) + n) | 0),
                    (e[0] = (r + e[0]) | 0),
                    (e[1] = (i + e[1]) | 0),
                    (e[2] = (n + e[2]) | 0),
                    (e[3] = (s + e[3]) | 0);
                }
                start() {
                  return (
                    (this._dataLength = 0),
                    (this._bufferLength = 0),
                    this._state.set(e.stateIdentity),
                    this
                  );
                }
                appendStr(t) {
                  let r = this._buffer8,
                    i = this._buffer32,
                    n = this._bufferLength,
                    s,
                    o;
                  for (o = 0; o < t.length; o += 1) {
                    if ((s = t.charCodeAt(o)) < 128) r[n++] = s;
                    else if (s < 2048)
                      (r[n++] = (s >>> 6) + 192), (r[n++] = (63 & s) | 128);
                    else if (s < 55296 || s > 56319)
                      (r[n++] = (s >>> 12) + 224),
                        (r[n++] = ((s >>> 6) & 63) | 128),
                        (r[n++] = (63 & s) | 128);
                    else {
                      if (
                        (s =
                          (s - 55296) * 1024 +
                          (t.charCodeAt(++o) - 56320) +
                          65536) > 1114111
                      )
                        throw Error(
                          "Unicode standard supports code points up to U+10FFFF"
                        );
                      (r[n++] = (s >>> 18) + 240),
                        (r[n++] = ((s >>> 12) & 63) | 128),
                        (r[n++] = ((s >>> 6) & 63) | 128),
                        (r[n++] = (63 & s) | 128);
                    }
                    n >= 64 &&
                      ((this._dataLength += 64),
                      e._md5cycle(this._state, i),
                      (n -= 64),
                      (i[0] = i[16]));
                  }
                  return (this._bufferLength = n), this;
                }
                appendAsciiStr(t) {
                  let r = this._buffer8,
                    i = this._buffer32,
                    n = this._bufferLength,
                    s,
                    o = 0;
                  for (;;) {
                    for (s = Math.min(t.length - o, 64 - n); s--; )
                      r[n++] = t.charCodeAt(o++);
                    if (n < 64) break;
                    (this._dataLength += 64),
                      e._md5cycle(this._state, i),
                      (n = 0);
                  }
                  return (this._bufferLength = n), this;
                }
                appendByteArray(t) {
                  let r = this._buffer8,
                    i = this._buffer32,
                    n = this._bufferLength,
                    s,
                    o = 0;
                  for (;;) {
                    for (s = Math.min(t.length - o, 64 - n); s--; )
                      r[n++] = t[o++];
                    if (n < 64) break;
                    (this._dataLength += 64),
                      e._md5cycle(this._state, i),
                      (n = 0);
                  }
                  return (this._bufferLength = n), this;
                }
                getState() {
                  let e = this._state;
                  return {
                    buffer: String.fromCharCode.apply(
                      null,
                      Array.from(this._buffer8)
                    ),
                    buflen: this._bufferLength,
                    length: this._dataLength,
                    state: [e[0], e[1], e[2], e[3]],
                  };
                }
                setState(e) {
                  let t = e.buffer,
                    r = e.state,
                    i = this._state,
                    n;
                  for (
                    this._dataLength = e.length,
                      this._bufferLength = e.buflen,
                      i[0] = r[0],
                      i[1] = r[1],
                      i[2] = r[2],
                      i[3] = r[3],
                      n = 0;
                    n < t.length;
                    n += 1
                  )
                    this._buffer8[n] = t.charCodeAt(n);
                }
                end(t = !1) {
                  let r = this._bufferLength,
                    i = this._buffer8,
                    n = this._buffer32,
                    s = (r >> 2) + 1;
                  this._dataLength += r;
                  let o = 8 * this._dataLength;
                  if (
                    ((i[r] = 128),
                    (i[r + 1] = i[r + 2] = i[r + 3] = 0),
                    n.set(e.buffer32Identity.subarray(s), s),
                    r > 55 &&
                      (e._md5cycle(this._state, n), n.set(e.buffer32Identity)),
                    o <= 0xffffffff)
                  )
                    n[14] = o;
                  else {
                    let e = o.toString(16).match(/(.*?)(.{0,8})$/);
                    if (null === e) return;
                    let t = parseInt(e[2], 16),
                      r = parseInt(e[1], 16) || 0;
                    (n[14] = t), (n[15] = r);
                  }
                  return (
                    e._md5cycle(this._state, n),
                    t ? this._state : e._hex(this._state)
                  );
                }
              }),
              "Md5"
            ),
            _(
              Y,
              "stateIdentity",
              new Int32Array([0x67452301, -0x10325477, -0x67452302, 0x10325476])
            ),
            _(
              Y,
              "buffer32Identity",
              new Int32Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
            ),
            _(Y, "hexChars", "0123456789abcdef"),
            _(Y, "hexOut", []),
            _(Y, "onePassHasher", new Y()),
            (X = Y);
        }),
        er = {};
      function ei(e) {
        return crypto.getRandomValues(a.alloc(e));
      }
      function en(e) {
        if ("sha256" === e)
          return {
            update: y(function (e) {
              return {
                digest: y(function () {
                  return a.from(Z(e));
                }, "digest"),
              };
            }, "update"),
          };
        if ("md5" === e)
          return {
            update: y(function (e) {
              return {
                digest: y(function () {
                  return "string" == typeof e
                    ? X.hashStr(e)
                    : X.hashByteArray(e);
                }, "digest"),
              };
            }, "update"),
          };
        throw Error(`Hash type '${e}' not supported`);
      }
      function es(e, t) {
        if ("sha256" !== e)
          throw Error(`\
Only sha256 is supported (requested: '${e}')`);
        return {
          update: y(function (e) {
            return {
              digest: y(function () {
                "string" == typeof t && (t = new TextEncoder().encode(t)),
                  "string" == typeof e && (e = new TextEncoder().encode(e));
                let r = t.length;
                if (r > 64) t = Z(t);
                else if (r < 64) {
                  let e = new Uint8Array(64);
                  e.set(t), (t = e);
                }
                let i = new Uint8Array(64),
                  n = new Uint8Array(64);
                for (let e = 0; e < 64; e++)
                  (i[e] = 54 ^ t[e]), (n[e] = 92 ^ t[e]);
                let s = new Uint8Array(e.length + 64);
                s.set(i, 0), s.set(e, 64);
                let o = new Uint8Array(96);
                return o.set(n, 0), o.set(Z(s), 64), a.from(Z(o));
              }, "digest"),
            };
          }, "update"),
        };
      }
      b(er, {
        createHash: () => en,
        createHmac: () => es,
        randomBytes: () => ei,
      });
      var eo = g(() => {
          A(),
            ee(),
            et(),
            y(ei, "randomBytes"),
            y(en, "createHash"),
            y(es, "createHmac");
        }),
        ea = w((e, t) => {
          A(),
            (t.exports = {
              host: "localhost",
              user: "win32" === l.platform ? l.env.USERNAME : l.env.USER,
              database: void 0,
              password: null,
              connectionString: void 0,
              port: 5432,
              rows: 0,
              binary: !1,
              max: 10,
              idleTimeoutMillis: 3e4,
              client_encoding: "",
              ssl: !1,
              application_name: void 0,
              fallback_application_name: void 0,
              options: void 0,
              parseInputDatesAsUTC: !1,
              statement_timeout: !1,
              lock_timeout: !1,
              idle_in_transaction_session_timeout: !1,
              query_timeout: !1,
              connect_timeout: 0,
              keepalives: 1,
              keepalives_idle: 0,
            });
          var r = H(),
            i = r.getTypeParser(20, "text"),
            n = r.getTypeParser(1016, "text");
          t.exports.__defineSetter__("parseInt8", function (e) {
            r.setTypeParser(20, "text", e ? r.getTypeParser(23, "text") : i),
              r.setTypeParser(
                1016,
                "text",
                e ? r.getTypeParser(1007, "text") : n
              );
          });
        }),
        el = w((e, t) => {
          A();
          var r = (eo(), x(er)),
            i = ea();
          function n(e) {
            return '"' + e.replace(/\\/g, "\\\\").replace(/"/g, '\\"') + '"';
          }
          function s(e) {
            for (var t = "{", r = 0; r < e.length; r++)
              r > 0 && (t += ","),
                null === e[r] || typeof e[r] > "u"
                  ? (t += "NULL")
                  : Array.isArray(e[r])
                    ? (t += s(e[r]))
                    : e[r] instanceof a
                      ? (t += "\\\\x" + e[r].toString("hex"))
                      : (t += n(o(e[r])));
            return t + "}";
          }
          y(n, "escapeElement"), y(s, "arrayString");
          var o = y(function (e, t) {
            if (null == e) return null;
            if (e instanceof a) return e;
            if (ArrayBuffer.isView(e)) {
              var r = a.from(e.buffer, e.byteOffset, e.byteLength);
              return r.length === e.byteLength
                ? r
                : r.slice(e.byteOffset, e.byteOffset + e.byteLength);
            }
            return e instanceof Date
              ? i.parseInputDatesAsUTC
                ? u(e)
                : d(e)
              : Array.isArray(e)
                ? s(e)
                : "object" == typeof e
                  ? l(e, t)
                  : e.toString();
          }, "prepareValue");
          function l(e, t) {
            if (e && "function" == typeof e.toPostgres) {
              if (-1 !== (t = t || []).indexOf(e))
                throw Error(
                  'circular reference detected while preparing "' +
                    e +
                    '" for query'
                );
              return t.push(e), o(e.toPostgres(o), t);
            }
            return JSON.stringify(e);
          }
          function c(e, t) {
            for (e = "" + e; e.length < t; ) e = "0" + e;
            return e;
          }
          function d(e) {
            var t = -e.getTimezoneOffset(),
              r = e.getFullYear(),
              i = r < 1;
            i && (r = Math.abs(r) + 1);
            var n =
              c(r, 4) +
              "-" +
              c(e.getMonth() + 1, 2) +
              "-" +
              c(e.getDate(), 2) +
              "T" +
              c(e.getHours(), 2) +
              ":" +
              c(e.getMinutes(), 2) +
              ":" +
              c(e.getSeconds(), 2) +
              "." +
              c(e.getMilliseconds(), 3);
            return (
              t < 0 ? ((n += "-"), (t *= -1)) : (n += "+"),
              (n += c(Math.floor(t / 60), 2) + ":" + c(t % 60, 2)),
              i && (n += " BC"),
              n
            );
          }
          function u(e) {
            var t = e.getUTCFullYear(),
              r = t < 1;
            r && (t = Math.abs(t) + 1);
            var i =
              c(t, 4) +
              "-" +
              c(e.getUTCMonth() + 1, 2) +
              "-" +
              c(e.getUTCDate(), 2) +
              "T" +
              c(e.getUTCHours(), 2) +
              ":" +
              c(e.getUTCMinutes(), 2) +
              ":" +
              c(e.getUTCSeconds(), 2) +
              "." +
              c(e.getUTCMilliseconds(), 3);
            return (i += "+00:00"), r && (i += " BC"), i;
          }
          function h(e, t, r) {
            return (
              (e = "string" == typeof e ? { text: e } : e),
              t && ("function" == typeof t ? (e.callback = t) : (e.values = t)),
              r && (e.callback = r),
              e
            );
          }
          y(l, "prepareObject"),
            y(c, "pad"),
            y(d, "dateToString"),
            y(u, "dateToStringUTC"),
            y(h, "normalizeQueryConfig");
          var p = y(function (e) {
              return r.createHash("md5").update(e, "utf-8").digest("hex");
            }, "md5"),
            f = y(function (e, t, r) {
              var i = p(t + e);
              return "md5" + p(a.concat([a.from(i), r]));
            }, "postgresMd5PasswordHash");
          t.exports = {
            prepareValue: y(function (e) {
              return o(e);
            }, "prepareValueWrapper"),
            normalizeQueryConfig: h,
            postgresMd5PasswordHash: f,
            md5: p,
          };
        }),
        ec = {};
      b(ec, { default: () => ed });
      var ed,
        eu = g(() => {
          A(), (ed = {});
        }),
        eh = w((e, t) => {
          A();
          var r = (eo(), x(er));
          function i(e) {
            if (-1 === e.indexOf("SCRAM-SHA-256"))
              throw Error(
                "SASL: Only mechanism SCRAM-SHA-256 is currently supported"
              );
            let t = r.randomBytes(18).toString("base64");
            return {
              mechanism: "SCRAM-SHA-256",
              clientNonce: t,
              response: "n,,n=*,r=" + t,
              message: "SASLInitialResponse",
            };
          }
          function n(e, t, r) {
            if ("SASLInitialResponse" !== e.message)
              throw Error("SASL: Last message was not SASLInitialResponse");
            if ("string" != typeof t)
              throw Error(
                "SASL: SCRAM-SERVER-FIRST-MESSAGE: client password must be a string"
              );
            if ("string" != typeof r)
              throw Error(
                "SASL: SCRAM-SERVER-FIRST-MESSAGE: serverData must be a string"
              );
            let i = d(r);
            if (i.nonce.startsWith(e.clientNonce)) {
              if (i.nonce.length === e.clientNonce.length)
                throw Error(
                  "SASL: SCRAM-SERVER-FIRST-MESSAGE: server nonce is too short"
                );
            } else
              throw Error(
                "SASL: SCRAM-SERVER-FIRST-MESSAGE: server nonce does not start with client nonce"
              );
            var n = m(t, a.from(i.salt, "base64"), i.iteration),
              s = f(n, "Client Key"),
              o = p(s),
              l = "n=*,r=" + e.clientNonce,
              c = "r=" + i.nonce + ",s=" + i.salt + ",i=" + i.iteration,
              u = "c=biws,r=" + i.nonce,
              y = l + "," + c + "," + u,
              g = h(s, f(o, y)).toString("base64"),
              w = f(n, "Server Key"),
              b = f(w, y);
            (e.message = "SASLResponse"),
              (e.serverSignature = b.toString("base64")),
              (e.response = u + ",p=" + g);
          }
          function s(e, t) {
            if ("SASLResponse" !== e.message)
              throw Error("SASL: Last message was not SASLResponse");
            if ("string" != typeof t)
              throw Error(
                "SASL: SCRAM-SERVER-FINAL-MESSAGE: serverData must be a string"
              );
            let { serverSignature: r } = u(t);
            if (r !== e.serverSignature)
              throw Error(
                "SASL: SCRAM-SERVER-FINAL-MESSAGE: server signature does not match"
              );
          }
          function o(e) {
            if ("string" != typeof e)
              throw TypeError("SASL: text must be a string");
            return e
              .split("")
              .map((t, r) => e.charCodeAt(r))
              .every((e) => (e >= 33 && e <= 43) || (e >= 45 && e <= 126));
          }
          function l(e) {
            return /^(?:[a-zA-Z0-9+/]{4})*(?:[a-zA-Z0-9+/]{2}==|[a-zA-Z0-9+/]{3}=)?$/.test(
              e
            );
          }
          function c(e) {
            if ("string" != typeof e)
              throw TypeError("SASL: attribute pairs text must be a string");
            return new Map(
              e.split(",").map((e) => {
                if (!/^.=/.test(e))
                  throw Error("SASL: Invalid attribute pair entry");
                return [e[0], e.substring(2)];
              })
            );
          }
          function d(e) {
            let t = c(e),
              r = t.get("r");
            if (r) {
              if (!o(r))
                throw Error(
                  "SASL: SCRAM-SERVER-FIRST-MESSAGE: nonce must only contain printable characters"
                );
            } else
              throw Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: nonce missing");
            let i = t.get("s");
            if (i) {
              if (!l(i))
                throw Error(
                  "SASL: SCRAM-SERVER-FIRST-MESSAGE: salt must be base64"
                );
            } else
              throw Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: salt missing");
            let n = t.get("i");
            if (n) {
              if (!/^[1-9][0-9]*$/.test(n))
                throw Error(
                  "SASL: SCRAM-SERVER-FIRST-MESSAGE: invalid iteration count"
                );
            } else
              throw Error(
                "SASL: SCRAM-SERVER-FIRST-MESSAGE: iteration missing"
              );
            return { nonce: r, salt: i, iteration: parseInt(n, 10) };
          }
          function u(e) {
            let t = c(e).get("v");
            if (t) {
              if (!l(t))
                throw Error(
                  "SASL: SCRAM-SERVER-FINAL-MESSAGE: server signature must be base64"
                );
            } else
              throw Error(
                "SASL: SCRAM-SERVER-FINAL-MESSAGE: server signature is missing"
              );
            return { serverSignature: t };
          }
          function h(e, t) {
            if (!a.isBuffer(e))
              throw TypeError("first argument must be a Buffer");
            if (!a.isBuffer(t))
              throw TypeError("second argument must be a Buffer");
            if (e.length !== t.length) throw Error("Buffer lengths must match");
            if (0 === e.length) throw Error("Buffers cannot be empty");
            return a.from(e.map((r, i) => e[i] ^ t[i]));
          }
          function p(e) {
            return r.createHash("sha256").update(e).digest();
          }
          function f(e, t) {
            return r.createHmac("sha256", e).update(t).digest();
          }
          function m(e, t, r) {
            for (
              var i = f(e, a.concat([t, a.from([0, 0, 0, 1])])), n = i, s = 0;
              s < r - 1;
              s++
            )
              n = h(n, (i = f(e, i)));
            return n;
          }
          y(i, "startSession"),
            y(n, "continueSession"),
            y(s, "finalizeSession"),
            y(o, "isPrintableChars"),
            y(l, "isBase64"),
            y(c, "parseAttributePairs"),
            y(d, "parseServerFirstMessage"),
            y(u, "parseServerFinalMessage"),
            y(h, "xorBuffers"),
            y(p, "sha256"),
            y(f, "hmacSha256"),
            y(m, "Hi"),
            (t.exports = {
              startSession: i,
              continueSession: n,
              finalizeSession: s,
            });
        }),
        ep = {};
      function ef(...e) {
        return e.join("/");
      }
      b(ep, { join: () => ef });
      var em = g(() => {
          A(), y(ef, "join");
        }),
        ey = {};
      function eg(e, t) {
        t(Error("No filesystem"));
      }
      b(ey, { stat: () => eg });
      var ew = g(() => {
          A(), y(eg, "stat");
        }),
        eb = {};
      b(eb, { default: () => ev });
      var ev,
        eN = g(() => {
          A(), (ev = {});
        }),
        ex = {};
      b(ex, { StringDecoder: () => eS });
      var e_,
        eS,
        eT = g(() => {
          A(),
            y(
              (e_ = class {
                constructor(e) {
                  _(this, "td"), (this.td = new TextDecoder(e));
                }
                write(e) {
                  return this.td.decode(e, { stream: !0 });
                }
                end(e) {
                  return this.td.decode(e);
                }
              }),
              "StringDecoder"
            ),
            (eS = e_);
        }),
        ek = w((e, t) => {
          A();
          var { Transform: r } = (eN(), x(eb)),
            { StringDecoder: i } = (eT(), x(ex)),
            n = Symbol("last"),
            s = Symbol("decoder");
          function o(e, t, r) {
            let i;
            if (this.overflow) {
              if (1 === (i = this[s].write(e).split(this.matcher)).length)
                return r();
              i.shift(), (this.overflow = !1);
            } else
              (this[n] += this[s].write(e)), (i = this[n].split(this.matcher));
            this[n] = i.pop();
            for (let e = 0; e < i.length; e++)
              try {
                l(this, this.mapper(i[e]));
              } catch (e) {
                return r(e);
              }
            if (
              ((this.overflow = this[n].length > this.maxLength),
              this.overflow && !this.skipOverflow)
            )
              return void r(Error("maximum buffer reached"));
            r();
          }
          function a(e) {
            if (((this[n] += this[s].end()), this[n]))
              try {
                l(this, this.mapper(this[n]));
              } catch (t) {
                return e(t);
              }
            e();
          }
          function l(e, t) {
            void 0 !== t && e.push(t);
          }
          function c(e) {
            return e;
          }
          function d(e, t, l) {
            switch (
              ((e = e || /\r?\n/),
              (t = t || c),
              (l = l || {}),
              arguments.length)
            ) {
              case 1:
                "function" == typeof e
                  ? ((t = e), (e = /\r?\n/))
                  : "object" != typeof e ||
                    e instanceof RegExp ||
                    e[Symbol.split] ||
                    ((l = e), (e = /\r?\n/));
                break;
              case 2:
                "function" == typeof e
                  ? ((l = t), (t = e), (e = /\r?\n/))
                  : "object" == typeof t && ((l = t), (t = c));
            }
            ((l = Object.assign({}, l)).autoDestroy = !0),
              (l.transform = o),
              (l.flush = a),
              (l.readableObjectMode = !0);
            let d = new r(l);
            return (
              (d[n] = ""),
              (d[s] = new i("utf8")),
              (d.matcher = e),
              (d.mapper = t),
              (d.maxLength = l.maxLength),
              (d.skipOverflow = l.skipOverflow || !1),
              (d.overflow = !1),
              (d._destroy = function (e, t) {
                (this._writableState.errorEmitted = !1), t(e);
              }),
              d
            );
          }
          y(o, "transform"),
            y(a, "flush"),
            y(l, "push"),
            y(c, "noop"),
            y(d, "split"),
            (t.exports = d);
        }),
        eA = w((e, t) => {
          A();
          var r = (em(), x(ep)),
            i = (eN(), x(eb)).Stream,
            n = ek(),
            s = (eu(), x(ec)),
            o = "win32" === l.platform,
            a = l.stderr;
          function c(e) {
            return (61440 & e) == 32768;
          }
          y(c, "isRegFile");
          var d = ["host", "port", "database", "user", "password"],
            u = d.length,
            h = d[u - 1];
          function p() {
            if (a instanceof i && !0 === a.writable) {
              var e = Array.prototype.slice.call(arguments).concat(`
`);
              a.write(s.format.apply(s, e));
            }
          }
          y(p, "warn"),
            Object.defineProperty(t.exports, "isWin", {
              get: y(function () {
                return o;
              }, "get"),
              set: y(function (e) {
                o = e;
              }, "set"),
            }),
            (t.exports.warnTo = function (e) {
              var t = a;
              return (a = e), t;
            }),
            (t.exports.getFileName = function (e) {
              var t = e || l.env;
              return (
                t.PGPASSFILE ||
                (o
                  ? r.join(t.APPDATA || "./", "postgresql", "pgpass.conf")
                  : r.join(t.HOME || "./", ".pgpass"))
              );
            }),
            (t.exports.usePgPass = function (e, t) {
              return (
                !Object.prototype.hasOwnProperty.call(l.env, "PGPASSWORD") &&
                (!!o ||
                  ((t = t || "<unkn>"),
                  c(e.mode)
                    ? !(63 & e.mode) ||
                      (p(
                        'WARNING: password file "%s" has group or world access; permissions should be u=rw (0600) or less',
                        t
                      ),
                      !1)
                    : (p('WARNING: password file "%s" is not a plain file', t),
                      !1)))
              );
            });
          var f = (t.exports.match = function (e, t) {
            return d.slice(0, -1).reduce(function (r, i, n) {
              return 1 == n && Number(e[i] || 5432) === Number(t[i])
                ? r && !0
                : r && ("*" === t[i] || t[i] === e[i]);
            }, !0);
          });
          t.exports.getPassword = function (e, t, r) {
            var i,
              s = t.pipe(n());
            function o(t) {
              var r = m(t);
              r && g(r) && f(e, r) && ((i = r[h]), s.end());
            }
            y(o, "onLine");
            var a = y(function () {
                t.destroy(), r(i);
              }, "onEnd"),
              l = y(function (e) {
                t.destroy(),
                  p("WARNING: error on reading file: %s", e),
                  r(void 0);
              }, "onErr");
            t.on("error", l), s.on("data", o).on("end", a).on("error", l);
          };
          var m = (t.exports.parseLine = function (e) {
              if (e.length < 11 || e.match(/^\s+#/)) return null;
              for (
                var t = "",
                  r = "",
                  i = 0,
                  n = 0,
                  s = {},
                  o = y(function (t, r, i) {
                    var n = e.substring(r, i);
                    Object.hasOwnProperty.call(l.env, "PGPASS_NO_DEESCAPE") ||
                      (n = n.replace(/\\([:\\])/g, "$1")),
                      (s[d[t]] = n);
                  }, "addToObj"),
                  a = 0;
                a < e.length - 1;
                a += 1
              ) {
                if (((t = e.charAt(a + 1)), (r = e.charAt(a)), i == u - 1)) {
                  o(i, n);
                  break;
                }
                a >= 0 &&
                  ":" == t &&
                  "\\" !== r &&
                  (o(i, n, a + 1), (n = a + 2), (i += 1));
              }
              return (s = Object.keys(s).length === u ? s : null);
            }),
            g = (t.exports.isValidEntry = function (e) {
              for (
                var t = {
                    0: function (e) {
                      return e.length > 0;
                    },
                    1: function (e) {
                      return (
                        "*" === e ||
                        (isFinite((e = Number(e))) &&
                          e > 0 &&
                          e < 0x20000000000000 &&
                          Math.floor(e) === e)
                      );
                    },
                    2: function (e) {
                      return e.length > 0;
                    },
                    3: function (e) {
                      return e.length > 0;
                    },
                    4: function (e) {
                      return e.length > 0;
                    },
                  },
                  r = 0;
                r < d.length;
                r += 1
              )
                if (!(0, t[r])(e[d[r]] || "")) return !1;
              return !0;
            });
        }),
        eE = w((e, t) => {
          A(), em(), x(ep);
          var r = (ew(), x(ey)),
            i = eA();
          (t.exports = function (e, t) {
            var n = i.getFileName();
            r.stat(n, function (s, o) {
              if (s || !i.usePgPass(o, n)) return t(void 0);
              var a = r.createReadStream(n);
              i.getPassword(e, a, t);
            });
          }),
            (t.exports.warnTo = i.warnTo);
        }),
        eC = {};
      b(eC, { default: () => eI });
      var eI,
        eO = g(() => {
          A(), (eI = {});
        }),
        eL = w((e, t) => {
          A();
          var r = ($(), x(q)),
            i = (ew(), x(ey));
          function n(e) {
            if ("/" === e.charAt(0)) {
              var t = e.split(" ");
              return { host: t[0], database: t[1] };
            }
            var n = r.parse(
                / |%[^a-f0-9]|%[a-f0-9][^a-f0-9]/i.test(e)
                  ? encodeURI(e).replace(/\%25(\d\d)/g, "%$1")
                  : e,
                !0
              ),
              t = n.query;
            for (var s in t)
              Array.isArray(t[s]) && (t[s] = t[s][t[s].length - 1]);
            var o = (n.auth || ":").split(":");
            if (
              ((t.user = o[0]),
              (t.password = o.splice(1).join(":")),
              (t.port = n.port),
              "socket:" == n.protocol)
            )
              return (
                (t.host = decodeURI(n.pathname)),
                (t.database = n.query.db),
                (t.client_encoding = n.query.encoding),
                t
              );
            t.host || (t.host = n.hostname);
            var a = n.pathname;
            if (!t.host && a && /^%2f/i.test(a)) {
              var l = a.split("/");
              (t.host = decodeURIComponent(l[0])), (a = l.splice(1).join("/"));
            }
            switch (
              (a && "/" === a.charAt(0) && (a = a.slice(1) || null),
              (t.database = a && decodeURI(a)),
              ("true" === t.ssl || "1" === t.ssl) && (t.ssl = !0),
              "0" === t.ssl && (t.ssl = !1),
              (t.sslcert || t.sslkey || t.sslrootcert || t.sslmode) &&
                (t.ssl = {}),
              t.sslcert && (t.ssl.cert = i.readFileSync(t.sslcert).toString()),
              t.sslkey && (t.ssl.key = i.readFileSync(t.sslkey).toString()),
              t.sslrootcert &&
                (t.ssl.ca = i.readFileSync(t.sslrootcert).toString()),
              t.sslmode)
            ) {
              case "disable":
                t.ssl = !1;
                break;
              case "prefer":
              case "require":
              case "verify-ca":
              case "verify-full":
                break;
              case "no-verify":
                t.ssl.rejectUnauthorized = !1;
            }
            return t;
          }
          y(n, "parse"), (t.exports = n), (n.parse = n);
        }),
        eR = w((e, t) => {
          A();
          var r = (eO(), x(eC)),
            i = ea(),
            n = eL().parse,
            s = y(function (e, t, r) {
              return (
                void 0 === r
                  ? (r = l.env["PG" + e.toUpperCase()])
                  : !1 === r || (r = l.env[r]),
                t[e] || r || i[e]
              );
            }, "val"),
            o = y(function () {
              switch (l.env.PGSSLMODE) {
                case "disable":
                  return !1;
                case "prefer":
                case "require":
                case "verify-ca":
                case "verify-full":
                  return !0;
                case "no-verify":
                  return { rejectUnauthorized: !1 };
              }
              return i.ssl;
            }, "readSSLConfigFromEnvironment"),
            a = y(function (e) {
              return (
                "'" + ("" + e).replace(/\\/g, "\\\\").replace(/'/g, "\\'") + "'"
              );
            }, "quoteParamValue"),
            c = y(function (e, t, r) {
              var i = t[r];
              null != i && e.push(r + "=" + a(i));
            }, "add"),
            d = class {
              constructor(e) {
                (e = "string" == typeof e ? n(e) : e || {}).connectionString &&
                  (e = Object.assign({}, e, n(e.connectionString))),
                  (this.user = s("user", e)),
                  (this.database = s("database", e)),
                  void 0 === this.database && (this.database = this.user),
                  (this.port = parseInt(s("port", e), 10)),
                  (this.host = s("host", e)),
                  Object.defineProperty(this, "password", {
                    configurable: !0,
                    enumerable: !1,
                    writable: !0,
                    value: s("password", e),
                  }),
                  (this.binary = s("binary", e)),
                  (this.options = s("options", e)),
                  (this.ssl = typeof e.ssl > "u" ? o() : e.ssl),
                  "string" == typeof this.ssl &&
                    "true" === this.ssl &&
                    (this.ssl = !0),
                  "no-verify" === this.ssl &&
                    (this.ssl = { rejectUnauthorized: !1 }),
                  this.ssl &&
                    this.ssl.key &&
                    Object.defineProperty(this.ssl, "key", { enumerable: !1 }),
                  (this.client_encoding = s("client_encoding", e)),
                  (this.replication = s("replication", e)),
                  (this.isDomainSocket = !(this.host || "").indexOf("/")),
                  (this.application_name = s(
                    "application_name",
                    e,
                    "PGAPPNAME"
                  )),
                  (this.fallback_application_name = s(
                    "fallback_application_name",
                    e,
                    !1
                  )),
                  (this.statement_timeout = s("statement_timeout", e, !1)),
                  (this.lock_timeout = s("lock_timeout", e, !1)),
                  (this.idle_in_transaction_session_timeout = s(
                    "idle_in_transaction_session_timeout",
                    e,
                    !1
                  )),
                  (this.query_timeout = s("query_timeout", e, !1)),
                  void 0 === e.connectionTimeoutMillis
                    ? (this.connect_timeout = l.env.PGCONNECT_TIMEOUT || 0)
                    : (this.connect_timeout = Math.floor(
                        e.connectionTimeoutMillis / 1e3
                      )),
                  !1 === e.keepAlive
                    ? (this.keepalives = 0)
                    : !0 === e.keepAlive && (this.keepalives = 1),
                  "number" == typeof e.keepAliveInitialDelayMillis &&
                    (this.keepalives_idle = Math.floor(
                      e.keepAliveInitialDelayMillis / 1e3
                    ));
              }
              getLibpqConnectionString(e) {
                var t = [];
                c(t, this, "user"),
                  c(t, this, "password"),
                  c(t, this, "port"),
                  c(t, this, "application_name"),
                  c(t, this, "fallback_application_name"),
                  c(t, this, "connect_timeout"),
                  c(t, this, "options");
                var i =
                  "object" == typeof this.ssl
                    ? this.ssl
                    : this.ssl
                      ? { sslmode: this.ssl }
                      : {};
                if (
                  (c(t, i, "sslmode"),
                  c(t, i, "sslca"),
                  c(t, i, "sslkey"),
                  c(t, i, "sslcert"),
                  c(t, i, "sslrootcert"),
                  this.database && t.push("dbname=" + a(this.database)),
                  this.replication &&
                    t.push("replication=" + a(this.replication)),
                  this.host && t.push("host=" + a(this.host)),
                  this.isDomainSocket)
                )
                  return e(null, t.join(" "));
                this.client_encoding &&
                  t.push("client_encoding=" + a(this.client_encoding)),
                  r.lookup(this.host, function (r, i) {
                    return r
                      ? e(r, null)
                      : (t.push("hostaddr=" + a(i)), e(null, t.join(" ")));
                  });
              }
            };
          y(d, "ConnectionParameters"), (t.exports = d);
        }),
        eP = w((e, t) => {
          A();
          var r = H(),
            i = /^([A-Za-z]+)(?: (\d+))?(?: (\d+))?/,
            n = class {
              constructor(e, t) {
                (this.command = null),
                  (this.rowCount = null),
                  (this.oid = null),
                  (this.rows = []),
                  (this.fields = []),
                  (this._parsers = void 0),
                  (this._types = t),
                  (this.RowCtor = null),
                  (this.rowAsArray = "array" === e),
                  this.rowAsArray && (this.parseRow = this._parseRowAsArray);
              }
              addCommandComplete(e) {
                var t;
                (t = e.text ? i.exec(e.text) : i.exec(e.command)) &&
                  ((this.command = t[1]),
                  t[3]
                    ? ((this.oid = parseInt(t[2], 10)),
                      (this.rowCount = parseInt(t[3], 10)))
                    : t[2] && (this.rowCount = parseInt(t[2], 10)));
              }
              _parseRowAsArray(e) {
                for (var t = Array(e.length), r = 0, i = e.length; r < i; r++) {
                  var n = e[r];
                  null !== n ? (t[r] = this._parsers[r](n)) : (t[r] = null);
                }
                return t;
              }
              parseRow(e) {
                for (var t = {}, r = 0, i = e.length; r < i; r++) {
                  var n = e[r],
                    s = this.fields[r].name;
                  null !== n ? (t[s] = this._parsers[r](n)) : (t[s] = null);
                }
                return t;
              }
              addRow(e) {
                this.rows.push(e);
              }
              addFields(e) {
                (this.fields = e),
                  this.fields.length && (this._parsers = Array(e.length));
                for (var t = 0; t < e.length; t++) {
                  var i = e[t];
                  this._types
                    ? (this._parsers[t] = this._types.getTypeParser(
                        i.dataTypeID,
                        i.format || "text"
                      ))
                    : (this._parsers[t] = r.getTypeParser(
                        i.dataTypeID,
                        i.format || "text"
                      ));
                }
              }
            };
          y(n, "Result"), (t.exports = n);
        }),
        eD = w((e, t) => {
          A();
          var { EventEmitter: r } = E(),
            i = eP(),
            n = el(),
            s = class extends r {
              constructor(e, t, r) {
                super(),
                  (e = n.normalizeQueryConfig(e, t, r)),
                  (this.text = e.text),
                  (this.values = e.values),
                  (this.rows = e.rows),
                  (this.types = e.types),
                  (this.name = e.name),
                  (this.binary = e.binary),
                  (this.portal = e.portal || ""),
                  (this.callback = e.callback),
                  (this._rowMode = e.rowMode),
                  l.domain &&
                    e.callback &&
                    (this.callback = l.domain.bind(e.callback)),
                  (this._result = new i(this._rowMode, this.types)),
                  (this._results = this._result),
                  (this.isPreparedStatement = !1),
                  (this._canceledDueToError = !1),
                  (this._promise = null);
              }
              requiresPreparation() {
                return (
                  !!this.name ||
                  !!this.rows ||
                  (!!this.text && !!this.values && this.values.length > 0)
                );
              }
              _checkForMultirow() {
                this._result.command &&
                  (Array.isArray(this._results) ||
                    (this._results = [this._result]),
                  (this._result = new i(this._rowMode, this.types)),
                  this._results.push(this._result));
              }
              handleRowDescription(e) {
                this._checkForMultirow(),
                  this._result.addFields(e.fields),
                  (this._accumulateRows =
                    this.callback || !this.listeners("row").length);
              }
              handleDataRow(e) {
                let t;
                if (!this._canceledDueToError) {
                  try {
                    t = this._result.parseRow(e.fields);
                  } catch (e) {
                    this._canceledDueToError = e;
                    return;
                  }
                  this.emit("row", t, this._result),
                    this._accumulateRows && this._result.addRow(t);
                }
              }
              handleCommandComplete(e, t) {
                this._checkForMultirow(),
                  this._result.addCommandComplete(e),
                  this.rows && t.sync();
              }
              handleEmptyQuery(e) {
                this.rows && e.sync();
              }
              handleError(e, t) {
                if (
                  (this._canceledDueToError &&
                    ((e = this._canceledDueToError),
                    (this._canceledDueToError = !1)),
                  this.callback)
                )
                  return this.callback(e);
                this.emit("error", e);
              }
              handleReadyForQuery(e) {
                if (this._canceledDueToError)
                  return this.handleError(this._canceledDueToError, e);
                if (this.callback)
                  try {
                    this.callback(null, this._results);
                  } catch (e) {
                    l.nextTick(() => {
                      throw e;
                    });
                  }
                this.emit("end", this._results);
              }
              submit(e) {
                if (
                  "string" != typeof this.text &&
                  "string" != typeof this.name
                )
                  return Error(
                    "A query must have either text or a name. Supplying neither is unsupported."
                  );
                let t = e.parsedStatements[this.name];
                return this.text && t && this.text !== t
                  ? Error(`Prepared statements must be unique - '${this.name}\
' was used for a different statement`)
                  : this.values && !Array.isArray(this.values)
                    ? Error("Query values must be an array")
                    : (this.requiresPreparation()
                        ? this.prepare(e)
                        : e.query(this.text),
                      null);
              }
              hasBeenParsed(e) {
                return this.name && e.parsedStatements[this.name];
              }
              handlePortalSuspended(e) {
                this._getRows(e, this.rows);
              }
              _getRows(e, t) {
                e.execute({ portal: this.portal, rows: t }),
                  t ? e.flush() : e.sync();
              }
              prepare(e) {
                (this.isPreparedStatement = !0),
                  this.hasBeenParsed(e) ||
                    e.parse({
                      text: this.text,
                      name: this.name,
                      types: this.types,
                    });
                try {
                  e.bind({
                    portal: this.portal,
                    statement: this.name,
                    values: this.values,
                    binary: this.binary,
                    valueMapper: n.prepareValue,
                  });
                } catch (t) {
                  this.handleError(t, e);
                  return;
                }
                e.describe({ type: "P", name: this.portal || "" }),
                  this._getRows(e, this.rows);
              }
              handleCopyInResponse(e) {
                e.sendCopyFail("No source stream defined");
              }
              handleCopyData(e, t) {}
            };
          y(s, "Query"), (t.exports = s);
        }),
        eq = w((e) => {
          A(),
            Object.defineProperty(e, "__esModule", { value: !0 }),
            (e.NoticeMessage =
              e.DataRowMessage =
              e.CommandCompleteMessage =
              e.ReadyForQueryMessage =
              e.NotificationResponseMessage =
              e.BackendKeyDataMessage =
              e.AuthenticationMD5Password =
              e.ParameterStatusMessage =
              e.ParameterDescriptionMessage =
              e.RowDescriptionMessage =
              e.Field =
              e.CopyResponse =
              e.CopyDataMessage =
              e.DatabaseError =
              e.copyDone =
              e.emptyQuery =
              e.replicationStart =
              e.portalSuspended =
              e.noData =
              e.closeComplete =
              e.bindComplete =
              e.parseComplete =
                void 0),
            (e.parseComplete = { name: "parseComplete", length: 5 }),
            (e.bindComplete = { name: "bindComplete", length: 5 }),
            (e.closeComplete = { name: "closeComplete", length: 5 }),
            (e.noData = { name: "noData", length: 5 }),
            (e.portalSuspended = { name: "portalSuspended", length: 5 }),
            (e.replicationStart = { name: "replicationStart", length: 4 }),
            (e.emptyQuery = { name: "emptyQuery", length: 4 }),
            (e.copyDone = { name: "copyDone", length: 4 });
          var t = class extends Error {
            constructor(e, t, r) {
              super(e), (this.length = t), (this.name = r);
            }
          };
          y(t, "DatabaseError"), (e.DatabaseError = t);
          var r = class {
            constructor(e, t) {
              (this.length = e), (this.chunk = t), (this.name = "copyData");
            }
          };
          y(r, "CopyDataMessage"), (e.CopyDataMessage = r);
          var i = class {
            constructor(e, t, r, i) {
              (this.length = e),
                (this.name = t),
                (this.binary = r),
                (this.columnTypes = Array(i));
            }
          };
          y(i, "CopyResponse"), (e.CopyResponse = i);
          var n = class {
            constructor(e, t, r, i, n, s, o) {
              (this.name = e),
                (this.tableID = t),
                (this.columnID = r),
                (this.dataTypeID = i),
                (this.dataTypeSize = n),
                (this.dataTypeModifier = s),
                (this.format = o);
            }
          };
          y(n, "Field"), (e.Field = n);
          var s = class {
            constructor(e, t) {
              (this.length = e),
                (this.fieldCount = t),
                (this.name = "rowDescription"),
                (this.fields = Array(this.fieldCount));
            }
          };
          y(s, "RowDescriptionMessage"), (e.RowDescriptionMessage = s);
          var o = class {
            constructor(e, t) {
              (this.length = e),
                (this.parameterCount = t),
                (this.name = "parameterDescription"),
                (this.dataTypeIDs = Array(this.parameterCount));
            }
          };
          y(o, "ParameterDescriptionMessage"),
            (e.ParameterDescriptionMessage = o);
          var a = class {
            constructor(e, t, r) {
              (this.length = e),
                (this.parameterName = t),
                (this.parameterValue = r),
                (this.name = "parameterStatus");
            }
          };
          y(a, "ParameterStatusMessage"), (e.ParameterStatusMessage = a);
          var l = class {
            constructor(e, t) {
              (this.length = e),
                (this.salt = t),
                (this.name = "authenticationMD5Password");
            }
          };
          y(l, "AuthenticationMD5Password"), (e.AuthenticationMD5Password = l);
          var c = class {
            constructor(e, t, r) {
              (this.length = e),
                (this.processID = t),
                (this.secretKey = r),
                (this.name = "backendKeyData");
            }
          };
          y(c, "BackendKeyDataMessage"), (e.BackendKeyDataMessage = c);
          var d = class {
            constructor(e, t, r, i) {
              (this.length = e),
                (this.processId = t),
                (this.channel = r),
                (this.payload = i),
                (this.name = "notification");
            }
          };
          y(d, "NotificationResponseMessage"),
            (e.NotificationResponseMessage = d);
          var u = class {
            constructor(e, t) {
              (this.length = e),
                (this.status = t),
                (this.name = "readyForQuery");
            }
          };
          y(u, "ReadyForQueryMessage"), (e.ReadyForQueryMessage = u);
          var h = class {
            constructor(e, t) {
              (this.length = e),
                (this.text = t),
                (this.name = "commandComplete");
            }
          };
          y(h, "CommandCompleteMessage"), (e.CommandCompleteMessage = h);
          var p = class {
            constructor(e, t) {
              (this.length = e),
                (this.fields = t),
                (this.name = "dataRow"),
                (this.fieldCount = t.length);
            }
          };
          y(p, "DataRowMessage"), (e.DataRowMessage = p);
          var f = class {
            constructor(e, t) {
              (this.length = e), (this.message = t), (this.name = "notice");
            }
          };
          y(f, "NoticeMessage"), (e.NoticeMessage = f);
        }),
        eU = w((e) => {
          A(),
            Object.defineProperty(e, "__esModule", { value: !0 }),
            (e.Writer = void 0);
          var t = class {
            constructor(e = 256) {
              (this.size = e),
                (this.offset = 5),
                (this.headerPosition = 0),
                (this.buffer = a.allocUnsafe(e));
            }
            ensure(e) {
              if (this.buffer.length - this.offset < e) {
                let t = this.buffer,
                  r = t.length + (t.length >> 1) + e;
                (this.buffer = a.allocUnsafe(r)), t.copy(this.buffer);
              }
            }
            addInt32(e) {
              return (
                this.ensure(4),
                (this.buffer[this.offset++] = (e >>> 24) & 255),
                (this.buffer[this.offset++] = (e >>> 16) & 255),
                (this.buffer[this.offset++] = (e >>> 8) & 255),
                (this.buffer[this.offset++] = (e >>> 0) & 255),
                this
              );
            }
            addInt16(e) {
              return (
                this.ensure(2),
                (this.buffer[this.offset++] = (e >>> 8) & 255),
                (this.buffer[this.offset++] = (e >>> 0) & 255),
                this
              );
            }
            addCString(e) {
              if (e) {
                let t = a.byteLength(e);
                this.ensure(t + 1),
                  this.buffer.write(e, this.offset, "utf-8"),
                  (this.offset += t);
              } else this.ensure(1);
              return (this.buffer[this.offset++] = 0), this;
            }
            addString(e = "") {
              let t = a.byteLength(e);
              return (
                this.ensure(t),
                this.buffer.write(e, this.offset),
                (this.offset += t),
                this
              );
            }
            add(e) {
              return (
                this.ensure(e.length),
                e.copy(this.buffer, this.offset),
                (this.offset += e.length),
                this
              );
            }
            join(e) {
              if (e) {
                this.buffer[this.headerPosition] = e;
                let t = this.offset - (this.headerPosition + 1);
                this.buffer.writeInt32BE(t, this.headerPosition + 1);
              }
              return this.buffer.slice(5 * !e, this.offset);
            }
            flush(e) {
              let t = this.join(e);
              return (
                (this.offset = 5),
                (this.headerPosition = 0),
                (this.buffer = a.allocUnsafe(this.size)),
                t
              );
            }
          };
          y(t, "Writer"), (e.Writer = t);
        }),
        e$ = w((e) => {
          A(),
            Object.defineProperty(e, "__esModule", { value: !0 }),
            (e.serialize = void 0);
          var t = eU(),
            r = new t.Writer(),
            i = y((e) => {
              for (let t of (r.addInt16(3).addInt16(0), Object.keys(e)))
                r.addCString(t).addCString(e[t]);
              r.addCString("client_encoding").addCString("UTF8");
              let i = r.addCString("").flush(),
                n = i.length + 4;
              return new t.Writer().addInt32(n).add(i).flush();
            }, "startup"),
            n = y(() => {
              let e = a.allocUnsafe(8);
              return e.writeInt32BE(8, 0), e.writeInt32BE(0x4d2162f, 4), e;
            }, "requestSsl"),
            s = y((e) => r.addCString(e).flush(112), "password"),
            o = y(function (e, t) {
              return (
                r.addCString(e).addInt32(a.byteLength(t)).addString(t),
                r.flush(112)
              );
            }, "sendSASLInitialResponseMessage"),
            l = y(function (e) {
              return r.addString(e).flush(112);
            }, "sendSCRAMClientFinalMessage"),
            c = y((e) => r.addCString(e).flush(81), "query"),
            d = [],
            u = y((e) => {
              let t = e.name || "";
              t.length > 63 &&
                (console.error(
                  "Warning! Postgres only supports 63 characters for query names."
                ),
                console.error("You supplied %s (%s)", t, t.length),
                console.error(
                  "This can cause conflicts and silent errors executing queries"
                ));
              let i = e.types || d,
                n = i.length,
                s = r.addCString(t).addCString(e.text).addInt16(n);
              for (let e = 0; e < n; e++) s.addInt32(i[e]);
              return r.flush(80);
            }, "parse"),
            h = new t.Writer(),
            p = y(function (e, t) {
              for (let i = 0; i < e.length; i++) {
                let n = t ? t(e[i], i) : e[i];
                null == n
                  ? (r.addInt16(0), h.addInt32(-1))
                  : n instanceof a
                    ? (r.addInt16(1), h.addInt32(n.length), h.add(n))
                    : (r.addInt16(0),
                      h.addInt32(a.byteLength(n)),
                      h.addString(n));
              }
            }, "writeValues"),
            f = y((e = {}) => {
              let t = e.portal || "",
                i = e.statement || "",
                n = e.binary || !1,
                s = e.values || d,
                o = s.length;
              return (
                r.addCString(t).addCString(i),
                r.addInt16(o),
                p(s, e.valueMapper),
                r.addInt16(o),
                r.add(h.flush()),
                r.addInt16(+!!n),
                r.flush(66)
              );
            }, "bind"),
            m = a.from([69, 0, 0, 0, 9, 0, 0, 0, 0, 0]),
            g = y((e) => {
              if (!e || (!e.portal && !e.rows)) return m;
              let t = e.portal || "",
                r = e.rows || 0,
                i = a.byteLength(t),
                n = 4 + i + 1 + 4,
                s = a.allocUnsafe(1 + n);
              return (
                (s[0] = 69),
                s.writeInt32BE(n, 1),
                s.write(t, 5, "utf-8"),
                (s[i + 5] = 0),
                s.writeUInt32BE(r, s.length - 4),
                s
              );
            }, "execute"),
            w = y((e, t) => {
              let r = a.allocUnsafe(16);
              return (
                r.writeInt32BE(16, 0),
                r.writeInt16BE(1234, 4),
                r.writeInt16BE(5678, 6),
                r.writeInt32BE(e, 8),
                r.writeInt32BE(t, 12),
                r
              );
            }, "cancel"),
            b = y((e, t) => {
              let r = 4 + a.byteLength(t) + 1,
                i = a.allocUnsafe(1 + r);
              return (
                (i[0] = e),
                i.writeInt32BE(r, 1),
                i.write(t, 5, "utf-8"),
                (i[r] = 0),
                i
              );
            }, "cstringMessage"),
            v = r.addCString("P").flush(68),
            N = r.addCString("S").flush(68),
            x = y(
              (e) =>
                e.name
                  ? b(68, `${e.type}${e.name || ""}`)
                  : "P" === e.type
                    ? v
                    : N,
              "describe"
            ),
            _ = y((e) => b(67, `${e.type}${e.name || ""}`), "close"),
            S = y((e) => r.add(e).flush(100), "copyData"),
            T = y((e) => b(102, e), "copyFail"),
            k = y((e) => a.from([e, 0, 0, 0, 4]), "codeOnlyBuffer"),
            E = k(72),
            C = k(83),
            I = k(88),
            O = k(99);
          e.serialize = {
            startup: i,
            password: s,
            requestSsl: n,
            sendSASLInitialResponseMessage: o,
            sendSCRAMClientFinalMessage: l,
            query: c,
            parse: u,
            bind: f,
            execute: g,
            describe: x,
            close: _,
            flush: y(() => E, "flush"),
            sync: y(() => C, "sync"),
            end: y(() => I, "end"),
            copyData: S,
            copyDone: y(() => O, "copyDone"),
            copyFail: T,
            cancel: w,
          };
        }),
        eB = w((e) => {
          A(),
            Object.defineProperty(e, "__esModule", { value: !0 }),
            (e.BufferReader = void 0);
          var t = a.allocUnsafe(0),
            r = class {
              constructor(e = 0) {
                (this.offset = e), (this.buffer = t), (this.encoding = "utf-8");
              }
              setBuffer(e, t) {
                (this.offset = e), (this.buffer = t);
              }
              int16() {
                let e = this.buffer.readInt16BE(this.offset);
                return (this.offset += 2), e;
              }
              byte() {
                let e = this.buffer[this.offset];
                return this.offset++, e;
              }
              int32() {
                let e = this.buffer.readInt32BE(this.offset);
                return (this.offset += 4), e;
              }
              uint32() {
                let e = this.buffer.readUInt32BE(this.offset);
                return (this.offset += 4), e;
              }
              string(e) {
                let t = this.buffer.toString(
                  this.encoding,
                  this.offset,
                  this.offset + e
                );
                return (this.offset += e), t;
              }
              cstring() {
                let e = this.offset,
                  t = e;
                for (; 0 !== this.buffer[t++]; );
                return (
                  (this.offset = t),
                  this.buffer.toString(this.encoding, e, t - 1)
                );
              }
              bytes(e) {
                let t = this.buffer.slice(this.offset, this.offset + e);
                return (this.offset += e), t;
              }
            };
          y(r, "BufferReader"), (e.BufferReader = r);
        }),
        eM = w((e) => {
          A(),
            Object.defineProperty(e, "__esModule", { value: !0 }),
            (e.Parser = void 0);
          var t = eq(),
            r = eB(),
            i = a.allocUnsafe(0),
            n = class {
              constructor(e) {
                if (
                  ((this.buffer = i),
                  (this.bufferLength = 0),
                  (this.bufferOffset = 0),
                  (this.reader = new r.BufferReader()),
                  e?.mode === "binary")
                )
                  throw Error("Binary mode not supported yet");
                this.mode = e?.mode || "text";
              }
              parse(e, t) {
                this.mergeBuffer(e);
                let r = this.bufferOffset + this.bufferLength,
                  n = this.bufferOffset;
                for (; n + 5 <= r; ) {
                  let e = this.buffer[n],
                    i = this.buffer.readUInt32BE(n + 1),
                    s = 1 + i;
                  if (s + n <= r)
                    t(this.handlePacket(n + 5, e, i, this.buffer)), (n += s);
                  else break;
                }
                n === r
                  ? ((this.buffer = i),
                    (this.bufferLength = 0),
                    (this.bufferOffset = 0))
                  : ((this.bufferLength = r - n), (this.bufferOffset = n));
              }
              mergeBuffer(e) {
                if (this.bufferLength > 0) {
                  let t = this.bufferLength + e.byteLength;
                  if (t + this.bufferOffset > this.buffer.byteLength) {
                    let e;
                    if (
                      t <= this.buffer.byteLength &&
                      this.bufferOffset >= this.bufferLength
                    )
                      e = this.buffer;
                    else {
                      let r = 2 * this.buffer.byteLength;
                      for (; t >= r; ) r *= 2;
                      e = a.allocUnsafe(r);
                    }
                    this.buffer.copy(
                      e,
                      0,
                      this.bufferOffset,
                      this.bufferOffset + this.bufferLength
                    ),
                      (this.buffer = e),
                      (this.bufferOffset = 0);
                  }
                  e.copy(this.buffer, this.bufferOffset + this.bufferLength),
                    (this.bufferLength = t);
                } else
                  (this.buffer = e),
                    (this.bufferOffset = 0),
                    (this.bufferLength = e.byteLength);
              }
              handlePacket(e, r, i, n) {
                switch (r) {
                  case 50:
                    return t.bindComplete;
                  case 49:
                    return t.parseComplete;
                  case 51:
                    return t.closeComplete;
                  case 110:
                    return t.noData;
                  case 115:
                    return t.portalSuspended;
                  case 99:
                    return t.copyDone;
                  case 87:
                    return t.replicationStart;
                  case 73:
                    return t.emptyQuery;
                  case 68:
                    return this.parseDataRowMessage(e, i, n);
                  case 67:
                    return this.parseCommandCompleteMessage(e, i, n);
                  case 90:
                    return this.parseReadyForQueryMessage(e, i, n);
                  case 65:
                    return this.parseNotificationMessage(e, i, n);
                  case 82:
                    return this.parseAuthenticationResponse(e, i, n);
                  case 83:
                    return this.parseParameterStatusMessage(e, i, n);
                  case 75:
                    return this.parseBackendKeyData(e, i, n);
                  case 69:
                    return this.parseErrorMessage(e, i, n, "error");
                  case 78:
                    return this.parseErrorMessage(e, i, n, "notice");
                  case 84:
                    return this.parseRowDescriptionMessage(e, i, n);
                  case 116:
                    return this.parseParameterDescriptionMessage(e, i, n);
                  case 71:
                    return this.parseCopyInMessage(e, i, n);
                  case 72:
                    return this.parseCopyOutMessage(e, i, n);
                  case 100:
                    return this.parseCopyData(e, i, n);
                  default:
                    return new t.DatabaseError(
                      "received invalid response: " + r.toString(16),
                      i,
                      "error"
                    );
                }
              }
              parseReadyForQueryMessage(e, r, i) {
                this.reader.setBuffer(e, i);
                let n = this.reader.string(1);
                return new t.ReadyForQueryMessage(r, n);
              }
              parseCommandCompleteMessage(e, r, i) {
                this.reader.setBuffer(e, i);
                let n = this.reader.cstring();
                return new t.CommandCompleteMessage(r, n);
              }
              parseCopyData(e, r, i) {
                let n = i.slice(e, e + (r - 4));
                return new t.CopyDataMessage(r, n);
              }
              parseCopyInMessage(e, t, r) {
                return this.parseCopyMessage(e, t, r, "copyInResponse");
              }
              parseCopyOutMessage(e, t, r) {
                return this.parseCopyMessage(e, t, r, "copyOutResponse");
              }
              parseCopyMessage(e, r, i, n) {
                this.reader.setBuffer(e, i);
                let s = 0 !== this.reader.byte(),
                  o = this.reader.int16(),
                  a = new t.CopyResponse(r, n, s, o);
                for (let e = 0; e < o; e++)
                  a.columnTypes[e] = this.reader.int16();
                return a;
              }
              parseNotificationMessage(e, r, i) {
                this.reader.setBuffer(e, i);
                let n = this.reader.int32(),
                  s = this.reader.cstring(),
                  o = this.reader.cstring();
                return new t.NotificationResponseMessage(r, n, s, o);
              }
              parseRowDescriptionMessage(e, r, i) {
                this.reader.setBuffer(e, i);
                let n = this.reader.int16(),
                  s = new t.RowDescriptionMessage(r, n);
                for (let e = 0; e < n; e++) s.fields[e] = this.parseField();
                return s;
              }
              parseField() {
                let e = this.reader.cstring(),
                  r = this.reader.uint32(),
                  i = this.reader.int16(),
                  n = this.reader.uint32(),
                  s = this.reader.int16(),
                  o = this.reader.int32(),
                  a = 0 === this.reader.int16() ? "text" : "binary";
                return new t.Field(e, r, i, n, s, o, a);
              }
              parseParameterDescriptionMessage(e, r, i) {
                this.reader.setBuffer(e, i);
                let n = this.reader.int16(),
                  s = new t.ParameterDescriptionMessage(r, n);
                for (let e = 0; e < n; e++)
                  s.dataTypeIDs[e] = this.reader.int32();
                return s;
              }
              parseDataRowMessage(e, r, i) {
                this.reader.setBuffer(e, i);
                let n = this.reader.int16(),
                  s = Array(n);
                for (let e = 0; e < n; e++) {
                  let t = this.reader.int32();
                  s[e] = -1 === t ? null : this.reader.string(t);
                }
                return new t.DataRowMessage(r, s);
              }
              parseParameterStatusMessage(e, r, i) {
                this.reader.setBuffer(e, i);
                let n = this.reader.cstring(),
                  s = this.reader.cstring();
                return new t.ParameterStatusMessage(r, n, s);
              }
              parseBackendKeyData(e, r, i) {
                this.reader.setBuffer(e, i);
                let n = this.reader.int32(),
                  s = this.reader.int32();
                return new t.BackendKeyDataMessage(r, n, s);
              }
              parseAuthenticationResponse(e, r, i) {
                this.reader.setBuffer(e, i);
                let n = this.reader.int32(),
                  s = { name: "authenticationOk", length: r };
                switch (n) {
                  case 0:
                    break;
                  case 3:
                    8 === s.length &&
                      (s.name = "authenticationCleartextPassword");
                    break;
                  case 5:
                    if (12 === s.length) {
                      s.name = "authenticationMD5Password";
                      let e = this.reader.bytes(4);
                      return new t.AuthenticationMD5Password(r, e);
                    }
                    break;
                  case 10:
                    {
                      let e;
                      (s.name = "authenticationSASL"), (s.mechanisms = []);
                      do (e = this.reader.cstring()) && s.mechanisms.push(e);
                      while (e);
                    }
                    break;
                  case 11:
                    (s.name = "authenticationSASLContinue"),
                      (s.data = this.reader.string(r - 8));
                    break;
                  case 12:
                    (s.name = "authenticationSASLFinal"),
                      (s.data = this.reader.string(r - 8));
                    break;
                  default:
                    throw Error("Unknown authenticationOk message type " + n);
                }
                return s;
              }
              parseErrorMessage(e, r, i, n) {
                this.reader.setBuffer(e, i);
                let s = {},
                  o = this.reader.string(1);
                for (; "\0" !== o; )
                  (s[o] = this.reader.cstring()), (o = this.reader.string(1));
                let a = s.M,
                  l =
                    "notice" === n
                      ? new t.NoticeMessage(r, a)
                      : new t.DatabaseError(a, r, n);
                return (
                  (l.severity = s.S),
                  (l.code = s.C),
                  (l.detail = s.D),
                  (l.hint = s.H),
                  (l.position = s.P),
                  (l.internalPosition = s.p),
                  (l.internalQuery = s.q),
                  (l.where = s.W),
                  (l.schema = s.s),
                  (l.table = s.t),
                  (l.column = s.c),
                  (l.dataType = s.d),
                  (l.constraint = s.n),
                  (l.file = s.F),
                  (l.line = s.L),
                  (l.routine = s.R),
                  l
                );
              }
            };
          y(n, "Parser"), (e.Parser = n);
        }),
        ej = w((e) => {
          A(),
            Object.defineProperty(e, "__esModule", { value: !0 }),
            (e.DatabaseError = e.serialize = e.parse = void 0);
          var t = eq();
          Object.defineProperty(e, "DatabaseError", {
            enumerable: !0,
            get: y(function () {
              return t.DatabaseError;
            }, "get"),
          });
          var r = e$();
          Object.defineProperty(e, "serialize", {
            enumerable: !0,
            get: y(function () {
              return r.serialize;
            }, "get"),
          });
          var i = eM();
          function n(e, t) {
            let r = new i.Parser();
            return (
              e.on("data", (e) => r.parse(e, t)),
              new Promise((t) => e.on("end", () => t()))
            );
          }
          y(n, "parse"), (e.parse = n);
        }),
        eW = {};
      function eF({ socket: e, servername: t }) {
        return e.startTls(t), e;
      }
      b(eW, { connect: () => eF });
      var eQ = g(() => {
          A(), y(eF, "connect");
        }),
        ez = w((e, t) => {
          A();
          var r = (D(), x(C)),
            i = E().EventEmitter,
            { parse: n, serialize: s } = ej(),
            o = s.flush(),
            a = s.sync(),
            l = s.end(),
            c = class extends i {
              constructor(e) {
                super(),
                  (e = e || {}),
                  (this.stream = e.stream || new r.Socket()),
                  (this._keepAlive = e.keepAlive),
                  (this._keepAliveInitialDelayMillis =
                    e.keepAliveInitialDelayMillis),
                  (this.lastBuffer = !1),
                  (this.parsedStatements = {}),
                  (this.ssl = e.ssl || !1),
                  (this._ending = !1),
                  (this._emitMessage = !1);
                var t = this;
                this.on("newListener", function (e) {
                  "message" === e && (t._emitMessage = !0);
                });
              }
              connect(e, t) {
                var i = this;
                (this._connecting = !0),
                  this.stream.setNoDelay(!0),
                  this.stream.connect(e, t),
                  this.stream.once("connect", function () {
                    i._keepAlive &&
                      i.stream.setKeepAlive(!0, i._keepAliveInitialDelayMillis),
                      i.emit("connect");
                  });
                let n = y(function (e) {
                  (i._ending &&
                    ("ECONNRESET" === e.code || "EPIPE" === e.code)) ||
                    i.emit("error", e);
                }, "reportStreamError");
                if (
                  (this.stream.on("error", n),
                  this.stream.on("close", function () {
                    i.emit("end");
                  }),
                  !this.ssl)
                )
                  return this.attachListeners(this.stream);
                this.stream.once("data", function (e) {
                  switch (e.toString("utf8")) {
                    case "S":
                      break;
                    case "N":
                      return (
                        i.stream.end(),
                        i.emit(
                          "error",
                          Error("The server does not support SSL connections")
                        )
                      );
                    default:
                      return (
                        i.stream.end(),
                        i.emit(
                          "error",
                          Error(
                            "There was an error establishing an SSL connection"
                          )
                        )
                      );
                  }
                  var s = (eQ(), x(eW));
                  let o = { socket: i.stream };
                  !0 !== i.ssl &&
                    (Object.assign(o, i.ssl),
                    "key" in i.ssl && (o.key = i.ssl.key)),
                    0 === r.isIP(t) && (o.servername = t);
                  try {
                    i.stream = s.connect(o);
                  } catch (e) {
                    return i.emit("error", e);
                  }
                  i.attachListeners(i.stream),
                    i.stream.on("error", n),
                    i.emit("sslconnect");
                });
              }
              attachListeners(e) {
                e.on("end", () => {
                  this.emit("end");
                }),
                  n(e, (e) => {
                    var t = "error" === e.name ? "errorMessage" : e.name;
                    this._emitMessage && this.emit("message", e),
                      this.emit(t, e);
                  });
              }
              requestSsl() {
                this.stream.write(s.requestSsl());
              }
              startup(e) {
                this.stream.write(s.startup(e));
              }
              cancel(e, t) {
                this._send(s.cancel(e, t));
              }
              password(e) {
                this._send(s.password(e));
              }
              sendSASLInitialResponseMessage(e, t) {
                this._send(s.sendSASLInitialResponseMessage(e, t));
              }
              sendSCRAMClientFinalMessage(e) {
                this._send(s.sendSCRAMClientFinalMessage(e));
              }
              _send(e) {
                return !!this.stream.writable && this.stream.write(e);
              }
              query(e) {
                this._send(s.query(e));
              }
              parse(e) {
                this._send(s.parse(e));
              }
              bind(e) {
                this._send(s.bind(e));
              }
              execute(e) {
                this._send(s.execute(e));
              }
              flush() {
                this.stream.writable && this.stream.write(o);
              }
              sync() {
                (this._ending = !0), this._send(o), this._send(a);
              }
              ref() {
                this.stream.ref();
              }
              unref() {
                this.stream.unref();
              }
              end() {
                return ((this._ending = !0),
                this._connecting && this.stream.writable)
                  ? this.stream.write(l, () => {
                      this.stream.end();
                    })
                  : void this.stream.end();
              }
              close(e) {
                this._send(s.close(e));
              }
              describe(e) {
                this._send(s.describe(e));
              }
              sendCopyFromChunk(e) {
                this._send(s.copyData(e));
              }
              endCopyFrom() {
                this._send(s.copyDone());
              }
              sendCopyFail(e) {
                this._send(s.copyFail(e));
              }
            };
          y(c, "Connection"), (t.exports = c);
        }),
        eV = w((e, t) => {
          A();
          var r = E().EventEmitter,
            i = (eu(), x(ec), el()),
            n = eh(),
            o = eE(),
            a = J(),
            c = eR(),
            d = eD(),
            u = ea(),
            h = ez(),
            p = class extends r {
              constructor(e) {
                super(),
                  (this.connectionParameters = new c(e)),
                  (this.user = this.connectionParameters.user),
                  (this.database = this.connectionParameters.database),
                  (this.port = this.connectionParameters.port),
                  (this.host = this.connectionParameters.host),
                  Object.defineProperty(this, "password", {
                    configurable: !0,
                    enumerable: !1,
                    writable: !0,
                    value: this.connectionParameters.password,
                  }),
                  (this.replication = this.connectionParameters.replication);
                var t = e || {};
                (this._Promise = t.Promise || s.Promise),
                  (this._types = new a(t.types)),
                  (this._ending = !1),
                  (this._connecting = !1),
                  (this._connected = !1),
                  (this._connectionError = !1),
                  (this._queryable = !0),
                  (this.connection =
                    t.connection ||
                    new h({
                      stream: t.stream,
                      ssl: this.connectionParameters.ssl,
                      keepAlive: t.keepAlive || !1,
                      keepAliveInitialDelayMillis:
                        t.keepAliveInitialDelayMillis || 0,
                      encoding:
                        this.connectionParameters.client_encoding || "utf8",
                    })),
                  (this.queryQueue = []),
                  (this.binary = t.binary || u.binary),
                  (this.processID = null),
                  (this.secretKey = null),
                  (this.ssl = this.connectionParameters.ssl || !1),
                  this.ssl &&
                    this.ssl.key &&
                    Object.defineProperty(this.ssl, "key", { enumerable: !1 }),
                  (this._connectionTimeoutMillis =
                    t.connectionTimeoutMillis || 0);
              }
              _errorAllQueries(e) {
                let t = y((t) => {
                  l.nextTick(() => {
                    t.handleError(e, this.connection);
                  });
                }, "enqueueError");
                this.activeQuery &&
                  (t(this.activeQuery), (this.activeQuery = null)),
                  this.queryQueue.forEach(t),
                  (this.queryQueue.length = 0);
              }
              _connect(e) {
                var t = this,
                  r = this.connection;
                if (
                  ((this._connectionCallback = e),
                  this._connecting || this._connected)
                ) {
                  let t = Error(
                    "Client has already been connected. You cannot reuse a client."
                  );
                  l.nextTick(() => {
                    e(t);
                  });
                  return;
                }
                (this._connecting = !0),
                  this.connectionTimeoutHandle,
                  this._connectionTimeoutMillis > 0 &&
                    (this.connectionTimeoutHandle = setTimeout(() => {
                      (r._ending = !0),
                        r.stream.destroy(Error("timeout expired"));
                    }, this._connectionTimeoutMillis)),
                  this.host && 0 === this.host.indexOf("/")
                    ? r.connect(this.host + "/.s.PGSQL." + this.port)
                    : r.connect(this.port, this.host),
                  r.on("connect", function () {
                    t.ssl ? r.requestSsl() : r.startup(t.getStartupConf());
                  }),
                  r.on("sslconnect", function () {
                    r.startup(t.getStartupConf());
                  }),
                  this._attachListeners(r),
                  r.once("end", () => {
                    let e = this._ending
                      ? Error("Connection terminated")
                      : Error("Connection terminated unexpectedly");
                    clearTimeout(this.connectionTimeoutHandle),
                      this._errorAllQueries(e),
                      this._ending ||
                        (this._connecting && !this._connectionError
                          ? this._connectionCallback
                            ? this._connectionCallback(e)
                            : this._handleErrorEvent(e)
                          : this._connectionError || this._handleErrorEvent(e)),
                      l.nextTick(() => {
                        this.emit("end");
                      });
                  });
              }
              connect(e) {
                return e
                  ? void this._connect(e)
                  : new this._Promise((e, t) => {
                      this._connect((r) => {
                        r ? t(r) : e();
                      });
                    });
              }
              _attachListeners(e) {
                e.on(
                  "authenticationCleartextPassword",
                  this._handleAuthCleartextPassword.bind(this)
                ),
                  e.on(
                    "authenticationMD5Password",
                    this._handleAuthMD5Password.bind(this)
                  ),
                  e.on("authenticationSASL", this._handleAuthSASL.bind(this)),
                  e.on(
                    "authenticationSASLContinue",
                    this._handleAuthSASLContinue.bind(this)
                  ),
                  e.on(
                    "authenticationSASLFinal",
                    this._handleAuthSASLFinal.bind(this)
                  ),
                  e.on("backendKeyData", this._handleBackendKeyData.bind(this)),
                  e.on("error", this._handleErrorEvent.bind(this)),
                  e.on("errorMessage", this._handleErrorMessage.bind(this)),
                  e.on("readyForQuery", this._handleReadyForQuery.bind(this)),
                  e.on("notice", this._handleNotice.bind(this)),
                  e.on("rowDescription", this._handleRowDescription.bind(this)),
                  e.on("dataRow", this._handleDataRow.bind(this)),
                  e.on(
                    "portalSuspended",
                    this._handlePortalSuspended.bind(this)
                  ),
                  e.on("emptyQuery", this._handleEmptyQuery.bind(this)),
                  e.on(
                    "commandComplete",
                    this._handleCommandComplete.bind(this)
                  ),
                  e.on("parseComplete", this._handleParseComplete.bind(this)),
                  e.on("copyInResponse", this._handleCopyInResponse.bind(this)),
                  e.on("copyData", this._handleCopyData.bind(this)),
                  e.on("notification", this._handleNotification.bind(this));
              }
              _checkPgPass(e) {
                let t = this.connection;
                "function" == typeof this.password
                  ? this._Promise
                      .resolve()
                      .then(() => this.password())
                      .then((r) => {
                        if (void 0 !== r) {
                          if ("string" != typeof r)
                            return void t.emit(
                              "error",
                              TypeError("Password must be a string")
                            );
                          this.connectionParameters.password = this.password =
                            r;
                        } else
                          this.connectionParameters.password = this.password =
                            null;
                        e();
                      })
                      .catch((e) => {
                        t.emit("error", e);
                      })
                  : null !== this.password
                    ? e()
                    : o(this.connectionParameters, (t) => {
                        void 0 !== t &&
                          (this.connectionParameters.password = this.password =
                            t),
                          e();
                      });
              }
              _handleAuthCleartextPassword(e) {
                this._checkPgPass(() => {
                  this.connection.password(this.password);
                });
              }
              _handleAuthMD5Password(e) {
                this._checkPgPass(() => {
                  let t = i.postgresMd5PasswordHash(
                    this.user,
                    this.password,
                    e.salt
                  );
                  this.connection.password(t);
                });
              }
              _handleAuthSASL(e) {
                this._checkPgPass(() => {
                  (this.saslSession = n.startSession(e.mechanisms)),
                    this.connection.sendSASLInitialResponseMessage(
                      this.saslSession.mechanism,
                      this.saslSession.response
                    );
                });
              }
              _handleAuthSASLContinue(e) {
                n.continueSession(this.saslSession, this.password, e.data),
                  this.connection.sendSCRAMClientFinalMessage(
                    this.saslSession.response
                  );
              }
              _handleAuthSASLFinal(e) {
                n.finalizeSession(this.saslSession, e.data),
                  (this.saslSession = null);
              }
              _handleBackendKeyData(e) {
                (this.processID = e.processID), (this.secretKey = e.secretKey);
              }
              _handleReadyForQuery(e) {
                this._connecting &&
                  ((this._connecting = !1),
                  (this._connected = !0),
                  clearTimeout(this.connectionTimeoutHandle),
                  this._connectionCallback &&
                    (this._connectionCallback(null, this),
                    (this._connectionCallback = null)),
                  this.emit("connect"));
                let { activeQuery: t } = this;
                (this.activeQuery = null),
                  (this.readyForQuery = !0),
                  t && t.handleReadyForQuery(this.connection),
                  this._pulseQueryQueue();
              }
              _handleErrorWhileConnecting(e) {
                if (!this._connectionError) {
                  if (
                    ((this._connectionError = !0),
                    clearTimeout(this.connectionTimeoutHandle),
                    this._connectionCallback)
                  )
                    return this._connectionCallback(e);
                  this.emit("error", e);
                }
              }
              _handleErrorEvent(e) {
                if (this._connecting)
                  return this._handleErrorWhileConnecting(e);
                (this._queryable = !1),
                  this._errorAllQueries(e),
                  this.emit("error", e);
              }
              _handleErrorMessage(e) {
                if (this._connecting)
                  return this._handleErrorWhileConnecting(e);
                let t = this.activeQuery;
                if (!t) return void this._handleErrorEvent(e);
                (this.activeQuery = null), t.handleError(e, this.connection);
              }
              _handleRowDescription(e) {
                this.activeQuery.handleRowDescription(e);
              }
              _handleDataRow(e) {
                this.activeQuery.handleDataRow(e);
              }
              _handlePortalSuspended(e) {
                this.activeQuery.handlePortalSuspended(this.connection);
              }
              _handleEmptyQuery(e) {
                this.activeQuery.handleEmptyQuery(this.connection);
              }
              _handleCommandComplete(e) {
                this.activeQuery.handleCommandComplete(e, this.connection);
              }
              _handleParseComplete(e) {
                this.activeQuery.name &&
                  (this.connection.parsedStatements[this.activeQuery.name] =
                    this.activeQuery.text);
              }
              _handleCopyInResponse(e) {
                this.activeQuery.handleCopyInResponse(this.connection);
              }
              _handleCopyData(e) {
                this.activeQuery.handleCopyData(e, this.connection);
              }
              _handleNotification(e) {
                this.emit("notification", e);
              }
              _handleNotice(e) {
                this.emit("notice", e);
              }
              getStartupConf() {
                var e = this.connectionParameters,
                  t = { user: e.user, database: e.database },
                  r = e.application_name || e.fallback_application_name;
                return (
                  r && (t.application_name = r),
                  e.replication && (t.replication = "" + e.replication),
                  e.statement_timeout &&
                    (t.statement_timeout = String(
                      parseInt(e.statement_timeout, 10)
                    )),
                  e.lock_timeout &&
                    (t.lock_timeout = String(parseInt(e.lock_timeout, 10))),
                  e.idle_in_transaction_session_timeout &&
                    (t.idle_in_transaction_session_timeout = String(
                      parseInt(e.idle_in_transaction_session_timeout, 10)
                    )),
                  e.options && (t.options = e.options),
                  t
                );
              }
              cancel(e, t) {
                if (e.activeQuery === t) {
                  var r = this.connection;
                  this.host && 0 === this.host.indexOf("/")
                    ? r.connect(this.host + "/.s.PGSQL." + this.port)
                    : r.connect(this.port, this.host),
                    r.on("connect", function () {
                      r.cancel(e.processID, e.secretKey);
                    });
                } else
                  -1 !== e.queryQueue.indexOf(t) &&
                    e.queryQueue.splice(e.queryQueue.indexOf(t), 1);
              }
              setTypeParser(e, t, r) {
                return this._types.setTypeParser(e, t, r);
              }
              getTypeParser(e, t) {
                return this._types.getTypeParser(e, t);
              }
              escapeIdentifier(e) {
                return '"' + e.replace(/"/g, '""') + '"';
              }
              escapeLiteral(e) {
                for (var t = !1, r = "'", i = 0; i < e.length; i++) {
                  var n = e[i];
                  "'" === n
                    ? (r += n + n)
                    : "\\" === n
                      ? ((r += n + n), (t = !0))
                      : (r += n);
                }
                return (r += "'"), !0 === t && (r = " E" + r), r;
              }
              _pulseQueryQueue() {
                if (!0 === this.readyForQuery)
                  if (
                    ((this.activeQuery = this.queryQueue.shift()),
                    this.activeQuery)
                  ) {
                    (this.readyForQuery = !1), (this.hasExecuted = !0);
                    let e = this.activeQuery.submit(this.connection);
                    e &&
                      l.nextTick(() => {
                        this.activeQuery.handleError(e, this.connection),
                          (this.readyForQuery = !0),
                          this._pulseQueryQueue();
                      });
                  } else
                    this.hasExecuted &&
                      ((this.activeQuery = null), this.emit("drain"));
              }
              query(e, t, r) {
                var i, n, s, o, a;
                if (null == e)
                  throw TypeError(
                    "Client was passed a null or undefined query"
                  );
                return (
                  "function" == typeof e.submit
                    ? ((s =
                        e.query_timeout ||
                        this.connectionParameters.query_timeout),
                      (n = i = e),
                      "function" == typeof t && (i.callback = i.callback || t))
                    : ((s = this.connectionParameters.query_timeout),
                      (i = new d(e, t, r)).callback ||
                        (n = new this._Promise((e, t) => {
                          i.callback = (r, i) => (r ? t(r) : e(i));
                        }))),
                  s &&
                    ((a = i.callback),
                    (o = setTimeout(() => {
                      var e = Error("Query read timeout");
                      l.nextTick(() => {
                        i.handleError(e, this.connection);
                      }),
                        a(e),
                        (i.callback = () => {});
                      var t = this.queryQueue.indexOf(i);
                      t > -1 && this.queryQueue.splice(t, 1),
                        this._pulseQueryQueue();
                    }, s)),
                    (i.callback = (e, t) => {
                      clearTimeout(o), a(e, t);
                    })),
                  this.binary && !i.binary && (i.binary = !0),
                  i._result &&
                    !i._result._types &&
                    (i._result._types = this._types),
                  this._queryable
                    ? this._ending
                      ? l.nextTick(() => {
                          i.handleError(
                            Error("Client was closed and is not queryable"),
                            this.connection
                          );
                        })
                      : (this.queryQueue.push(i), this._pulseQueryQueue())
                    : l.nextTick(() => {
                        i.handleError(
                          Error(
                            "Client has encountered a connection error and is not queryable"
                          ),
                          this.connection
                        );
                      }),
                  n
                );
              }
              ref() {
                this.connection.ref();
              }
              unref() {
                this.connection.unref();
              }
              end(e) {
                if (((this._ending = !0), !this.connection._connecting))
                  if (!e) return this._Promise.resolve();
                  else e();
                if (
                  (this.activeQuery || !this._queryable
                    ? this.connection.stream.destroy()
                    : this.connection.end(),
                  !e)
                )
                  return new this._Promise((e) => {
                    this.connection.once("end", e);
                  });
                this.connection.once("end", e);
              }
            };
          y(p, "Client"), (p.Query = d), (t.exports = p);
        }),
        eK = w((e, t) => {
          A();
          var r = E().EventEmitter,
            i = y(function () {}, "NOOP"),
            n = y((e, t) => {
              let r = e.findIndex(t);
              return -1 === r ? void 0 : e.splice(r, 1)[0];
            }, "removeWhere"),
            a = class {
              constructor(e, t, r) {
                (this.client = e),
                  (this.idleListener = t),
                  (this.timeoutId = r);
              }
            };
          y(a, "IdleItem");
          var c = class {
            constructor(e) {
              this.callback = e;
            }
          };
          function d() {
            throw Error(
              "Release called on client which has already been released to the pool."
            );
          }
          function u(e, t) {
            let r, i;
            return t
              ? { callback: t, result: void 0 }
              : {
                  callback: y(function (e, t) {
                    e ? r(e) : i(t);
                  }, "cb"),
                  result: new e(function (e, t) {
                    (i = e), (r = t);
                  }).catch((e) => {
                    throw (Error.captureStackTrace(e), e);
                  }),
                };
          }
          function h(e, t) {
            return y(function r(i) {
              (i.client = t),
                t.removeListener("error", r),
                t.on("error", () => {
                  e.log(
                    "additional client error after disconnection due to error",
                    i
                  );
                }),
                e._remove(t),
                e.emit("error", i, t);
            }, "idleListener");
          }
          y(c, "PendingItem"),
            y(d, "throwOnDoubleRelease"),
            y(u, "promisify"),
            y(h, "makeIdleListener");
          var p = class extends r {
            constructor(e, t) {
              super(),
                (this.options = Object.assign({}, e)),
                null != e &&
                  "password" in e &&
                  Object.defineProperty(this.options, "password", {
                    configurable: !0,
                    enumerable: !1,
                    writable: !0,
                    value: e.password,
                  }),
                null != e &&
                  e.ssl &&
                  e.ssl.key &&
                  Object.defineProperty(this.options.ssl, "key", {
                    enumerable: !1,
                  }),
                (this.options.max =
                  this.options.max || this.options.poolSize || 10),
                (this.options.min = this.options.min || 0),
                (this.options.maxUses = this.options.maxUses || 1 / 0),
                (this.options.allowExitOnIdle =
                  this.options.allowExitOnIdle || !1),
                (this.options.maxLifetimeSeconds =
                  this.options.maxLifetimeSeconds || 0),
                (this.log = this.options.log || function () {}),
                (this.Client = this.options.Client || t || e1().Client),
                (this.Promise = this.options.Promise || s.Promise),
                typeof this.options.idleTimeoutMillis > "u" &&
                  (this.options.idleTimeoutMillis = 1e4),
                (this._clients = []),
                (this._idle = []),
                (this._expired = new WeakSet()),
                (this._pendingQueue = []),
                (this._endCallback = void 0),
                (this.ending = !1),
                (this.ended = !1);
            }
            _isFull() {
              return this._clients.length >= this.options.max;
            }
            _isAboveMin() {
              return this._clients.length > this.options.min;
            }
            _pulseQueue() {
              if ((this.log("pulse queue"), this.ended))
                return void this.log("pulse queue ended");
              if (this.ending) {
                this.log("pulse queue on ending"),
                  this._idle.length &&
                    this._idle.slice().map((e) => {
                      this._remove(e.client);
                    }),
                  this._clients.length ||
                    ((this.ended = !0), this._endCallback());
                return;
              }
              if (!this._pendingQueue.length)
                return void this.log("no queued requests");
              if (!this._idle.length && this._isFull()) return;
              let e = this._pendingQueue.shift();
              if (this._idle.length) {
                let t = this._idle.pop();
                clearTimeout(t.timeoutId);
                let r = t.client;
                r.ref && r.ref();
                let i = t.idleListener;
                return this._acquireClient(r, e, i, !1);
              }
              if (!this._isFull()) return this.newClient(e);
              throw Error("unexpected condition");
            }
            _remove(e) {
              let t = n(this._idle, (t) => t.client === e);
              void 0 !== t && clearTimeout(t.timeoutId),
                (this._clients = this._clients.filter((t) => t !== e)),
                e.end(),
                this.emit("remove", e);
            }
            connect(e) {
              if (this.ending) {
                let t = Error(
                  "Cannot use a pool after calling end on the pool"
                );
                return e ? e(t) : this.Promise.reject(t);
              }
              let t = u(this.Promise, e),
                r = t.result;
              if (this._isFull() || this._idle.length) {
                if (
                  (this._idle.length && l.nextTick(() => this._pulseQueue()),
                  !this.options.connectionTimeoutMillis)
                )
                  return this._pendingQueue.push(new c(t.callback)), r;
                let e = y((e, r, i) => {
                    clearTimeout(s), t.callback(e, r, i);
                  }, "queueCallback"),
                  i = new c(e),
                  s = setTimeout(() => {
                    n(this._pendingQueue, (t) => t.callback === e),
                      (i.timedOut = !0),
                      t.callback(
                        Error("timeout exceeded when trying to connect")
                      );
                  }, this.options.connectionTimeoutMillis);
                return s.unref && s.unref(), this._pendingQueue.push(i), r;
              }
              return this.newClient(new c(t.callback)), r;
            }
            newClient(e) {
              let t = new this.Client(this.options);
              this._clients.push(t);
              let r = h(this, t);
              this.log("checking client timeout");
              let n,
                s = !1;
              this.options.connectionTimeoutMillis &&
                (n = setTimeout(() => {
                  this.log("ending client due to timeout"),
                    (s = !0),
                    t.connection ? t.connection.stream.destroy() : t.end();
                }, this.options.connectionTimeoutMillis)),
                this.log("connecting new client"),
                t.connect((o) => {
                  if ((n && clearTimeout(n), t.on("error", r), o))
                    this.log("client failed to connect", o),
                      (this._clients = this._clients.filter((e) => e !== t)),
                      s &&
                        (o = Error(
                          "Connection terminated due to connection timeout",
                          { cause: o }
                        )),
                      this._pulseQueue(),
                      e.timedOut || e.callback(o, void 0, i);
                  else {
                    if (
                      (this.log("new client connected"),
                      0 !== this.options.maxLifetimeSeconds)
                    ) {
                      let e = setTimeout(() => {
                        this.log("ending client due to expired lifetime"),
                          this._expired.add(t),
                          -1 !== this._idle.findIndex((e) => e.client === t) &&
                            this._acquireClient(
                              t,
                              new c((e, t, r) => r()),
                              r,
                              !1
                            );
                      }, 1e3 * this.options.maxLifetimeSeconds);
                      e.unref(), t.once("end", () => clearTimeout(e));
                    }
                    return this._acquireClient(t, e, r, !0);
                  }
                });
            }
            _acquireClient(e, t, r, n) {
              n && this.emit("connect", e),
                this.emit("acquire", e),
                (e.release = this._releaseOnce(e, r)),
                e.removeListener("error", r),
                t.timedOut
                  ? n && this.options.verify
                    ? this.options.verify(e, e.release)
                    : e.release()
                  : n && this.options.verify
                    ? this.options.verify(e, (r) => {
                        if (r) return e.release(r), t.callback(r, void 0, i);
                        t.callback(void 0, e, e.release);
                      })
                    : t.callback(void 0, e, e.release);
            }
            _releaseOnce(e, t) {
              let r = !1;
              return (i) => {
                r && d(), (r = !0), this._release(e, t, i);
              };
            }
            _release(e, t, r) {
              let i;
              if (
                (e.on("error", t),
                (e._poolUseCount = (e._poolUseCount || 0) + 1),
                this.emit("release", r, e),
                r ||
                  this.ending ||
                  !e._queryable ||
                  e._ending ||
                  e._poolUseCount >= this.options.maxUses)
              ) {
                e._poolUseCount >= this.options.maxUses &&
                  this.log("remove expended client"),
                  this._remove(e),
                  this._pulseQueue();
                return;
              }
              if (this._expired.has(e)) {
                this.log("remove expired client"),
                  this._expired.delete(e),
                  this._remove(e),
                  this._pulseQueue();
                return;
              }
              this.options.idleTimeoutMillis &&
                this._isAboveMin() &&
                ((i = setTimeout(() => {
                  this.log("remove idle client"), this._remove(e);
                }, this.options.idleTimeoutMillis)),
                this.options.allowExitOnIdle && i.unref()),
                this.options.allowExitOnIdle && e.unref(),
                this._idle.push(new a(e, t, i)),
                this._pulseQueue();
            }
            query(e, t, r) {
              if ("function" == typeof e) {
                let t = u(this.Promise, e);
                return (
                  o(function () {
                    return t.callback(
                      Error(
                        "Passing a function as the first parameter to pool.query is not supported"
                      )
                    );
                  }),
                  t.result
                );
              }
              "function" == typeof t && ((r = t), (t = void 0));
              let i = u(this.Promise, r);
              return (
                (r = i.callback),
                this.connect((i, n) => {
                  if (i) return r(i);
                  let s = !1,
                    o = y((e) => {
                      s || ((s = !0), n.release(e), r(e));
                    }, "onError");
                  n.once("error", o), this.log("dispatching query");
                  try {
                    n.query(e, t, (e, t) => {
                      if (
                        (this.log("query dispatched"),
                        n.removeListener("error", o),
                        !s)
                      )
                        return (s = !0), n.release(e), e ? r(e) : r(void 0, t);
                    });
                  } catch (e) {
                    return n.release(e), r(e);
                  }
                }),
                i.result
              );
            }
            end(e) {
              if ((this.log("ending"), this.ending)) {
                let t = Error("Called end on pool more than once");
                return e ? e(t) : this.Promise.reject(t);
              }
              this.ending = !0;
              let t = u(this.Promise, e);
              return (
                (this._endCallback = t.callback), this._pulseQueue(), t.result
              );
            }
            get waitingCount() {
              return this._pendingQueue.length;
            }
            get idleCount() {
              return this._idle.length;
            }
            get expiredCount() {
              return this._clients.reduce(
                (e, t) => e + +!!this._expired.has(t),
                0
              );
            }
            get totalCount() {
              return this._clients.length;
            }
          };
          y(p, "Pool"), (t.exports = p);
        }),
        eG = {};
      b(eG, { default: () => eH });
      var eH,
        eJ = g(() => {
          A(), (eH = {});
        }),
        eZ = w((e, t) => {
          t.exports = {
            name: "pg",
            version: "8.8.0",
            description:
              "PostgreSQL client - pure javascript & libpq with the same API",
            keywords: [
              "database",
              "libpq",
              "pg",
              "postgre",
              "postgres",
              "postgresql",
              "rdbms",
            ],
            homepage: "https://github.com/brianc/node-postgres",
            repository: {
              type: "git",
              url: "git://github.com/brianc/node-postgres.git",
              directory: "packages/pg",
            },
            author: "Brian Carlson <brian.m.carlson@gmail.com>",
            main: "./lib",
            dependencies: {
              "buffer-writer": "2.0.0",
              "packet-reader": "1.0.0",
              "pg-connection-string": "^2.5.0",
              "pg-pool": "^3.5.2",
              "pg-protocol": "^1.5.0",
              "pg-types": "^2.1.0",
              pgpass: "1.x",
            },
            devDependencies: {
              async: "2.6.4",
              bluebird: "3.5.2",
              co: "4.6.0",
              "pg-copy-streams": "0.3.0",
            },
            peerDependencies: { "pg-native": ">=3.0.1" },
            peerDependenciesMeta: { "pg-native": { optional: !0 } },
            scripts: { test: "make test-all" },
            files: ["lib", "SPONSORS.md"],
            license: "MIT",
            engines: { node: ">= 8.0.0" },
            gitHead: "c99fb2c127ddf8d712500db2c7b9a5491a178655",
          };
        }),
        eY = w((e, t) => {
          A();
          var r = E().EventEmitter,
            i = (eu(), x(ec)),
            n = el(),
            s = (t.exports = function (e, t, i) {
              r.call(this),
                (e = n.normalizeQueryConfig(e, t, i)),
                (this.text = e.text),
                (this.values = e.values),
                (this.name = e.name),
                (this.callback = e.callback),
                (this.state = "new"),
                (this._arrayMode = "array" === e.rowMode),
                (this._emitRowEvents = !1),
                this.on(
                  "newListener",
                  function (e) {
                    "row" === e && (this._emitRowEvents = !0);
                  }.bind(this)
                );
            });
          i.inherits(s, r);
          var a = {
            sqlState: "code",
            statementPosition: "position",
            messagePrimary: "message",
            context: "where",
            schemaName: "schema",
            tableName: "table",
            columnName: "column",
            dataTypeName: "dataType",
            constraintName: "constraint",
            sourceFile: "file",
            sourceLine: "line",
            sourceFunction: "routine",
          };
          (s.prototype.handleError = function (e) {
            var t = this.native.pq.resultErrorFields();
            if (t) for (var r in t) e[a[r] || r] = t[r];
            this.callback ? this.callback(e) : this.emit("error", e),
              (this.state = "error");
          }),
            (s.prototype.then = function (e, t) {
              return this._getPromise().then(e, t);
            }),
            (s.prototype.catch = function (e) {
              return this._getPromise().catch(e);
            }),
            (s.prototype._getPromise = function () {
              return (
                this._promise ||
                  (this._promise = new Promise(
                    function (e, t) {
                      this._once("end", e), this._once("error", t);
                    }.bind(this)
                  )),
                this._promise
              );
            }),
            (s.prototype.submit = function (e) {
              this.state = "running";
              var t = this;
              (this.native = e.native), (e.native.arrayMode = this._arrayMode);
              var r = y(function (r, i, n) {
                if (
                  ((e.native.arrayMode = !1),
                  o(function () {
                    t.emit("_done");
                  }),
                  r)
                )
                  return t.handleError(r);
                t._emitRowEvents &&
                  (n.length > 1
                    ? i.forEach((e, r) => {
                        e.forEach((e) => {
                          t.emit("row", e, n[r]);
                        });
                      })
                    : i.forEach(function (e) {
                        t.emit("row", e, n);
                      })),
                  (t.state = "end"),
                  t.emit("end", n),
                  t.callback && t.callback(null, n);
              }, "after");
              if ((l.domain && (r = l.domain.bind(r)), this.name)) {
                this.name.length > 63 &&
                  (console.error(
                    "Warning! Postgres only supports 63 characters for query names."
                  ),
                  console.error(
                    "You supplied %s (%s)",
                    this.name,
                    this.name.length
                  ),
                  console.error(
                    "This can cause conflicts and silent errors executing queries"
                  ));
                var i = (this.values || []).map(n.prepareValue);
                if (e.namedQueries[this.name]) {
                  if (this.text && e.namedQueries[this.name] !== this.text) {
                    let e = Error(`Prepa\
red statements must be unique - '${this.name}' was used for a different statement`);
                    return r(e);
                  }
                  return e.native.execute(this.name, i, r);
                }
                return e.native.prepare(
                  this.name,
                  this.text,
                  i.length,
                  function (n) {
                    return n
                      ? r(n)
                      : ((e.namedQueries[t.name] = t.text),
                        t.native.execute(t.name, i, r));
                  }
                );
              }
              if (this.values) {
                if (!Array.isArray(this.values)) {
                  let e = Error("Query values must be an array");
                  return r(e);
                }
                var s = this.values.map(n.prepareValue);
                e.native.query(this.text, s, r);
              } else e.native.query(this.text, r);
            });
        }),
        eX = w((e, t) => {
          A();
          var r = (eJ(), x(eG)),
            i = J(),
            n = (eZ(), E().EventEmitter),
            o = (eu(), x(ec)),
            a = eR(),
            c = eY(),
            d = (t.exports = function (e) {
              n.call(this),
                (e = e || {}),
                (this._Promise = e.Promise || s.Promise),
                (this._types = new i(e.types)),
                (this.native = new r({ types: this._types })),
                (this._queryQueue = []),
                (this._ending = !1),
                (this._connecting = !1),
                (this._connected = !1),
                (this._queryable = !0);
              var t = (this.connectionParameters = new a(e));
              (this.user = t.user),
                Object.defineProperty(this, "password", {
                  configurable: !0,
                  enumerable: !1,
                  writable: !0,
                  value: t.password,
                }),
                (this.database = t.database),
                (this.host = t.host),
                (this.port = t.port),
                (this.namedQueries = {});
            });
          (d.Query = c),
            o.inherits(d, n),
            (d.prototype._errorAllQueries = function (e) {
              let t = y((t) => {
                l.nextTick(() => {
                  (t.native = this.native), t.handleError(e);
                });
              }, "enqueueError");
              this._hasActiveQuery() &&
                (t(this._activeQuery), (this._activeQuery = null)),
                this._queryQueue.forEach(t),
                (this._queryQueue.length = 0);
            }),
            (d.prototype._connect = function (e) {
              var t = this;
              if (this._connecting)
                return void l.nextTick(() =>
                  e(
                    Error(
                      "Client has already been connected. You cannot reuse a client."
                    )
                  )
                );
              (this._connecting = !0),
                this.connectionParameters.getLibpqConnectionString(
                  function (r, i) {
                    if (r) return e(r);
                    t.native.connect(i, function (r) {
                      if (r) return t.native.end(), e(r);
                      (t._connected = !0),
                        t.native.on("error", function (e) {
                          (t._queryable = !1),
                            t._errorAllQueries(e),
                            t.emit("error", e);
                        }),
                        t.native.on("notification", function (e) {
                          t.emit("notification", {
                            channel: e.relname,
                            payload: e.extra,
                          });
                        }),
                        t.emit("connect"),
                        t._pulseQueryQueue(!0),
                        e();
                    });
                  }
                );
            }),
            (d.prototype.connect = function (e) {
              return e
                ? void this._connect(e)
                : new this._Promise((e, t) => {
                    this._connect((r) => {
                      r ? t(r) : e();
                    });
                  });
            }),
            (d.prototype.query = function (e, t, r) {
              var i, n, s, o, a;
              if (null == e)
                throw TypeError("Client was passed a null or undefined query");
              if ("function" == typeof e.submit)
                (s =
                  e.query_timeout || this.connectionParameters.query_timeout),
                  (n = i = e),
                  "function" == typeof t && (e.callback = t);
              else if (
                ((s = this.connectionParameters.query_timeout),
                !(i = new c(e, t, r)).callback)
              ) {
                let e, t;
                (n = new this._Promise((r, i) => {
                  (e = r), (t = i);
                })),
                  (i.callback = (r, i) => (r ? t(r) : e(i)));
              }
              return (
                s &&
                  ((a = i.callback),
                  (o = setTimeout(() => {
                    var e = Error("Query read timeout");
                    l.nextTick(() => {
                      i.handleError(e, this.connection);
                    }),
                      a(e),
                      (i.callback = () => {});
                    var t = this._queryQueue.indexOf(i);
                    t > -1 && this._queryQueue.splice(t, 1),
                      this._pulseQueryQueue();
                  }, s)),
                  (i.callback = (e, t) => {
                    clearTimeout(o), a(e, t);
                  })),
                this._queryable
                  ? this._ending
                    ? ((i.native = this.native),
                      l.nextTick(() => {
                        i.handleError(
                          Error("Client was closed and is not queryable")
                        );
                      }))
                    : (this._queryQueue.push(i), this._pulseQueryQueue())
                  : ((i.native = this.native),
                    l.nextTick(() => {
                      i.handleError(
                        Error(
                          "Client has encountered a connection error and is not queryable"
                        )
                      );
                    })),
                n
              );
            }),
            (d.prototype.end = function (e) {
              var t,
                r = this;
              return (
                (this._ending = !0),
                this._connected || this.once("connect", this.end.bind(this, e)),
                e ||
                  (t = new this._Promise(function (t, r) {
                    e = y((e) => (e ? r(e) : t()), "cb");
                  })),
                this.native.end(function () {
                  r._errorAllQueries(Error("Connection terminated")),
                    l.nextTick(() => {
                      r.emit("end"), e && e();
                    });
                }),
                t
              );
            }),
            (d.prototype._hasActiveQuery = function () {
              return (
                this._activeQuery &&
                "error" !== this._activeQuery.state &&
                "end" !== this._activeQuery.state
              );
            }),
            (d.prototype._pulseQueryQueue = function (e) {
              if (this._connected && !this._hasActiveQuery()) {
                var t = this._queryQueue.shift();
                if (!t) {
                  e || this.emit("drain");
                  return;
                }
                (this._activeQuery = t), t.submit(this);
                var r = this;
                t.once("_done", function () {
                  r._pulseQueryQueue();
                });
              }
            }),
            (d.prototype.cancel = function (e) {
              this._activeQuery === e
                ? this.native.cancel(function () {})
                : -1 !== this._queryQueue.indexOf(e) &&
                  this._queryQueue.splice(this._queryQueue.indexOf(e), 1);
            }),
            (d.prototype.ref = function () {}),
            (d.prototype.unref = function () {}),
            (d.prototype.setTypeParser = function (e, t, r) {
              return this._types.setTypeParser(e, t, r);
            }),
            (d.prototype.getTypeParser = function (e, t) {
              return this._types.getTypeParser(e, t);
            });
        }),
        e0 = w((e, t) => {
          A(), (t.exports = eX());
        }),
        e1 = w((e, t) => {
          A();
          var r = eV(),
            i = ea(),
            n = ez(),
            s = eK(),
            { DatabaseError: o } = ej(),
            a = y((e) => {
              var t;
              return (
                y(
                  (t = class extends s {
                    constructor(t) {
                      super(t, e);
                    }
                  }),
                  "BoundPool"
                ),
                t
              );
            }, "poolFactory"),
            c = y(function (e) {
              (this.defaults = i),
                (this.Client = e),
                (this.Query = this.Client.Query),
                (this.Pool = a(this.Client)),
                (this._pools = []),
                (this.Connection = n),
                (this.types = H()),
                (this.DatabaseError = o);
            }, "PG");
          "u" > typeof l.env.NODE_PG_FORCE_NATIVE
            ? (t.exports = new c(e0()))
            : ((t.exports = new c(r)),
              Object.defineProperty(t.exports, "native", {
                configurable: !0,
                enumerable: !1,
                get() {
                  var e = null;
                  try {
                    e = new c(e0());
                  } catch (e) {
                    if ("MODULE_NOT_FOUND" !== e.code) throw e;
                  }
                  return (
                    Object.defineProperty(t.exports, "native", { value: e }), e
                  );
                },
              }));
        });
      A(), A(), D(), $(), A();
      var e2 = Object.defineProperty,
        e5 = Object.defineProperties,
        e6 = Object.getOwnPropertyDescriptors,
        e4 = Object.getOwnPropertySymbols,
        e3 = Object.prototype.hasOwnProperty,
        e8 = Object.prototype.propertyIsEnumerable,
        e9 = y(
          (e, t, r) =>
            t in e
              ? e2(e, t, {
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                  value: r,
                })
              : (e[t] = r),
          "__defNormalProp"
        ),
        e7 = y((e, t) => {
          for (var r in t || (t = {})) e3.call(t, r) && e9(e, r, t[r]);
          if (e4) for (var r of e4(t)) e8.call(t, r) && e9(e, r, t[r]);
          return e;
        }, "__spreadValues"),
        te = y((e, t) => e5(e, e6(t)), "__spreadProps"),
        tt = 2 === new Uint8Array(new Uint16Array([258]).buffer)[0],
        tr = new TextDecoder(),
        ti = new TextEncoder(),
        tn = ti.encode("0123456789abcdef"),
        ts = ti.encode("0123456789ABCDEF"),
        to = ti
          .encode(
            "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
          )
          .slice();
      function ta(e, { alphabet: t, scratchArr: r } = {}) {
        if (!i)
          if (((i = new Uint16Array(256)), (n = new Uint16Array(256)), tt))
            for (let e = 0; e < 256; e++)
              (i[e] = (tn[15 & e] << 8) | tn[e >>> 4]),
                (n[e] = (ts[15 & e] << 8) | ts[e >>> 4]);
          else
            for (let e = 0; e < 256; e++)
              (i[e] = tn[15 & e] | (tn[e >>> 4] << 8)),
                (n[e] = ts[15 & e] | (ts[e >>> 4] << 8));
        e.byteOffset % 4 != 0 && (e = new Uint8Array(e));
        let s = e.length,
          o = s >>> 2,
          a = r || new Uint16Array(s),
          l = new Uint32Array(e.buffer, e.byteOffset, o),
          c = new Uint32Array(a.buffer, a.byteOffset, s >>> 1),
          d = "upper" === t ? n : i,
          u = 0,
          h = 0,
          p;
        if (tt)
          for (; u < o; )
            (p = l[u++]),
              (c[h++] = (d[(p >>> 8) & 255] << 16) | d[255 & p]),
              (c[h++] = (d[p >>> 24] << 16) | d[(p >>> 16) & 255]);
        else
          for (; u < o; )
            (p = l[u++]),
              (c[h++] = (d[p >>> 24] << 16) | d[(p >>> 16) & 255]),
              (c[h++] = (d[(p >>> 8) & 255] << 16) | d[255 & p]);
        for (u <<= 2; u < s; ) a[u] = d[e[u++]];
        return tr.decode(a.subarray(0, s));
      }
      function tl(e, t = {}) {
        let r = "",
          i = e.length,
          n = Math.ceil(i / 504e3),
          s = new Uint16Array(n > 1 ? 504e3 : i);
        for (let i = 0; i < n; i++) {
          let n = 504e3 * i,
            o = n + 504e3;
          r += ta(e.subarray(n, o), te(e7({}, t), { scratchArr: s }));
        }
        return r;
      }
      function tc(e, t = {}) {
        return "upper" !== t.alphabet && "function" == typeof e.toHex
          ? e.toHex()
          : tl(e, t);
      }
      (to[62] = 45),
        (to[63] = 95),
        y(ta, "_toHex"),
        y(tl, "_toHexChunked"),
        y(tc, "toHex"),
        A();
      var td = class e {
        constructor(e, t) {
          (this.strings = e), (this.values = t);
        }
        toParameterizedQuery(t = { query: "", params: [] }) {
          let { strings: r, values: i } = this;
          for (let n = 0, s = r.length; n < s; n++)
            if (((t.query += r[n]), n < i.length)) {
              let r = i[n];
              if (r instanceof th) t.query += r.sql;
              else if (r instanceof t_)
                if (r.queryData instanceof e)
                  r.queryData.toParameterizedQuery(t);
                else {
                  if (r.queryData.params?.length)
                    throw Error("This query is not composable");
                  t.query += r.queryData.query;
                }
              else {
                let { params: e } = t;
                e.push(r),
                  (t.query += "$" + e.length),
                  (r instanceof a || ArrayBuffer.isView(r)) &&
                    (t.query += "::bytea");
              }
            }
          return t;
        }
      };
      y(td, "SqlTemplate");
      var tu = class {
        constructor(e) {
          this.sql = e;
        }
      };
      y(tu, "UnsafeRawSql");
      var th = tu;
      function tp() {
        "u" > typeof window &&
          "u" > typeof document &&
          "u" > typeof console &&
          "function" == typeof console.warn &&
          console.warn(`          
        ************************************************************
        *                                                          *
        *  WARNING: Running SQL directly from the browser can have *
        *  security implications. Even if your database is         *
        *  protected by Row-Level Security (RLS), use it at your   *
        *  own risk. This approach is great for fast prototyping,  *
        *  but ensure proper safeguards are in place to prevent    *
        *  misuse or execution of expensive SQL queries by your    *
        *  end users.                                              *
        *                                                          *
        *  If you've assessed the risks, suppress this message     *
        *  using the disableWarningInBrowsers configuration        *
        *  parameter.                                              *
        *                                                          *
        ************************************************************`);
      }
      A(), y(tp, "warnIfBrowser"), D();
      var tf = N(J()),
        tm = N(el()),
        ty = class e extends Error {
          constructor(t) {
            super(t),
              _(this, "name", "NeonDbError"),
              _(this, "severity"),
              _(this, "code"),
              _(this, "detail"),
              _(this, "hint"),
              _(this, "position"),
              _(this, "internalPosition"),
              _(this, "internalQuery"),
              _(this, "where"),
              _(this, "schema"),
              _(this, "table"),
              _(this, "column"),
              _(this, "dataType"),
              _(this, "constraint"),
              _(this, "file"),
              _(this, "line"),
              _(this, "routine"),
              _(this, "sourceError"),
              "captureStackTrace" in Error &&
                "function" == typeof Error.captureStackTrace &&
                Error.captureStackTrace(this, e);
          }
        };
      y(ty, "NeonDbError");
      var tg =
          "transaction() expects an array of queries, or a function returning an array of queries",
        tw = [
          "severity",
          "code",
          "detail",
          "hint",
          "position",
          "internalPosition",
          "internalQuery",
          "where",
          "schema",
          "table",
          "column",
          "dataType",
          "constraint",
          "file",
          "line",
          "routine",
        ];
      function tb(e) {
        return e instanceof a ? "\\x" + tc(e) : e;
      }
      function tv(e) {
        let { query: t, params: r } =
          e instanceof td ? e.toParameterizedQuery() : e;
        return { query: t, params: r.map((e) => tb((0, tm.prepareValue)(e))) };
      }
      function tN(
        e,
        {
          arrayMode: t,
          fullResults: r,
          fetchOptions: i,
          isolationLevel: n,
          readOnly: s,
          deferrable: o,
          authToken: a,
          disableWarningInBrowsers: l,
        } = {}
      ) {
        let c;
        if (!e)
          throw Error(
            "No database connection string was provided to `neon()`. Perhaps an environment variable has not been set?"
          );
        try {
          c = U(e);
        } catch {
          throw Error(
            "Database connection string provided to `neon()` is not a valid URL. Connection string: " +
              String(e)
          );
        }
        let { protocol: d, username: u, hostname: h, port: p, pathname: f } = c;
        if (("postgres:" !== d && "postgresql:" !== d) || !u || !h || !f)
          throw Error(
            "Database connection string format for `neon()` should be: postgresql://user:password@host.tld/dbname?option=value"
          );
        function m(e, ...t) {
          if (!(Array.isArray(e) && Array.isArray(e.raw) && Array.isArray(t)))
            throw Error(
              'This function can now be called only as a tagged-template function: sql`SELECT ${value}`, not sql("SELECT $1", [value], options). For a conventional function call with value placeholders ($1, $2, etc.), use sql.query("SELECT $1", [value], options).'
            );
          return new t_(g, new td(e, t));
        }
        async function g(c, d, u) {
          let f,
            { fetchEndpoint: m, fetchFunction: y } = P,
            g = Array.isArray(c) ? { queries: c.map((e) => tv(e)) } : tv(c),
            w = i ?? {},
            b = t ?? !1,
            v = r ?? !1,
            N = n,
            x = s,
            _ = o;
          void 0 !== u &&
            (void 0 !== u.fetchOptions && (w = { ...w, ...u.fetchOptions }),
            void 0 !== u.arrayMode && (b = u.arrayMode),
            void 0 !== u.fullResults && (v = u.fullResults),
            void 0 !== u.isolationLevel && (N = u.isolationLevel),
            void 0 !== u.readOnly && (x = u.readOnly),
            void 0 !== u.deferrable && (_ = u.deferrable)),
            void 0 === d ||
              Array.isArray(d) ||
              void 0 === d.fetchOptions ||
              (w = { ...w, ...d.fetchOptions });
          let S = a;
          Array.isArray(d) || d?.authToken === void 0 || (S = d.authToken);
          let T =
              "function" == typeof m ? m(h, p, { jwtAuth: void 0 !== S }) : m,
            k = {
              "Neon-Connection-String": e,
              "Neon-Raw-Text-Output": "true",
              "Neon-Array-Mode": "true",
            },
            A = await tT(S);
          A && (k.Authorization = `Bearer ${A}`),
            Array.isArray(c) &&
              (void 0 !== N && (k["Neon-Batch-Isolation-Level"] = N),
              void 0 !== x && (k["Neon-Batch-Read-Only"] = String(x)),
              void 0 !== _ && (k["Neon-Batch-Deferrable"] = String(_))),
            l || P.disableWarningInBrowsers || tp();
          try {
            f = await (y ?? fetch)(T, {
              method: "POST",
              body: JSON.stringify(g),
              headers: k,
              ...w,
            });
          } catch (t) {
            let e = new ty(`Error connecting to database: ${t}`);
            throw ((e.sourceError = t), e);
          }
          if (f.ok) {
            let e = await f.json();
            if (Array.isArray(c)) {
              let t = e.results;
              if (!Array.isArray(t))
                throw new ty("Neon internal error: unexpected result format");
              return t.map((e, t) => {
                let r = d[t] ?? {};
                return tS(e, {
                  arrayMode: r.arrayMode ?? b,
                  fullResults: r.fullResults ?? v,
                  types: r.types,
                });
              });
            }
            {
              let t = d ?? {};
              return tS(e, {
                arrayMode: t.arrayMode ?? b,
                fullResults: t.fullResults ?? v,
                types: t.types,
              });
            }
          }
          {
            let { status: e } = f;
            if (400 === e) {
              let e = await f.json(),
                t = new ty(e.message);
              for (let r of tw) t[r] = e[r] ?? void 0;
              throw t;
            }
            {
              let t = await f.text();
              throw new ty(`Server error (HTTP status ${e}): ${t}`);
            }
          }
        }
        return (
          y(m, "templateFn"),
          (m.query = (e, t, r) => new t_(g, { query: e, params: t ?? [] }, r)),
          (m.unsafe = (e) => new th(e)),
          (m.transaction = async (e, t) => {
            if (("function" == typeof e && (e = e(m)), !Array.isArray(e)))
              throw Error(tg);
            return (
              e.forEach((e) => {
                if (!(e instanceof t_)) throw Error(tg);
              }),
              g(
                e.map((e) => e.queryData),
                e.map((e) => e.opts ?? {}),
                t
              )
            );
          }),
          y(g, "execute"),
          m
        );
      }
      y(tb, "encodeBuffersAsBytea"), y(tv, "prepareQuery"), y(tN, "neon");
      var tx = class {
        constructor(e, t, r) {
          (this.execute = e), (this.queryData = t), (this.opts = r);
        }
        then(e, t) {
          return this.execute(this.queryData, this.opts).then(e, t);
        }
        catch(e) {
          return this.execute(this.queryData, this.opts).catch(e);
        }
        finally(e) {
          return this.execute(this.queryData, this.opts).finally(e);
        }
      };
      y(tx, "NeonQueryPromise");
      var t_ = tx;
      function tS(e, { arrayMode: t, fullResults: r, types: i }) {
        let n = new tf.default(i),
          s = e.fields.map((e) => e.name),
          o = e.fields.map((e) => n.getTypeParser(e.dataTypeID)),
          a =
            !0 === t
              ? e.rows.map((e) =>
                  e.map((e, t) => (null === e ? null : o[t](e)))
                )
              : e.rows.map((e) =>
                  Object.fromEntries(
                    e.map((e, t) => [s[t], null === e ? null : o[t](e)])
                  )
                );
        return r
          ? ((e.viaNeonFetch = !0),
            (e.rowAsArray = t),
            (e.rows = a),
            (e._parsers = o),
            (e._types = n),
            e)
          : a;
      }
      async function tT(e) {
        if ("string" == typeof e) return e;
        if ("function" == typeof e)
          try {
            return await Promise.resolve(e());
          } catch (t) {
            let e = new ty("Error getting auth token.");
            throw (
              (t instanceof Error &&
                (e = new ty(`Error getting auth token: ${t.message}`)),
              e)
            );
          }
      }
      y(tS, "processQueryResult"), y(tT, "getAuthToken"), A();
      var tk = N(e1());
      A();
      var tA = N(e1()),
        tE = class extends tA.Client {
          constructor(e) {
            super(e), (this.config = e);
          }
          get neonConfig() {
            return this.connection.stream;
          }
          connect(e) {
            let { neonConfig: t } = this;
            t.forceDisablePgSSL && (this.ssl = this.connection.ssl = !1),
              this.ssl &&
                t.useSecureWebSocket &&
                console.warn(
                  "SSL is enabled for both Postgres (e.g. ?sslmode=require in the connection string + forceDisablePgSSL = false) and the WebSocket tunnel (useSecureWebSocket = true). Double encryption will increase latency and CPU usage. It may be appropriate to disable SSL in the Postgres connection parameters or set forceDisablePgSSL = true."
                );
            let r =
                ("string" != typeof this.config &&
                  this.config?.host !== void 0) ||
                ("string" != typeof this.config &&
                  this.config?.connectionString !== void 0) ||
                void 0 !== l.env.PGHOST,
              i = l.env.USER ?? l.env.USERNAME;
            if (
              !r &&
              "localhost" === this.host &&
              this.user === i &&
              this.database === i &&
              null === this.password
            )
              throw Error(`No database host or connection string wa\
s set, and key parameters have default values (host: localhost, user: ${i}, db: ${i}, password: null\
). Is an environment variable missing? Alternatively, if you intended to connect with these paramete\
rs, please set the host to 'localhost' explicitly.`);
            let n = super.connect(e),
              s = t.pipelineTLS && this.ssl,
              o = "password" === t.pipelineConnect;
            if (!s && !t.pipelineConnect) return n;
            let a = this.connection;
            if ((s && a.on("connect", () => a.stream.emit("data", "S")), o)) {
              a.removeAllListeners("authenticationCleartextPassword"),
                a.removeAllListeners("readyForQuery"),
                a.once("readyForQuery", () =>
                  a.on("readyForQuery", this._handleReadyForQuery.bind(this))
                );
              let e = this.ssl ? "sslconnect" : "connect";
              a.on(e, () => {
                this.neonConfig.disableWarningInBrowsers || tp(),
                  this._handleAuthCleartextPassword(),
                  this._handleReadyForQuery();
              });
            }
            return n;
          }
          async _handleAuthSASLContinue(e) {
            if (
              typeof crypto > "u" ||
              void 0 === crypto.subtle ||
              void 0 === crypto.subtle.importKey
            )
              throw Error(
                "Cannot use SASL auth when `crypto.subtle` is not defined"
              );
            let t = crypto.subtle,
              r = this.saslSession,
              i = this.password,
              n = e.data;
            if (
              "SASLInitialResponse" !== r.message ||
              "string" != typeof i ||
              "string" != typeof n
            )
              throw Error("SASL: protocol error");
            let s = Object.fromEntries(
                n.split(",").map((e) => {
                  if (!/^.=/.test(e))
                    throw Error("SASL: Invalid attribute pair entry");
                  return [e[0], e.substring(2)];
                })
              ),
              o = s.r,
              l = s.s,
              c = s.i;
            if (!o || !/^[!-+--~]+$/.test(o))
              throw Error(
                "SASL: SCRAM-SERVER-FIRST-MESSAGE: nonce missing/unprintable"
              );
            if (
              !l ||
              !/^(?:[a-zA-Z0-9+/]{4})*(?:[a-zA-Z0-9+/]{2}==|[a-zA-Z0-9+/]{3}=)?$/.test(
                l
              )
            )
              throw Error(
                "SASL: SCRAM-SERVER-FIRST-MESSAGE: salt missing/not base64"
              );
            if (!c || !/^[1-9][0-9]*$/.test(c))
              throw Error(
                "SASL: SCRAM-SERVER-FIRST-MESSAGE: missing/invalid iteration count"
              );
            if (!o.startsWith(r.clientNonce))
              throw Error(
                "SASL: SCRAM-SERVER-FIRST-MESSAGE: server nonce does not start with client nonce"
              );
            if (o.length === r.clientNonce.length)
              throw Error(
                "SASL: SCRAM-SERVER-FIRST-MESSAGE: server nonce is too short"
              );
            let d = parseInt(c, 10),
              u = a.from(l, "base64"),
              h = new TextEncoder(),
              p = h.encode(i),
              f = await t.importKey(
                "raw",
                p,
                { name: "HMAC", hash: { name: "SHA-256" } },
                !1,
                ["sign"]
              ),
              m = new Uint8Array(
                await t.sign("HMAC", f, a.concat([u, a.from([0, 0, 0, 1])]))
              ),
              y = m;
            for (var g = 0; g < d - 1; g++)
              (m = new Uint8Array(await t.sign("HMAC", f, m))),
                (y = a.from(y.map((e, t) => y[t] ^ m[t])));
            let w = y,
              b = await t.importKey(
                "raw",
                w,
                { name: "HMAC", hash: { name: "SHA-256" } },
                !1,
                ["sign"]
              ),
              v = new Uint8Array(
                await t.sign("HMAC", b, h.encode("Client Key"))
              ),
              N = await t.digest("SHA-256", v),
              x = "n=*,r=" + r.clientNonce,
              _ = "r=" + o + ",s=" + l + ",i=" + d,
              S = "c=biws,r=" + o,
              T = x + "," + _ + "," + S,
              k = await t.importKey(
                "raw",
                N,
                { name: "HMAC", hash: { name: "SHA-256" } },
                !1,
                ["sign"]
              );
            var A = new Uint8Array(await t.sign("HMAC", k, h.encode(T))),
              E = a.from(v.map((e, t) => v[t] ^ A[t])).toString("base64");
            let C = await t.importKey(
                "raw",
                w,
                { name: "HMAC", hash: { name: "SHA-256" } },
                !1,
                ["sign"]
              ),
              I = await t.sign("HMAC", C, h.encode("Server Key")),
              O = await t.importKey(
                "raw",
                I,
                { name: "HMAC", hash: { name: "SHA-256" } },
                !1,
                ["sign"]
              );
            var L = a.from(await t.sign("HMAC", O, h.encode(T)));
            (r.message = "SASLResponse"),
              (r.serverSignature = L.toString("base64")),
              (r.response = S + ",p=" + E),
              this.connection.sendSCRAMClientFinalMessage(
                this.saslSession.response
              );
          }
        };
      y(tE, "NeonClient"), D();
      var tC = N(eR());
      function tI(e, t) {
        let r, i;
        return t
          ? { callback: t, result: void 0 }
          : {
              callback: y(function (e, t) {
                e ? r(e) : i(t);
              }, "cb"),
              result: new e(function (e, t) {
                (i = e), (r = t);
              }),
            };
      }
      y(tI, "promisify");
      var tO = class extends tk.Pool {
        constructor() {
          super(...arguments),
            _(this, "Client", tE),
            _(this, "hasFetchUnsupportedListeners", !1),
            _(this, "addListener", this.on);
        }
        on(e, t) {
          return (
            "error" !== e && (this.hasFetchUnsupportedListeners = !0),
            super.on(e, t)
          );
        }
        query(e, t, r) {
          if (
            !P.poolQueryViaFetch ||
            this.hasFetchUnsupportedListeners ||
            "function" == typeof e
          )
            return super.query(e, t, r);
          "function" == typeof t && ((r = t), (t = void 0));
          let i = tI(this.Promise, r);
          r = i.callback;
          try {
            let i = new tC.default(this.options),
              n = encodeURIComponent,
              s = encodeURI,
              o = `postgresql://${n(i.user)}:${n(i.password)}@${n(i.host)}\
/${s(i.database)}`,
              a = "string" == typeof e ? e : e.text,
              l = t ?? e.values ?? [];
            tN(o, { fullResults: !0, arrayMode: "array" === e.rowMode })
              .query(a, l, { types: e.types ?? this.options?.types })
              .then((e) => r(void 0, e))
              .catch((e) => r(e));
          } catch (e) {
            r(e);
          }
          return i.result;
        }
      };
      y(tO, "NeonPool"), D();
      var tL = N(e1());
      tL.DatabaseError, tL.defaults, tL.escapeIdentifier, tL.escapeLiteral;
      var tR = tL.types,
        tP = r(90211);
      class tD {
        static [tP.i] = "ConsoleLogWriter";
        write(e) {
          console.log(e);
        }
      }
      class tq {
        static [tP.i] = "DefaultLogger";
        writer;
        constructor(e) {
          this.writer = e?.writer ?? new tD();
        }
        logQuery(e, t) {
          let r = t.map((e) => {
              try {
                return JSON.stringify(e);
              } catch {
                return String(e);
              }
            }),
            i = r.length ? ` -- params: [${r.join(", ")}]` : "";
          this.writer.write(`Query: ${e}${i}`);
        }
      }
      class tU {
        static [tP.i] = "NoopLogger";
        logQuery() {}
      }
      var t$ = r(93994),
        tB = r(11916),
        tM = r(47590),
        tj = r(91631);
      class tW {
        constructor(e) {
          this.table = e;
        }
        static [tP.i] = "ColumnAliasProxyHandler";
        get(e, t) {
          return "table" === t ? this.table : e[t];
        }
      }
      class tF {
        constructor(e, t) {
          (this.alias = e), (this.replaceOriginalName = t);
        }
        static [tP.i] = "TableAliasProxyHandler";
        get(e, t) {
          if (t === tM.XI.Symbol.IsAlias) return !0;
          if (
            t === tM.XI.Symbol.Name ||
            (this.replaceOriginalName && t === tM.XI.Symbol.OriginalName)
          )
            return this.alias;
          if (t === tj.n) return { ...e[tj.n], name: this.alias, isAlias: !0 };
          if (t === tM.XI.Symbol.Columns) {
            let t = e[tM.XI.Symbol.Columns];
            if (!t) return t;
            let r = {};
            return (
              Object.keys(t).map((i) => {
                r[i] = new Proxy(t[i], new tW(new Proxy(e, this)));
              }),
              r
            );
          }
          let r = e[t];
          return (0, tP.is)(r, t$.V)
            ? new Proxy(r, new tW(new Proxy(e, this)))
            : r;
        }
      }
      class tQ {
        constructor(e) {
          this.alias = e;
        }
        static [tP.i] = null;
        get(e, t) {
          return "sourceTable" === t ? tz(e.sourceTable, this.alias) : e[t];
        }
      }
      function tz(e, t) {
        return new Proxy(e, new tF(t, !1));
      }
      function tV(e, t) {
        return new Proxy(e, new tW(new Proxy(e.table, new tF(t, !1))));
      }
      function tK(e, t) {
        return new tB.Xs.Aliased(tG(e.sql, t), e.fieldAlias);
      }
      function tG(e, t) {
        return tB.ll.join(
          e.queryChunks.map((e) =>
            (0, tP.is)(e, t$.V)
              ? tV(e, t)
              : (0, tP.is)(e, tB.Xs)
                ? tG(e, t)
                : (0, tP.is)(e, tB.Xs.Aliased)
                  ? tK(e, t)
                  : e
          )
        );
      }
      function tH(e) {
        return (
          e
            .replace(/['\u2019]/g, "")
            .match(/[\da-z]+|[A-Z]+(?![a-z])|[A-Z][\da-z]+/g) ?? []
        )
          .map((e) => e.toLowerCase())
          .join("_");
      }
      function tJ(e) {
        return (
          e
            .replace(/['\u2019]/g, "")
            .match(/[\da-z]+|[A-Z]+(?![a-z])|[A-Z][\da-z]+/g) ?? []
        ).reduce(
          (e, t, r) =>
            e +
            (0 === r ? t.toLowerCase() : `${t[0].toUpperCase()}${t.slice(1)}`),
          ""
        );
      }
      function tZ(e) {
        return e;
      }
      class tY {
        static [tP.i] = "CasingCache";
        cache = {};
        cachedTables = {};
        convert;
        constructor(e) {
          this.convert = "snake_case" === e ? tH : "camelCase" === e ? tJ : tZ;
        }
        getColumnCasing(e) {
          if (!e.keyAsName) return e.name;
          let t = e.table[tM.XI.Symbol.Schema] ?? "public",
            r = e.table[tM.XI.Symbol.OriginalName],
            i = `${t}.${r}.${e.name}`;
          return this.cache[i] || this.cacheTable(e.table), this.cache[i];
        }
        cacheTable(e) {
          let t = e[tM.XI.Symbol.Schema] ?? "public",
            r = e[tM.XI.Symbol.OriginalName],
            i = `${t}.${r}`;
          if (!this.cachedTables[i]) {
            for (let t of Object.values(e[tM.XI.Symbol.Columns])) {
              let e = `${i}.${t.name}`;
              this.cache[e] = this.convert(t.name);
            }
            this.cachedTables[i] = !0;
          }
        }
        clearCache() {
          (this.cache = {}), (this.cachedTables = {});
        }
      }
      class tX extends Error {
        static [tP.i] = "DrizzleError";
        constructor({ message: e, cause: t }) {
          super(e), (this.name = "DrizzleError"), (this.cause = t);
        }
      }
      class t0 extends tX {
        static [tP.i] = "TransactionRollbackError";
        constructor() {
          super({ message: "Rollback" });
        }
      }
      var t1 = r(64055),
        t2 = r(60218),
        t5 = r(26514),
        t6 = r(40469),
        t4 = r(89649),
        t3 = r(11618),
        t8 = r(93136),
        t9 = r(17463),
        t7 = r(1081),
        re = r(29911),
        rt = r(22047),
        rr = r(80382),
        ri = r(72259);
      class rn extends tB.Ss {
        static [tP.i] = "PgViewBase";
      }
      class rs {
        static [tP.i] = "PgDialect";
        casing;
        constructor(e) {
          this.casing = new tY(e?.casing);
        }
        async migrate(e, t, r) {
          let i =
              "string" == typeof r
                ? "__drizzle_migrations"
                : (r.migrationsTable ?? "__drizzle_migrations"),
            n =
              "string" == typeof r
                ? "drizzle"
                : (r.migrationsSchema ?? "drizzle"),
            s = (0, tB.ll)`
			CREATE TABLE IF NOT EXISTS ${tB.ll.identifier(n)}.${tB.ll.identifier(i)} (
				id SERIAL PRIMARY KEY,
				hash text NOT NULL,
				created_at bigint
			)
		`;
          await t.execute(
            (0, tB.ll)`CREATE SCHEMA IF NOT EXISTS ${tB.ll.identifier(n)}`
          ),
            await t.execute(s);
          let o = (
            await t.all(
              (0,
              tB.ll)`select id, hash, created_at from ${tB.ll.identifier(n)}.${tB.ll.identifier(i)} order by created_at desc limit 1`
            )
          )[0];
          await t.transaction(async (t) => {
            for await (let r of e)
              if (!o || Number(o.created_at) < r.folderMillis) {
                for (let e of r.sql) await t.execute(tB.ll.raw(e));
                await t.execute(
                  (0,
                  tB.ll)`insert into ${tB.ll.identifier(n)}.${tB.ll.identifier(i)} ("hash", "created_at") values(${r.hash}, ${r.folderMillis})`
                );
              }
          });
        }
        escapeName(e) {
          return `"${e}"`;
        }
        escapeParam(e) {
          return `$${e + 1}`;
        }
        escapeString(e) {
          return `'${e.replace(/'/g, "''")}'`;
        }
        buildWithCTE(e) {
          if (!e?.length) return;
          let t = [(0, tB.ll)`with `];
          for (let [r, i] of e.entries())
            t.push((0, tB.ll)`${tB.ll.identifier(i._.alias)} as (${i._.sql})`),
              r < e.length - 1 && t.push((0, tB.ll)`, `);
          return t.push((0, tB.ll)` `), tB.ll.join(t);
        }
        buildDeleteQuery({ table: e, where: t, returning: r, withList: i }) {
          let n = this.buildWithCTE(i),
            s = r
              ? (0,
                tB.ll)` returning ${this.buildSelection(r, { isSingleTable: !0 })}`
              : void 0,
            o = t ? (0, tB.ll)` where ${t}` : void 0;
          return (0, tB.ll)`${n}delete from ${e}${o}${s}`;
        }
        buildUpdateSet(e, t) {
          let r = e[tM.XI.Symbol.Columns],
            i = Object.keys(r).filter(
              (e) => void 0 !== t[e] || r[e]?.onUpdateFn !== void 0
            ),
            n = i.length;
          return tB.ll.join(
            i.flatMap((e, i) => {
              let s = r[e],
                o = t[e] ?? tB.ll.param(s.onUpdateFn(), s),
                a = (0,
                tB.ll)`${tB.ll.identifier(this.casing.getColumnCasing(s))} = ${o}`;
              return i < n - 1 ? [a, tB.ll.raw(", ")] : [a];
            })
          );
        }
        buildUpdateQuery({
          table: e,
          set: t,
          where: r,
          returning: i,
          withList: n,
          from: s,
          joins: o,
        }) {
          let a = this.buildWithCTE(n),
            l = e[t7.mu.Symbol.Name],
            c = e[t7.mu.Symbol.Schema],
            d = e[t7.mu.Symbol.OriginalName],
            u = l === d ? void 0 : l,
            h = (0,
            tB.ll)`${c ? (0, tB.ll)`${tB.ll.identifier(c)}.` : void 0}${tB.ll.identifier(d)}${u && (0, tB.ll)` ${tB.ll.identifier(u)}`}`,
            p = this.buildUpdateSet(e, t),
            f = s && tB.ll.join([tB.ll.raw(" from "), this.buildFromTable(s)]),
            m = this.buildJoins(o),
            y = i
              ? (0,
                tB.ll)` returning ${this.buildSelection(i, { isSingleTable: !s })}`
              : void 0,
            g = r ? (0, tB.ll)` where ${r}` : void 0;
          return (0, tB.ll)`${a}update ${h} set ${p}${f}${m}${g}${y}`;
        }
        buildSelection(e, { isSingleTable: t = !1 } = {}) {
          let r = e.length,
            i = e.flatMap(({ field: e }, i) => {
              let n = [];
              if ((0, tP.is)(e, tB.Xs.Aliased) && e.isSelectionField)
                n.push(tB.ll.identifier(e.fieldAlias));
              else if ((0, tP.is)(e, tB.Xs.Aliased) || (0, tP.is)(e, tB.Xs)) {
                let r = (0, tP.is)(e, tB.Xs.Aliased) ? e.sql : e;
                t
                  ? n.push(
                      new tB.Xs(
                        r.queryChunks.map((e) =>
                          (0, tP.is)(e, t1.Kl)
                            ? tB.ll.identifier(this.casing.getColumnCasing(e))
                            : e
                        )
                      )
                    )
                  : n.push(r),
                  (0, tP.is)(e, tB.Xs.Aliased) &&
                    n.push((0, tB.ll)` as ${tB.ll.identifier(e.fieldAlias)}`);
              } else
                (0, tP.is)(e, t$.V) &&
                  (t
                    ? n.push(tB.ll.identifier(this.casing.getColumnCasing(e)))
                    : n.push(e));
              return i < r - 1 && n.push((0, tB.ll)`, `), n;
            });
          return tB.ll.join(i);
        }
        buildJoins(e) {
          if (!e || 0 === e.length) return;
          let t = [];
          for (let [r, i] of e.entries()) {
            0 === r && t.push((0, tB.ll)` `);
            let n = i.table,
              s = i.lateral ? (0, tB.ll)` lateral` : void 0,
              o = i.on ? (0, tB.ll)` on ${i.on}` : void 0;
            if ((0, tP.is)(n, t7.mu)) {
              let e = n[t7.mu.Symbol.Name],
                r = n[t7.mu.Symbol.Schema],
                a = n[t7.mu.Symbol.OriginalName],
                l = e === a ? void 0 : i.alias;
              t.push(
                (0,
                tB.ll)`${tB.ll.raw(i.joinType)} join${s} ${r ? (0, tB.ll)`${tB.ll.identifier(r)}.` : void 0}${tB.ll.identifier(a)}${l && (0, tB.ll)` ${tB.ll.identifier(l)}`}${o}`
              );
            } else if ((0, tP.is)(n, tB.Ss)) {
              let e = n[tj.n].name,
                r = n[tj.n].schema,
                a = n[tj.n].originalName,
                l = e === a ? void 0 : i.alias;
              t.push(
                (0,
                tB.ll)`${tB.ll.raw(i.joinType)} join${s} ${r ? (0, tB.ll)`${tB.ll.identifier(r)}.` : void 0}${tB.ll.identifier(a)}${l && (0, tB.ll)` ${tB.ll.identifier(l)}`}${o}`
              );
            } else
              t.push((0, tB.ll)`${tB.ll.raw(i.joinType)} join${s} ${n}${o}`);
            r < e.length - 1 && t.push((0, tB.ll)` `);
          }
          return tB.ll.join(t);
        }
        buildFromTable(e) {
          if ((0, tP.is)(e, tM.XI) && e[tM.XI.Symbol.IsAlias]) {
            let t = (0,
            tB.ll)`${tB.ll.identifier(e[tM.XI.Symbol.OriginalName])}`;
            return (
              e[tM.XI.Symbol.Schema] &&
                (t = (0,
                tB.ll)`${tB.ll.identifier(e[tM.XI.Symbol.Schema])}.${t}`),
              (0, tB.ll)`${t} ${tB.ll.identifier(e[tM.XI.Symbol.Name])}`
            );
          }
          return e;
        }
        buildSelectQuery({
          withList: e,
          fields: t,
          fieldsFlat: r,
          where: i,
          having: n,
          table: s,
          joins: o,
          orderBy: a,
          groupBy: l,
          limit: c,
          offset: d,
          lockingClause: u,
          distinct: h,
          setOperators: p,
        }) {
          let f,
            m,
            y,
            g = r ?? (0, ri.He)(t);
          for (let e of g) {
            let t;
            if (
              (0, tP.is)(e.field, t$.V) &&
              (0, tM.Io)(e.field.table) !==
                ((0, tP.is)(s, rr.n)
                  ? s._.alias
                  : (0, tP.is)(s, rn)
                    ? s[tj.n].name
                    : (0, tP.is)(s, tB.Xs)
                      ? void 0
                      : (0, tM.Io)(s)) &&
              ((t = e.field.table),
              !o?.some(
                ({ alias: e }) =>
                  e ===
                  (t[tM.XI.Symbol.IsAlias]
                    ? (0, tM.Io)(t)
                    : t[tM.XI.Symbol.BaseName])
              ))
            ) {
              let t = (0, tM.Io)(e.field.table);
              throw Error(
                `Your "${e.path.join("->")}" field references a column "${t}"."${e.field.name}", but the table "${t}" is not part of the query! Did you forget to join it?`
              );
            }
          }
          let w = !o || 0 === o.length,
            b = this.buildWithCTE(e);
          h &&
            (f =
              !0 === h
                ? (0, tB.ll)` distinct`
                : (0,
                  tB.ll)` distinct on (${tB.ll.join(h.on, (0, tB.ll)`, `)})`);
          let v = this.buildSelection(g, { isSingleTable: w }),
            N = this.buildFromTable(s),
            x = this.buildJoins(o),
            _ = i ? (0, tB.ll)` where ${i}` : void 0,
            S = n ? (0, tB.ll)` having ${n}` : void 0;
          a &&
            a.length > 0 &&
            (m = (0, tB.ll)` order by ${tB.ll.join(a, (0, tB.ll)`, `)}`),
            l &&
              l.length > 0 &&
              (y = (0, tB.ll)` group by ${tB.ll.join(l, (0, tB.ll)`, `)}`);
          let T =
              "object" == typeof c || ("number" == typeof c && c >= 0)
                ? (0, tB.ll)` limit ${c}`
                : void 0,
            k = d ? (0, tB.ll)` offset ${d}` : void 0,
            A = tB.ll.empty();
          if (u) {
            let e = (0, tB.ll)` for ${tB.ll.raw(u.strength)}`;
            u.config.of &&
              e.append(
                (0,
                tB.ll)` of ${tB.ll.join(Array.isArray(u.config.of) ? u.config.of : [u.config.of], (0, tB.ll)`, `)}`
              ),
              u.config.noWait
                ? e.append((0, tB.ll)` nowait`)
                : u.config.skipLocked && e.append((0, tB.ll)` skip locked`),
              A.append(e);
          }
          let E = (0,
          tB.ll)`${b}select${f} ${v} from ${N}${x}${_}${y}${S}${m}${T}${k}${A}`;
          return p.length > 0 ? this.buildSetOperations(E, p) : E;
        }
        buildSetOperations(e, t) {
          let [r, ...i] = t;
          if (!r)
            throw Error("Cannot pass undefined values to any set operator");
          return 0 === i.length
            ? this.buildSetOperationQuery({ leftSelect: e, setOperator: r })
            : this.buildSetOperations(
                this.buildSetOperationQuery({ leftSelect: e, setOperator: r }),
                i
              );
        }
        buildSetOperationQuery({
          leftSelect: e,
          setOperator: {
            type: t,
            isAll: r,
            rightSelect: i,
            limit: n,
            orderBy: s,
            offset: o,
          },
        }) {
          let a,
            l = (0, tB.ll)`(${e.getSQL()}) `,
            c = (0, tB.ll)`(${i.getSQL()})`;
          if (s && s.length > 0) {
            let e = [];
            for (let t of s)
              if ((0, tP.is)(t, t1.Kl)) e.push(tB.ll.identifier(t.name));
              else if ((0, tP.is)(t, tB.Xs)) {
                for (let e = 0; e < t.queryChunks.length; e++) {
                  let r = t.queryChunks[e];
                  (0, tP.is)(r, t1.Kl) &&
                    (t.queryChunks[e] = tB.ll.identifier(r.name));
                }
                e.push((0, tB.ll)`${t}`);
              } else e.push((0, tB.ll)`${t}`);
            a = (0, tB.ll)` order by ${tB.ll.join(e, (0, tB.ll)`, `)} `;
          }
          let d =
              "object" == typeof n || ("number" == typeof n && n >= 0)
                ? (0, tB.ll)` limit ${n}`
                : void 0,
            u = tB.ll.raw(`${t} ${r ? "all " : ""}`),
            h = o ? (0, tB.ll)` offset ${o}` : void 0;
          return (0, tB.ll)`${l}${u}${c}${a}${d}${h}`;
        }
        buildInsertQuery({
          table: e,
          values: t,
          onConflict: r,
          returning: i,
          withList: n,
          select: s,
          overridingSystemValue_: o,
        }) {
          let a = [],
            l = Object.entries(e[tM.XI.Symbol.Columns]).filter(
              ([e, t]) => !t.shouldDisableInsert()
            ),
            c = l.map(([, e]) =>
              tB.ll.identifier(this.casing.getColumnCasing(e))
            );
          if (s) (0, tP.is)(t, tB.Xs) ? a.push(t) : a.push(t.getSQL());
          else
            for (let [e, r] of (a.push(tB.ll.raw("values ")), t.entries())) {
              let i = [];
              for (let [e, t] of l) {
                let n = r[e];
                if (
                  void 0 === n ||
                  ((0, tP.is)(n, tB.Iw) && void 0 === n.value)
                )
                  if (void 0 !== t.defaultFn) {
                    let e = t.defaultFn(),
                      r = (0, tP.is)(e, tB.Xs) ? e : tB.ll.param(e, t);
                    i.push(r);
                  } else if (t.default || void 0 === t.onUpdateFn)
                    i.push((0, tB.ll)`default`);
                  else {
                    let e = t.onUpdateFn(),
                      r = (0, tP.is)(e, tB.Xs) ? e : tB.ll.param(e, t);
                    i.push(r);
                  }
                else i.push(n);
              }
              a.push(i), e < t.length - 1 && a.push((0, tB.ll)`, `);
            }
          let d = this.buildWithCTE(n),
            u = tB.ll.join(a),
            h = i
              ? (0,
                tB.ll)` returning ${this.buildSelection(i, { isSingleTable: !0 })}`
              : void 0,
            p = r ? (0, tB.ll)` on conflict ${r}` : void 0,
            f = !0 === o ? (0, tB.ll)`overriding system value ` : void 0;
          return (0, tB.ll)`${d}insert into ${e} ${c} ${f}${u}${p}${h}`;
        }
        buildRefreshMaterializedViewQuery({
          view: e,
          concurrently: t,
          withNoData: r,
        }) {
          let i = t ? (0, tB.ll)` concurrently` : void 0,
            n = r ? (0, tB.ll)` with no data` : void 0;
          return (0, tB.ll)`refresh materialized view${i} ${e}${n}`;
        }
        prepareTyping(e) {
          if ((0, tP.is)(e, t2.kn) || (0, tP.is)(e, t5.iX)) return "json";
          if ((0, tP.is)(e, t6.Z5)) return "decimal";
          if ((0, tP.is)(e, t4.Xd)) return "time";
          if ((0, tP.is)(e, t3.KM) || (0, tP.is)(e, t3.xQ)) return "timestamp";
          if ((0, tP.is)(e, t8.qw) || (0, tP.is)(e, t8.dw)) return "date";
          else if ((0, tP.is)(e, t9.dL)) return "uuid";
          else return "none";
        }
        sqlToQuery(e, t) {
          return e.toQuery({
            casing: this.casing,
            escapeName: this.escapeName,
            escapeParam: this.escapeParam,
            escapeString: this.escapeString,
            prepareTyping: this.prepareTyping,
            invokeSource: t,
          });
        }
        buildRelationalQueryWithoutPK({
          fullSchema: e,
          schema: t,
          tableNamesMap: r,
          table: i,
          tableConfig: n,
          queryConfig: s,
          tableAlias: o,
          nestedQueryRelation: a,
          joinOn: l,
        }) {
          let c,
            d = [],
            u,
            h,
            p = [],
            f,
            m = [];
          if (!0 === s)
            d = Object.entries(n.columns).map(([e, t]) => ({
              dbKey: t.name,
              tsKey: e,
              field: tV(t, o),
              relationTableTsKey: void 0,
              isJson: !1,
              selection: [],
            }));
          else {
            let i = Object.fromEntries(
              Object.entries(n.columns).map(([e, t]) => [e, tV(t, o)])
            );
            if (s.where) {
              let e =
                "function" == typeof s.where
                  ? s.where(i, (0, re.mm)())
                  : s.where;
              f = e && tG(e, o);
            }
            let a = [],
              l = [];
            if (s.columns) {
              let e = !1;
              for (let [t, r] of Object.entries(s.columns))
                void 0 !== r &&
                  t in n.columns &&
                  (e || !0 !== r || (e = !0), l.push(t));
              l.length > 0 &&
                (l = e
                  ? l.filter((e) => s.columns?.[e] === !0)
                  : Object.keys(n.columns).filter((e) => !l.includes(e)));
            } else l = Object.keys(n.columns);
            for (let e of l) {
              let t = n.columns[e];
              a.push({ tsKey: e, value: t });
            }
            let c = [];
            if (
              (s.with &&
                (c = Object.entries(s.with)
                  .filter((e) => !!e[1])
                  .map(([e, t]) => ({
                    tsKey: e,
                    queryConfig: t,
                    relation: n.relations[e],
                  }))),
              s.extras)
            )
              for (let [e, t] of Object.entries(
                "function" == typeof s.extras
                  ? s.extras(i, { sql: tB.ll })
                  : s.extras
              ))
                a.push({ tsKey: e, value: tK(t, o) });
            for (let { tsKey: e, value: t } of a)
              d.push({
                dbKey: (0, tP.is)(t, tB.Xs.Aliased)
                  ? t.fieldAlias
                  : n.columns[e].name,
                tsKey: e,
                field: (0, tP.is)(t, t$.V) ? tV(t, o) : t,
                relationTableTsKey: void 0,
                isJson: !1,
                selection: [],
              });
            let y =
              "function" == typeof s.orderBy
                ? s.orderBy(i, (0, re.rl)())
                : (s.orderBy ?? []);
            for (let {
              tsKey: i,
              queryConfig: n,
              relation: a,
            } of (Array.isArray(y) || (y = [y]),
            (p = y.map((e) => ((0, tP.is)(e, t$.V) ? tV(e, o) : tG(e, o)))),
            (u = s.limit),
            (h = s.offset),
            c)) {
              let s = (0, re.W0)(t, r, a),
                l = r[(0, tM.Lf)(a.referencedTable)],
                c = `${o}_${i}`,
                u = (0, rt.Uo)(
                  ...s.fields.map((e, t) =>
                    (0, rt.eq)(tV(s.references[t], c), tV(e, o))
                  )
                ),
                h = this.buildRelationalQueryWithoutPK({
                  fullSchema: e,
                  schema: t,
                  tableNamesMap: r,
                  table: e[l],
                  tableConfig: t[l],
                  queryConfig: (0, tP.is)(a, re.pD)
                    ? !0 === n
                      ? { limit: 1 }
                      : { ...n, limit: 1 }
                    : n,
                  tableAlias: c,
                  joinOn: u,
                  nestedQueryRelation: a,
                }),
                p = (0,
                tB.ll)`${tB.ll.identifier(c)}.${tB.ll.identifier("data")}`.as(
                  i
                );
              m.push({
                on: (0, tB.ll)`true`,
                table: new rr.n(h.sql, {}, c),
                alias: c,
                joinType: "left",
                lateral: !0,
              }),
                d.push({
                  dbKey: i,
                  tsKey: i,
                  field: p,
                  relationTableTsKey: l,
                  isJson: !0,
                  selection: h.selection,
                });
            }
          }
          if (0 === d.length)
            throw new tX({
              message: `No fields selected for table "${n.tsName}" ("${o}")`,
            });
          if (((f = (0, rt.Uo)(l, f)), a)) {
            let e = (0, tB.ll)`json_build_array(${tB.ll.join(
              d.map(({ field: e, tsKey: t, isJson: r }) =>
                r
                  ? (0,
                    tB.ll)`${tB.ll.identifier(`${o}_${t}`)}.${tB.ll.identifier("data")}`
                  : (0, tP.is)(e, tB.Xs.Aliased)
                    ? e.sql
                    : e
              ),
              (0, tB.ll)`, `
            )})`;
            (0, tP.is)(a, re.iv) &&
              (e = (0,
              tB.ll)`coalesce(json_agg(${e}${p.length > 0 ? (0, tB.ll)` order by ${tB.ll.join(p, (0, tB.ll)`, `)}` : void 0}), '[]'::json)`);
            let t = [
              {
                dbKey: "data",
                tsKey: "data",
                field: e.as("data"),
                isJson: !0,
                relationTableTsKey: n.tsName,
                selection: d,
              },
            ];
            void 0 !== u || void 0 !== h || p.length > 0
              ? ((c = this.buildSelectQuery({
                  table: tz(i, o),
                  fields: {},
                  fieldsFlat: [{ path: [], field: tB.ll.raw("*") }],
                  where: f,
                  limit: u,
                  offset: h,
                  orderBy: p,
                  setOperators: [],
                })),
                (f = void 0),
                (u = void 0),
                (h = void 0),
                (p = []))
              : (c = tz(i, o)),
              (c = this.buildSelectQuery({
                table: (0, tP.is)(c, t7.mu) ? c : new rr.n(c, {}, o),
                fields: {},
                fieldsFlat: t.map(({ field: e }) => ({
                  path: [],
                  field: (0, tP.is)(e, t$.V) ? tV(e, o) : e,
                })),
                joins: m,
                where: f,
                limit: u,
                offset: h,
                orderBy: p,
                setOperators: [],
              }));
          } else
            c = this.buildSelectQuery({
              table: tz(i, o),
              fields: {},
              fieldsFlat: d.map(({ field: e }) => ({
                path: [],
                field: (0, tP.is)(e, t$.V) ? tV(e, o) : e,
              })),
              joins: m,
              where: f,
              limit: u,
              offset: h,
              orderBy: p,
              setOperators: [],
            });
          return { tableTsKey: n.tsName, sql: c, selection: d };
        }
      }
      class ro {
        static [tP.i] = "SelectionProxyHandler";
        config;
        constructor(e) {
          this.config = { ...e };
        }
        get(e, t) {
          if ("_" === t)
            return {
              ...e._,
              selectedFields: new Proxy(e._.selectedFields, this),
            };
          if (t === tj.n)
            return {
              ...e[tj.n],
              selectedFields: new Proxy(e[tj.n].selectedFields, this),
            };
          if ("symbol" == typeof t) return e[t];
          let r = (
            (0, tP.is)(e, rr.n)
              ? e._.selectedFields
              : (0, tP.is)(e, tB.Ss)
                ? e[tj.n].selectedFields
                : e
          )[t];
          if ((0, tP.is)(r, tB.Xs.Aliased)) {
            if ("sql" === this.config.sqlAliasedBehavior && !r.isSelectionField)
              return r.sql;
            let e = r.clone();
            return (e.isSelectionField = !0), e;
          }
          if ((0, tP.is)(r, tB.Xs)) {
            if ("sql" === this.config.sqlBehavior) return r;
            throw Error(
              `You tried to reference "${t}" field from a subquery, which is a raw SQL field, but it doesn't have an alias declared. Please add an alias to the field using ".as('alias')" method.`
            );
          }
          return (0, tP.is)(r, t$.V)
            ? this.config.alias
              ? new Proxy(
                  r,
                  new tW(
                    new Proxy(
                      r.table,
                      new tF(
                        this.config.alias,
                        this.config.replaceOriginalName ?? !1
                      )
                    )
                  )
                )
              : r
            : "object" != typeof r || null === r
              ? r
              : new Proxy(r, new ro(this.config));
        }
      }
      class ra {
        static [tP.i] = "TypedQueryBuilder";
        getSelectedFields() {
          return this._.selectedFields;
        }
      }
      class rl {
        static [tP.i] = "QueryPromise";
        [Symbol.toStringTag] = "QueryPromise";
        catch(e) {
          return this.then(void 0, e);
        }
        finally(e) {
          return this.then(
            (t) => (e?.(), t),
            (t) => {
              throw (e?.(), t);
            }
          );
        }
        then(e, t) {
          return this.execute().then(e, t);
        }
      }
      var rc = r(41286);
      function rd(e) {
        return (0, tP.is)(e, t7.mu)
          ? [
              e[tM.Sj]
                ? `${e[tM.Sj]}.${e[tM.XI.Symbol.BaseName]}`
                : e[tM.XI.Symbol.BaseName],
            ]
          : (0, tP.is)(e, rr.n)
            ? (e._.usedTables ?? [])
            : (0, tP.is)(e, tB.Xs)
              ? (e.usedTables ?? [])
              : [];
      }
      class ru {
        static [tP.i] = "PgSelectBuilder";
        fields;
        session;
        dialect;
        withList = [];
        distinct;
        constructor(e) {
          (this.fields = e.fields),
            (this.session = e.session),
            (this.dialect = e.dialect),
            e.withList && (this.withList = e.withList),
            (this.distinct = e.distinct);
        }
        authToken;
        setToken(e) {
          return (this.authToken = e), this;
        }
        from(e) {
          let t,
            r = !!this.fields;
          return (
            (t = this.fields
              ? this.fields
              : (0, tP.is)(e, rr.n)
                ? Object.fromEntries(
                    Object.keys(e._.selectedFields).map((t) => [t, e[t]])
                  )
                : (0, tP.is)(e, rn)
                  ? e[tj.n].selectedFields
                  : (0, tP.is)(e, tB.Xs)
                    ? {}
                    : (0, ri.YD)(e)),
            new rp({
              table: e,
              fields: t,
              isPartialSelect: r,
              session: this.session,
              dialect: this.dialect,
              withList: this.withList,
              distinct: this.distinct,
            }).setToken(this.authToken)
          );
        }
      }
      class rh extends ra {
        static [tP.i] = "PgSelectQueryBuilder";
        _;
        config;
        joinsNotNullableMap;
        tableName;
        isPartialSelect;
        session;
        dialect;
        cacheConfig = void 0;
        usedTables = new Set();
        constructor({
          table: e,
          fields: t,
          isPartialSelect: r,
          session: i,
          dialect: n,
          withList: s,
          distinct: o,
        }) {
          for (let a of (super(),
          (this.config = {
            withList: s,
            table: e,
            fields: { ...t },
            distinct: o,
            setOperators: [],
          }),
          (this.isPartialSelect = r),
          (this.session = i),
          (this.dialect = n),
          (this._ = { selectedFields: t, config: this.config }),
          (this.tableName = (0, ri.zN)(e)),
          (this.joinsNotNullableMap =
            "string" == typeof this.tableName ? { [this.tableName]: !0 } : {}),
          rd(e)))
            this.usedTables.add(a);
        }
        getUsedTables() {
          return [...this.usedTables];
        }
        createJoin(e, t) {
          return (r, i) => {
            let n = this.tableName,
              s = (0, ri.zN)(r);
            for (let e of rd(r)) this.usedTables.add(e);
            if (
              "string" == typeof s &&
              this.config.joins?.some((e) => e.alias === s)
            )
              throw Error(`Alias "${s}" is already used in this query`);
            if (
              !this.isPartialSelect &&
              (1 === Object.keys(this.joinsNotNullableMap).length &&
                "string" == typeof n &&
                (this.config.fields = { [n]: this.config.fields }),
              "string" == typeof s && !(0, tP.is)(r, tB.Xs))
            ) {
              let e = (0, tP.is)(r, rr.n)
                ? r._.selectedFields
                : (0, tP.is)(r, tB.Ss)
                  ? r[tj.n].selectedFields
                  : r[tM.XI.Symbol.Columns];
              this.config.fields[s] = e;
            }
            if (
              ("function" == typeof i &&
                (i = i(
                  new Proxy(
                    this.config.fields,
                    new ro({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })
                  )
                )),
              this.config.joins || (this.config.joins = []),
              this.config.joins.push({
                on: i,
                table: r,
                joinType: e,
                alias: s,
                lateral: t,
              }),
              "string" == typeof s)
            )
              switch (e) {
                case "left":
                  this.joinsNotNullableMap[s] = !1;
                  break;
                case "right":
                  (this.joinsNotNullableMap = Object.fromEntries(
                    Object.entries(this.joinsNotNullableMap).map(([e]) => [
                      e,
                      !1,
                    ])
                  )),
                    (this.joinsNotNullableMap[s] = !0);
                  break;
                case "cross":
                case "inner":
                  this.joinsNotNullableMap[s] = !0;
                  break;
                case "full":
                  (this.joinsNotNullableMap = Object.fromEntries(
                    Object.entries(this.joinsNotNullableMap).map(([e]) => [
                      e,
                      !1,
                    ])
                  )),
                    (this.joinsNotNullableMap[s] = !1);
              }
            return this;
          };
        }
        leftJoin = this.createJoin("left", !1);
        leftJoinLateral = this.createJoin("left", !0);
        rightJoin = this.createJoin("right", !1);
        innerJoin = this.createJoin("inner", !1);
        innerJoinLateral = this.createJoin("inner", !0);
        fullJoin = this.createJoin("full", !1);
        crossJoin = this.createJoin("cross", !1);
        crossJoinLateral = this.createJoin("cross", !0);
        createSetOperator(e, t) {
          return (r) => {
            let i = "function" == typeof r ? r(rm()) : r;
            if (!(0, ri.DV)(this.getSelectedFields(), i.getSelectedFields()))
              throw Error(
                "Set operator error (union / intersect / except): selected fields are not the same or are in a different order"
              );
            return (
              this.config.setOperators.push({
                type: e,
                isAll: t,
                rightSelect: i,
              }),
              this
            );
          };
        }
        union = this.createSetOperator("union", !1);
        unionAll = this.createSetOperator("union", !0);
        intersect = this.createSetOperator("intersect", !1);
        intersectAll = this.createSetOperator("intersect", !0);
        except = this.createSetOperator("except", !1);
        exceptAll = this.createSetOperator("except", !0);
        addSetOperators(e) {
          return this.config.setOperators.push(...e), this;
        }
        where(e) {
          return (
            "function" == typeof e &&
              (e = e(
                new Proxy(
                  this.config.fields,
                  new ro({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })
                )
              )),
            (this.config.where = e),
            this
          );
        }
        having(e) {
          return (
            "function" == typeof e &&
              (e = e(
                new Proxy(
                  this.config.fields,
                  new ro({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })
                )
              )),
            (this.config.having = e),
            this
          );
        }
        groupBy(...e) {
          if ("function" == typeof e[0]) {
            let t = e[0](
              new Proxy(
                this.config.fields,
                new ro({ sqlAliasedBehavior: "alias", sqlBehavior: "sql" })
              )
            );
            this.config.groupBy = Array.isArray(t) ? t : [t];
          } else this.config.groupBy = e;
          return this;
        }
        orderBy(...e) {
          if ("function" == typeof e[0]) {
            let t = e[0](
                new Proxy(
                  this.config.fields,
                  new ro({ sqlAliasedBehavior: "alias", sqlBehavior: "sql" })
                )
              ),
              r = Array.isArray(t) ? t : [t];
            this.config.setOperators.length > 0
              ? (this.config.setOperators.at(-1).orderBy = r)
              : (this.config.orderBy = r);
          } else
            this.config.setOperators.length > 0
              ? (this.config.setOperators.at(-1).orderBy = e)
              : (this.config.orderBy = e);
          return this;
        }
        limit(e) {
          return (
            this.config.setOperators.length > 0
              ? (this.config.setOperators.at(-1).limit = e)
              : (this.config.limit = e),
            this
          );
        }
        offset(e) {
          return (
            this.config.setOperators.length > 0
              ? (this.config.setOperators.at(-1).offset = e)
              : (this.config.offset = e),
            this
          );
        }
        for(e, t = {}) {
          return (this.config.lockingClause = { strength: e, config: t }), this;
        }
        getSQL() {
          return this.dialect.buildSelectQuery(this.config);
        }
        toSQL() {
          let { typings: e, ...t } = this.dialect.sqlToQuery(this.getSQL());
          return t;
        }
        as(e) {
          let t = [];
          if ((t.push(...rd(this.config.table)), this.config.joins))
            for (let e of this.config.joins) t.push(...rd(e.table));
          return new Proxy(
            new rr.n(this.getSQL(), this.config.fields, e, !1, [...new Set(t)]),
            new ro({
              alias: e,
              sqlAliasedBehavior: "alias",
              sqlBehavior: "error",
            })
          );
        }
        getSelectedFields() {
          return new Proxy(
            this.config.fields,
            new ro({
              alias: this.tableName,
              sqlAliasedBehavior: "alias",
              sqlBehavior: "error",
            })
          );
        }
        $dynamic() {
          return this;
        }
        $withCache(e) {
          return (
            (this.cacheConfig =
              void 0 === e
                ? { config: {}, enable: !0, autoInvalidate: !0 }
                : !1 === e
                  ? { enable: !1 }
                  : { enable: !0, autoInvalidate: !0, ...e }),
            this
          );
        }
      }
      class rp extends rh {
        static [tP.i] = "PgSelect";
        _prepare(e) {
          let {
            session: t,
            config: r,
            dialect: i,
            joinsNotNullableMap: n,
            authToken: s,
            cacheConfig: o,
            usedTables: a,
          } = this;
          if (!t)
            throw Error(
              "Cannot execute a query on a query builder. Please use a database instance instead."
            );
          let { fields: l } = r;
          return rc.k.startActiveSpan("drizzle.prepareQuery", () => {
            let r = (0, ri.He)(l),
              c = t.prepareQuery(
                i.sqlToQuery(this.getSQL()),
                r,
                e,
                !0,
                void 0,
                { type: "select", tables: [...a] },
                o
              );
            return (c.joinsNotNullableMap = n), c.setToken(s);
          });
        }
        prepare(e) {
          return this._prepare(e);
        }
        authToken;
        setToken(e) {
          return (this.authToken = e), this;
        }
        execute = (e) =>
          rc.k.startActiveSpan("drizzle.operation", () =>
            this._prepare().execute(e, this.authToken)
          );
      }
      function rf(e, t) {
        return (r, i, ...n) => {
          let s = [i, ...n].map((r) => ({ type: e, isAll: t, rightSelect: r }));
          for (let e of s)
            if (
              !(0, ri.DV)(
                r.getSelectedFields(),
                e.rightSelect.getSelectedFields()
              )
            )
              throw Error(
                "Set operator error (union / intersect / except): selected fields are not the same or are in a different order"
              );
          return r.addSetOperators(s);
        };
      }
      (0, ri.XJ)(rp, [rl]);
      let rm = () => ({
          union: ry,
          unionAll: rg,
          intersect: rw,
          intersectAll: rb,
          except: rv,
          exceptAll: rN,
        }),
        ry = rf("union", !1),
        rg = rf("union", !0),
        rw = rf("intersect", !1),
        rb = rf("intersect", !0),
        rv = rf("except", !1),
        rN = rf("except", !0);
      class rx {
        static [tP.i] = "PgQueryBuilder";
        dialect;
        dialectConfig;
        constructor(e) {
          (this.dialect = (0, tP.is)(e, rs) ? e : void 0),
            (this.dialectConfig = (0, tP.is)(e, rs) ? void 0 : e);
        }
        $with = (e, t) => {
          let r = this;
          return {
            as: (i) => (
              "function" == typeof i && (i = i(r)),
              new Proxy(
                new rr.J(
                  i.getSQL(),
                  t ??
                    ("getSelectedFields" in i
                      ? (i.getSelectedFields() ?? {})
                      : {}),
                  e,
                  !0
                ),
                new ro({
                  alias: e,
                  sqlAliasedBehavior: "alias",
                  sqlBehavior: "error",
                })
              )
            ),
          };
        };
        with(...e) {
          let t = this;
          return {
            select: function (r) {
              return new ru({
                fields: r ?? void 0,
                session: void 0,
                dialect: t.getDialect(),
                withList: e,
              });
            },
            selectDistinct: function (e) {
              return new ru({
                fields: e ?? void 0,
                session: void 0,
                dialect: t.getDialect(),
                distinct: !0,
              });
            },
            selectDistinctOn: function (e, r) {
              return new ru({
                fields: r ?? void 0,
                session: void 0,
                dialect: t.getDialect(),
                distinct: { on: e },
              });
            },
          };
        }
        select(e) {
          return new ru({
            fields: e ?? void 0,
            session: void 0,
            dialect: this.getDialect(),
          });
        }
        selectDistinct(e) {
          return new ru({
            fields: e ?? void 0,
            session: void 0,
            dialect: this.getDialect(),
            distinct: !0,
          });
        }
        selectDistinctOn(e, t) {
          return new ru({
            fields: t ?? void 0,
            session: void 0,
            dialect: this.getDialect(),
            distinct: { on: e },
          });
        }
        getDialect() {
          return (
            this.dialect || (this.dialect = new rs(this.dialectConfig)),
            this.dialect
          );
        }
      }
      class r_ {
        constructor(e, t, r, i) {
          (this.table = e),
            (this.session = t),
            (this.dialect = r),
            (this.withList = i);
        }
        static [tP.i] = "PgUpdateBuilder";
        authToken;
        setToken(e) {
          return (this.authToken = e), this;
        }
        set(e) {
          return new rS(
            this.table,
            (0, ri.q)(this.table, e),
            this.session,
            this.dialect,
            this.withList
          ).setToken(this.authToken);
        }
      }
      class rS extends rl {
        constructor(e, t, r, i, n) {
          super(),
            (this.session = r),
            (this.dialect = i),
            (this.config = { set: t, table: e, withList: n, joins: [] }),
            (this.tableName = (0, ri.zN)(e)),
            (this.joinsNotNullableMap =
              "string" == typeof this.tableName
                ? { [this.tableName]: !0 }
                : {});
        }
        static [tP.i] = "PgUpdate";
        config;
        tableName;
        joinsNotNullableMap;
        cacheConfig;
        from(e) {
          let t = (0, ri.zN)(e);
          return (
            "string" == typeof t && (this.joinsNotNullableMap[t] = !0),
            (this.config.from = e),
            this
          );
        }
        getTableLikeFields(e) {
          return (0, tP.is)(e, t7.mu)
            ? e[tM.XI.Symbol.Columns]
            : (0, tP.is)(e, rr.n)
              ? e._.selectedFields
              : e[tj.n].selectedFields;
        }
        createJoin(e) {
          return (t, r) => {
            let i = (0, ri.zN)(t);
            if (
              "string" == typeof i &&
              this.config.joins.some((e) => e.alias === i)
            )
              throw Error(`Alias "${i}" is already used in this query`);
            if ("function" == typeof r) {
              let e =
                this.config.from && !(0, tP.is)(this.config.from, tB.Xs)
                  ? this.getTableLikeFields(this.config.from)
                  : void 0;
              r = r(
                new Proxy(
                  this.config.table[tM.XI.Symbol.Columns],
                  new ro({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })
                ),
                e &&
                  new Proxy(
                    e,
                    new ro({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })
                  )
              );
            }
            if (
              (this.config.joins.push({
                on: r,
                table: t,
                joinType: e,
                alias: i,
              }),
              "string" == typeof i)
            )
              switch (e) {
                case "left":
                  this.joinsNotNullableMap[i] = !1;
                  break;
                case "right":
                  (this.joinsNotNullableMap = Object.fromEntries(
                    Object.entries(this.joinsNotNullableMap).map(([e]) => [
                      e,
                      !1,
                    ])
                  )),
                    (this.joinsNotNullableMap[i] = !0);
                  break;
                case "inner":
                  this.joinsNotNullableMap[i] = !0;
                  break;
                case "full":
                  (this.joinsNotNullableMap = Object.fromEntries(
                    Object.entries(this.joinsNotNullableMap).map(([e]) => [
                      e,
                      !1,
                    ])
                  )),
                    (this.joinsNotNullableMap[i] = !1);
              }
            return this;
          };
        }
        leftJoin = this.createJoin("left");
        rightJoin = this.createJoin("right");
        innerJoin = this.createJoin("inner");
        fullJoin = this.createJoin("full");
        where(e) {
          return (this.config.where = e), this;
        }
        returning(e) {
          if (
            !e &&
            ((e = Object.assign({}, this.config.table[tM.XI.Symbol.Columns])),
            this.config.from)
          ) {
            let t = (0, ri.zN)(this.config.from);
            if (
              "string" == typeof t &&
              this.config.from &&
              !(0, tP.is)(this.config.from, tB.Xs)
            ) {
              let r = this.getTableLikeFields(this.config.from);
              e[t] = r;
            }
            for (let t of this.config.joins) {
              let r = (0, ri.zN)(t.table);
              if ("string" == typeof r && !(0, tP.is)(t.table, tB.Xs)) {
                let i = this.getTableLikeFields(t.table);
                e[r] = i;
              }
            }
          }
          return (
            (this.config.returningFields = e),
            (this.config.returning = (0, ri.He)(e)),
            this
          );
        }
        getSQL() {
          return this.dialect.buildUpdateQuery(this.config);
        }
        toSQL() {
          let { typings: e, ...t } = this.dialect.sqlToQuery(this.getSQL());
          return t;
        }
        _prepare(e) {
          let t = this.session.prepareQuery(
            this.dialect.sqlToQuery(this.getSQL()),
            this.config.returning,
            e,
            !0,
            void 0,
            { type: "insert", tables: rd(this.config.table) },
            this.cacheConfig
          );
          return (t.joinsNotNullableMap = this.joinsNotNullableMap), t;
        }
        prepare(e) {
          return this._prepare(e);
        }
        authToken;
        setToken(e) {
          return (this.authToken = e), this;
        }
        execute = (e) => this._prepare().execute(e, this.authToken);
        getSelectedFields() {
          return this.config.returningFields
            ? new Proxy(
                this.config.returningFields,
                new ro({
                  alias: (0, tM.Io)(this.config.table),
                  sqlAliasedBehavior: "alias",
                  sqlBehavior: "error",
                })
              )
            : void 0;
        }
        $dynamic() {
          return this;
        }
      }
      class rT {
        constructor(e, t, r, i, n) {
          (this.table = e),
            (this.session = t),
            (this.dialect = r),
            (this.withList = i),
            (this.overridingSystemValue_ = n);
        }
        static [tP.i] = "PgInsertBuilder";
        authToken;
        setToken(e) {
          return (this.authToken = e), this;
        }
        overridingSystemValue() {
          return (this.overridingSystemValue_ = !0), this;
        }
        values(e) {
          if (0 === (e = Array.isArray(e) ? e : [e]).length)
            throw Error("values() must be called with at least one value");
          let t = e.map((e) => {
            let t = {},
              r = this.table[tM.XI.Symbol.Columns];
            for (let i of Object.keys(e)) {
              let n = e[i];
              t[i] = (0, tP.is)(n, tB.Xs) ? n : new tB.Iw(n, r[i]);
            }
            return t;
          });
          return new rk(
            this.table,
            t,
            this.session,
            this.dialect,
            this.withList,
            !1,
            this.overridingSystemValue_
          ).setToken(this.authToken);
        }
        select(e) {
          let t = "function" == typeof e ? e(new rx()) : e;
          if (
            !(0, tP.is)(t, tB.Xs) &&
            !(0, ri.DV)(this.table[tM.e], t._.selectedFields)
          )
            throw Error(
              "Insert select error: selected fields are not the same or are in a different order compared to the table definition"
            );
          return new rk(
            this.table,
            t,
            this.session,
            this.dialect,
            this.withList,
            !0
          );
        }
      }
      class rk extends rl {
        constructor(e, t, r, i, n, s, o) {
          super(),
            (this.session = r),
            (this.dialect = i),
            (this.config = {
              table: e,
              values: t,
              withList: n,
              select: s,
              overridingSystemValue_: o,
            });
        }
        static [tP.i] = "PgInsert";
        config;
        cacheConfig;
        returning(e = this.config.table[tM.XI.Symbol.Columns]) {
          return (
            (this.config.returningFields = e),
            (this.config.returning = (0, ri.He)(e)),
            this
          );
        }
        onConflictDoNothing(e = {}) {
          if (void 0 === e.target)
            this.config.onConflict = (0, tB.ll)`do nothing`;
          else {
            let t = "";
            t = Array.isArray(e.target)
              ? e.target
                  .map((e) =>
                    this.dialect.escapeName(
                      this.dialect.casing.getColumnCasing(e)
                    )
                  )
                  .join(",")
              : this.dialect.escapeName(
                  this.dialect.casing.getColumnCasing(e.target)
                );
            let r = e.where ? (0, tB.ll)` where ${e.where}` : void 0;
            this.config.onConflict = (0,
            tB.ll)`(${tB.ll.raw(t)})${r} do nothing`;
          }
          return this;
        }
        onConflictDoUpdate(e) {
          if (e.where && (e.targetWhere || e.setWhere))
            throw Error(
              'You cannot use both "where" and "targetWhere"/"setWhere" at the same time - "where" is deprecated, use "targetWhere" or "setWhere" instead.'
            );
          let t = e.where ? (0, tB.ll)` where ${e.where}` : void 0,
            r = e.targetWhere ? (0, tB.ll)` where ${e.targetWhere}` : void 0,
            i = e.setWhere ? (0, tB.ll)` where ${e.setWhere}` : void 0,
            n = this.dialect.buildUpdateSet(
              this.config.table,
              (0, ri.q)(this.config.table, e.set)
            ),
            s = "";
          return (
            (s = Array.isArray(e.target)
              ? e.target
                  .map((e) =>
                    this.dialect.escapeName(
                      this.dialect.casing.getColumnCasing(e)
                    )
                  )
                  .join(",")
              : this.dialect.escapeName(
                  this.dialect.casing.getColumnCasing(e.target)
                )),
            (this.config.onConflict = (0,
            tB.ll)`(${tB.ll.raw(s)})${r} do update set ${n}${t}${i}`),
            this
          );
        }
        getSQL() {
          return this.dialect.buildInsertQuery(this.config);
        }
        toSQL() {
          let { typings: e, ...t } = this.dialect.sqlToQuery(this.getSQL());
          return t;
        }
        _prepare(e) {
          return rc.k.startActiveSpan("drizzle.prepareQuery", () =>
            this.session.prepareQuery(
              this.dialect.sqlToQuery(this.getSQL()),
              this.config.returning,
              e,
              !0,
              void 0,
              { type: "insert", tables: rd(this.config.table) },
              this.cacheConfig
            )
          );
        }
        prepare(e) {
          return this._prepare(e);
        }
        authToken;
        setToken(e) {
          return (this.authToken = e), this;
        }
        execute = (e) =>
          rc.k.startActiveSpan("drizzle.operation", () =>
            this._prepare().execute(e, this.authToken)
          );
        getSelectedFields() {
          return this.config.returningFields
            ? new Proxy(
                this.config.returningFields,
                new ro({
                  alias: (0, tM.Io)(this.config.table),
                  sqlAliasedBehavior: "alias",
                  sqlBehavior: "error",
                })
              )
            : void 0;
        }
        $dynamic() {
          return this;
        }
      }
      class rA extends rl {
        constructor(e, t, r, i) {
          super(),
            (this.session = t),
            (this.dialect = r),
            (this.config = { table: e, withList: i });
        }
        static [tP.i] = "PgDelete";
        config;
        cacheConfig;
        where(e) {
          return (this.config.where = e), this;
        }
        returning(e = this.config.table[tM.XI.Symbol.Columns]) {
          return (
            (this.config.returningFields = e),
            (this.config.returning = (0, ri.He)(e)),
            this
          );
        }
        getSQL() {
          return this.dialect.buildDeleteQuery(this.config);
        }
        toSQL() {
          let { typings: e, ...t } = this.dialect.sqlToQuery(this.getSQL());
          return t;
        }
        _prepare(e) {
          return rc.k.startActiveSpan("drizzle.prepareQuery", () =>
            this.session.prepareQuery(
              this.dialect.sqlToQuery(this.getSQL()),
              this.config.returning,
              e,
              !0,
              void 0,
              { type: "delete", tables: rd(this.config.table) },
              this.cacheConfig
            )
          );
        }
        prepare(e) {
          return this._prepare(e);
        }
        authToken;
        setToken(e) {
          return (this.authToken = e), this;
        }
        execute = (e) =>
          rc.k.startActiveSpan("drizzle.operation", () =>
            this._prepare().execute(e, this.authToken)
          );
        getSelectedFields() {
          return this.config.returningFields
            ? new Proxy(
                this.config.returningFields,
                new ro({
                  alias: (0, tM.Io)(this.config.table),
                  sqlAliasedBehavior: "alias",
                  sqlBehavior: "error",
                })
              )
            : void 0;
        }
        $dynamic() {
          return this;
        }
      }
      class rE extends tB.Xs {
        constructor(e) {
          super(rE.buildEmbeddedCount(e.source, e.filters).queryChunks),
            (this.params = e),
            this.mapWith(Number),
            (this.session = e.session),
            (this.sql = rE.buildCount(e.source, e.filters));
        }
        sql;
        token;
        static [tP.i] = "PgCountBuilder";
        [Symbol.toStringTag] = "PgCountBuilder";
        session;
        static buildEmbeddedCount(e, t) {
          return (0,
          tB.ll)`(select count(*) from ${e}${tB.ll.raw(" where ").if(t)}${t})`;
        }
        static buildCount(e, t) {
          return (0,
          tB.ll)`select count(*) as count from ${e}${tB.ll.raw(" where ").if(t)}${t};`;
        }
        setToken(e) {
          return (this.token = e), this;
        }
        then(e, t) {
          return Promise.resolve(this.session.count(this.sql, this.token)).then(
            e,
            t
          );
        }
        catch(e) {
          return this.then(void 0, e);
        }
        finally(e) {
          return this.then(
            (t) => (e?.(), t),
            (t) => {
              throw (e?.(), t);
            }
          );
        }
      }
      class rC {
        constructor(e, t, r, i, n, s, o) {
          (this.fullSchema = e),
            (this.schema = t),
            (this.tableNamesMap = r),
            (this.table = i),
            (this.tableConfig = n),
            (this.dialect = s),
            (this.session = o);
        }
        static [tP.i] = "PgRelationalQueryBuilder";
        findMany(e) {
          return new rI(
            this.fullSchema,
            this.schema,
            this.tableNamesMap,
            this.table,
            this.tableConfig,
            this.dialect,
            this.session,
            e || {},
            "many"
          );
        }
        findFirst(e) {
          return new rI(
            this.fullSchema,
            this.schema,
            this.tableNamesMap,
            this.table,
            this.tableConfig,
            this.dialect,
            this.session,
            e ? { ...e, limit: 1 } : { limit: 1 },
            "first"
          );
        }
      }
      class rI extends rl {
        constructor(e, t, r, i, n, s, o, a, l) {
          super(),
            (this.fullSchema = e),
            (this.schema = t),
            (this.tableNamesMap = r),
            (this.table = i),
            (this.tableConfig = n),
            (this.dialect = s),
            (this.session = o),
            (this.config = a),
            (this.mode = l);
        }
        static [tP.i] = "PgRelationalQuery";
        _prepare(e) {
          return rc.k.startActiveSpan("drizzle.prepareQuery", () => {
            let { query: t, builtQuery: r } = this._toSQL();
            return this.session.prepareQuery(r, void 0, e, !0, (e, r) => {
              let i = e.map((e) =>
                (0, re.I$)(this.schema, this.tableConfig, e, t.selection, r)
              );
              return "first" === this.mode ? i[0] : i;
            });
          });
        }
        prepare(e) {
          return this._prepare(e);
        }
        _getQuery() {
          return this.dialect.buildRelationalQueryWithoutPK({
            fullSchema: this.fullSchema,
            schema: this.schema,
            tableNamesMap: this.tableNamesMap,
            table: this.table,
            tableConfig: this.tableConfig,
            queryConfig: this.config,
            tableAlias: this.tableConfig.tsName,
          });
        }
        getSQL() {
          return this._getQuery().sql;
        }
        _toSQL() {
          let e = this._getQuery(),
            t = this.dialect.sqlToQuery(e.sql);
          return { query: e, builtQuery: t };
        }
        toSQL() {
          return this._toSQL().builtQuery;
        }
        authToken;
        setToken(e) {
          return (this.authToken = e), this;
        }
        execute() {
          return rc.k.startActiveSpan("drizzle.operation", () =>
            this._prepare().execute(void 0, this.authToken)
          );
        }
      }
      class rO extends rl {
        constructor(e, t, r, i) {
          super(),
            (this.execute = e),
            (this.sql = t),
            (this.query = r),
            (this.mapBatchResult = i);
        }
        static [tP.i] = "PgRaw";
        getSQL() {
          return this.sql;
        }
        getQuery() {
          return this.query;
        }
        mapResult(e, t) {
          return t ? this.mapBatchResult(e) : e;
        }
        _prepare() {
          return this;
        }
        isResponseInArrayMode() {
          return !1;
        }
      }
      class rL extends rl {
        constructor(e, t, r) {
          super(),
            (this.session = t),
            (this.dialect = r),
            (this.config = { view: e });
        }
        static [tP.i] = "PgRefreshMaterializedView";
        config;
        concurrently() {
          if (void 0 !== this.config.withNoData)
            throw Error("Cannot use concurrently and withNoData together");
          return (this.config.concurrently = !0), this;
        }
        withNoData() {
          if (void 0 !== this.config.concurrently)
            throw Error("Cannot use concurrently and withNoData together");
          return (this.config.withNoData = !0), this;
        }
        getSQL() {
          return this.dialect.buildRefreshMaterializedViewQuery(this.config);
        }
        toSQL() {
          let { typings: e, ...t } = this.dialect.sqlToQuery(this.getSQL());
          return t;
        }
        _prepare(e) {
          return rc.k.startActiveSpan("drizzle.prepareQuery", () =>
            this.session.prepareQuery(
              this.dialect.sqlToQuery(this.getSQL()),
              void 0,
              e,
              !0
            )
          );
        }
        prepare(e) {
          return this._prepare(e);
        }
        authToken;
        setToken(e) {
          return (this.authToken = e), this;
        }
        execute = (e) =>
          rc.k.startActiveSpan("drizzle.operation", () =>
            this._prepare().execute(e, this.authToken)
          );
      }
      class rR {
        constructor(e, t, r) {
          if (
            ((this.dialect = e),
            (this.session = t),
            (this._ = r
              ? {
                  schema: r.schema,
                  fullSchema: r.fullSchema,
                  tableNamesMap: r.tableNamesMap,
                  session: t,
                }
              : {
                  schema: void 0,
                  fullSchema: {},
                  tableNamesMap: {},
                  session: t,
                }),
            (this.query = {}),
            this._.schema)
          )
            for (let [i, n] of Object.entries(this._.schema))
              this.query[i] = new rC(
                r.fullSchema,
                this._.schema,
                this._.tableNamesMap,
                r.fullSchema[i],
                n,
                e,
                t
              );
          this.$cache = { invalidate: async (e) => {} };
        }
        static [tP.i] = "PgDatabase";
        query;
        $with = (e, t) => {
          let r = this;
          return {
            as: (i) => (
              "function" == typeof i && (i = i(new rx(r.dialect))),
              new Proxy(
                new rr.J(
                  i.getSQL(),
                  t ??
                    ("getSelectedFields" in i
                      ? (i.getSelectedFields() ?? {})
                      : {}),
                  e,
                  !0
                ),
                new ro({
                  alias: e,
                  sqlAliasedBehavior: "alias",
                  sqlBehavior: "error",
                })
              )
            ),
          };
        };
        $count(e, t) {
          return new rE({ source: e, filters: t, session: this.session });
        }
        $cache;
        with(...e) {
          let t = this;
          return {
            select: function (r) {
              return new ru({
                fields: r ?? void 0,
                session: t.session,
                dialect: t.dialect,
                withList: e,
              });
            },
            selectDistinct: function (r) {
              return new ru({
                fields: r ?? void 0,
                session: t.session,
                dialect: t.dialect,
                withList: e,
                distinct: !0,
              });
            },
            selectDistinctOn: function (r, i) {
              return new ru({
                fields: i ?? void 0,
                session: t.session,
                dialect: t.dialect,
                withList: e,
                distinct: { on: r },
              });
            },
            update: function (r) {
              return new r_(r, t.session, t.dialect, e);
            },
            insert: function (r) {
              return new rT(r, t.session, t.dialect, e);
            },
            delete: function (r) {
              return new rA(r, t.session, t.dialect, e);
            },
          };
        }
        select(e) {
          return new ru({
            fields: e ?? void 0,
            session: this.session,
            dialect: this.dialect,
          });
        }
        selectDistinct(e) {
          return new ru({
            fields: e ?? void 0,
            session: this.session,
            dialect: this.dialect,
            distinct: !0,
          });
        }
        selectDistinctOn(e, t) {
          return new ru({
            fields: t ?? void 0,
            session: this.session,
            dialect: this.dialect,
            distinct: { on: e },
          });
        }
        update(e) {
          return new r_(e, this.session, this.dialect);
        }
        insert(e) {
          return new rT(e, this.session, this.dialect);
        }
        delete(e) {
          return new rA(e, this.session, this.dialect);
        }
        refreshMaterializedView(e) {
          return new rL(e, this.session, this.dialect);
        }
        authToken;
        execute(e) {
          let t = "string" == typeof e ? tB.ll.raw(e) : e.getSQL(),
            r = this.dialect.sqlToQuery(t),
            i = this.session.prepareQuery(r, void 0, void 0, !1);
          return new rO(
            () => i.execute(void 0, this.authToken),
            t,
            r,
            (e) => i.mapResult(e, !0)
          );
        }
        transaction(e, t) {
          return this.session.transaction(e, t);
        }
      }
      class rP {
        static [tP.i] = "Cache";
      }
      class rD extends rP {
        strategy() {
          return "all";
        }
        static [tP.i] = "NoopCache";
        async get(e) {}
        async put(e, t, r, i) {}
        async onMutate(e) {}
      }
      async function rq(e, t) {
        let r = `${e}-${JSON.stringify(t)}`,
          i = new TextEncoder().encode(r);
        return [...new Uint8Array(await crypto.subtle.digest("SHA-256", i))]
          .map((e) => e.toString(16).padStart(2, "0"))
          .join("");
      }
      class rU extends Error {
        constructor(e, t, r) {
          super(`Failed query: ${e}
params: ${t}`),
            (this.query = e),
            (this.params = t),
            (this.cause = r),
            Error.captureStackTrace(this, rU),
            r && (this.cause = r);
        }
      }
      class r$ {
        constructor(e, t, r, i) {
          (this.query = e),
            (this.cache = t),
            (this.queryMetadata = r),
            (this.cacheConfig = i),
            t &&
              "all" === t.strategy() &&
              void 0 === i &&
              (this.cacheConfig = { enable: !0, autoInvalidate: !0 }),
            this.cacheConfig?.enable || (this.cacheConfig = void 0);
        }
        authToken;
        getQuery() {
          return this.query;
        }
        mapResult(e, t) {
          return e;
        }
        setToken(e) {
          return (this.authToken = e), this;
        }
        static [tP.i] = "PgPreparedQuery";
        joinsNotNullableMap;
        async queryWithCache(e, t, r) {
          if (
            void 0 === this.cache ||
            (0, tP.is)(this.cache, rD) ||
            void 0 === this.queryMetadata ||
            (this.cacheConfig && !this.cacheConfig.enable)
          )
            try {
              return await r();
            } catch (r) {
              throw new rU(e, t, r);
            }
          if (
            ("insert" === this.queryMetadata.type ||
              "update" === this.queryMetadata.type ||
              "delete" === this.queryMetadata.type) &&
            this.queryMetadata.tables.length > 0
          )
            try {
              let [e] = await Promise.all([
                r(),
                this.cache.onMutate({ tables: this.queryMetadata.tables }),
              ]);
              return e;
            } catch (r) {
              throw new rU(e, t, r);
            }
          if (!this.cacheConfig)
            try {
              return await r();
            } catch (r) {
              throw new rU(e, t, r);
            }
          if ("select" === this.queryMetadata.type) {
            let i = await this.cache.get(
              this.cacheConfig.tag ?? (await rq(e, t)),
              this.queryMetadata.tables,
              void 0 !== this.cacheConfig.tag,
              this.cacheConfig.autoInvalidate
            );
            if (void 0 === i) {
              let i;
              try {
                i = await r();
              } catch (r) {
                throw new rU(e, t, r);
              }
              return (
                await this.cache.put(
                  this.cacheConfig.tag ?? (await rq(e, t)),
                  i,
                  this.cacheConfig.autoInvalidate
                    ? this.queryMetadata.tables
                    : [],
                  void 0 !== this.cacheConfig.tag,
                  this.cacheConfig.config
                ),
                i
              );
            }
            return i;
          }
          try {
            return await r();
          } catch (r) {
            throw new rU(e, t, r);
          }
        }
      }
      class rB {
        constructor(e) {
          this.dialect = e;
        }
        static [tP.i] = "PgSession";
        execute(e, t) {
          return rc.k.startActiveSpan("drizzle.operation", () =>
            rc.k
              .startActiveSpan("drizzle.prepareQuery", () =>
                this.prepareQuery(
                  this.dialect.sqlToQuery(e),
                  void 0,
                  void 0,
                  !1
                )
              )
              .setToken(t)
              .execute(void 0, t)
          );
        }
        all(e) {
          return this.prepareQuery(
            this.dialect.sqlToQuery(e),
            void 0,
            void 0,
            !1
          ).all();
        }
        async count(e, t) {
          return Number((await this.execute(e, t))[0].count);
        }
      }
      class rM extends rR {
        constructor(e, t, r, i = 0) {
          super(e, t, r), (this.schema = r), (this.nestedIndex = i);
        }
        static [tP.i] = "PgTransaction";
        rollback() {
          throw new t0();
        }
        getTransactionConfigSQL(e) {
          let t = [];
          return (
            e.isolationLevel && t.push(`isolation level ${e.isolationLevel}`),
            e.accessMode && t.push(e.accessMode),
            "boolean" == typeof e.deferrable &&
              t.push(e.deferrable ? "deferrable" : "not deferrable"),
            tB.ll.raw(t.join(" "))
          );
        }
        setTransaction(e) {
          return this.session.execute(
            (0, tB.ll)`set transaction ${this.getTransactionConfigSQL(e)}`
          );
        }
      }
      class rj extends r$ {
        constructor(e, t, r, i, n, s, o, a, l, c, d) {
          super({ sql: t, params: r }, n, s, o),
            (this.client = e),
            (this.params = r),
            (this.logger = i),
            (this.fields = a),
            (this._isResponseInArrayMode = c),
            (this.customResultMapper = d),
            (this.rawQueryConfig = {
              name: l,
              text: t,
              types: {
                getTypeParser: (e, t) =>
                  e === tR.builtins.TIMESTAMPTZ ||
                  e === tR.builtins.TIMESTAMP ||
                  e === tR.builtins.DATE ||
                  e === tR.builtins.INTERVAL ||
                  1231 === e ||
                  1115 === e ||
                  1185 === e ||
                  1187 === e ||
                  1182 === e
                    ? (e) => e
                    : tR.getTypeParser(e, t),
              },
            }),
            (this.queryConfig = {
              name: l,
              text: t,
              rowMode: "array",
              types: {
                getTypeParser: (e, t) =>
                  e === tR.builtins.TIMESTAMPTZ ||
                  e === tR.builtins.TIMESTAMP ||
                  e === tR.builtins.DATE ||
                  e === tR.builtins.INTERVAL ||
                  1231 === e ||
                  1115 === e ||
                  1185 === e ||
                  1187 === e ||
                  1182 === e
                    ? (e) => e
                    : tR.getTypeParser(e, t),
              },
            });
        }
        static [tP.i] = "NeonPreparedQuery";
        rawQueryConfig;
        queryConfig;
        async execute(e = {}) {
          let t = (0, tB.Ct)(this.params, e);
          this.logger.logQuery(this.rawQueryConfig.text, t);
          let {
            fields: r,
            client: i,
            rawQueryConfig: n,
            queryConfig: s,
            joinsNotNullableMap: o,
            customResultMapper: a,
          } = this;
          if (!r && !a)
            return await this.queryWithCache(
              n.text,
              t,
              async () => await i.query(n, t)
            );
          let l = await this.queryWithCache(
            s.text,
            t,
            async () => await i.query(s, t)
          );
          return a ? a(l.rows) : l.rows.map((e) => (0, ri.a6)(r, e, o));
        }
        all(e = {}) {
          let t = (0, tB.Ct)(this.params, e);
          return (
            this.logger.logQuery(this.rawQueryConfig.text, t),
            this.queryWithCache(
              this.rawQueryConfig.text,
              t,
              async () => await this.client.query(this.rawQueryConfig, t)
            ).then((e) => e.rows)
          );
        }
        values(e = {}) {
          let t = (0, tB.Ct)(this.params, e);
          return (
            this.logger.logQuery(this.rawQueryConfig.text, t),
            this.queryWithCache(
              this.queryConfig.text,
              t,
              async () => await this.client.query(this.queryConfig, t)
            ).then((e) => e.rows)
          );
        }
        isResponseInArrayMode() {
          return this._isResponseInArrayMode;
        }
      }
      class rW extends rB {
        constructor(e, t, r, i = {}) {
          super(t),
            (this.client = e),
            (this.schema = r),
            (this.options = i),
            (this.logger = i.logger ?? new tU()),
            (this.cache = i.cache ?? new rD());
        }
        static [tP.i] = "NeonSession";
        logger;
        cache;
        prepareQuery(e, t, r, i, n, s, o) {
          return new rj(
            this.client,
            e.sql,
            e.params,
            this.logger,
            this.cache,
            s,
            o,
            t,
            r,
            i,
            n
          );
        }
        async query(e, t) {
          return (
            this.logger.logQuery(e, t),
            await this.client.query({ rowMode: "array", text: e, values: t })
          );
        }
        async queryObjects(e, t) {
          return this.client.query(e, t);
        }
        async count(e) {
          return Number((await this.execute(e)).rows[0].count);
        }
        async transaction(e, t = {}) {
          let r =
              this.client instanceof tO
                ? new rW(
                    await this.client.connect(),
                    this.dialect,
                    this.schema,
                    this.options
                  )
                : this,
            i = new rF(this.dialect, r, this.schema);
          await i.execute((0, tB.ll)`begin ${i.getTransactionConfigSQL(t)}`);
          try {
            let t = await e(i);
            return await i.execute((0, tB.ll)`commit`), t;
          } catch (e) {
            throw (await i.execute((0, tB.ll)`rollback`), e);
          } finally {
            this.client instanceof tO && r.client.release();
          }
        }
      }
      class rF extends rM {
        static [tP.i] = "NeonTransaction";
        async transaction(e) {
          let t = `sp${this.nestedIndex + 1}`,
            r = new rF(
              this.dialect,
              this.session,
              this.schema,
              this.nestedIndex + 1
            );
          await r.execute(tB.ll.raw(`savepoint ${t}`));
          try {
            let i = await e(r);
            return await r.execute(tB.ll.raw(`release savepoint ${t}`)), i;
          } catch (e) {
            throw (await r.execute(tB.ll.raw(`rollback to savepoint ${t}`)), e);
          }
        }
      }
      class rQ {
        constructor(e, t, r = {}) {
          (this.client = e), (this.dialect = t), (this.options = r);
        }
        static [tP.i] = "NeonDriver";
        createSession(e) {
          return new rW(this.client, this.dialect, e, {
            logger: this.options.logger,
            cache: this.options.cache,
          });
        }
      }
      class rz extends rR {
        static [tP.i] = "NeonServerlessDatabase";
      }
      function rV(e, t = {}) {
        let r,
          i,
          n = new rs({ casing: t.casing });
        if (
          (!0 === t.logger ? (r = new tq()) : !1 !== t.logger && (r = t.logger),
          t.schema)
        ) {
          let e = (0, re._k)(t.schema, re.DZ);
          i = {
            fullSchema: t.schema,
            schema: e.tables,
            tableNamesMap: e.tableNamesMap,
          };
        }
        let s = new rQ(e, n, { logger: r, cache: t.cache }).createSession(i),
          o = new rz(n, s, i);
        return (
          (o.$client = e),
          (o.$cache = t.cache),
          o.$cache && (o.$cache.invalidate = t.cache?.onMutate),
          o
        );
      }
      function rK(...e) {
        if ("string" == typeof e[0])
          return rV(new tO({ connectionString: e[0] }), e[1]);
        if ((0, ri.Lq)(e[0])) {
          let { connection: t, client: r, ws: i, ...n } = e[0];
          return (i && (P.webSocketConstructor = i), r)
            ? rV(r, n)
            : rV(new tO("string" == typeof t ? { connectionString: t } : t), n);
        }
        return rV(e[0], e[1]);
      }
      (rK || (rK = {})).mock = function (e) {
        return rV({}, e);
      };
    },
    29194: (e, t, r) => {
      r.d(t, { A: () => s, g: () => o });
      var i = r(72623),
        n = r(29882);
      let s = (e) => (0, n.A)(e) || (0, i.R)(e),
        o = ["KeyObject"];
      (globalThis.CryptoKey || i.A?.CryptoKey) && o.push("CryptoKey");
    },
    29597: (e, t, r) => {
      r.d(t, { o: () => n });
      var i = r(96051);
      let n = (0, i.CN)({
        is: (e) => "InsertQueryNode" === e.kind,
        create: (e, t, r) =>
          (0, i.CN)({
            kind: "InsertQueryNode",
            into: e,
            ...(t && { with: t }),
            replace: r,
          }),
        createWithoutInto: () => (0, i.CN)({ kind: "InsertQueryNode" }),
        cloneWith: (e, t) => (0, i.CN)({ ...e, ...t }),
      });
    },
    29882: (e, t, r) => {
      r.d(t, { A: () => n });
      var i = r(57975);
      let n = (e) => i.types.isKeyObject(e);
    },
    29900: (e, t, r) => {
      r.d(t, { E: () => o });
      var i = r(1045),
        n = r(96051),
        s = r(6710);
      let o = (0, n.CN)({
        raw: (e, t = []) =>
          (0, n.CN)({
            sql: e,
            query: i.z.createWithSql(e),
            parameters: (0, n.CN)(t),
            queryId: (0, s.a)(),
          }),
      });
    },
    29911: (e, t, r) => {
      r.d(t, {
        iv: () => m,
        pD: () => f,
        DZ: () => N,
        _k: () => w,
        mm: () => y,
        rl: () => g,
        I$: () =>
          function e(t, r, i, o, a = (e) => e) {
            let l = {};
            for (let [c, d] of o.entries())
              if (d.isJson) {
                let n = r.relations[d.tsKey],
                  o = i[c],
                  u = "string" == typeof o ? JSON.parse(o) : o;
                l[d.tsKey] = (0, s.is)(n, f)
                  ? u && e(t, t[d.relationTableTsKey], u, d.selection, a)
                  : u.map((r) =>
                      e(t, t[d.relationTableTsKey], r, d.selection, a)
                    );
              } else {
                let e,
                  t = a(i[c]),
                  r = d.field;
                (e = (0, s.is)(r, n.V)
                  ? r
                  : (0, s.is)(r, u.Xs)
                    ? r.decoder
                    : r.sql.decoder),
                  (l[d.tsKey] = null === t ? null : e.mapFromDriverValue(t));
              }
            return l;
          },
        W0: () => v,
        K1: () => b,
      });
      var i = r(47590),
        n = r(93994),
        s = r(90211),
        o = r(1081);
      class a {
        static [s.i] = "PgPrimaryKeyBuilder";
        columns;
        name;
        constructor(e, t) {
          (this.columns = e), (this.name = t);
        }
        build(e) {
          return new l(e, this.columns, this.name);
        }
      }
      class l {
        constructor(e, t, r) {
          (this.table = e), (this.columns = t), (this.name = r);
        }
        static [s.i] = "PgPrimaryKey";
        columns;
        name;
        getName() {
          return (
            this.name ??
            `${this.table[o.mu.Symbol.Name]}_${this.columns.map((e) => e.name).join("_")}_pk`
          );
        }
      }
      var c = r(22047),
        d = r(51101),
        u = r(11916);
      class h {
        constructor(e, t, r) {
          (this.sourceTable = e),
            (this.referencedTable = t),
            (this.relationName = r),
            (this.referencedTableName = t[i.XI.Symbol.Name]);
        }
        static [s.i] = "Relation";
        referencedTableName;
        fieldName;
      }
      class p {
        constructor(e, t) {
          (this.table = e), (this.config = t);
        }
        static [s.i] = "Relations";
      }
      class f extends h {
        constructor(e, t, r, i) {
          super(e, t, r?.relationName),
            (this.config = r),
            (this.isNullable = i);
        }
        static [s.i] = "One";
        withFieldName(e) {
          let t = new f(
            this.sourceTable,
            this.referencedTable,
            this.config,
            this.isNullable
          );
          return (t.fieldName = e), t;
        }
      }
      class m extends h {
        constructor(e, t, r) {
          super(e, t, r?.relationName), (this.config = r);
        }
        static [s.i] = "Many";
        withFieldName(e) {
          let t = new m(this.sourceTable, this.referencedTable, this.config);
          return (t.fieldName = e), t;
        }
      }
      function y() {
        return {
          and: c.Uo,
          between: c.Tq,
          eq: c.eq,
          exists: c.t2,
          gt: c.gt,
          gte: c.RO,
          ilike: c.B3,
          inArray: c.RV,
          isNull: c.kZ,
          isNotNull: c.Pe,
          like: c.mj,
          lt: c.lt,
          lte: c.wJ,
          ne: c.ne,
          not: c.AU,
          notBetween: c.o8,
          notExists: c.KJ,
          notLike: c.RK,
          notIlike: c.q1,
          notInArray: c.KL,
          or: c.or,
          sql: u.ll,
        };
      }
      function g() {
        return { sql: u.ll, asc: d.Y, desc: d.i };
      }
      function w(e, t) {
        1 === Object.keys(e).length &&
          "default" in e &&
          !(0, s.is)(e.default, i.XI) &&
          (e = e.default);
        let r = {},
          n = {},
          o = {};
        for (let [l, c] of Object.entries(e))
          if ((0, s.is)(c, i.XI)) {
            let e = (0, i.Lf)(c),
              t = n[e];
            for (let n of ((r[e] = l),
            (o[l] = {
              tsName: l,
              dbName: c[i.XI.Symbol.Name],
              schema: c[i.XI.Symbol.Schema],
              columns: c[i.XI.Symbol.Columns],
              relations: t?.relations ?? {},
              primaryKey: t?.primaryKey ?? [],
            }),
            Object.values(c[i.XI.Symbol.Columns])))
              n.primary && o[l].primaryKey.push(n);
            let d = c[i.XI.Symbol.ExtraConfigBuilder]?.(
              c[i.XI.Symbol.ExtraConfigColumns]
            );
            if (d)
              for (let e of Object.values(d))
                (0, s.is)(e, a) && o[l].primaryKey.push(...e.columns);
          } else if ((0, s.is)(c, p)) {
            let e,
              s = (0, i.Lf)(c.table),
              a = r[s];
            for (let [r, i] of Object.entries(c.config(t(c.table))))
              if (a) {
                let t = o[a];
                (t.relations[r] = i), e && t.primaryKey.push(...e);
              } else
                s in n || (n[s] = { relations: {}, primaryKey: e }),
                  (n[s].relations[r] = i);
          }
        return { tables: o, tableNamesMap: r };
      }
      function b(e, t) {
        return new p(e, (e) =>
          Object.fromEntries(
            Object.entries(t(e)).map(([e, t]) => [e, t.withFieldName(e)])
          )
        );
      }
      function v(e, t, r) {
        if ((0, s.is)(r, f) && r.config)
          return { fields: r.config.fields, references: r.config.references };
        let n = t[(0, i.Lf)(r.referencedTable)];
        if (!n)
          throw Error(
            `Table "${r.referencedTable[i.XI.Symbol.Name]}" not found in schema`
          );
        let o = e[n];
        if (!o) throw Error(`Table "${n}" not found in schema`);
        let a = r.sourceTable,
          l = t[(0, i.Lf)(a)];
        if (!l)
          throw Error(`Table "${a[i.XI.Symbol.Name]}" not found in schema`);
        let c = [];
        for (let e of Object.values(o.relations))
          ((r.relationName && r !== e && e.relationName === r.relationName) ||
            (!r.relationName && e.referencedTable === r.sourceTable)) &&
            c.push(e);
        if (c.length > 1)
          throw r.relationName
            ? Error(
                `There are multiple relations with name "${r.relationName}" in table "${n}"`
              )
            : Error(
                `There are multiple relations between "${n}" and "${r.sourceTable[i.XI.Symbol.Name]}". Please specify relation name`
              );
        if (c[0] && (0, s.is)(c[0], f) && c[0].config)
          return {
            fields: c[0].config.references,
            references: c[0].config.fields,
          };
        throw Error(
          `There is not enough information to infer relation "${l}.${r.fieldName}"`
        );
      }
      function N(e) {
        return {
          one: function (t, r) {
            return new f(
              e,
              t,
              r,
              r?.fields.reduce((e, t) => e && t.notNull, !0) ?? !1
            );
          },
          many: function (t, r) {
            return new m(e, t, r);
          },
        };
      }
    },
    30052: (e, t, r) => {
      r.d(t, { A: () => n });
      var i = r(41321);
      let n = function (e, t, r, n, s) {
        let o;
        if (void 0 !== s.crit && n?.crit === void 0)
          throw new e(
            '"crit" (Critical) Header Parameter MUST be integrity protected'
          );
        if (!n || void 0 === n.crit) return new Set();
        if (
          !Array.isArray(n.crit) ||
          0 === n.crit.length ||
          n.crit.some((e) => "string" != typeof e || 0 === e.length)
        )
          throw new e(
            '"crit" (Critical) Header Parameter MUST be an array of non-empty strings when present'
          );
        for (let a of ((o =
          void 0 !== r ? new Map([...Object.entries(r), ...t.entries()]) : t),
        n.crit)) {
          if (!o.has(a))
            throw new i.T0(
              `Extension Header Parameter "${a}" is not recognized`
            );
          if (void 0 === s[a])
            throw new e(`Extension Header Parameter "${a}" is missing`);
          if (o.get(a) && void 0 === n[a])
            throw new e(
              `Extension Header Parameter "${a}" MUST be integrity protected`
            );
        }
        return new Set(n.crit);
      };
    },
    30060: (e, t, r) => {
      r.d(t, {
        LG: () => g,
        UD: () => P,
        Ny: () => R,
        aE: () => e7,
        Zr: () => v,
      });
      var i,
        n,
        s,
        o,
        a,
        l,
        c,
        d = r(8126);
      let u = (() => {
        let e = function () {};
        return (e.prototype = Object.create(null)), e;
      })();
      function h() {
        return { root: { key: "" }, static: new u() };
      }
      function p(e) {
        return e.split("/").filter(Boolean);
      }
      function f(e, t) {
        let r = new u();
        for (let [i, n] of t) {
          let t = i < 0 ? e.slice(-1 * i).join("/") : e[i];
          if ("string" == typeof n) r[n] = t;
          else {
            let e = t.match(n);
            if (e) for (let t in e.groups) r[t] = e.groups[t];
          }
        }
        return r;
      }
      function m(e, t = "", r, i) {
        let n = p(r),
          s = e.root,
          o = 0,
          a = [];
        for (let e = 0; e < n.length; e++) {
          let t = n[e];
          if (t.startsWith("**")) {
            s.wildcard || (s.wildcard = { key: "**" }),
              (s = s.wildcard),
              a.push([-e, t.split(":")[1] || "_", 2 === t.length]);
            break;
          }
          if ("*" === t || t.includes(":")) {
            s.param || (s.param = { key: "*" }), (s = s.param);
            let r = "*" === t;
            a.push([
              e,
              r
                ? `_${o++}`
                : (function (e) {
                    if (!e.includes(":", 1)) return e.slice(1);
                    let t = e.replace(/:(\w+)/g, (e, t) => `(?<${t}>\\w+)`);
                    return RegExp(`^${t}$`);
                  })(t),
              r,
            ]);
            continue;
          }
          let r = s.static?.[t];
          if (r) s = r;
          else {
            let e = { key: t };
            s.static || (s.static = new u()), (s.static[t] = e), (s = e);
          }
        }
        let l = a.length > 0;
        s.methods || (s.methods = new u()),
          s.methods[t] || (s.methods[t] = []),
          s.methods[t].push({ data: i || null, paramsMap: l ? a : void 0 }),
          l || (e.static[r] = s);
      }
      var y = {
          OK: 200,
          CREATED: 201,
          ACCEPTED: 202,
          NO_CONTENT: 204,
          MULTIPLE_CHOICES: 300,
          MOVED_PERMANENTLY: 301,
          FOUND: 302,
          SEE_OTHER: 303,
          NOT_MODIFIED: 304,
          TEMPORARY_REDIRECT: 307,
          BAD_REQUEST: 400,
          UNAUTHORIZED: 401,
          PAYMENT_REQUIRED: 402,
          FORBIDDEN: 403,
          NOT_FOUND: 404,
          METHOD_NOT_ALLOWED: 405,
          NOT_ACCEPTABLE: 406,
          PROXY_AUTHENTICATION_REQUIRED: 407,
          REQUEST_TIMEOUT: 408,
          CONFLICT: 409,
          GONE: 410,
          LENGTH_REQUIRED: 411,
          PRECONDITION_FAILED: 412,
          PAYLOAD_TOO_LARGE: 413,
          URI_TOO_LONG: 414,
          UNSUPPORTED_MEDIA_TYPE: 415,
          RANGE_NOT_SATISFIABLE: 416,
          EXPECTATION_FAILED: 417,
          "I'M_A_TEAPOT": 418,
          MISDIRECTED_REQUEST: 421,
          UNPROCESSABLE_ENTITY: 422,
          LOCKED: 423,
          FAILED_DEPENDENCY: 424,
          TOO_EARLY: 425,
          UPGRADE_REQUIRED: 426,
          PRECONDITION_REQUIRED: 428,
          TOO_MANY_REQUESTS: 429,
          REQUEST_HEADER_FIELDS_TOO_LARGE: 431,
          UNAVAILABLE_FOR_LEGAL_REASONS: 451,
          INTERNAL_SERVER_ERROR: 500,
          NOT_IMPLEMENTED: 501,
          BAD_GATEWAY: 502,
          SERVICE_UNAVAILABLE: 503,
          GATEWAY_TIMEOUT: 504,
          HTTP_VERSION_NOT_SUPPORTED: 505,
          VARIANT_ALSO_NEGOTIATES: 506,
          INSUFFICIENT_STORAGE: 507,
          LOOP_DETECTED: 508,
          NOT_EXTENDED: 510,
          NETWORK_AUTHENTICATION_REQUIRED: 511,
        },
        g = class extends Error {
          constructor(
            e = "INTERNAL_SERVER_ERROR",
            t,
            r = {},
            i = "number" == typeof e ? e : y[e]
          ) {
            super(t?.message),
              (this.status = e),
              (this.body = t),
              (this.headers = r),
              (this.statusCode = i),
              (this.name = "APIError"),
              (this.status = e),
              (this.headers = r),
              (this.statusCode = i),
              (this.body = t
                ? {
                    code: t?.message
                      ?.toUpperCase()
                      .replace(/ /g, "_")
                      .replace(/[^A-Z0-9_]/g, ""),
                    ...t,
                  }
                : void 0),
              (this.stack = "");
          }
        };
      async function w(e) {
        let t = e.headers.get("content-type") || "";
        if (e.body) {
          if (t.includes("application/json")) return await e.json();
          if (t.includes("application/x-www-form-urlencoded")) {
            let t = await e.formData(),
              r = {};
            return (
              t.forEach((e, t) => {
                r[t] = e.toString();
              }),
              r
            );
          }
          if (t.includes("multipart/form-data")) {
            let t = await e.formData(),
              r = {};
            return (
              t.forEach((e, t) => {
                r[t] = e;
              }),
              r
            );
          }
          return t.includes("text/plain")
            ? await e.text()
            : t.includes("application/octet-stream")
              ? await e.arrayBuffer()
              : t.includes("application/pdf") ||
                  t.includes("image/") ||
                  t.includes("video/")
                ? await e.blob()
                : t.includes("application/stream") ||
                    e.body instanceof ReadableStream
                  ? e.body
                  : await e.text();
        }
      }
      function b(e) {
        return e instanceof g || e?.name === "APIError";
      }
      function v(e, t) {
        if (e instanceof Response)
          return (
            t?.headers instanceof Headers &&
              t.headers.forEach((t, r) => {
                e.headers.set(r, t);
              }),
            e
          );
        if (e?._flag === "json") {
          let t = e.routerResponse;
          return t instanceof Response
            ? t
            : v(e.body, { headers: e.headers, status: e.status });
        }
        if (b(e))
          return v(e.body, {
            status: e.statusCode,
            statusText: e.status.toString(),
            headers: t?.headers || e.headers,
          });
        let r = e,
          i = new Headers(t?.headers);
        return (
          e
            ? "string" == typeof e
              ? ((r = e), i.set("Content-Type", "text/plain"))
              : e instanceof ArrayBuffer || ArrayBuffer.isView(e)
                ? ((r = e), i.set("Content-Type", "application/octet-stream"))
                : e instanceof Blob
                  ? ((r = e),
                    i.set("Content-Type", e.type || "application/octet-stream"))
                  : e instanceof FormData
                    ? (r = e)
                    : e instanceof URLSearchParams
                      ? ((r = e),
                        i.set(
                          "Content-Type",
                          "application/x-www-form-urlencoded"
                        ))
                      : e instanceof ReadableStream
                        ? ((r = e),
                          i.set("Content-Type", "application/octet-stream"))
                        : (function (e) {
                            if (void 0 === e) return !1;
                            let t = typeof e;
                            return (
                              "string" === t ||
                              "number" === t ||
                              "boolean" === t ||
                              null === t ||
                              ("object" === t &&
                                (!!Array.isArray(e) ||
                                  (!e.buffer &&
                                    ((e.constructor &&
                                      "Object" === e.constructor.name) ||
                                      "function" == typeof e.toJSON))))
                            );
                          })(e) &&
                          ((r = JSON.stringify(e)),
                          i.set("Content-Type", "application/json"))
            : (null === e && (r = JSON.stringify(null)),
              i.set("content-type", "application/json")),
          new Response(r, { ...t, headers: i })
        );
      }
      async function N(e, t = {}) {
        let r = { body: t.body, query: t.query };
        if (e.body) {
          let i = await e.body["~standard"].validate(t.body);
          if (i.issues) return { data: null, error: x(i.issues, "body") };
          r.body = i.value;
        }
        if (e.query) {
          let i = await e.query["~standard"].validate(t.query);
          if (i.issues) return { data: null, error: x(i.issues, "query") };
          r.query = i.value;
        }
        return e.requireHeaders && !t.headers
          ? { data: null, error: { message: "Headers is required" } }
          : e.requireRequest && !t.request
            ? { data: null, error: { message: "Request is required" } }
            : { data: r, error: null };
      }
      function x(e, t) {
        let r = [];
        for (let t of e) {
          let e = t.message;
          r.push(e);
        }
        return { message: `Invalid ${t} parameters` };
      }
      var _ = { name: "HMAC", hash: "SHA-256" },
        S = async (e) => {
          let t = "string" == typeof e ? new TextEncoder().encode(e) : e;
          return await d.aK.importKey("raw", t, _, !1, ["sign", "verify"]);
        },
        T = async (e, t, r) => {
          try {
            let i = atob(e),
              n = new Uint8Array(i.length);
            for (let e = 0, t = i.length; e < t; e++) n[e] = i.charCodeAt(e);
            return await d.aK.verify(_, r, n, new TextEncoder().encode(t));
          } catch (e) {
            return !1;
          }
        },
        k = async (e, t) => {
          let r = await S(t);
          return btoa(
            String.fromCharCode(
              ...new Uint8Array(
                await d.aK.sign(_.name, r, new TextEncoder().encode(e))
              )
            )
          );
        },
        A = async (e, t) => {
          let r = await k(e, t);
          return (e = encodeURIComponent((e = `${e}.${r}`)));
        },
        E = (e, t) => {
          let r = e;
          if (t)
            if ("secure" === t) r = "__Secure-" + e;
            else {
              if ("host" !== t) return;
              r = "__Host-" + e;
            }
          return r;
        },
        C = (e, t, r = {}) => {
          let i;
          if (
            ((i =
              r?.prefix === "secure"
                ? `__Secure-${e}=${t}`
                : r?.prefix === "host"
                  ? `__Host-${e}=${t}`
                  : `${e}=${t}`),
            e.startsWith("__Secure-") && !r.secure && (r.secure = !0),
            e.startsWith("__Host-") &&
              (r.secure || (r.secure = !0),
              "/" !== r.path && (r.path = "/"),
              r.domain && (r.domain = void 0)),
            r && "number" == typeof r.maxAge && r.maxAge >= 0)
          ) {
            if (r.maxAge > 3456e4)
              throw Error(
                "Cookies Max-Age SHOULD NOT be greater than 400 days (34560000 seconds) in duration."
              );
            i += `; Max-Age=${Math.floor(r.maxAge)}`;
          }
          if (
            (r.domain && "host" !== r.prefix && (i += `; Domain=${r.domain}`),
            r.path && (i += `; Path=${r.path}`),
            r.expires)
          ) {
            if (r.expires.getTime() - Date.now() > 3456e7)
              throw Error(
                "Cookies Expires SHOULD NOT be greater than 400 days (34560000 seconds) in the future."
              );
            i += `; Expires=${r.expires.toUTCString()}`;
          }
          return (
            r.httpOnly && (i += "; HttpOnly"),
            r.secure && (i += "; Secure"),
            r.sameSite &&
              (i += `; SameSite=${r.sameSite.charAt(0).toUpperCase() + r.sameSite.slice(1)}`),
            r.partitioned &&
              (r.secure || (r.secure = !0), (i += "; Partitioned")),
            i
          );
        },
        I = (e, t, r) => C(e, (t = encodeURIComponent(t)), r),
        O = async (e, t, r, i) => C(e, (t = await A(t, r)), i),
        L = async (e, { options: t, path: r }) => {
          let i = new Headers(),
            { data: n, error: s } = await N(t, e);
          if (s)
            throw new g(400, { message: s.message, code: "VALIDATION_ERROR" });
          let o =
              "headers" in e
                ? e.headers instanceof Headers
                  ? e.headers
                  : new Headers(e.headers)
                : "request" in e && e.request instanceof Request
                  ? e.request.headers
                  : null,
            a = o?.get("cookie"),
            l = a
              ? (function (e) {
                  if ("string" != typeof e)
                    throw TypeError("argument str must be a string");
                  let t = new Map(),
                    r = 0;
                  for (; r < e.length; ) {
                    let i = e.indexOf("=", r);
                    if (-1 === i) break;
                    let n = e.indexOf(";", r);
                    if (-1 === n) n = e.length;
                    else if (n < i) {
                      r = e.lastIndexOf(";", i - 1) + 1;
                      continue;
                    }
                    let s = e.slice(r, i).trim();
                    if (!t.has(s)) {
                      let r = e.slice(i + 1, n).trim();
                      34 === r.codePointAt(0) && (r = r.slice(1, -1)),
                        t.set(
                          s,
                          (function (e) {
                            try {
                              return e.includes("%")
                                ? decodeURIComponent(e)
                                : e;
                            } catch {
                              return e;
                            }
                          })(r)
                        );
                    }
                    r = n + 1;
                  }
                  return t;
                })(a)
              : void 0,
            c = {
              ...e,
              body: n.body,
              query: n.query,
              path: e.path || r,
              context: "context" in e && e.context ? e.context : {},
              returned: void 0,
              headers: e?.headers,
              request: e?.request,
              params: "params" in e ? e.params : void 0,
              method: e.method,
              setHeader: (e, t) => {
                i.set(e, t);
              },
              getHeader: (e) => (o ? o.get(e) : null),
              getCookie: (e, t) => {
                let r = E(e, t);
                return (r && l?.get(r)) || null;
              },
              getSignedCookie: async (e, t, r) => {
                let i = E(e, r);
                if (!i) return null;
                let n = l?.get(i);
                if (!n) return null;
                let s = n.lastIndexOf(".");
                if (s < 1) return null;
                let o = n.substring(0, s),
                  a = n.substring(s + 1);
                if (44 !== a.length || !a.endsWith("=")) return null;
                let c = await S(t);
                return !!(await T(a, o, c)) && o;
              },
              setCookie: (e, t, r) => {
                let n = I(e, t, r);
                return i.append("set-cookie", n), n;
              },
              setSignedCookie: async (e, t, r, n) => {
                let s = await O(e, t, r, n);
                return i.append("set-cookie", s), s;
              },
              redirect: (e) => (
                i.set("location", e), new g("FOUND", void 0, i)
              ),
              error: (e, t, r) => new g(e, t, r),
              json: (t, r) =>
                e.asResponse
                  ? { body: r?.body || t, routerResponse: r, _flag: "json" }
                  : t,
              responseHeaders: i,
            };
          for (let e of t.use || []) {
            let t = await e({ ...c, returnHeaders: !0, asResponse: !1 });
            t.response && Object.assign(c.context, t.response),
              t.headers &&
                t.headers.forEach((e, t) => {
                  c.responseHeaders.set(t, e);
                });
          }
          return c;
        };
      function R(e, t) {
        let r = async (r) => {
          let i = "function" == typeof e ? e : t,
            n = await L(r, {
              options: "function" == typeof e ? {} : e,
              path: "/",
            });
          if (!i) throw Error("handler must be defined");
          let s = await i(n),
            o = n.responseHeaders;
          return r.returnHeaders ? { headers: o, response: s } : s;
        };
        return (r.options = "function" == typeof e ? {} : e), r;
      }
      R.create = (e) =>
        function (t, r) {
          if ("function" == typeof t) return R({ use: e?.use }, t);
          if (!r) throw Error("Middleware handler is required");
          return R(
            { ...t, method: "*", use: [...(e?.use || []), ...(t.use || [])] },
            r
          );
        };
      var P = (e, t, r) => {
        let i = async (...i) => {
          let n = i[0] || {},
            s = await L(n, { options: t, path: e }),
            o = await r(s).catch(async (e) => {
              if (b(e)) {
                let r = t.onAPIError;
                if ((r && (await r(e)), n.asResponse)) return e;
              }
              throw e;
            }),
            a = s.responseHeaders;
          return n.asResponse
            ? v(o, { headers: a })
            : n.returnHeaders
              ? { headers: a, response: o }
              : o;
        };
        return (i.options = t), (i.path = e), i;
      };
      (P.create = (e) => (t, r, i) =>
        P(t, { ...r, use: [...(r?.use || []), ...(e?.use || [])] }, i)),
        (function (e) {
          (e.assertEqual = (e) => e),
            (e.assertIs = function (e) {}),
            (e.assertNever = function (e) {
              throw Error();
            }),
            (e.arrayToEnum = (e) => {
              let t = {};
              for (let r of e) t[r] = r;
              return t;
            }),
            (e.getValidEnumValues = (t) => {
              let r = e.objectKeys(t).filter((e) => "number" != typeof t[t[e]]),
                i = {};
              for (let e of r) i[e] = t[e];
              return e.objectValues(i);
            }),
            (e.objectValues = (t) =>
              e.objectKeys(t).map(function (e) {
                return t[e];
              })),
            (e.objectKeys =
              "function" == typeof Object.keys
                ? (e) => Object.keys(e)
                : (e) => {
                    let t = [];
                    for (let r in e)
                      Object.prototype.hasOwnProperty.call(e, r) && t.push(r);
                    return t;
                  }),
            (e.find = (e, t) => {
              for (let r of e) if (t(r)) return r;
            }),
            (e.isInteger =
              "function" == typeof Number.isInteger
                ? (e) => Number.isInteger(e)
                : (e) =>
                    "number" == typeof e && isFinite(e) && Math.floor(e) === e),
            (e.joinValues = function (e, t = " | ") {
              return e
                .map((e) => ("string" == typeof e ? `'${e}'` : e))
                .join(t);
            }),
            (e.jsonStringifyReplacer = (e, t) =>
              "bigint" == typeof t ? t.toString() : t);
        })(i || (i = {})),
        ((n || (n = {})).mergeShapes = (e, t) => ({ ...e, ...t }));
      var D = i.arrayToEnum([
          "string",
          "nan",
          "number",
          "integer",
          "float",
          "boolean",
          "date",
          "bigint",
          "symbol",
          "function",
          "undefined",
          "null",
          "array",
          "object",
          "unknown",
          "promise",
          "void",
          "never",
          "map",
          "set",
        ]),
        q = (e) => {
          switch (typeof e) {
            case "undefined":
              return D.undefined;
            case "string":
              return D.string;
            case "number":
              return isNaN(e) ? D.nan : D.number;
            case "boolean":
              return D.boolean;
            case "function":
              return D.function;
            case "bigint":
              return D.bigint;
            case "symbol":
              return D.symbol;
            case "object":
              if (Array.isArray(e)) return D.array;
              if (null === e) return D.null;
              if (
                e.then &&
                "function" == typeof e.then &&
                e.catch &&
                "function" == typeof e.catch
              )
                return D.promise;
              if ("undefined" != typeof Map && e instanceof Map) return D.map;
              if ("undefined" != typeof Set && e instanceof Set) return D.set;
              if ("undefined" != typeof Date && e instanceof Date)
                return D.date;
              return D.object;
            default:
              return D.unknown;
          }
        },
        U = i.arrayToEnum([
          "invalid_type",
          "invalid_literal",
          "custom",
          "invalid_union",
          "invalid_union_discriminator",
          "invalid_enum_value",
          "unrecognized_keys",
          "invalid_arguments",
          "invalid_return_type",
          "invalid_date",
          "invalid_string",
          "too_small",
          "too_big",
          "invalid_intersection_types",
          "not_multiple_of",
          "not_finite",
        ]),
        $ = class e extends Error {
          get errors() {
            return this.issues;
          }
          constructor(e) {
            super(),
              (this.issues = []),
              (this.addIssue = (e) => {
                this.issues = [...this.issues, e];
              }),
              (this.addIssues = (e = []) => {
                this.issues = [...this.issues, ...e];
              });
            let t = new.target.prototype;
            Object.setPrototypeOf
              ? Object.setPrototypeOf(this, t)
              : (this.__proto__ = t),
              (this.name = "ZodError"),
              (this.issues = e);
          }
          format(e) {
            let t =
                e ||
                function (e) {
                  return e.message;
                },
              r = { _errors: [] },
              i = (e) => {
                for (let n of e.issues)
                  if ("invalid_union" === n.code) n.unionErrors.map(i);
                  else if ("invalid_return_type" === n.code)
                    i(n.returnTypeError);
                  else if ("invalid_arguments" === n.code) i(n.argumentsError);
                  else if (0 === n.path.length) r._errors.push(t(n));
                  else {
                    let e = r,
                      i = 0;
                    for (; i < n.path.length; ) {
                      let r = n.path[i];
                      i === n.path.length - 1
                        ? ((e[r] = e[r] || { _errors: [] }),
                          e[r]._errors.push(t(n)))
                        : (e[r] = e[r] || { _errors: [] }),
                        (e = e[r]),
                        i++;
                    }
                  }
              };
            return i(this), r;
          }
          static assert(t) {
            if (!(t instanceof e)) throw Error(`Not a ZodError: ${t}`);
          }
          toString() {
            return this.message;
          }
          get message() {
            return JSON.stringify(this.issues, i.jsonStringifyReplacer, 2);
          }
          get isEmpty() {
            return 0 === this.issues.length;
          }
          flatten(e = (e) => e.message) {
            let t = {},
              r = [];
            for (let i of this.issues)
              i.path.length > 0
                ? ((t[i.path[0]] = t[i.path[0]] || []), t[i.path[0]].push(e(i)))
                : r.push(e(i));
            return { formErrors: r, fieldErrors: t };
          }
          get formErrors() {
            return this.flatten();
          }
        };
      $.create = (e) => new $(e);
      var B = (e, t) => {
          let r;
          switch (e.code) {
            case U.invalid_type:
              r =
                e.received === D.undefined
                  ? "Required"
                  : `Expected ${e.expected}, received ${e.received}`;
              break;
            case U.invalid_literal:
              r = `Invalid literal value, expected ${JSON.stringify(e.expected, i.jsonStringifyReplacer)}`;
              break;
            case U.unrecognized_keys:
              r = `Unrecognized key(s) in object: ${i.joinValues(e.keys, ", ")}`;
              break;
            case U.invalid_union:
              r = "Invalid input";
              break;
            case U.invalid_union_discriminator:
              r = `Invalid discriminator value. Expected ${i.joinValues(e.options)}`;
              break;
            case U.invalid_enum_value:
              r = `Invalid enum value. Expected ${i.joinValues(e.options)}, received '${e.received}'`;
              break;
            case U.invalid_arguments:
              r = "Invalid function arguments";
              break;
            case U.invalid_return_type:
              r = "Invalid function return type";
              break;
            case U.invalid_date:
              r = "Invalid date";
              break;
            case U.invalid_string:
              "object" == typeof e.validation
                ? "includes" in e.validation
                  ? ((r = `Invalid input: must include "${e.validation.includes}"`),
                    "number" == typeof e.validation.position &&
                      (r = `${r} at one or more positions greater than or equal to ${e.validation.position}`))
                  : "startsWith" in e.validation
                    ? (r = `Invalid input: must start with "${e.validation.startsWith}"`)
                    : "endsWith" in e.validation
                      ? (r = `Invalid input: must end with "${e.validation.endsWith}"`)
                      : i.assertNever(e.validation)
                : (r =
                    "regex" !== e.validation
                      ? `Invalid ${e.validation}`
                      : "Invalid");
              break;
            case U.too_small:
              r =
                "array" === e.type
                  ? `Array must contain ${e.exact ? "exactly" : e.inclusive ? "at least" : "more than"} ${e.minimum} element(s)`
                  : "string" === e.type
                    ? `String must contain ${e.exact ? "exactly" : e.inclusive ? "at least" : "over"} ${e.minimum} character(s)`
                    : "number" === e.type
                      ? `Number must be ${e.exact ? "exactly equal to " : e.inclusive ? "greater than or equal to " : "greater than "}${e.minimum}`
                      : "date" === e.type
                        ? `Date must be ${e.exact ? "exactly equal to " : e.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(e.minimum))}`
                        : "Invalid input";
              break;
            case U.too_big:
              r =
                "array" === e.type
                  ? `Array must contain ${e.exact ? "exactly" : e.inclusive ? "at most" : "less than"} ${e.maximum} element(s)`
                  : "string" === e.type
                    ? `String must contain ${e.exact ? "exactly" : e.inclusive ? "at most" : "under"} ${e.maximum} character(s)`
                    : "number" === e.type
                      ? `Number must be ${e.exact ? "exactly" : e.inclusive ? "less than or equal to" : "less than"} ${e.maximum}`
                      : "bigint" === e.type
                        ? `BigInt must be ${e.exact ? "exactly" : e.inclusive ? "less than or equal to" : "less than"} ${e.maximum}`
                        : "date" === e.type
                          ? `Date must be ${e.exact ? "exactly" : e.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(e.maximum))}`
                          : "Invalid input";
              break;
            case U.custom:
              r = "Invalid input";
              break;
            case U.invalid_intersection_types:
              r = "Intersection results could not be merged";
              break;
            case U.not_multiple_of:
              r = `Number must be a multiple of ${e.multipleOf}`;
              break;
            case U.not_finite:
              r = "Number must be finite";
              break;
            default:
              (r = t.defaultError), i.assertNever(e);
          }
          return { message: r };
        },
        M = (e) => {
          let { data: t, path: r, errorMaps: i, issueData: n } = e,
            s = [...r, ...(n.path || [])],
            o = { ...n, path: s };
          if (void 0 !== n.message)
            return { ...n, path: s, message: n.message };
          let a = "";
          for (let e of i
            .filter((e) => !!e)
            .slice()
            .reverse())
            a = e(o, { data: t, defaultError: a }).message;
          return { ...n, path: s, message: a };
        };
      function j(e, t) {
        let r = M({
          issueData: t,
          data: e.data,
          path: e.path,
          errorMaps: [
            e.common.contextualErrorMap,
            e.schemaErrorMap,
            B,
            B == B ? void 0 : B,
          ].filter((e) => !!e),
        });
        e.common.issues.push(r);
      }
      var W = class e {
          constructor() {
            this.value = "valid";
          }
          dirty() {
            "valid" === this.value && (this.value = "dirty");
          }
          abort() {
            "aborted" !== this.value && (this.value = "aborted");
          }
          static mergeArray(e, t) {
            let r = [];
            for (let i of t) {
              if ("aborted" === i.status) return F;
              "dirty" === i.status && e.dirty(), r.push(i.value);
            }
            return { status: e.value, value: r };
          }
          static async mergeObjectAsync(t, r) {
            let i = [];
            for (let e of r) {
              let t = await e.key,
                r = await e.value;
              i.push({ key: t, value: r });
            }
            return e.mergeObjectSync(t, i);
          }
          static mergeObjectSync(e, t) {
            let r = {};
            for (let i of t) {
              let { key: t, value: n } = i;
              if ("aborted" === t.status || "aborted" === n.status) return F;
              "dirty" === t.status && e.dirty(),
                "dirty" === n.status && e.dirty(),
                "__proto__" !== t.value &&
                  (void 0 !== n.value || i.alwaysSet) &&
                  (r[t.value] = n.value);
            }
            return { status: e.value, value: r };
          }
        },
        F = Object.freeze({ status: "aborted" }),
        Q = (e) => ({ status: "dirty", value: e }),
        z = (e) => ({ status: "valid", value: e }),
        V = (e) => "aborted" === e.status,
        K = (e) => "dirty" === e.status,
        G = (e) => "valid" === e.status,
        H = (e) => "undefined" != typeof Promise && e instanceof Promise;
      function J(e, t, r, i) {
        if ("a" === r && !i)
          throw TypeError("Private accessor was defined without a getter");
        if ("function" == typeof t ? e !== t || !i : !t.has(e))
          throw TypeError(
            "Cannot read private member from an object whose class did not declare it"
          );
        return "m" === r ? i : "a" === r ? i.call(e) : i ? i.value : t.get(e);
      }
      function Z(e, t, r, i, n) {
        if ("m" === i) throw TypeError("Private method is not writable");
        if ("a" === i && !n)
          throw TypeError("Private accessor was defined without a setter");
        if ("function" == typeof t ? e !== t || !n : !t.has(e))
          throw TypeError(
            "Cannot write private member to an object whose class did not declare it"
          );
        return "a" === i ? n.call(e, r) : n ? (n.value = r) : t.set(e, r), r;
      }
      !(function (e) {
        (e.errToObj = (e) => ("string" == typeof e ? { message: e } : e || {})),
          (e.toString = (e) =>
            "string" == typeof e ? e : null == e ? void 0 : e.message);
      })(s || (s = {}));
      var Y = class {
          constructor(e, t, r, i) {
            (this._cachedPath = []),
              (this.parent = e),
              (this.data = t),
              (this._path = r),
              (this._key = i);
          }
          get path() {
            return (
              this._cachedPath.length ||
                (this._key instanceof Array
                  ? this._cachedPath.push(...this._path, ...this._key)
                  : this._cachedPath.push(...this._path, this._key)),
              this._cachedPath
            );
          }
        },
        X = (e, t) => {
          if (G(t)) return { success: !0, data: t.value };
          if (!e.common.issues.length)
            throw Error("Validation failed but no issues detected.");
          return {
            success: !1,
            get error() {
              if (this._error) return this._error;
              let t = new $(e.common.issues);
              return (this._error = t), this._error;
            },
          };
        };
      function ee(e) {
        if (!e) return {};
        let {
          errorMap: t,
          invalid_type_error: r,
          required_error: i,
          description: n,
        } = e;
        if (t && (r || i))
          throw Error(
            'Can\'t use "invalid_type_error" or "required_error" in conjunction with custom error map.'
          );
        return t
          ? { errorMap: t, description: n }
          : {
              errorMap: (t, n) => {
                var s, o;
                let { message: a } = e;
                return "invalid_enum_value" === t.code
                  ? { message: null != a ? a : n.defaultError }
                  : void 0 === n.data
                    ? {
                        message:
                          null != (s = null != a ? a : i) ? s : n.defaultError,
                      }
                    : "invalid_type" !== t.code
                      ? { message: n.defaultError }
                      : {
                          message:
                            null != (o = null != a ? a : r)
                              ? o
                              : n.defaultError,
                        };
              },
              description: n,
            };
      }
      var et = class {
          get description() {
            return this._def.description;
          }
          _getType(e) {
            return q(e.data);
          }
          _getOrReturnCtx(e, t) {
            return (
              t || {
                common: e.parent.common,
                data: e.data,
                parsedType: q(e.data),
                schemaErrorMap: this._def.errorMap,
                path: e.path,
                parent: e.parent,
              }
            );
          }
          _processInputParams(e) {
            return {
              status: new W(),
              ctx: {
                common: e.parent.common,
                data: e.data,
                parsedType: q(e.data),
                schemaErrorMap: this._def.errorMap,
                path: e.path,
                parent: e.parent,
              },
            };
          }
          _parseSync(e) {
            let t = this._parse(e);
            if (H(t)) throw Error("Synchronous parse encountered promise.");
            return t;
          }
          _parseAsync(e) {
            return Promise.resolve(this._parse(e));
          }
          parse(e, t) {
            let r = this.safeParse(e, t);
            if (r.success) return r.data;
            throw r.error;
          }
          safeParse(e, t) {
            var r;
            let i = {
                common: {
                  issues: [],
                  async: null != (r = null == t ? void 0 : t.async) && r,
                  contextualErrorMap: null == t ? void 0 : t.errorMap,
                },
                path: (null == t ? void 0 : t.path) || [],
                schemaErrorMap: this._def.errorMap,
                parent: null,
                data: e,
                parsedType: q(e),
              },
              n = this._parseSync({ data: e, path: i.path, parent: i });
            return X(i, n);
          }
          "~validate"(e) {
            var t, r;
            let i = {
              common: { issues: [], async: !!this["~standard"].async },
              path: [],
              schemaErrorMap: this._def.errorMap,
              parent: null,
              data: e,
              parsedType: q(e),
            };
            if (!this["~standard"].async)
              try {
                let t = this._parseSync({ data: e, path: [], parent: i });
                return G(t) ? { value: t.value } : { issues: i.common.issues };
              } catch (e) {
                (null ==
                (r =
                  null == (t = null == e ? void 0 : e.message)
                    ? void 0
                    : t.toLowerCase())
                  ? void 0
                  : r.includes("encountered")) &&
                  (this["~standard"].async = !0),
                  (i.common = { issues: [], async: !0 });
              }
            return this._parseAsync({ data: e, path: [], parent: i }).then(
              (e) => (G(e) ? { value: e.value } : { issues: i.common.issues })
            );
          }
          async parseAsync(e, t) {
            let r = await this.safeParseAsync(e, t);
            if (r.success) return r.data;
            throw r.error;
          }
          async safeParseAsync(e, t) {
            let r = {
                common: {
                  issues: [],
                  contextualErrorMap: null == t ? void 0 : t.errorMap,
                  async: !0,
                },
                path: (null == t ? void 0 : t.path) || [],
                schemaErrorMap: this._def.errorMap,
                parent: null,
                data: e,
                parsedType: q(e),
              },
              i = this._parse({ data: e, path: r.path, parent: r });
            return X(r, await (H(i) ? i : Promise.resolve(i)));
          }
          refine(e, t) {
            let r = (e) =>
              "string" == typeof t || void 0 === t
                ? { message: t }
                : "function" == typeof t
                  ? t(e)
                  : t;
            return this._refinement((t, i) => {
              let n = e(t),
                s = () => i.addIssue({ code: U.custom, ...r(t) });
              return "undefined" != typeof Promise && n instanceof Promise
                ? n.then((e) => !!e || (s(), !1))
                : !!n || (s(), !1);
            });
          }
          refinement(e, t) {
            return this._refinement(
              (r, i) =>
                !!e(r) || (i.addIssue("function" == typeof t ? t(r, i) : t), !1)
            );
          }
          _refinement(e) {
            return new eG({
              schema: this,
              typeName: c.ZodEffects,
              effect: { type: "refinement", refinement: e },
            });
          }
          superRefine(e) {
            return this._refinement(e);
          }
          constructor(e) {
            (this.spa = this.safeParseAsync),
              (this._def = e),
              (this.parse = this.parse.bind(this)),
              (this.safeParse = this.safeParse.bind(this)),
              (this.parseAsync = this.parseAsync.bind(this)),
              (this.safeParseAsync = this.safeParseAsync.bind(this)),
              (this.spa = this.spa.bind(this)),
              (this.refine = this.refine.bind(this)),
              (this.refinement = this.refinement.bind(this)),
              (this.superRefine = this.superRefine.bind(this)),
              (this.optional = this.optional.bind(this)),
              (this.nullable = this.nullable.bind(this)),
              (this.nullish = this.nullish.bind(this)),
              (this.array = this.array.bind(this)),
              (this.promise = this.promise.bind(this)),
              (this.or = this.or.bind(this)),
              (this.and = this.and.bind(this)),
              (this.transform = this.transform.bind(this)),
              (this.brand = this.brand.bind(this)),
              (this.default = this.default.bind(this)),
              (this.catch = this.catch.bind(this)),
              (this.describe = this.describe.bind(this)),
              (this.pipe = this.pipe.bind(this)),
              (this.readonly = this.readonly.bind(this)),
              (this.isNullable = this.isNullable.bind(this)),
              (this.isOptional = this.isOptional.bind(this)),
              (this["~standard"] = {
                version: 1,
                vendor: "zod",
                validate: (e) => this["~validate"](e),
              });
          }
          optional() {
            return eH.create(this, this._def);
          }
          nullable() {
            return eJ.create(this, this._def);
          }
          nullish() {
            return this.nullable().optional();
          }
          array() {
            return eO.create(this);
          }
          promise() {
            return eK.create(this, this._def);
          }
          or(e) {
            return eR.create([this, e], this._def);
          }
          and(e) {
            return eq.create(this, e, this._def);
          }
          transform(e) {
            return new eG({
              ...ee(this._def),
              schema: this,
              typeName: c.ZodEffects,
              effect: { type: "transform", transform: e },
            });
          }
          default(e) {
            return new eZ({
              ...ee(this._def),
              innerType: this,
              defaultValue: "function" == typeof e ? e : () => e,
              typeName: c.ZodDefault,
            });
          }
          brand() {
            return new e0({
              typeName: c.ZodBranded,
              type: this,
              ...ee(this._def),
            });
          }
          catch(e) {
            return new eY({
              ...ee(this._def),
              innerType: this,
              catchValue: "function" == typeof e ? e : () => e,
              typeName: c.ZodCatch,
            });
          }
          describe(e) {
            return new this.constructor({ ...this._def, description: e });
          }
          pipe(e) {
            return e1.create(this, e);
          }
          readonly() {
            return e2.create(this);
          }
          isOptional() {
            return this.safeParse(void 0).success;
          }
          isNullable() {
            return this.safeParse(null).success;
          }
        },
        er = /^c[^\s-]{8,}$/i,
        ei = /^[0-9a-z]+$/,
        en = /^[0-9A-HJKMNP-TV-Z]{26}$/i,
        es =
          /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i,
        eo = /^[a-z0-9_-]{21}$/i,
        ea = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/,
        el =
          /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/,
        ec =
          /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i,
        ed =
          /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
        eu =
          /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/,
        eh =
          /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/,
        ep =
          /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,
        ef = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,
        em =
          /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,
        ey =
          "((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))",
        eg = RegExp(`^${ey}$`);
      function ew(e) {
        let t = "([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d";
        return (
          e.precision
            ? (t = `${t}\\.\\d{${e.precision}}`)
            : null == e.precision && (t = `${t}(\\.\\d+)?`),
          t
        );
      }
      var eb = class e extends et {
        _parse(e) {
          var t, r, n, s;
          let o;
          if (
            (this._def.coerce && (e.data = String(e.data)),
            this._getType(e) !== D.string)
          ) {
            let t = this._getOrReturnCtx(e);
            return (
              j(t, {
                code: U.invalid_type,
                expected: D.string,
                received: t.parsedType,
              }),
              F
            );
          }
          let a = new W();
          for (let c of this._def.checks)
            if ("min" === c.kind)
              e.data.length < c.value &&
                (j((o = this._getOrReturnCtx(e, o)), {
                  code: U.too_small,
                  minimum: c.value,
                  type: "string",
                  inclusive: !0,
                  exact: !1,
                  message: c.message,
                }),
                a.dirty());
            else if ("max" === c.kind)
              e.data.length > c.value &&
                (j((o = this._getOrReturnCtx(e, o)), {
                  code: U.too_big,
                  maximum: c.value,
                  type: "string",
                  inclusive: !0,
                  exact: !1,
                  message: c.message,
                }),
                a.dirty());
            else if ("length" === c.kind) {
              let t = e.data.length > c.value,
                r = e.data.length < c.value;
              (t || r) &&
                ((o = this._getOrReturnCtx(e, o)),
                t
                  ? j(o, {
                      code: U.too_big,
                      maximum: c.value,
                      type: "string",
                      inclusive: !0,
                      exact: !0,
                      message: c.message,
                    })
                  : r &&
                    j(o, {
                      code: U.too_small,
                      minimum: c.value,
                      type: "string",
                      inclusive: !0,
                      exact: !0,
                      message: c.message,
                    }),
                a.dirty());
            } else if ("email" === c.kind)
              ec.test(e.data) ||
                (j((o = this._getOrReturnCtx(e, o)), {
                  validation: "email",
                  code: U.invalid_string,
                  message: c.message,
                }),
                a.dirty());
            else if ("emoji" === c.kind)
              l ||
                (l = RegExp(
                  "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$",
                  "u"
                )),
                l.test(e.data) ||
                  (j((o = this._getOrReturnCtx(e, o)), {
                    validation: "emoji",
                    code: U.invalid_string,
                    message: c.message,
                  }),
                  a.dirty());
            else if ("uuid" === c.kind)
              es.test(e.data) ||
                (j((o = this._getOrReturnCtx(e, o)), {
                  validation: "uuid",
                  code: U.invalid_string,
                  message: c.message,
                }),
                a.dirty());
            else if ("nanoid" === c.kind)
              eo.test(e.data) ||
                (j((o = this._getOrReturnCtx(e, o)), {
                  validation: "nanoid",
                  code: U.invalid_string,
                  message: c.message,
                }),
                a.dirty());
            else if ("cuid" === c.kind)
              er.test(e.data) ||
                (j((o = this._getOrReturnCtx(e, o)), {
                  validation: "cuid",
                  code: U.invalid_string,
                  message: c.message,
                }),
                a.dirty());
            else if ("cuid2" === c.kind)
              ei.test(e.data) ||
                (j((o = this._getOrReturnCtx(e, o)), {
                  validation: "cuid2",
                  code: U.invalid_string,
                  message: c.message,
                }),
                a.dirty());
            else if ("ulid" === c.kind)
              en.test(e.data) ||
                (j((o = this._getOrReturnCtx(e, o)), {
                  validation: "ulid",
                  code: U.invalid_string,
                  message: c.message,
                }),
                a.dirty());
            else if ("url" === c.kind)
              try {
                new URL(e.data);
              } catch (t) {
                j((o = this._getOrReturnCtx(e, o)), {
                  validation: "url",
                  code: U.invalid_string,
                  message: c.message,
                }),
                  a.dirty();
              }
            else
              "regex" === c.kind
                ? ((c.regex.lastIndex = 0),
                  c.regex.test(e.data) ||
                    (j((o = this._getOrReturnCtx(e, o)), {
                      validation: "regex",
                      code: U.invalid_string,
                      message: c.message,
                    }),
                    a.dirty()))
                : "trim" === c.kind
                  ? (e.data = e.data.trim())
                  : "includes" === c.kind
                    ? e.data.includes(c.value, c.position) ||
                      (j((o = this._getOrReturnCtx(e, o)), {
                        code: U.invalid_string,
                        validation: { includes: c.value, position: c.position },
                        message: c.message,
                      }),
                      a.dirty())
                    : "toLowerCase" === c.kind
                      ? (e.data = e.data.toLowerCase())
                      : "toUpperCase" === c.kind
                        ? (e.data = e.data.toUpperCase())
                        : "startsWith" === c.kind
                          ? e.data.startsWith(c.value) ||
                            (j((o = this._getOrReturnCtx(e, o)), {
                              code: U.invalid_string,
                              validation: { startsWith: c.value },
                              message: c.message,
                            }),
                            a.dirty())
                          : "endsWith" === c.kind
                            ? e.data.endsWith(c.value) ||
                              (j((o = this._getOrReturnCtx(e, o)), {
                                code: U.invalid_string,
                                validation: { endsWith: c.value },
                                message: c.message,
                              }),
                              a.dirty())
                            : "datetime" === c.kind
                              ? (function (e) {
                                  let t = `${ey}T${ew(e)}`,
                                    r = [];
                                  return (
                                    r.push(e.local ? "Z?" : "Z"),
                                    e.offset && r.push("([+-]\\d{2}:?\\d{2})"),
                                    (t = `${t}(${r.join("|")})`),
                                    RegExp(`^${t}$`)
                                  );
                                })(c).test(e.data) ||
                                (j((o = this._getOrReturnCtx(e, o)), {
                                  code: U.invalid_string,
                                  validation: "datetime",
                                  message: c.message,
                                }),
                                a.dirty())
                              : "date" === c.kind
                                ? eg.test(e.data) ||
                                  (j((o = this._getOrReturnCtx(e, o)), {
                                    code: U.invalid_string,
                                    validation: "date",
                                    message: c.message,
                                  }),
                                  a.dirty())
                                : "time" === c.kind
                                  ? RegExp(`^${ew(c)}$`).test(e.data) ||
                                    (j((o = this._getOrReturnCtx(e, o)), {
                                      code: U.invalid_string,
                                      validation: "time",
                                      message: c.message,
                                    }),
                                    a.dirty())
                                  : "duration" === c.kind
                                    ? el.test(e.data) ||
                                      (j((o = this._getOrReturnCtx(e, o)), {
                                        validation: "duration",
                                        code: U.invalid_string,
                                        message: c.message,
                                      }),
                                      a.dirty())
                                    : "ip" === c.kind
                                      ? ((t = e.data),
                                        !(
                                          (("v4" === (r = c.version) || !r) &&
                                            ed.test(t)) ||
                                          (("v6" === r || !r) && eh.test(t))
                                        ) &&
                                          1 &&
                                          (j((o = this._getOrReturnCtx(e, o)), {
                                            validation: "ip",
                                            code: U.invalid_string,
                                            message: c.message,
                                          }),
                                          a.dirty()))
                                      : "jwt" === c.kind
                                        ? !(function (e, t) {
                                            if (!ea.test(e)) return !1;
                                            try {
                                              let [r] = e.split("."),
                                                i = r
                                                  .replace(/-/g, "+")
                                                  .replace(/_/g, "/")
                                                  .padEnd(
                                                    r.length +
                                                      ((4 - (r.length % 4)) %
                                                        4),
                                                    "="
                                                  ),
                                                n = JSON.parse(atob(i));
                                              if (
                                                "object" != typeof n ||
                                                null === n ||
                                                !n.typ ||
                                                !n.alg ||
                                                (t && n.alg !== t)
                                              )
                                                return !1;
                                              return !0;
                                            } catch (e) {
                                              return !1;
                                            }
                                          })(e.data, c.alg) &&
                                          (j((o = this._getOrReturnCtx(e, o)), {
                                            validation: "jwt",
                                            code: U.invalid_string,
                                            message: c.message,
                                          }),
                                          a.dirty())
                                        : "cidr" === c.kind
                                          ? ((n = e.data),
                                            !(
                                              (("v4" === (s = c.version) ||
                                                !s) &&
                                                eu.test(n)) ||
                                              (("v6" === s || !s) && ep.test(n))
                                            ) &&
                                              1 &&
                                              (j(
                                                (o = this._getOrReturnCtx(
                                                  e,
                                                  o
                                                )),
                                                {
                                                  validation: "cidr",
                                                  code: U.invalid_string,
                                                  message: c.message,
                                                }
                                              ),
                                              a.dirty()))
                                          : "base64" === c.kind
                                            ? ef.test(e.data) ||
                                              (j(
                                                (o = this._getOrReturnCtx(
                                                  e,
                                                  o
                                                )),
                                                {
                                                  validation: "base64",
                                                  code: U.invalid_string,
                                                  message: c.message,
                                                }
                                              ),
                                              a.dirty())
                                            : "base64url" === c.kind
                                              ? em.test(e.data) ||
                                                (j(
                                                  (o = this._getOrReturnCtx(
                                                    e,
                                                    o
                                                  )),
                                                  {
                                                    validation: "base64url",
                                                    code: U.invalid_string,
                                                    message: c.message,
                                                  }
                                                ),
                                                a.dirty())
                                              : i.assertNever(c);
          return { status: a.value, value: e.data };
        }
        _regex(e, t, r) {
          return this.refinement((t) => e.test(t), {
            validation: t,
            code: U.invalid_string,
            ...s.errToObj(r),
          });
        }
        _addCheck(t) {
          return new e({ ...this._def, checks: [...this._def.checks, t] });
        }
        email(e) {
          return this._addCheck({ kind: "email", ...s.errToObj(e) });
        }
        url(e) {
          return this._addCheck({ kind: "url", ...s.errToObj(e) });
        }
        emoji(e) {
          return this._addCheck({ kind: "emoji", ...s.errToObj(e) });
        }
        uuid(e) {
          return this._addCheck({ kind: "uuid", ...s.errToObj(e) });
        }
        nanoid(e) {
          return this._addCheck({ kind: "nanoid", ...s.errToObj(e) });
        }
        cuid(e) {
          return this._addCheck({ kind: "cuid", ...s.errToObj(e) });
        }
        cuid2(e) {
          return this._addCheck({ kind: "cuid2", ...s.errToObj(e) });
        }
        ulid(e) {
          return this._addCheck({ kind: "ulid", ...s.errToObj(e) });
        }
        base64(e) {
          return this._addCheck({ kind: "base64", ...s.errToObj(e) });
        }
        base64url(e) {
          return this._addCheck({ kind: "base64url", ...s.errToObj(e) });
        }
        jwt(e) {
          return this._addCheck({ kind: "jwt", ...s.errToObj(e) });
        }
        ip(e) {
          return this._addCheck({ kind: "ip", ...s.errToObj(e) });
        }
        cidr(e) {
          return this._addCheck({ kind: "cidr", ...s.errToObj(e) });
        }
        datetime(e) {
          var t, r;
          return "string" == typeof e
            ? this._addCheck({
                kind: "datetime",
                precision: null,
                offset: !1,
                local: !1,
                message: e,
              })
            : this._addCheck({
                kind: "datetime",
                precision:
                  void 0 === (null == e ? void 0 : e.precision)
                    ? null
                    : null == e
                      ? void 0
                      : e.precision,
                offset: null != (t = null == e ? void 0 : e.offset) && t,
                local: null != (r = null == e ? void 0 : e.local) && r,
                ...s.errToObj(null == e ? void 0 : e.message),
              });
        }
        date(e) {
          return this._addCheck({ kind: "date", message: e });
        }
        time(e) {
          return "string" == typeof e
            ? this._addCheck({ kind: "time", precision: null, message: e })
            : this._addCheck({
                kind: "time",
                precision:
                  void 0 === (null == e ? void 0 : e.precision)
                    ? null
                    : null == e
                      ? void 0
                      : e.precision,
                ...s.errToObj(null == e ? void 0 : e.message),
              });
        }
        duration(e) {
          return this._addCheck({ kind: "duration", ...s.errToObj(e) });
        }
        regex(e, t) {
          return this._addCheck({ kind: "regex", regex: e, ...s.errToObj(t) });
        }
        includes(e, t) {
          return this._addCheck({
            kind: "includes",
            value: e,
            position: null == t ? void 0 : t.position,
            ...s.errToObj(null == t ? void 0 : t.message),
          });
        }
        startsWith(e, t) {
          return this._addCheck({
            kind: "startsWith",
            value: e,
            ...s.errToObj(t),
          });
        }
        endsWith(e, t) {
          return this._addCheck({
            kind: "endsWith",
            value: e,
            ...s.errToObj(t),
          });
        }
        min(e, t) {
          return this._addCheck({ kind: "min", value: e, ...s.errToObj(t) });
        }
        max(e, t) {
          return this._addCheck({ kind: "max", value: e, ...s.errToObj(t) });
        }
        length(e, t) {
          return this._addCheck({ kind: "length", value: e, ...s.errToObj(t) });
        }
        nonempty(e) {
          return this.min(1, s.errToObj(e));
        }
        trim() {
          return new e({
            ...this._def,
            checks: [...this._def.checks, { kind: "trim" }],
          });
        }
        toLowerCase() {
          return new e({
            ...this._def,
            checks: [...this._def.checks, { kind: "toLowerCase" }],
          });
        }
        toUpperCase() {
          return new e({
            ...this._def,
            checks: [...this._def.checks, { kind: "toUpperCase" }],
          });
        }
        get isDatetime() {
          return !!this._def.checks.find((e) => "datetime" === e.kind);
        }
        get isDate() {
          return !!this._def.checks.find((e) => "date" === e.kind);
        }
        get isTime() {
          return !!this._def.checks.find((e) => "time" === e.kind);
        }
        get isDuration() {
          return !!this._def.checks.find((e) => "duration" === e.kind);
        }
        get isEmail() {
          return !!this._def.checks.find((e) => "email" === e.kind);
        }
        get isURL() {
          return !!this._def.checks.find((e) => "url" === e.kind);
        }
        get isEmoji() {
          return !!this._def.checks.find((e) => "emoji" === e.kind);
        }
        get isUUID() {
          return !!this._def.checks.find((e) => "uuid" === e.kind);
        }
        get isNANOID() {
          return !!this._def.checks.find((e) => "nanoid" === e.kind);
        }
        get isCUID() {
          return !!this._def.checks.find((e) => "cuid" === e.kind);
        }
        get isCUID2() {
          return !!this._def.checks.find((e) => "cuid2" === e.kind);
        }
        get isULID() {
          return !!this._def.checks.find((e) => "ulid" === e.kind);
        }
        get isIP() {
          return !!this._def.checks.find((e) => "ip" === e.kind);
        }
        get isCIDR() {
          return !!this._def.checks.find((e) => "cidr" === e.kind);
        }
        get isBase64() {
          return !!this._def.checks.find((e) => "base64" === e.kind);
        }
        get isBase64url() {
          return !!this._def.checks.find((e) => "base64url" === e.kind);
        }
        get minLength() {
          let e = null;
          for (let t of this._def.checks)
            "min" === t.kind && (null === e || t.value > e) && (e = t.value);
          return e;
        }
        get maxLength() {
          let e = null;
          for (let t of this._def.checks)
            "max" === t.kind && (null === e || t.value < e) && (e = t.value);
          return e;
        }
      };
      eb.create = (e) => {
        var t;
        return new eb({
          checks: [],
          typeName: c.ZodString,
          coerce: null != (t = null == e ? void 0 : e.coerce) && t,
          ...ee(e),
        });
      };
      var ev = class e extends et {
        constructor() {
          super(...arguments),
            (this.min = this.gte),
            (this.max = this.lte),
            (this.step = this.multipleOf);
        }
        _parse(e) {
          let t;
          if (
            (this._def.coerce && (e.data = Number(e.data)),
            this._getType(e) !== D.number)
          ) {
            let t = this._getOrReturnCtx(e);
            return (
              j(t, {
                code: U.invalid_type,
                expected: D.number,
                received: t.parsedType,
              }),
              F
            );
          }
          let r = new W();
          for (let n of this._def.checks)
            "int" === n.kind
              ? i.isInteger(e.data) ||
                (j((t = this._getOrReturnCtx(e, t)), {
                  code: U.invalid_type,
                  expected: "integer",
                  received: "float",
                  message: n.message,
                }),
                r.dirty())
              : "min" === n.kind
                ? (n.inclusive ? e.data < n.value : e.data <= n.value) &&
                  (j((t = this._getOrReturnCtx(e, t)), {
                    code: U.too_small,
                    minimum: n.value,
                    type: "number",
                    inclusive: n.inclusive,
                    exact: !1,
                    message: n.message,
                  }),
                  r.dirty())
                : "max" === n.kind
                  ? (n.inclusive ? e.data > n.value : e.data >= n.value) &&
                    (j((t = this._getOrReturnCtx(e, t)), {
                      code: U.too_big,
                      maximum: n.value,
                      type: "number",
                      inclusive: n.inclusive,
                      exact: !1,
                      message: n.message,
                    }),
                    r.dirty())
                  : "multipleOf" === n.kind
                    ? 0 !==
                        (function (e, t) {
                          let r = (e.toString().split(".")[1] || "").length,
                            i = (t.toString().split(".")[1] || "").length,
                            n = r > i ? r : i;
                          return (
                            (parseInt(e.toFixed(n).replace(".", "")) %
                              parseInt(t.toFixed(n).replace(".", ""))) /
                            Math.pow(10, n)
                          );
                        })(e.data, n.value) &&
                      (j((t = this._getOrReturnCtx(e, t)), {
                        code: U.not_multiple_of,
                        multipleOf: n.value,
                        message: n.message,
                      }),
                      r.dirty())
                    : "finite" === n.kind
                      ? Number.isFinite(e.data) ||
                        (j((t = this._getOrReturnCtx(e, t)), {
                          code: U.not_finite,
                          message: n.message,
                        }),
                        r.dirty())
                      : i.assertNever(n);
          return { status: r.value, value: e.data };
        }
        gte(e, t) {
          return this.setLimit("min", e, !0, s.toString(t));
        }
        gt(e, t) {
          return this.setLimit("min", e, !1, s.toString(t));
        }
        lte(e, t) {
          return this.setLimit("max", e, !0, s.toString(t));
        }
        lt(e, t) {
          return this.setLimit("max", e, !1, s.toString(t));
        }
        setLimit(t, r, i, n) {
          return new e({
            ...this._def,
            checks: [
              ...this._def.checks,
              { kind: t, value: r, inclusive: i, message: s.toString(n) },
            ],
          });
        }
        _addCheck(t) {
          return new e({ ...this._def, checks: [...this._def.checks, t] });
        }
        int(e) {
          return this._addCheck({ kind: "int", message: s.toString(e) });
        }
        positive(e) {
          return this._addCheck({
            kind: "min",
            value: 0,
            inclusive: !1,
            message: s.toString(e),
          });
        }
        negative(e) {
          return this._addCheck({
            kind: "max",
            value: 0,
            inclusive: !1,
            message: s.toString(e),
          });
        }
        nonpositive(e) {
          return this._addCheck({
            kind: "max",
            value: 0,
            inclusive: !0,
            message: s.toString(e),
          });
        }
        nonnegative(e) {
          return this._addCheck({
            kind: "min",
            value: 0,
            inclusive: !0,
            message: s.toString(e),
          });
        }
        multipleOf(e, t) {
          return this._addCheck({
            kind: "multipleOf",
            value: e,
            message: s.toString(t),
          });
        }
        finite(e) {
          return this._addCheck({ kind: "finite", message: s.toString(e) });
        }
        safe(e) {
          return this._addCheck({
            kind: "min",
            inclusive: !0,
            value: Number.MIN_SAFE_INTEGER,
            message: s.toString(e),
          })._addCheck({
            kind: "max",
            inclusive: !0,
            value: Number.MAX_SAFE_INTEGER,
            message: s.toString(e),
          });
        }
        get minValue() {
          let e = null;
          for (let t of this._def.checks)
            "min" === t.kind && (null === e || t.value > e) && (e = t.value);
          return e;
        }
        get maxValue() {
          let e = null;
          for (let t of this._def.checks)
            "max" === t.kind && (null === e || t.value < e) && (e = t.value);
          return e;
        }
        get isInt() {
          return !!this._def.checks.find(
            (e) =>
              "int" === e.kind ||
              ("multipleOf" === e.kind && i.isInteger(e.value))
          );
        }
        get isFinite() {
          let e = null,
            t = null;
          for (let r of this._def.checks)
            if (
              "finite" === r.kind ||
              "int" === r.kind ||
              "multipleOf" === r.kind
            )
              return !0;
            else
              "min" === r.kind
                ? (null === t || r.value > t) && (t = r.value)
                : "max" === r.kind &&
                  (null === e || r.value < e) &&
                  (e = r.value);
          return Number.isFinite(t) && Number.isFinite(e);
        }
      };
      ev.create = (e) =>
        new ev({
          checks: [],
          typeName: c.ZodNumber,
          coerce: (null == e ? void 0 : e.coerce) || !1,
          ...ee(e),
        });
      var eN = class e extends et {
        constructor() {
          super(...arguments), (this.min = this.gte), (this.max = this.lte);
        }
        _parse(e) {
          let t;
          if (this._def.coerce)
            try {
              e.data = BigInt(e.data);
            } catch (t) {
              return this._getInvalidInput(e);
            }
          if (this._getType(e) !== D.bigint) return this._getInvalidInput(e);
          let r = new W();
          for (let n of this._def.checks)
            "min" === n.kind
              ? (n.inclusive ? e.data < n.value : e.data <= n.value) &&
                (j((t = this._getOrReturnCtx(e, t)), {
                  code: U.too_small,
                  type: "bigint",
                  minimum: n.value,
                  inclusive: n.inclusive,
                  message: n.message,
                }),
                r.dirty())
              : "max" === n.kind
                ? (n.inclusive ? e.data > n.value : e.data >= n.value) &&
                  (j((t = this._getOrReturnCtx(e, t)), {
                    code: U.too_big,
                    type: "bigint",
                    maximum: n.value,
                    inclusive: n.inclusive,
                    message: n.message,
                  }),
                  r.dirty())
                : "multipleOf" === n.kind
                  ? e.data % n.value !== BigInt(0) &&
                    (j((t = this._getOrReturnCtx(e, t)), {
                      code: U.not_multiple_of,
                      multipleOf: n.value,
                      message: n.message,
                    }),
                    r.dirty())
                  : i.assertNever(n);
          return { status: r.value, value: e.data };
        }
        _getInvalidInput(e) {
          let t = this._getOrReturnCtx(e);
          return (
            j(t, {
              code: U.invalid_type,
              expected: D.bigint,
              received: t.parsedType,
            }),
            F
          );
        }
        gte(e, t) {
          return this.setLimit("min", e, !0, s.toString(t));
        }
        gt(e, t) {
          return this.setLimit("min", e, !1, s.toString(t));
        }
        lte(e, t) {
          return this.setLimit("max", e, !0, s.toString(t));
        }
        lt(e, t) {
          return this.setLimit("max", e, !1, s.toString(t));
        }
        setLimit(t, r, i, n) {
          return new e({
            ...this._def,
            checks: [
              ...this._def.checks,
              { kind: t, value: r, inclusive: i, message: s.toString(n) },
            ],
          });
        }
        _addCheck(t) {
          return new e({ ...this._def, checks: [...this._def.checks, t] });
        }
        positive(e) {
          return this._addCheck({
            kind: "min",
            value: BigInt(0),
            inclusive: !1,
            message: s.toString(e),
          });
        }
        negative(e) {
          return this._addCheck({
            kind: "max",
            value: BigInt(0),
            inclusive: !1,
            message: s.toString(e),
          });
        }
        nonpositive(e) {
          return this._addCheck({
            kind: "max",
            value: BigInt(0),
            inclusive: !0,
            message: s.toString(e),
          });
        }
        nonnegative(e) {
          return this._addCheck({
            kind: "min",
            value: BigInt(0),
            inclusive: !0,
            message: s.toString(e),
          });
        }
        multipleOf(e, t) {
          return this._addCheck({
            kind: "multipleOf",
            value: e,
            message: s.toString(t),
          });
        }
        get minValue() {
          let e = null;
          for (let t of this._def.checks)
            "min" === t.kind && (null === e || t.value > e) && (e = t.value);
          return e;
        }
        get maxValue() {
          let e = null;
          for (let t of this._def.checks)
            "max" === t.kind && (null === e || t.value < e) && (e = t.value);
          return e;
        }
      };
      eN.create = (e) => {
        var t;
        return new eN({
          checks: [],
          typeName: c.ZodBigInt,
          coerce: null != (t = null == e ? void 0 : e.coerce) && t,
          ...ee(e),
        });
      };
      var ex = class extends et {
        _parse(e) {
          if (
            (this._def.coerce && (e.data = !!e.data),
            this._getType(e) !== D.boolean)
          ) {
            let t = this._getOrReturnCtx(e);
            return (
              j(t, {
                code: U.invalid_type,
                expected: D.boolean,
                received: t.parsedType,
              }),
              F
            );
          }
          return z(e.data);
        }
      };
      ex.create = (e) =>
        new ex({
          typeName: c.ZodBoolean,
          coerce: (null == e ? void 0 : e.coerce) || !1,
          ...ee(e),
        });
      var e_ = class e extends et {
        _parse(e) {
          let t;
          if (
            (this._def.coerce && (e.data = new Date(e.data)),
            this._getType(e) !== D.date)
          ) {
            let t = this._getOrReturnCtx(e);
            return (
              j(t, {
                code: U.invalid_type,
                expected: D.date,
                received: t.parsedType,
              }),
              F
            );
          }
          if (isNaN(e.data.getTime()))
            return j(this._getOrReturnCtx(e), { code: U.invalid_date }), F;
          let r = new W();
          for (let n of this._def.checks)
            "min" === n.kind
              ? e.data.getTime() < n.value &&
                (j((t = this._getOrReturnCtx(e, t)), {
                  code: U.too_small,
                  message: n.message,
                  inclusive: !0,
                  exact: !1,
                  minimum: n.value,
                  type: "date",
                }),
                r.dirty())
              : "max" === n.kind
                ? e.data.getTime() > n.value &&
                  (j((t = this._getOrReturnCtx(e, t)), {
                    code: U.too_big,
                    message: n.message,
                    inclusive: !0,
                    exact: !1,
                    maximum: n.value,
                    type: "date",
                  }),
                  r.dirty())
                : i.assertNever(n);
          return { status: r.value, value: new Date(e.data.getTime()) };
        }
        _addCheck(t) {
          return new e({ ...this._def, checks: [...this._def.checks, t] });
        }
        min(e, t) {
          return this._addCheck({
            kind: "min",
            value: e.getTime(),
            message: s.toString(t),
          });
        }
        max(e, t) {
          return this._addCheck({
            kind: "max",
            value: e.getTime(),
            message: s.toString(t),
          });
        }
        get minDate() {
          let e = null;
          for (let t of this._def.checks)
            "min" === t.kind && (null === e || t.value > e) && (e = t.value);
          return null != e ? new Date(e) : null;
        }
        get maxDate() {
          let e = null;
          for (let t of this._def.checks)
            "max" === t.kind && (null === e || t.value < e) && (e = t.value);
          return null != e ? new Date(e) : null;
        }
      };
      e_.create = (e) =>
        new e_({
          checks: [],
          coerce: (null == e ? void 0 : e.coerce) || !1,
          typeName: c.ZodDate,
          ...ee(e),
        });
      var eS = class extends et {
        _parse(e) {
          if (this._getType(e) !== D.symbol) {
            let t = this._getOrReturnCtx(e);
            return (
              j(t, {
                code: U.invalid_type,
                expected: D.symbol,
                received: t.parsedType,
              }),
              F
            );
          }
          return z(e.data);
        }
      };
      eS.create = (e) => new eS({ typeName: c.ZodSymbol, ...ee(e) });
      var eT = class extends et {
        _parse(e) {
          if (this._getType(e) !== D.undefined) {
            let t = this._getOrReturnCtx(e);
            return (
              j(t, {
                code: U.invalid_type,
                expected: D.undefined,
                received: t.parsedType,
              }),
              F
            );
          }
          return z(e.data);
        }
      };
      eT.create = (e) => new eT({ typeName: c.ZodUndefined, ...ee(e) });
      var ek = class extends et {
        _parse(e) {
          if (this._getType(e) !== D.null) {
            let t = this._getOrReturnCtx(e);
            return (
              j(t, {
                code: U.invalid_type,
                expected: D.null,
                received: t.parsedType,
              }),
              F
            );
          }
          return z(e.data);
        }
      };
      ek.create = (e) => new ek({ typeName: c.ZodNull, ...ee(e) });
      var eA = class extends et {
        constructor() {
          super(...arguments), (this._any = !0);
        }
        _parse(e) {
          return z(e.data);
        }
      };
      eA.create = (e) => new eA({ typeName: c.ZodAny, ...ee(e) });
      var eE = class extends et {
        constructor() {
          super(...arguments), (this._unknown = !0);
        }
        _parse(e) {
          return z(e.data);
        }
      };
      eE.create = (e) => new eE({ typeName: c.ZodUnknown, ...ee(e) });
      var eC = class extends et {
        _parse(e) {
          let t = this._getOrReturnCtx(e);
          return (
            j(t, {
              code: U.invalid_type,
              expected: D.never,
              received: t.parsedType,
            }),
            F
          );
        }
      };
      eC.create = (e) => new eC({ typeName: c.ZodNever, ...ee(e) });
      var eI = class extends et {
        _parse(e) {
          if (this._getType(e) !== D.undefined) {
            let t = this._getOrReturnCtx(e);
            return (
              j(t, {
                code: U.invalid_type,
                expected: D.void,
                received: t.parsedType,
              }),
              F
            );
          }
          return z(e.data);
        }
      };
      eI.create = (e) => new eI({ typeName: c.ZodVoid, ...ee(e) });
      var eO = class e extends et {
        _parse(e) {
          let { ctx: t, status: r } = this._processInputParams(e),
            i = this._def;
          if (t.parsedType !== D.array)
            return (
              j(t, {
                code: U.invalid_type,
                expected: D.array,
                received: t.parsedType,
              }),
              F
            );
          if (null !== i.exactLength) {
            let e = t.data.length > i.exactLength.value,
              n = t.data.length < i.exactLength.value;
            (e || n) &&
              (j(t, {
                code: e ? U.too_big : U.too_small,
                minimum: n ? i.exactLength.value : void 0,
                maximum: e ? i.exactLength.value : void 0,
                type: "array",
                inclusive: !0,
                exact: !0,
                message: i.exactLength.message,
              }),
              r.dirty());
          }
          if (
            (null !== i.minLength &&
              t.data.length < i.minLength.value &&
              (j(t, {
                code: U.too_small,
                minimum: i.minLength.value,
                type: "array",
                inclusive: !0,
                exact: !1,
                message: i.minLength.message,
              }),
              r.dirty()),
            null !== i.maxLength &&
              t.data.length > i.maxLength.value &&
              (j(t, {
                code: U.too_big,
                maximum: i.maxLength.value,
                type: "array",
                inclusive: !0,
                exact: !1,
                message: i.maxLength.message,
              }),
              r.dirty()),
            t.common.async)
          )
            return Promise.all(
              [...t.data].map((e, r) =>
                i.type._parseAsync(new Y(t, e, t.path, r))
              )
            ).then((e) => W.mergeArray(r, e));
          let n = [...t.data].map((e, r) =>
            i.type._parseSync(new Y(t, e, t.path, r))
          );
          return W.mergeArray(r, n);
        }
        get element() {
          return this._def.type;
        }
        min(t, r) {
          return new e({
            ...this._def,
            minLength: { value: t, message: s.toString(r) },
          });
        }
        max(t, r) {
          return new e({
            ...this._def,
            maxLength: { value: t, message: s.toString(r) },
          });
        }
        length(t, r) {
          return new e({
            ...this._def,
            exactLength: { value: t, message: s.toString(r) },
          });
        }
        nonempty(e) {
          return this.min(1, e);
        }
      };
      eO.create = (e, t) =>
        new eO({
          type: e,
          minLength: null,
          maxLength: null,
          exactLength: null,
          typeName: c.ZodArray,
          ...ee(t),
        });
      var eL = class e extends et {
        constructor() {
          super(...arguments),
            (this._cached = null),
            (this.nonstrict = this.passthrough),
            (this.augment = this.extend);
        }
        _getCached() {
          if (null !== this._cached) return this._cached;
          let e = this._def.shape(),
            t = i.objectKeys(e);
          return (this._cached = { shape: e, keys: t });
        }
        _parse(e) {
          if (this._getType(e) !== D.object) {
            let t = this._getOrReturnCtx(e);
            return (
              j(t, {
                code: U.invalid_type,
                expected: D.object,
                received: t.parsedType,
              }),
              F
            );
          }
          let { status: t, ctx: r } = this._processInputParams(e),
            { shape: i, keys: n } = this._getCached(),
            s = [];
          if (
            !(
              this._def.catchall instanceof eC &&
              "strip" === this._def.unknownKeys
            )
          )
            for (let e in r.data) n.includes(e) || s.push(e);
          let o = [];
          for (let e of n) {
            let t = i[e],
              n = r.data[e];
            o.push({
              key: { status: "valid", value: e },
              value: t._parse(new Y(r, n, r.path, e)),
              alwaysSet: e in r.data,
            });
          }
          if (this._def.catchall instanceof eC) {
            let e = this._def.unknownKeys;
            if ("passthrough" === e)
              for (let e of s)
                o.push({
                  key: { status: "valid", value: e },
                  value: { status: "valid", value: r.data[e] },
                });
            else if ("strict" === e)
              s.length > 0 &&
                (j(r, { code: U.unrecognized_keys, keys: s }), t.dirty());
            else if ("strip" === e);
            else
              throw Error(
                "Internal ZodObject error: invalid unknownKeys value."
              );
          } else {
            let e = this._def.catchall;
            for (let t of s) {
              let i = r.data[t];
              o.push({
                key: { status: "valid", value: t },
                value: e._parse(new Y(r, i, r.path, t)),
                alwaysSet: t in r.data,
              });
            }
          }
          return r.common.async
            ? Promise.resolve()
                .then(async () => {
                  let e = [];
                  for (let t of o) {
                    let r = await t.key,
                      i = await t.value;
                    e.push({ key: r, value: i, alwaysSet: t.alwaysSet });
                  }
                  return e;
                })
                .then((e) => W.mergeObjectSync(t, e))
            : W.mergeObjectSync(t, o);
        }
        get shape() {
          return this._def.shape();
        }
        strict(t) {
          return (
            s.errToObj,
            new e({
              ...this._def,
              unknownKeys: "strict",
              ...(void 0 !== t
                ? {
                    errorMap: (e, r) => {
                      var i, n, o, a;
                      let l =
                        null !=
                        (o =
                          null == (n = (i = this._def).errorMap)
                            ? void 0
                            : n.call(i, e, r).message)
                          ? o
                          : r.defaultError;
                      return "unrecognized_keys" === e.code
                        ? {
                            message:
                              null != (a = s.errToObj(t).message) ? a : l,
                          }
                        : { message: l };
                    },
                  }
                : {}),
            })
          );
        }
        strip() {
          return new e({ ...this._def, unknownKeys: "strip" });
        }
        passthrough() {
          return new e({ ...this._def, unknownKeys: "passthrough" });
        }
        extend(t) {
          return new e({
            ...this._def,
            shape: () => ({ ...this._def.shape(), ...t }),
          });
        }
        merge(t) {
          return new e({
            unknownKeys: t._def.unknownKeys,
            catchall: t._def.catchall,
            shape: () => ({ ...this._def.shape(), ...t._def.shape() }),
            typeName: c.ZodObject,
          });
        }
        setKey(e, t) {
          return this.augment({ [e]: t });
        }
        catchall(t) {
          return new e({ ...this._def, catchall: t });
        }
        pick(t) {
          let r = {};
          return (
            i.objectKeys(t).forEach((e) => {
              t[e] && this.shape[e] && (r[e] = this.shape[e]);
            }),
            new e({ ...this._def, shape: () => r })
          );
        }
        omit(t) {
          let r = {};
          return (
            i.objectKeys(this.shape).forEach((e) => {
              t[e] || (r[e] = this.shape[e]);
            }),
            new e({ ...this._def, shape: () => r })
          );
        }
        deepPartial() {
          return (function e(t) {
            if (t instanceof eL) {
              let r = {};
              for (let i in t.shape) {
                let n = t.shape[i];
                r[i] = eH.create(e(n));
              }
              return new eL({ ...t._def, shape: () => r });
            }
            if (t instanceof eO)
              return new eO({ ...t._def, type: e(t.element) });
            if (t instanceof eH) return eH.create(e(t.unwrap()));
            if (t instanceof eJ) return eJ.create(e(t.unwrap()));
            if (t instanceof eU) return eU.create(t.items.map((t) => e(t)));
            else return t;
          })(this);
        }
        partial(t) {
          let r = {};
          return (
            i.objectKeys(this.shape).forEach((e) => {
              let i = this.shape[e];
              t && !t[e] ? (r[e] = i) : (r[e] = i.optional());
            }),
            new e({ ...this._def, shape: () => r })
          );
        }
        required(t) {
          let r = {};
          return (
            i.objectKeys(this.shape).forEach((e) => {
              if (t && !t[e]) r[e] = this.shape[e];
              else {
                let t = this.shape[e];
                for (; t instanceof eH; ) t = t._def.innerType;
                r[e] = t;
              }
            }),
            new e({ ...this._def, shape: () => r })
          );
        }
        keyof() {
          return eQ(i.objectKeys(this.shape));
        }
      };
      (eL.create = (e, t) =>
        new eL({
          shape: () => e,
          unknownKeys: "strip",
          catchall: eC.create(),
          typeName: c.ZodObject,
          ...ee(t),
        })),
        (eL.strictCreate = (e, t) =>
          new eL({
            shape: () => e,
            unknownKeys: "strict",
            catchall: eC.create(),
            typeName: c.ZodObject,
            ...ee(t),
          })),
        (eL.lazycreate = (e, t) =>
          new eL({
            shape: e,
            unknownKeys: "strip",
            catchall: eC.create(),
            typeName: c.ZodObject,
            ...ee(t),
          }));
      var eR = class extends et {
        _parse(e) {
          let { ctx: t } = this._processInputParams(e),
            r = this._def.options;
          if (t.common.async)
            return Promise.all(
              r.map(async (e) => {
                let r = {
                  ...t,
                  common: { ...t.common, issues: [] },
                  parent: null,
                };
                return {
                  result: await e._parseAsync({
                    data: t.data,
                    path: t.path,
                    parent: r,
                  }),
                  ctx: r,
                };
              })
            ).then(function (e) {
              for (let t of e) if ("valid" === t.result.status) return t.result;
              for (let r of e)
                if ("dirty" === r.result.status)
                  return t.common.issues.push(...r.ctx.common.issues), r.result;
              let r = e.map((e) => new $(e.ctx.common.issues));
              return j(t, { code: U.invalid_union, unionErrors: r }), F;
            });
          {
            let e,
              i = [];
            for (let n of r) {
              let r = {
                  ...t,
                  common: { ...t.common, issues: [] },
                  parent: null,
                },
                s = n._parseSync({ data: t.data, path: t.path, parent: r });
              if ("valid" === s.status) return s;
              "dirty" !== s.status || e || (e = { result: s, ctx: r }),
                r.common.issues.length && i.push(r.common.issues);
            }
            if (e)
              return t.common.issues.push(...e.ctx.common.issues), e.result;
            let n = i.map((e) => new $(e));
            return j(t, { code: U.invalid_union, unionErrors: n }), F;
          }
        }
        get options() {
          return this._def.options;
        }
      };
      eR.create = (e, t) =>
        new eR({ options: e, typeName: c.ZodUnion, ...ee(t) });
      var eP = (e) => {
          if (e instanceof eW) return eP(e.schema);
          if (e instanceof eG) return eP(e.innerType());
          if (e instanceof eF) return [e.value];
          if (e instanceof ez) return e.options;
          if (e instanceof eV) return i.objectValues(e.enum);
          else if (e instanceof eZ) return eP(e._def.innerType);
          else if (e instanceof eT) return [void 0];
          else if (e instanceof ek) return [null];
          else if (e instanceof eH) return [void 0, ...eP(e.unwrap())];
          else if (e instanceof eJ) return [null, ...eP(e.unwrap())];
          else if (e instanceof e0) return eP(e.unwrap());
          else if (e instanceof e2) return eP(e.unwrap());
          else if (e instanceof eY) return eP(e._def.innerType);
          else return [];
        },
        eD = class e extends et {
          _parse(e) {
            let { ctx: t } = this._processInputParams(e);
            if (t.parsedType !== D.object)
              return (
                j(t, {
                  code: U.invalid_type,
                  expected: D.object,
                  received: t.parsedType,
                }),
                F
              );
            let r = this.discriminator,
              i = t.data[r],
              n = this.optionsMap.get(i);
            return n
              ? t.common.async
                ? n._parseAsync({ data: t.data, path: t.path, parent: t })
                : n._parseSync({ data: t.data, path: t.path, parent: t })
              : (j(t, {
                  code: U.invalid_union_discriminator,
                  options: Array.from(this.optionsMap.keys()),
                  path: [r],
                }),
                F);
          }
          get discriminator() {
            return this._def.discriminator;
          }
          get options() {
            return this._def.options;
          }
          get optionsMap() {
            return this._def.optionsMap;
          }
          static create(t, r, i) {
            let n = new Map();
            for (let e of r) {
              let r = eP(e.shape[t]);
              if (!r.length)
                throw Error(
                  `A discriminator value for key \`${t}\` could not be extracted from all schema options`
                );
              for (let i of r) {
                if (n.has(i))
                  throw Error(
                    `Discriminator property ${String(t)} has duplicate value ${String(i)}`
                  );
                n.set(i, e);
              }
            }
            return new e({
              typeName: c.ZodDiscriminatedUnion,
              discriminator: t,
              options: r,
              optionsMap: n,
              ...ee(i),
            });
          }
        },
        eq = class extends et {
          _parse(e) {
            let { status: t, ctx: r } = this._processInputParams(e),
              n = (e, n) => {
                if (V(e) || V(n)) return F;
                let s = (function e(t, r) {
                  let n = q(t),
                    s = q(r);
                  if (t === r) return { valid: !0, data: t };
                  if (n === D.object && s === D.object) {
                    let n = i.objectKeys(r),
                      s = i.objectKeys(t).filter((e) => -1 !== n.indexOf(e)),
                      o = { ...t, ...r };
                    for (let i of s) {
                      let n = e(t[i], r[i]);
                      if (!n.valid) return { valid: !1 };
                      o[i] = n.data;
                    }
                    return { valid: !0, data: o };
                  }
                  if (n === D.array && s === D.array) {
                    if (t.length !== r.length) return { valid: !1 };
                    let i = [];
                    for (let n = 0; n < t.length; n++) {
                      let s = e(t[n], r[n]);
                      if (!s.valid) return { valid: !1 };
                      i.push(s.data);
                    }
                    return { valid: !0, data: i };
                  }
                  if (n === D.date && s === D.date && +t == +r)
                    return { valid: !0, data: t };
                  return { valid: !1 };
                })(e.value, n.value);
                return s.valid
                  ? ((K(e) || K(n)) && t.dirty(),
                    { status: t.value, value: s.data })
                  : (j(r, { code: U.invalid_intersection_types }), F);
              };
            return r.common.async
              ? Promise.all([
                  this._def.left._parseAsync({
                    data: r.data,
                    path: r.path,
                    parent: r,
                  }),
                  this._def.right._parseAsync({
                    data: r.data,
                    path: r.path,
                    parent: r,
                  }),
                ]).then(([e, t]) => n(e, t))
              : n(
                  this._def.left._parseSync({
                    data: r.data,
                    path: r.path,
                    parent: r,
                  }),
                  this._def.right._parseSync({
                    data: r.data,
                    path: r.path,
                    parent: r,
                  })
                );
          }
        };
      eq.create = (e, t, r) =>
        new eq({ left: e, right: t, typeName: c.ZodIntersection, ...ee(r) });
      var eU = class e extends et {
        _parse(e) {
          let { status: t, ctx: r } = this._processInputParams(e);
          if (r.parsedType !== D.array)
            return (
              j(r, {
                code: U.invalid_type,
                expected: D.array,
                received: r.parsedType,
              }),
              F
            );
          if (r.data.length < this._def.items.length)
            return (
              j(r, {
                code: U.too_small,
                minimum: this._def.items.length,
                inclusive: !0,
                exact: !1,
                type: "array",
              }),
              F
            );
          !this._def.rest &&
            r.data.length > this._def.items.length &&
            (j(r, {
              code: U.too_big,
              maximum: this._def.items.length,
              inclusive: !0,
              exact: !1,
              type: "array",
            }),
            t.dirty());
          let i = [...r.data]
            .map((e, t) => {
              let i = this._def.items[t] || this._def.rest;
              return i ? i._parse(new Y(r, e, r.path, t)) : null;
            })
            .filter((e) => !!e);
          return r.common.async
            ? Promise.all(i).then((e) => W.mergeArray(t, e))
            : W.mergeArray(t, i);
        }
        get items() {
          return this._def.items;
        }
        rest(t) {
          return new e({ ...this._def, rest: t });
        }
      };
      eU.create = (e, t) => {
        if (!Array.isArray(e))
          throw Error("You must pass an array of schemas to z.tuple([ ... ])");
        return new eU({ items: e, typeName: c.ZodTuple, rest: null, ...ee(t) });
      };
      var e$ = class e extends et {
          get keySchema() {
            return this._def.keyType;
          }
          get valueSchema() {
            return this._def.valueType;
          }
          _parse(e) {
            let { status: t, ctx: r } = this._processInputParams(e);
            if (r.parsedType !== D.object)
              return (
                j(r, {
                  code: U.invalid_type,
                  expected: D.object,
                  received: r.parsedType,
                }),
                F
              );
            let i = [],
              n = this._def.keyType,
              s = this._def.valueType;
            for (let e in r.data)
              i.push({
                key: n._parse(new Y(r, e, r.path, e)),
                value: s._parse(new Y(r, r.data[e], r.path, e)),
                alwaysSet: e in r.data,
              });
            return r.common.async
              ? W.mergeObjectAsync(t, i)
              : W.mergeObjectSync(t, i);
          }
          get element() {
            return this._def.valueType;
          }
          static create(t, r, i) {
            return new e(
              r instanceof et
                ? { keyType: t, valueType: r, typeName: c.ZodRecord, ...ee(i) }
                : {
                    keyType: eb.create(),
                    valueType: t,
                    typeName: c.ZodRecord,
                    ...ee(r),
                  }
            );
          }
        },
        eB = class extends et {
          get keySchema() {
            return this._def.keyType;
          }
          get valueSchema() {
            return this._def.valueType;
          }
          _parse(e) {
            let { status: t, ctx: r } = this._processInputParams(e);
            if (r.parsedType !== D.map)
              return (
                j(r, {
                  code: U.invalid_type,
                  expected: D.map,
                  received: r.parsedType,
                }),
                F
              );
            let i = this._def.keyType,
              n = this._def.valueType,
              s = [...r.data.entries()].map(([e, t], s) => ({
                key: i._parse(new Y(r, e, r.path, [s, "key"])),
                value: n._parse(new Y(r, t, r.path, [s, "value"])),
              }));
            if (r.common.async) {
              let e = new Map();
              return Promise.resolve().then(async () => {
                for (let r of s) {
                  let i = await r.key,
                    n = await r.value;
                  if ("aborted" === i.status || "aborted" === n.status)
                    return F;
                  ("dirty" === i.status || "dirty" === n.status) && t.dirty(),
                    e.set(i.value, n.value);
                }
                return { status: t.value, value: e };
              });
            }
            {
              let e = new Map();
              for (let r of s) {
                let i = r.key,
                  n = r.value;
                if ("aborted" === i.status || "aborted" === n.status) return F;
                ("dirty" === i.status || "dirty" === n.status) && t.dirty(),
                  e.set(i.value, n.value);
              }
              return { status: t.value, value: e };
            }
          }
        };
      eB.create = (e, t, r) =>
        new eB({ valueType: t, keyType: e, typeName: c.ZodMap, ...ee(r) });
      var eM = class e extends et {
        _parse(e) {
          let { status: t, ctx: r } = this._processInputParams(e);
          if (r.parsedType !== D.set)
            return (
              j(r, {
                code: U.invalid_type,
                expected: D.set,
                received: r.parsedType,
              }),
              F
            );
          let i = this._def;
          null !== i.minSize &&
            r.data.size < i.minSize.value &&
            (j(r, {
              code: U.too_small,
              minimum: i.minSize.value,
              type: "set",
              inclusive: !0,
              exact: !1,
              message: i.minSize.message,
            }),
            t.dirty()),
            null !== i.maxSize &&
              r.data.size > i.maxSize.value &&
              (j(r, {
                code: U.too_big,
                maximum: i.maxSize.value,
                type: "set",
                inclusive: !0,
                exact: !1,
                message: i.maxSize.message,
              }),
              t.dirty());
          let n = this._def.valueType;
          function s(e) {
            let r = new Set();
            for (let i of e) {
              if ("aborted" === i.status) return F;
              "dirty" === i.status && t.dirty(), r.add(i.value);
            }
            return { status: t.value, value: r };
          }
          let o = [...r.data.values()].map((e, t) =>
            n._parse(new Y(r, e, r.path, t))
          );
          return r.common.async ? Promise.all(o).then((e) => s(e)) : s(o);
        }
        min(t, r) {
          return new e({
            ...this._def,
            minSize: { value: t, message: s.toString(r) },
          });
        }
        max(t, r) {
          return new e({
            ...this._def,
            maxSize: { value: t, message: s.toString(r) },
          });
        }
        size(e, t) {
          return this.min(e, t).max(e, t);
        }
        nonempty(e) {
          return this.min(1, e);
        }
      };
      eM.create = (e, t) =>
        new eM({
          valueType: e,
          minSize: null,
          maxSize: null,
          typeName: c.ZodSet,
          ...ee(t),
        });
      var ej = class e extends et {
          constructor() {
            super(...arguments), (this.validate = this.implement);
          }
          _parse(e) {
            let { ctx: t } = this._processInputParams(e);
            if (t.parsedType !== D.function)
              return (
                j(t, {
                  code: U.invalid_type,
                  expected: D.function,
                  received: t.parsedType,
                }),
                F
              );
            function r(e, r) {
              return M({
                data: e,
                path: t.path,
                errorMaps: [
                  t.common.contextualErrorMap,
                  t.schemaErrorMap,
                  B,
                  B,
                ].filter((e) => !!e),
                issueData: { code: U.invalid_arguments, argumentsError: r },
              });
            }
            function i(e, r) {
              return M({
                data: e,
                path: t.path,
                errorMaps: [
                  t.common.contextualErrorMap,
                  t.schemaErrorMap,
                  B,
                  B,
                ].filter((e) => !!e),
                issueData: { code: U.invalid_return_type, returnTypeError: r },
              });
            }
            let n = { errorMap: t.common.contextualErrorMap },
              s = t.data;
            if (this._def.returns instanceof eK) {
              let e = this;
              return z(async function (...t) {
                let o = new $([]),
                  a = await e._def.args.parseAsync(t, n).catch((e) => {
                    throw (o.addIssue(r(t, e)), o);
                  }),
                  l = await Reflect.apply(s, this, a);
                return await e._def.returns._def.type
                  .parseAsync(l, n)
                  .catch((e) => {
                    throw (o.addIssue(i(l, e)), o);
                  });
              });
            }
            {
              let e = this;
              return z(function (...t) {
                let o = e._def.args.safeParse(t, n);
                if (!o.success) throw new $([r(t, o.error)]);
                let a = Reflect.apply(s, this, o.data),
                  l = e._def.returns.safeParse(a, n);
                if (!l.success) throw new $([i(a, l.error)]);
                return l.data;
              });
            }
          }
          parameters() {
            return this._def.args;
          }
          returnType() {
            return this._def.returns;
          }
          args(...t) {
            return new e({
              ...this._def,
              args: eU.create(t).rest(eE.create()),
            });
          }
          returns(t) {
            return new e({ ...this._def, returns: t });
          }
          implement(e) {
            return this.parse(e);
          }
          strictImplement(e) {
            return this.parse(e);
          }
          static create(t, r, i) {
            return new e({
              args: t || eU.create([]).rest(eE.create()),
              returns: r || eE.create(),
              typeName: c.ZodFunction,
              ...ee(i),
            });
          }
        },
        eW = class extends et {
          get schema() {
            return this._def.getter();
          }
          _parse(e) {
            let { ctx: t } = this._processInputParams(e);
            return this._def
              .getter()
              ._parse({ data: t.data, path: t.path, parent: t });
          }
        };
      eW.create = (e, t) =>
        new eW({ getter: e, typeName: c.ZodLazy, ...ee(t) });
      var eF = class extends et {
        _parse(e) {
          if (e.data !== this._def.value) {
            let t = this._getOrReturnCtx(e);
            return (
              j(t, {
                received: t.data,
                code: U.invalid_literal,
                expected: this._def.value,
              }),
              F
            );
          }
          return { status: "valid", value: e.data };
        }
        get value() {
          return this._def.value;
        }
      };
      function eQ(e, t) {
        return new ez({ values: e, typeName: c.ZodEnum, ...ee(t) });
      }
      eF.create = (e, t) =>
        new eF({ value: e, typeName: c.ZodLiteral, ...ee(t) });
      var ez = class e extends et {
        constructor() {
          super(...arguments), o.set(this, void 0);
        }
        _parse(e) {
          if ("string" != typeof e.data) {
            let t = this._getOrReturnCtx(e),
              r = this._def.values;
            return (
              j(t, {
                expected: i.joinValues(r),
                received: t.parsedType,
                code: U.invalid_type,
              }),
              F
            );
          }
          if (
            (J(this, o, "f") || Z(this, o, new Set(this._def.values), "f"),
            !J(this, o, "f").has(e.data))
          ) {
            let t = this._getOrReturnCtx(e),
              r = this._def.values;
            return (
              j(t, {
                received: t.data,
                code: U.invalid_enum_value,
                options: r,
              }),
              F
            );
          }
          return z(e.data);
        }
        get options() {
          return this._def.values;
        }
        get enum() {
          let e = {};
          for (let t of this._def.values) e[t] = t;
          return e;
        }
        get Values() {
          let e = {};
          for (let t of this._def.values) e[t] = t;
          return e;
        }
        get Enum() {
          let e = {};
          for (let t of this._def.values) e[t] = t;
          return e;
        }
        extract(t, r = this._def) {
          return e.create(t, { ...this._def, ...r });
        }
        exclude(t, r = this._def) {
          return e.create(
            this.options.filter((e) => !t.includes(e)),
            { ...this._def, ...r }
          );
        }
      };
      (o = new WeakMap()), (ez.create = eQ);
      var eV = class extends et {
        constructor() {
          super(...arguments), a.set(this, void 0);
        }
        _parse(e) {
          let t = i.getValidEnumValues(this._def.values),
            r = this._getOrReturnCtx(e);
          if (r.parsedType !== D.string && r.parsedType !== D.number) {
            let e = i.objectValues(t);
            return (
              j(r, {
                expected: i.joinValues(e),
                received: r.parsedType,
                code: U.invalid_type,
              }),
              F
            );
          }
          if (
            (J(this, a, "f") ||
              Z(this, a, new Set(i.getValidEnumValues(this._def.values)), "f"),
            !J(this, a, "f").has(e.data))
          ) {
            let e = i.objectValues(t);
            return (
              j(r, {
                received: r.data,
                code: U.invalid_enum_value,
                options: e,
              }),
              F
            );
          }
          return z(e.data);
        }
        get enum() {
          return this._def.values;
        }
      };
      (a = new WeakMap()),
        (eV.create = (e, t) =>
          new eV({ values: e, typeName: c.ZodNativeEnum, ...ee(t) }));
      var eK = class extends et {
        unwrap() {
          return this._def.type;
        }
        _parse(e) {
          let { ctx: t } = this._processInputParams(e);
          return t.parsedType !== D.promise && !1 === t.common.async
            ? (j(t, {
                code: U.invalid_type,
                expected: D.promise,
                received: t.parsedType,
              }),
              F)
            : z(
                (t.parsedType === D.promise
                  ? t.data
                  : Promise.resolve(t.data)
                ).then((e) =>
                  this._def.type.parseAsync(e, {
                    path: t.path,
                    errorMap: t.common.contextualErrorMap,
                  })
                )
              );
        }
      };
      eK.create = (e, t) =>
        new eK({ type: e, typeName: c.ZodPromise, ...ee(t) });
      var eG = class extends et {
        innerType() {
          return this._def.schema;
        }
        sourceType() {
          return this._def.schema._def.typeName === c.ZodEffects
            ? this._def.schema.sourceType()
            : this._def.schema;
        }
        _parse(e) {
          let { status: t, ctx: r } = this._processInputParams(e),
            n = this._def.effect || null,
            s = {
              addIssue: (e) => {
                j(r, e), e.fatal ? t.abort() : t.dirty();
              },
              get path() {
                return r.path;
              },
            };
          if (((s.addIssue = s.addIssue.bind(s)), "preprocess" === n.type)) {
            let e = n.transform(r.data, s);
            if (r.common.async)
              return Promise.resolve(e).then(async (e) => {
                if ("aborted" === t.value) return F;
                let i = await this._def.schema._parseAsync({
                  data: e,
                  path: r.path,
                  parent: r,
                });
                return "aborted" === i.status
                  ? F
                  : "dirty" === i.status || "dirty" === t.value
                    ? Q(i.value)
                    : i;
              });
            {
              if ("aborted" === t.value) return F;
              let i = this._def.schema._parseSync({
                data: e,
                path: r.path,
                parent: r,
              });
              return "aborted" === i.status
                ? F
                : "dirty" === i.status || "dirty" === t.value
                  ? Q(i.value)
                  : i;
            }
          }
          if ("refinement" === n.type) {
            let e = (e) => {
              let t = n.refinement(e, s);
              if (r.common.async) return Promise.resolve(t);
              if (t instanceof Promise)
                throw Error(
                  "Async refinement encountered during synchronous parse operation. Use .parseAsync instead."
                );
              return e;
            };
            if (!1 !== r.common.async)
              return this._def.schema
                ._parseAsync({ data: r.data, path: r.path, parent: r })
                .then((r) =>
                  "aborted" === r.status
                    ? F
                    : ("dirty" === r.status && t.dirty(),
                      e(r.value).then(() => ({
                        status: t.value,
                        value: r.value,
                      })))
                );
            {
              let i = this._def.schema._parseSync({
                data: r.data,
                path: r.path,
                parent: r,
              });
              return "aborted" === i.status
                ? F
                : ("dirty" === i.status && t.dirty(),
                  e(i.value),
                  { status: t.value, value: i.value });
            }
          }
          if ("transform" === n.type)
            if (!1 !== r.common.async)
              return this._def.schema
                ._parseAsync({ data: r.data, path: r.path, parent: r })
                .then((e) =>
                  G(e)
                    ? Promise.resolve(n.transform(e.value, s)).then((e) => ({
                        status: t.value,
                        value: e,
                      }))
                    : e
                );
            else {
              let e = this._def.schema._parseSync({
                data: r.data,
                path: r.path,
                parent: r,
              });
              if (!G(e)) return e;
              let i = n.transform(e.value, s);
              if (i instanceof Promise)
                throw Error(
                  "Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead."
                );
              return { status: t.value, value: i };
            }
          i.assertNever(n);
        }
      };
      (eG.create = (e, t, r) =>
        new eG({ schema: e, typeName: c.ZodEffects, effect: t, ...ee(r) })),
        (eG.createWithPreprocess = (e, t, r) =>
          new eG({
            schema: t,
            effect: { type: "preprocess", transform: e },
            typeName: c.ZodEffects,
            ...ee(r),
          }));
      var eH = class extends et {
        _parse(e) {
          return this._getType(e) === D.undefined
            ? z(void 0)
            : this._def.innerType._parse(e);
        }
        unwrap() {
          return this._def.innerType;
        }
      };
      eH.create = (e, t) =>
        new eH({ innerType: e, typeName: c.ZodOptional, ...ee(t) });
      var eJ = class extends et {
        _parse(e) {
          return this._getType(e) === D.null
            ? z(null)
            : this._def.innerType._parse(e);
        }
        unwrap() {
          return this._def.innerType;
        }
      };
      eJ.create = (e, t) =>
        new eJ({ innerType: e, typeName: c.ZodNullable, ...ee(t) });
      var eZ = class extends et {
        _parse(e) {
          let { ctx: t } = this._processInputParams(e),
            r = t.data;
          return (
            t.parsedType === D.undefined && (r = this._def.defaultValue()),
            this._def.innerType._parse({ data: r, path: t.path, parent: t })
          );
        }
        removeDefault() {
          return this._def.innerType;
        }
      };
      eZ.create = (e, t) =>
        new eZ({
          innerType: e,
          typeName: c.ZodDefault,
          defaultValue:
            "function" == typeof t.default ? t.default : () => t.default,
          ...ee(t),
        });
      var eY = class extends et {
        _parse(e) {
          let { ctx: t } = this._processInputParams(e),
            r = { ...t, common: { ...t.common, issues: [] } },
            i = this._def.innerType._parse({
              data: r.data,
              path: r.path,
              parent: { ...r },
            });
          return H(i)
            ? i.then((e) => ({
                status: "valid",
                value:
                  "valid" === e.status
                    ? e.value
                    : this._def.catchValue({
                        get error() {
                          return new $(r.common.issues);
                        },
                        input: r.data,
                      }),
              }))
            : {
                status: "valid",
                value:
                  "valid" === i.status
                    ? i.value
                    : this._def.catchValue({
                        get error() {
                          return new $(r.common.issues);
                        },
                        input: r.data,
                      }),
              };
        }
        removeCatch() {
          return this._def.innerType;
        }
      };
      eY.create = (e, t) =>
        new eY({
          innerType: e,
          typeName: c.ZodCatch,
          catchValue: "function" == typeof t.catch ? t.catch : () => t.catch,
          ...ee(t),
        });
      var eX = class extends et {
        _parse(e) {
          if (this._getType(e) !== D.nan) {
            let t = this._getOrReturnCtx(e);
            return (
              j(t, {
                code: U.invalid_type,
                expected: D.nan,
                received: t.parsedType,
              }),
              F
            );
          }
          return { status: "valid", value: e.data };
        }
      };
      (eX.create = (e) => new eX({ typeName: c.ZodNaN, ...ee(e) })),
        Symbol("zod_brand");
      var e0 = class extends et {
          _parse(e) {
            let { ctx: t } = this._processInputParams(e),
              r = t.data;
            return this._def.type._parse({ data: r, path: t.path, parent: t });
          }
          unwrap() {
            return this._def.type;
          }
        },
        e1 = class e extends et {
          _parse(e) {
            let { status: t, ctx: r } = this._processInputParams(e);
            if (r.common.async)
              return (async () => {
                let e = await this._def.in._parseAsync({
                  data: r.data,
                  path: r.path,
                  parent: r,
                });
                return "aborted" === e.status
                  ? F
                  : "dirty" === e.status
                    ? (t.dirty(), Q(e.value))
                    : this._def.out._parseAsync({
                        data: e.value,
                        path: r.path,
                        parent: r,
                      });
              })();
            {
              let e = this._def.in._parseSync({
                data: r.data,
                path: r.path,
                parent: r,
              });
              return "aborted" === e.status
                ? F
                : "dirty" === e.status
                  ? (t.dirty(), { status: "dirty", value: e.value })
                  : this._def.out._parseSync({
                      data: e.value,
                      path: r.path,
                      parent: r,
                    });
            }
          }
          static create(t, r) {
            return new e({ in: t, out: r, typeName: c.ZodPipeline });
          }
        },
        e2 = class extends et {
          _parse(e) {
            let t = this._def.innerType._parse(e),
              r = (e) => (G(e) && (e.value = Object.freeze(e.value)), e);
            return H(t) ? t.then((e) => r(e)) : r(t);
          }
          unwrap() {
            return this._def.innerType;
          }
        };
      (e2.create = (e, t) =>
        new e2({ innerType: e, typeName: c.ZodReadonly, ...ee(t) })),
        eL.lazycreate,
        (function (e) {
          (e.ZodString = "ZodString"),
            (e.ZodNumber = "ZodNumber"),
            (e.ZodNaN = "ZodNaN"),
            (e.ZodBigInt = "ZodBigInt"),
            (e.ZodBoolean = "ZodBoolean"),
            (e.ZodDate = "ZodDate"),
            (e.ZodSymbol = "ZodSymbol"),
            (e.ZodUndefined = "ZodUndefined"),
            (e.ZodNull = "ZodNull"),
            (e.ZodAny = "ZodAny"),
            (e.ZodUnknown = "ZodUnknown"),
            (e.ZodNever = "ZodNever"),
            (e.ZodVoid = "ZodVoid"),
            (e.ZodArray = "ZodArray"),
            (e.ZodObject = "ZodObject"),
            (e.ZodUnion = "ZodUnion"),
            (e.ZodDiscriminatedUnion = "ZodDiscriminatedUnion"),
            (e.ZodIntersection = "ZodIntersection"),
            (e.ZodTuple = "ZodTuple"),
            (e.ZodRecord = "ZodRecord"),
            (e.ZodMap = "ZodMap"),
            (e.ZodSet = "ZodSet"),
            (e.ZodFunction = "ZodFunction"),
            (e.ZodLazy = "ZodLazy"),
            (e.ZodLiteral = "ZodLiteral"),
            (e.ZodEnum = "ZodEnum"),
            (e.ZodEffects = "ZodEffects"),
            (e.ZodNativeEnum = "ZodNativeEnum"),
            (e.ZodOptional = "ZodOptional"),
            (e.ZodNullable = "ZodNullable"),
            (e.ZodDefault = "ZodDefault"),
            (e.ZodCatch = "ZodCatch"),
            (e.ZodPromise = "ZodPromise"),
            (e.ZodBranded = "ZodBranded"),
            (e.ZodPipeline = "ZodPipeline"),
            (e.ZodReadonly = "ZodReadonly");
        })(c || (c = {})),
        eb.create,
        ev.create,
        eX.create,
        eN.create,
        ex.create,
        e_.create,
        eS.create,
        eT.create,
        ek.create,
        eA.create,
        eE.create,
        eC.create,
        eI.create,
        eO.create,
        eL.create,
        eL.strictCreate,
        eR.create,
        eD.create,
        eq.create,
        eU.create,
        e$.create,
        eB.create,
        eM.create,
        ej.create,
        eW.create,
        eF.create,
        ez.create,
        eV.create,
        eK.create,
        eG.create,
        eH.create,
        eJ.create,
        eG.createWithPreprocess,
        e1.create;
      var e5 = {};
      function e6(e) {
        switch (e.constructor.name) {
          case "ZodString":
          default:
            return "string";
          case "ZodNumber":
            return "number";
          case "ZodBoolean":
            return "boolean";
          case "ZodObject":
            return "object";
          case "ZodArray":
            return "array";
        }
      }
      function e4(e) {
        let t = [];
        return (
          e.metadata?.openapi?.parameters
            ? t.push(...e.metadata.openapi.parameters)
            : e.query instanceof eL &&
              Object.entries(e.query.shape).forEach(([e, r]) => {
                r instanceof et &&
                  t.push({
                    name: e,
                    in: "query",
                    schema: {
                      type: e6(r),
                      ...("minLength" in r && r.minLength
                        ? { minLength: r.minLength }
                        : {}),
                      description: r.description,
                    },
                  });
              }),
          t
        );
      }
      function e3(e) {
        return {
          400: {
            content: {
              "application/json": {
                schema: {
                  type: "object",
                  properties: { message: { type: "string" } },
                  required: ["message"],
                },
              },
            },
            description:
              "Bad Request. Usually due to missing parameters, or invalid parameters.",
          },
          401: {
            content: {
              "application/json": {
                schema: {
                  type: "object",
                  properties: { message: { type: "string" } },
                  required: ["message"],
                },
              },
            },
            description:
              "Unauthorized. Due to missing or invalid authentication.",
          },
          403: {
            content: {
              "application/json": {
                schema: {
                  type: "object",
                  properties: { message: { type: "string" } },
                },
              },
            },
            description:
              "Forbidden. You do not have permission to access this resource or to perform this action.",
          },
          404: {
            content: {
              "application/json": {
                schema: {
                  type: "object",
                  properties: { message: { type: "string" } },
                },
              },
            },
            description: "Not Found. The requested resource was not found.",
          },
          429: {
            content: {
              "application/json": {
                schema: {
                  type: "object",
                  properties: { message: { type: "string" } },
                },
              },
            },
            description:
              "Too Many Requests. You have exceeded the rate limit. Try again later.",
          },
          500: {
            content: {
              "application/json": {
                schema: {
                  type: "object",
                  properties: { message: { type: "string" } },
                },
              },
            },
            description:
              "Internal Server Error. This is a problem with the server that you cannot fix.",
          },
          ...e,
        };
      }
      async function e8(e, t) {
        return (
          Object.entries(e).forEach(([e, t]) => {
            let r = t.options;
            if (
              !r.metadata?.SERVER_ONLY &&
              ("GET" === r.method &&
                (e5[t.path] = {
                  get: {
                    tags: ["Default", ...(r.metadata?.openapi?.tags || [])],
                    description: r.metadata?.openapi?.description,
                    operationId: r.metadata?.openapi?.operationId,
                    security: [{ bearerAuth: [] }],
                    parameters: e4(r),
                    responses: e3(r.metadata?.openapi?.responses),
                  },
                }),
              "POST" === r.method)
            ) {
              let e = (function (e) {
                if (e.metadata?.openapi?.requestBody)
                  return e.metadata.openapi.requestBody;
                if (e.body && (e.body instanceof eL || e.body instanceof eH)) {
                  let t = e.body.shape;
                  if (!t) return;
                  let r = {},
                    i = [];
                  return (
                    Object.entries(t).forEach(([e, t]) => {
                      t instanceof et &&
                        ((r[e] = { type: e6(t), description: t.description }),
                        t instanceof eH || i.push(e));
                    }),
                    {
                      required: !(e.body instanceof eH) && !!e.body,
                      content: {
                        "application/json": {
                          schema: {
                            type: "object",
                            properties: r,
                            required: i,
                          },
                        },
                      },
                    }
                  );
                }
              })(r);
              e5[t.path] = {
                post: {
                  tags: ["Default", ...(r.metadata?.openapi?.tags || [])],
                  description: r.metadata?.openapi?.description,
                  operationId: r.metadata?.openapi?.operationId,
                  security: [{ bearerAuth: [] }],
                  parameters: e4(r),
                  ...(e
                    ? { requestBody: e }
                    : {
                        requestBody: {
                          content: {
                            "application/json": {
                              schema: { type: "object", properties: {} },
                            },
                          },
                        },
                      }),
                  responses: e3(r.metadata?.openapi?.responses),
                },
              };
            }
          }),
          {
            openapi: "3.1.1",
            info: {
              title: "Better Auth",
              description: "API Reference for your Better Auth Instance",
              version: "1.1.0",
            },
            components: { schemas: {} },
            security: [{ apiKeyCookie: [] }],
            servers: [{ url: t?.url }],
            tags: [
              {
                name: "Default",
                description:
                  "Default endpoints that are included with Better Auth by default. These endpoints are not part of any plugin.",
              },
            ],
            paths: e5,
          }
        );
      }
      var e9 = (e, t) => `<!doctype html>
<html>
  <head>
    <title>Scalar API Reference</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1" />
  </head>
  <body>
    <script
      id="api-reference"
      type="application/json">
    ${JSON.stringify(e)}
    </script>
	 <script>
      var configuration = {
	  	favicon: ${t?.logo ? `data:image/svg+xml;utf8,${encodeURIComponent(t.logo)}` : void 0} ,
	   	theme: ${t?.theme || "saturn"},
        metaData: {
			title: ${t?.title || "Open API Reference"},
			description: ${t?.description || "Better Call Open API"},
		}
      }
      document.getElementById('api-reference').dataset.configuration =
        JSON.stringify(configuration)
    </script>
	  <script src="https://cdn.jsdelivr.net/npm/@scalar/api-reference"></script>
  </body>
</html>`,
        e7 = (e, t) => {
          if (!t?.openapi?.disabled) {
            let r = { path: "/api/reference", ...t?.openapi };
            e.openapi = P(
              r.path,
              { method: "GET" },
              async (t) =>
                new Response(e9(await e8(e), r.scalar), {
                  headers: { "Content-Type": "text/html" },
                })
            );
          }
          let r = h(),
            i = h();
          for (let t of Object.values(e))
            if (!(!t.options || t.options?.metadata?.SERVER_ONLY))
              for (let e of Array.isArray(t.options?.method)
                ? t.options.method
                : [t.options?.method])
                m(r, e, t.path, t);
          if (t?.routerMiddleware?.length)
            for (let { path: e, middleware: r } of t.routerMiddleware)
              m(i, "*", e, r);
          let n = async (e) => {
            let n = new URL(e.url),
              s = t?.basePath ? n.pathname.split(t.basePath)[1] : n.pathname;
            if (!s?.length)
              return (
                t?.onError?.(Error("NOT_FOUND")),
                new Response(null, { status: 404, statusText: "Not Found" })
              );
            let o = (function (e, t = "", r, i) {
              "/" === r[r.length - 1] && (r = r.slice(0, -1));
              let n = e.static[r];
              if (n && n.methods) {
                let e = n.methods[t] || n.methods[""];
                if (void 0 !== e) return e[0];
              }
              let s = p(r),
                o = (function e(t, r, i, n, s) {
                  if (s === n.length) {
                    if (r.methods) {
                      let e = r.methods[i] || r.methods[""];
                      if (e) return e;
                    }
                    if (r.param && r.param.methods) {
                      let e = r.param.methods[i] || r.param.methods[""];
                      if (e) {
                        let t = e[0].paramsMap;
                        if (t?.[t?.length - 1]?.[2]) return e;
                      }
                    }
                    if (r.wildcard && r.wildcard.methods) {
                      let e = r.wildcard.methods[i] || r.wildcard.methods[""];
                      if (e) {
                        let t = e[0].paramsMap;
                        if (t?.[t?.length - 1]?.[2]) return e;
                      }
                    }
                    return;
                  }
                  let o = n[s];
                  if (r.static) {
                    let a = r.static[o];
                    if (a) {
                      let r = e(t, a, i, n, s + 1);
                      if (r) return r;
                    }
                  }
                  if (r.param) {
                    let o = e(t, r.param, i, n, s + 1);
                    if (o) return o;
                  }
                  if (r.wildcard && r.wildcard.methods)
                    return r.wildcard.methods[i] || r.wildcard.methods[""];
                })(e, e.root, t, s, 0)?.[0];
              if (void 0 !== o)
                return {
                  data: o.data,
                  params: o.paramsMap ? f(s, o.paramsMap) : void 0,
                };
            })(r, e.method, s);
            if (!o?.data)
              return new Response(null, {
                status: 404,
                statusText: "Not Found",
              });
            let a = {};
            n.searchParams.forEach((e, t) => {
              t in a
                ? Array.isArray(a[t])
                  ? a[t].push(e)
                  : (a[t] = [a[t], e])
                : (a[t] = e);
            });
            let l = o.data,
              c = {
                path: s,
                method: e.method,
                headers: e.headers,
                params: o.params ? JSON.parse(JSON.stringify(o.params)) : {},
                request: e,
                body: await w(l.options.cloneRequest ? e.clone() : e),
                query: a,
                _flag: "router",
                asResponse: !0,
                context: t?.routerContext,
              };
            try {
              let e = (function (e, t = "", r, i) {
                "/" === r[r.length - 1] && (r = r.slice(0, -1));
                let n = p(r);
                return (function e(t, r, i, n, s, o = []) {
                  let a = n[s];
                  if (r.wildcard && r.wildcard.methods) {
                    let e = r.wildcard.methods[i] || r.wildcard.methods[""];
                    e && o.push(...e);
                  }
                  if (
                    r.param &&
                    (e(t, r.param, i, n, s + 1, o),
                    s === n.length && r.param.methods)
                  ) {
                    let e = r.param.methods[i] || r.param.methods[""];
                    e && o.push(...e);
                  }
                  let l = r.static?.[a];
                  if (
                    (l && e(t, l, i, n, s + 1, o), s === n.length && r.methods)
                  ) {
                    let e = r.methods[i] || r.methods[""];
                    e && o.push(...e);
                  }
                  return o;
                })(e, e.root, t, n, 0).map((e) => ({
                  data: e.data,
                  params: e.paramsMap ? f(n, e.paramsMap) : void 0,
                }));
              })(i, "*", s);
              if (e?.length)
                for (let { data: t, params: r } of e) {
                  let e = await t({ ...c, params: r, asResponse: !1 });
                  if (e instanceof Response) return e;
                }
              return await l(c);
            } catch (e) {
              if (b(e)) return v(e);
              return (
                console.error("# SERVER_ERROR: ", e),
                new Response(null, {
                  status: 500,
                  statusText: "Internal Server Error",
                })
              );
            }
          };
          return {
            handler: async (e) => {
              let r = await t?.onRequest?.(e);
              if (r instanceof Response) return r;
              let i = r instanceof Request ? r : e,
                s = await n(i),
                o = await t?.onResponse?.(s);
              return o instanceof Response ? o : s;
            },
            endpoints: e,
          };
        };
    },
    30154: (e, t, r) => {
      r.d(t, { B: () => s, o: () => n });
      var i = r(96051);
      let n = ["preserve rows", "delete rows", "drop"],
        s = (0, i.CN)({
          is: (e) => "CreateTableNode" === e.kind,
          create: (e) =>
            (0, i.CN)({
              kind: "CreateTableNode",
              table: e,
              columns: (0, i.CN)([]),
            }),
          cloneWithColumn: (e, t) =>
            (0, i.CN)({ ...e, columns: (0, i.CN)([...e.columns, t]) }),
          cloneWithConstraint: (e, t) =>
            (0, i.CN)({
              ...e,
              constraints: e.constraints
                ? (0, i.CN)([...e.constraints, t])
                : (0, i.CN)([t]),
            }),
          cloneWithFrontModifier: (e, t) =>
            (0, i.CN)({
              ...e,
              frontModifiers: e.frontModifiers
                ? (0, i.CN)([...e.frontModifiers, t])
                : (0, i.CN)([t]),
            }),
          cloneWithEndModifier: (e, t) =>
            (0, i.CN)({
              ...e,
              endModifiers: e.endModifiers
                ? (0, i.CN)([...e.endModifiers, t])
                : (0, i.CN)([t]),
            }),
          cloneWith: (e, t) => (0, i.CN)({ ...e, ...t }),
        });
    },
    30377: (e, t, r) => {
      r.d(t, { g: () => i });
      let i = (0, r(16459).q)("a-z", "0-9", "A-Z", "-_");
    },
    31437: (e, t, r) => {
      r.d(t, { h: () => n });
      var i = r(96051);
      let n = (0, i.CN)({
        is: (e) => "PrimitiveValueListNode" === e.kind,
        create: (e) =>
          (0, i.CN)({
            kind: "PrimitiveValueListNode",
            values: (0, i.CN)([...e]),
          }),
      });
    },
    33669: (e, t, r) => {
      r.d(t, { JB: () => c, M$: () => h, Xm: () => u, uJ: () => d });
      var i = r(96051),
        n = r(83755),
        s = r(82099),
        o = r(75423),
        a = r(67872),
        l = r(6193);
      function c(e) {
        return (0, i.MH)(e) ? e.map((e) => d(e)) : [d(e)];
      }
      function d(e) {
        return (0, i.Kg)(e)
          ? u(e)
          : (0, l.uc)(e)
            ? e.toOperationNode()
            : (0, o.v0)(e);
      }
      function u(e) {
        let t = " as ";
        if (!e.includes(t)) return h(e);
        {
          let [r, i] = e.split(t).map(p);
          return n.N.create(h(r), a.O.create(i));
        }
      }
      function h(e) {
        if (!e.includes(".")) return s.H.create(e);
        {
          let [t, r] = e.split(".").map(p);
          return s.H.createWithSchema(t, r);
        }
      }
      function p(e) {
        return e.trim();
      }
    },
    33746: (e, t, r) => {
      r.d(t, {
        $G: () => p,
        OR: () => u,
        a6: () => d,
        eC: () => f,
        vt: () => h,
      });
      var i = r(10257),
        n = r(7846),
        s = r(49442),
        o = r(51875),
        a = r(62055);
      r(98196), r(61229);
      let l = (e, t) => {
          let r = {
            t: `${e}${t}`,
            value: e,
            tFormat: t,
            toMilliseconds: () => {
              switch (t) {
                case "ms":
                  return e;
                case "s":
                  return 1e3 * e;
                case "m":
                  return 1e3 * e * 60;
                case "h":
                  return 1e3 * e * 3600;
                case "d":
                  return 1e3 * e * 86400;
                case "w":
                  return 1e3 * e * 604800;
                case "y":
                  return 1e3 * e * 31536e3;
              }
            },
            toSeconds: () => r.toMilliseconds() / 1e3,
            toMinutes: () => r.toSeconds() / 60,
            toHours: () => r.toMinutes() / 60,
            toDays: () => r.toHours() / 24,
            toWeeks: () => r.toDays() / 7,
            toYears: () => r.toDays() / 365,
            getDate: () => new Date(Date.now() + r.toMilliseconds()),
            add: (e) => {
              let t =
                "string" == typeof e
                  ? c(e).toMilliseconds()
                  : e.toMilliseconds();
              return l(r.toMilliseconds() + t, "ms");
            },
            subtract: (e) => {
              let t =
                "string" == typeof e
                  ? c(e).toMilliseconds()
                  : e.toMilliseconds();
              return l(r.toMilliseconds() - t, "ms");
            },
            multiply: (e) => l(r.toMilliseconds() * e, "ms"),
            divide: (e) => l(r.toMilliseconds() / e, "ms"),
            equals: (e) => {
              let t =
                "string" == typeof e
                  ? c(e).toMilliseconds()
                  : e.toMilliseconds();
              return r.toMilliseconds() === t;
            },
            lessThan: (e) => {
              let t =
                "string" == typeof e
                  ? c(e).toMilliseconds()
                  : e.toMilliseconds();
              return r.toMilliseconds() < t;
            },
            greaterThan: (e) => {
              let t =
                "string" == typeof e
                  ? c(e).toMilliseconds()
                  : e.toMilliseconds();
              return r.toMilliseconds() > t;
            },
            format: (e) => {
              let t = r.getDate();
              return e.replace(/YYYY|MM|DD|HH|mm|ss/g, (e) => {
                switch (e) {
                  case "YYYY":
                    return t.getFullYear().toString();
                  case "MM":
                    return (t.getMonth() + 1).toString().padStart(2, "0");
                  case "DD":
                    return t.getDate().toString().padStart(2, "0");
                  case "HH":
                    return t.getHours().toString().padStart(2, "0");
                  case "mm":
                    return t.getMinutes().toString().padStart(2, "0");
                  case "ss":
                    return t.getSeconds().toString().padStart(2, "0");
                  default:
                    return e;
                }
              });
            },
            fromNow: () => {
              let e = r.toMilliseconds();
              return e < 0
                ? r.ago()
                : e < 1e3
                  ? "in a few seconds"
                  : e < 6e4
                    ? `in ${Math.round(e / 1e3)} seconds`
                    : e < 36e5
                      ? `in ${Math.round(e / 6e4)} minutes`
                      : e < 864e5
                        ? `in ${Math.round(e / 36e5)} hours`
                        : e < 6048e5
                          ? `in ${Math.round(e / 864e5)} days`
                          : e < 26298e5
                            ? `in ${Math.round(e / 6048e5)} weeks`
                            : e < 315576e5
                              ? `in ${Math.round(e / 26298e5)} months`
                              : `in ${Math.round(e / 315576e5)} years`;
            },
            ago: () => {
              let e = -r.toMilliseconds();
              return e < 0
                ? r.fromNow()
                : e < 1e3
                  ? "a few seconds ago"
                  : e < 6e4
                    ? `${Math.round(e / 1e3)} seconds ago`
                    : e < 36e5
                      ? `${Math.round(e / 6e4)} minutes ago`
                      : e < 864e5
                        ? `${Math.round(e / 36e5)} hours ago`
                        : e < 6048e5
                          ? `${Math.round(e / 864e5)} days ago`
                          : e < 26298e5
                            ? `${Math.round(e / 6048e5)} weeks ago`
                            : e < 315576e5
                              ? `${Math.round(e / 26298e5)} months ago`
                              : `${Math.round(e / 315576e5)} years ago`;
            },
          };
          return r;
        },
        c = (e) => {
          let t = e.match(/^(\d+)(ms|s|m|h|d|w|y)$/);
          if (!t) throw Error("Invalid time format");
          return l(parseInt(t[1]), t[2]);
        };
      function d(e) {
        let t = (
            e.advanced?.useSecureCookies !== void 0
              ? e.advanced?.useSecureCookies
              : void 0 !== e.baseURL
                ? !!e.baseURL.startsWith("https://")
                : s.a
          )
            ? "__Secure-"
            : "",
          r = !!e.advanced?.crossSubDomainCookies?.enabled,
          n = r
            ? e.advanced?.crossSubDomainCookies?.domain ||
              (e.baseURL ? new URL(e.baseURL).hostname : void 0)
            : void 0;
        if (r && !n)
          throw new i.B(
            "baseURL is required when crossSubdomainCookies are enabled"
          );
        return function (i, s = {}) {
          let o = e.advanced?.cookiePrefix || "better-auth",
            a = e.advanced?.cookies?.[i]?.name || `${o}.${i}`,
            l = e.advanced?.cookies?.[i]?.attributes;
          return {
            name: `${t}${a}`,
            attributes: {
              secure: !!t,
              sameSite: "lax",
              path: "/",
              httpOnly: !0,
              ...(r ? { domain: n } : {}),
              ...e.advanced?.defaultCookieAttributes,
              ...s,
              ...l,
            },
          };
        };
      }
      function u(e) {
        let t = d(e),
          r = t("session_token", {
            maxAge: e.session?.expiresIn || l(7, "d").toSeconds(),
          }),
          i = t("session_data", {
            maxAge: e.session?.cookieCache?.maxAge || 300,
          }),
          n = t("dont_remember");
        return {
          sessionToken: { name: r.name, options: r.attributes },
          sessionData: { name: i.name, options: i.attributes },
          dontRememberToken: { name: n.name, options: n.attributes },
        };
      }
      async function h(e, t) {
        if (e.context.options.session?.cookieCache?.enabled) {
          let r = {
              session: Object.entries(t.session).reduce((t, [r, i]) => {
                let n = e.context.options.session?.additionalFields?.[r];
                return (n && !1 === n.returned) || (t[r] = i), t;
              }, {}),
              user: t.user,
            },
            s = o.z.encode(
              JSON.stringify({
                session: r,
                expiresAt: (0, n.g)(
                  e.context.authCookies.sessionData.options.maxAge || 60,
                  "sec"
                ).getTime(),
                signature: await (0, a.s)("SHA-256", "base64urlnopad").sign(
                  e.context.secret,
                  JSON.stringify({
                    ...r,
                    expiresAt: (0, n.g)(
                      e.context.authCookies.sessionData.options.maxAge || 60,
                      "sec"
                    ).getTime(),
                  })
                ),
              }),
              { padding: !1 }
            );
          if (s.length > 4093)
            throw new i.B(
              "Session data is too large to store in the cookie. Please disable session cookie caching or reduce the size of the session data"
            );
          e.setCookie(
            e.context.authCookies.sessionData.name,
            s,
            e.context.authCookies.sessionData.options
          );
        }
      }
      async function p(e, t, r, i) {
        let n = await e.getSignedCookie(
          e.context.authCookies.dontRememberToken.name,
          e.context.secret
        );
        r = void 0 !== r ? r : !!n;
        let s = e.context.authCookies.sessionToken.options,
          o = r ? void 0 : e.context.sessionConfig.expiresIn;
        await e.setSignedCookie(
          e.context.authCookies.sessionToken.name,
          t.session.token,
          e.context.secret,
          { ...s, maxAge: o, ...i }
        ),
          r &&
            (await e.setSignedCookie(
              e.context.authCookies.dontRememberToken.name,
              "true",
              e.context.secret,
              e.context.authCookies.dontRememberToken.options
            )),
          await h(e, t),
          e.context.setNewSession(t),
          e.context.options.secondaryStorage &&
            (await e.context.secondaryStorage?.set(
              t.session.token,
              JSON.stringify({ user: t.user, session: t.session }),
              Math.floor(
                (new Date(t.session.expiresAt).getTime() - Date.now()) / 1e3
              )
            ));
      }
      function f(e, t) {
        e.setCookie(e.context.authCookies.sessionToken.name, "", {
          ...e.context.authCookies.sessionToken.options,
          maxAge: 0,
        }),
          e.setCookie(e.context.authCookies.sessionData.name, "", {
            ...e.context.authCookies.sessionData.options,
            maxAge: 0,
          }),
          t ||
            e.setCookie(e.context.authCookies.dontRememberToken.name, "", {
              ...e.context.authCookies.dontRememberToken.options,
              maxAge: 0,
            });
      }
    },
    35665: (e, t, r) => {
      r.d(t, { P: () => s });
      var i = r(96051),
        n = r(74465);
      let s = (0, i.CN)({
        is: (e) => "CaseNode" === e.kind,
        create: (e) => (0, i.CN)({ kind: "CaseNode", value: e }),
        cloneWithWhen: (e, t) =>
          (0, i.CN)({ ...e, when: (0, i.CN)(e.when ? [...e.when, t] : [t]) }),
        cloneWithThen: (e, t) =>
          (0, i.CN)({
            ...e,
            when: e.when
              ? (0, i.CN)([
                  ...e.when.slice(0, -1),
                  n.t.cloneWithResult(e.when[e.when.length - 1], t),
                ])
              : void 0,
          }),
        cloneWith: (e, t) => (0, i.CN)({ ...e, ...t }),
      });
    },
    36357: (e, t, r) => {
      r.d(t, { Xm: () => a, we: () => s, zX: () => o });
      var i = r(96051);
      let n = ["->", "->>"],
        s = [
          "=",
          "==",
          "!=",
          "<>",
          ">",
          ">=",
          "<",
          "<=",
          "in",
          "not in",
          "is",
          "is not",
          "like",
          "not like",
          "match",
          "ilike",
          "not ilike",
          "@>",
          "<@",
          "^@",
          "&&",
          "?",
          "?&",
          "?|",
          "!<",
          "!>",
          "<=>",
          "!~",
          "~",
          "~*",
          "!~*",
          "@@",
          "@@@",
          "!!",
          "<->",
          "regexp",
          "is distinct from",
          "is not distinct from",
          "+",
          "-",
          "*",
          "/",
          "%",
          "^",
          "&",
          "|",
          "#",
          "<<",
          ">>",
          "&&",
          "||",
          ...n,
          "not",
          "-",
          "exists",
          "not exists",
          "between",
          "between symmetric",
        ],
        o = (0, i.CN)({
          is: (e) => "OperatorNode" === e.kind,
          create: (e) => (0, i.CN)({ kind: "OperatorNode", operator: e }),
        });
      function a(e) {
        return (0, i.Kg)(e) && n.includes(e);
      }
    },
    37991: (e, t, r) => {
      r.d(t, { c: () => a, l: () => l });
      let i = ["info", "success", "warn", "error", "debug"],
        n = {
          reset: "\x1b[0m",
          bright: "\x1b[1m",
          dim: "\x1b[2m",
          fg: {
            red: "\x1b[31m",
            green: "\x1b[32m",
            yellow: "\x1b[33m",
            blue: "\x1b[34m",
            magenta: "\x1b[35m",
          },
        },
        s = {
          info: n.fg.blue,
          success: n.fg.green,
          warn: n.fg.yellow,
          error: n.fg.red,
          debug: n.fg.magenta,
        },
        o = (e, t) => {
          let r = new Date().toISOString();
          return `${n.dim}${r}${n.reset} ${s[e]}${e.toUpperCase()}${n.reset} ${n.bright}[Better Auth]:${n.reset} ${t}`;
        },
        a = (e) => {
          let t = e?.disabled !== !0,
            r = e?.level ?? "error",
            n = (n, s, a = []) => {
              if (!t || !(i.indexOf(n) <= i.indexOf(r))) return;
              let l = o(n, s);
              if (!e || "function" != typeof e.log)
                return void ("error" === n
                  ? console.error(l, ...a)
                  : "warn" === n
                    ? console.warn(l, ...a)
                    : console.log(l, ...a));
              e.log("success" === n ? "info" : n, s, ...a);
            };
          return Object.fromEntries(
            i.map((e) => [e, (...[t, ...r]) => n(e, t, r)])
          );
        },
        l = a();
    },
    38508: (e, t, r) => {
      r.d(t, { F: () => i, x: () => n });
      class i extends Error {
        node;
        constructor(e) {
          super("no result"), (this.node = e);
        }
      }
      function n(e) {
        return Object.prototype.hasOwnProperty.call(e, "prototype");
      }
    },
    38537: (e, t, r) => {
      r.d(t, { l: () => g });
      var i = r(67872),
        n = r(10132),
        s = r(1045),
        o = r(89400),
        a = r(666),
        l = r(33669),
        c = r(11750),
        d = r(6710),
        u = r(83755),
        h = r(96051),
        p = r(87201);
      class f {
        #e;
        constructor(e) {
          this.#e = (0, h.CN)(e);
        }
        get expressionType() {}
        get isRawBuilder() {
          return !0;
        }
        as(e) {
          return new y(this, e);
        }
        $castTo() {
          return new f({ ...this.#e });
        }
        $notNull() {
          return new f(this.#e);
        }
        withPlugin(e) {
          return new f({
            ...this.#e,
            plugins:
              void 0 !== this.#e.plugins
                ? (0, h.CN)([...this.#e.plugins, e])
                : (0, h.CN)([e]),
          });
        }
        toOperationNode() {
          return this.#d(this.#u());
        }
        compile(e) {
          return this.#h(this.#u(e));
        }
        async execute(e) {
          let t = this.#u(e);
          return t.executeQuery(this.#h(t), this.#e.queryId);
        }
        #u(e) {
          let t = void 0 !== e ? e.getExecutor() : p.W;
          return void 0 !== this.#e.plugins
            ? t.withPlugins(this.#e.plugins)
            : t;
        }
        #d(e) {
          return e.transformQuery(this.#e.rawNode, this.#e.queryId);
        }
        #h(e) {
          return e.compileQuery(this.#d(e), this.#e.queryId);
        }
      }
      function m(e) {
        return new f(e);
      }
      class y {
        #p;
        #i;
        constructor(e, t) {
          (this.#p = e), (this.#i = t);
        }
        get expression() {
          return this.#p;
        }
        get alias() {
          return this.#i;
        }
        get rawBuilder() {
          return this.#p;
        }
        toOperationNode() {
          return u.N.create(
            this.#p.toOperationNode(),
            (0, n.N)(this.#i) ? this.#i.toOperationNode() : i.O.create(this.#i)
          );
        }
      }
      let g = Object.assign(
        (e, ...t) =>
          m({ queryId: (0, d.a)(), rawNode: s.z.create(e, t?.map(w) ?? []) }),
        {
          ref: (e) =>
            m({
              queryId: (0, d.a)(),
              rawNode: s.z.createWithChild((0, a.q5)(e)),
            }),
          val: (e) =>
            m({
              queryId: (0, d.a)(),
              rawNode: s.z.createWithChild((0, c.$s)(e)),
            }),
          value(e) {
            return this.val(e);
          },
          table: (e) =>
            m({
              queryId: (0, d.a)(),
              rawNode: s.z.createWithChild((0, l.M$)(e)),
            }),
          id(...e) {
            let t = Array(e.length + 1).fill(".");
            return (
              (t[0] = ""),
              (t[t.length - 1] = ""),
              m({
                queryId: (0, d.a)(),
                rawNode: s.z.create(t, e.map(i.O.create)),
              })
            );
          },
          lit: (e) =>
            m({
              queryId: (0, d.a)(),
              rawNode: s.z.createWithChild(o.q.createImmediate(e)),
            }),
          literal(e) {
            return this.lit(e);
          },
          raw: (e) => m({ queryId: (0, d.a)(), rawNode: s.z.createWithSql(e) }),
          join(e, t = g`, `) {
            let r = Array(Math.max(2 * e.length - 1, 0)),
              i = t.toOperationNode();
            for (let t = 0; t < e.length; ++t)
              (r[2 * t] = w(e[t])), t !== e.length - 1 && (r[2 * t + 1] = i);
            return m({
              queryId: (0, d.a)(),
              rawNode: s.z.createWithChildren(r),
            });
          },
        }
      );
      function w(e) {
        return (0, n.N)(e) ? e.toOperationNode() : (0, c.$s)(e);
      }
    },
    39773: (e, t, r) => {
      function i(e) {
        if (null === e || "object" != typeof e) return !1;
        let t = Object.getPrototypeOf(e);
        return (
          (null === t ||
            t === Object.prototype ||
            null === Object.getPrototypeOf(t)) &&
          !(Symbol.iterator in e) &&
          (!(Symbol.toStringTag in e) ||
            "[object Module]" === Object.prototype.toString.call(e))
        );
      }
      function n(e) {
        return (...t) =>
          t.reduce(
            (t, r) =>
              (function e(t, r, n = ".", s) {
                if (!i(r)) return e(t, {}, n, s);
                let o = Object.assign({}, r);
                for (let r in t) {
                  if ("__proto__" === r || "constructor" === r) continue;
                  let a = t[r];
                  null != a &&
                    ((s && s(o, r, a, n)) ||
                      (Array.isArray(a) && Array.isArray(o[r])
                        ? (o[r] = [...a, ...o[r]])
                        : i(a) && i(o[r])
                          ? (o[r] = e(
                              a,
                              o[r],
                              (n ? `${n}.` : "") + r.toString(),
                              s
                            ))
                          : (o[r] = a)));
                }
                return o;
              })(t, r, "", e),
            {}
          );
      }
      r.d(t, { $Q: () => s, Ay: () => s });
      let s = n();
      n((e, t, r) => {
        if (void 0 !== e[t] && "function" == typeof r)
          return (e[t] = r(e[t])), !0;
      }),
        n((e, t, r) => {
          if (Array.isArray(e[t]) && "function" == typeof r)
            return (e[t] = r(e[t])), !0;
        });
    },
    40469: (e, t, r) => {
      r.d(t, { Z5: () => a, sH: () => h });
      var i = r(90211),
        n = r(72259),
        s = r(64055);
      class o extends s.pe {
        static [i.i] = "PgNumericBuilder";
        constructor(e, t, r) {
          super(e, "string", "PgNumeric"),
            (this.config.precision = t),
            (this.config.scale = r);
        }
        build(e) {
          return new a(e, this.config);
        }
      }
      class a extends s.Kl {
        static [i.i] = "PgNumeric";
        precision;
        scale;
        constructor(e, t) {
          super(e, t), (this.precision = t.precision), (this.scale = t.scale);
        }
        mapFromDriverValue(e) {
          return "string" == typeof e ? e : String(e);
        }
        getSQLType() {
          return void 0 !== this.precision && void 0 !== this.scale
            ? `numeric(${this.precision}, ${this.scale})`
            : void 0 === this.precision
              ? "numeric"
              : `numeric(${this.precision})`;
        }
      }
      class l extends s.pe {
        static [i.i] = "PgNumericNumberBuilder";
        constructor(e, t, r) {
          super(e, "number", "PgNumericNumber"),
            (this.config.precision = t),
            (this.config.scale = r);
        }
        build(e) {
          return new c(e, this.config);
        }
      }
      class c extends s.Kl {
        static [i.i] = "PgNumericNumber";
        precision;
        scale;
        constructor(e, t) {
          super(e, t), (this.precision = t.precision), (this.scale = t.scale);
        }
        mapFromDriverValue(e) {
          return "number" == typeof e ? e : Number(e);
        }
        mapToDriverValue = String;
        getSQLType() {
          return void 0 !== this.precision && void 0 !== this.scale
            ? `numeric(${this.precision}, ${this.scale})`
            : void 0 === this.precision
              ? "numeric"
              : `numeric(${this.precision})`;
        }
      }
      class d extends s.pe {
        static [i.i] = "PgNumericBigIntBuilder";
        constructor(e, t, r) {
          super(e, "bigint", "PgNumericBigInt"),
            (this.config.precision = t),
            (this.config.scale = r);
        }
        build(e) {
          return new u(e, this.config);
        }
      }
      class u extends s.Kl {
        static [i.i] = "PgNumericBigInt";
        precision;
        scale;
        constructor(e, t) {
          super(e, t), (this.precision = t.precision), (this.scale = t.scale);
        }
        mapFromDriverValue = BigInt;
        mapToDriverValue = String;
        getSQLType() {
          return void 0 !== this.precision && void 0 !== this.scale
            ? `numeric(${this.precision}, ${this.scale})`
            : void 0 === this.precision
              ? "numeric"
              : `numeric(${this.precision})`;
        }
      }
      function h(e, t) {
        let { name: r, config: i } = (0, n.Ll)(e, t),
          s = i?.mode;
        return "number" === s
          ? new l(r, i?.precision, i?.scale)
          : "bigint" === s
            ? new d(r, i?.precision, i?.scale)
            : new o(r, i?.precision, i?.scale);
      }
    },
    40856: (e, t, r) => {
      r.d(t, { y: () => l });
      var i = r(11916),
        n = r(51101),
        s = r(22047),
        o = r(10257),
        a = r(50983);
      r(30060), r(12486), r(51875), r(84941), r(30377), r(37991);
      let l = (e, t) =>
        (0, a.c)({
          config: {
            adapterId: "drizzle",
            adapterName: "Drizzle Adapter",
            usePlural: t.usePlural ?? !1,
            debugLogs: t.debugLogs ?? !1,
          },
          adapter: ({ getFieldName: r, debugLog: a }) => {
            function l(r) {
              let i = t.schema || e._.fullSchema;
              if (!i)
                throw new o.B(
                  "Drizzle adapter failed to initialize. Schema not found. Please provide a schema object in the adapter options object."
                );
              let n = i[r];
              if (!n)
                throw new o.B(
                  `[# Drizzle Adapter]: The model "${r}" was not found in the schema object. Please pass the schema directly to the adapter options.`
                );
              return n;
            }
            let c = async (r, a, c, u) => {
              if ("mysql" !== t.provider) return (await a.returning())[0];
              await a.execute();
              let h = l(r),
                p = a.config?.values;
              if (u?.length) {
                let t = d(u, r);
                return (
                  await e
                    .select()
                    .from(h)
                    .where(...t)
                )[0];
              }
              if (p && p[0]?.id?.value) {
                let t = p[0]?.id?.value;
                return (
                  t ||
                    (t = (
                      await e
                        .select({ id: (0, i.ll)`LAST_INSERT_ID()` })
                        .from(h)
                        .orderBy((0, n.i)(h.id))
                        .limit(1)
                    )[0].id),
                  (
                    await e
                      .select()
                      .from(h)
                      .where((0, s.eq)(h.id, t))
                      .limit(1)
                      .execute()
                  )[0]
                );
              }
              if (c.id)
                return (
                  await e
                    .select()
                    .from(h)
                    .where((0, s.eq)(h.id, c.id))
                    .limit(1)
                    .execute()
                )[0];
              if (!("id" in h))
                throw new o.B(
                  `The model "${r}" does not have an "id" field. Please use the "id" field as your primary key.`
                );
              return (
                await e
                  .select()
                  .from(h)
                  .orderBy((0, n.i)(h.id))
                  .limit(1)
                  .execute()
              )[0];
            };
            function d(e, t) {
              let i = l(t);
              if (!e) return [];
              if (1 === e.length) {
                let n = e[0];
                if (!n) return [];
                let a = r({ model: t, field: n.field });
                if (!i[a])
                  throw new o.B(
                    `The field "${n.field}" does not exist in the schema for the model "${t}". Please update your schema.`
                  );
                if ("in" === n.operator) {
                  if (!Array.isArray(n.value))
                    throw new o.B(
                      `The value for the field "${n.field}" must be an array when using the "in" operator.`
                    );
                  return [(0, s.RV)(i[a], n.value)];
                }
                return "contains" === n.operator
                  ? [(0, s.mj)(i[a], `%${n.value}%`)]
                  : "starts_with" === n.operator
                    ? [(0, s.mj)(i[a], `${n.value}%`)]
                    : "ends_with" === n.operator
                      ? [(0, s.mj)(i[a], `%${n.value}`)]
                      : "lt" === n.operator
                        ? [(0, s.lt)(i[a], n.value)]
                        : "lte" === n.operator
                          ? [(0, s.wJ)(i[a], n.value)]
                          : "ne" === n.operator
                            ? [(0, s.ne)(i[a], n.value)]
                            : "gt" === n.operator
                              ? [(0, s.gt)(i[a], n.value)]
                              : "gte" === n.operator
                                ? [(0, s.RO)(i[a], n.value)]
                                : [(0, s.eq)(i[a], n.value)];
              }
              let n = e.filter((e) => "AND" === e.connector || !e.connector),
                a = e.filter((e) => "OR" === e.connector),
                c = (0, s.Uo)(
                  ...n.map((e) => {
                    let n = r({ model: t, field: e.field });
                    if ("in" === e.operator) {
                      if (!Array.isArray(e.value))
                        throw new o.B(
                          `The value for the field "${e.field}" must be an array when using the "in" operator.`
                        );
                      return (0, s.RV)(i[n], e.value);
                    }
                    return (0, s.eq)(i[n], e.value);
                  })
                ),
                d = (0, s.or)(
                  ...a.map((e) => {
                    let n = r({ model: t, field: e.field });
                    return (0, s.eq)(i[n], e.value);
                  })
                ),
                u = [];
              return n.length && u.push(c), a.length && u.push(d), u;
            }
            return {
              async create({ model: t, data: r }) {
                let i = l(t);
                if (!i)
                  throw new o.B(
                    "Drizzle adapter failed to initialize. Schema not found. Please provide a schema object in the adapter options object."
                  );
                for (let e in r)
                  if (!i[e])
                    throw new o.B(
                      `The field "${e}" does not exist in the "${t}" schema. Please update your drizzle schema or re-generate using "npx @better-auth/cli generate".`
                    );
                let n = e.insert(i).values(r);
                return await c(t, n, r);
              },
              async findOne({ model: t, where: r }) {
                let i = l(t),
                  n = d(r, t),
                  s = await e
                    .select()
                    .from(i)
                    .where(...n);
                return s.length ? s[0] : null;
              },
              async findMany({
                model: t,
                where: i,
                sortBy: s,
                limit: o,
                offset: a,
              }) {
                let c = l(t),
                  u = i ? d(i, t) : [],
                  h = s?.direction === "desc" ? n.i : n.Y,
                  p = e
                    .select()
                    .from(c)
                    .limit(o || 100)
                    .offset(a || 0);
                return (
                  s?.field && p.orderBy(h(c[r({ model: t, field: s?.field })])),
                  await p.where(...u)
                );
              },
              async count({ model: t, where: r }) {
                let n = l(t),
                  s = r ? d(r, t) : [];
                return (
                  await e
                    .select({
                      count: (0, i.ll)`count(${i.ll.raw("*")})`.mapWith(Number),
                    })
                    .from(n)
                    .where(...s)
                )[0].count;
              },
              async update({ model: t, where: r, update: i }) {
                let n = l(t),
                  s = d(r, t),
                  o = e
                    .update(n)
                    .set(i)
                    .where(...s);
                return await c(t, o, i, r);
              },
              async updateMany({ model: t, where: r, update: i }) {
                let n = l(t),
                  s = d(r, t),
                  o = e
                    .update(n)
                    .set(i)
                    .where(...s);
                return await o;
              },
              async delete({ model: t, where: r }) {
                let i = l(t),
                  n = d(r, t),
                  s = e.delete(i).where(...n);
                return await s;
              },
              async deleteMany({ model: t, where: r }) {
                let i = l(t),
                  n = d(r, t),
                  s = e.delete(i).where(...n);
                return await s;
              },
              options: t,
            };
          },
        });
    },
    40928: (e, t, r) => {
      r.d(t, { C: () => a, g: () => o });
      var i = r(10132),
        n = r(666),
        s = r(96051);
      class o {
        #f;
        get dynamicReference() {
          return this.#f;
        }
        get refType() {}
        constructor(e) {
          this.#f = e;
        }
        toOperationNode() {
          return (0, n.vd)(this.#f);
        }
      }
      function a(e) {
        return (0, s.Gv)(e) && (0, i.N)(e) && (0, s.Kg)(e.dynamicReference);
      }
    },
    41286: (e, t, r) => {
      let i, n;
      r.d(t, { k: () => o });
      var s = r(4304);
      let o = {
        startActiveSpan: (e, t) =>
          i
            ? (n || (n = i.trace.getTracer("drizzle-orm", "0.44.2")),
              (0, s.i)(
                (r, i) =>
                  i.startActiveSpan(e, (e) => {
                    try {
                      return t(e);
                    } catch (t) {
                      throw (
                        (e.setStatus({
                          code: r.SpanStatusCode.ERROR,
                          message:
                            t instanceof Error ? t.message : "Unknown error",
                        }),
                        t)
                      );
                    } finally {
                      e.end();
                    }
                  }),
                i,
                n
              ))
            : t(),
      };
    },
    41321: (e, t, r) => {
      r.d(t, {
        $4: () => h,
        BT: () => u,
        Dm: () => d,
        Dp: () => c,
        Rb: () => o,
        T0: () => a,
        Ye: () => l,
        h2: () => f,
        i4: () => i,
        ie: () => n,
        n: () => s,
        xb: () => p,
      });
      class i extends Error {
        static code = "ERR_JOSE_GENERIC";
        code = "ERR_JOSE_GENERIC";
        constructor(e, t) {
          super(e, t),
            (this.name = this.constructor.name),
            Error.captureStackTrace?.(this, this.constructor);
        }
      }
      class n extends i {
        static code = "ERR_JWT_CLAIM_VALIDATION_FAILED";
        code = "ERR_JWT_CLAIM_VALIDATION_FAILED";
        claim;
        reason;
        payload;
        constructor(e, t, r = "unspecified", i = "unspecified") {
          super(e, { cause: { claim: r, reason: i, payload: t } }),
            (this.claim = r),
            (this.reason = i),
            (this.payload = t);
        }
      }
      class s extends i {
        static code = "ERR_JWT_EXPIRED";
        code = "ERR_JWT_EXPIRED";
        claim;
        reason;
        payload;
        constructor(e, t, r = "unspecified", i = "unspecified") {
          super(e, { cause: { claim: r, reason: i, payload: t } }),
            (this.claim = r),
            (this.reason = i),
            (this.payload = t);
        }
      }
      class o extends i {
        static code = "ERR_JOSE_ALG_NOT_ALLOWED";
        code = "ERR_JOSE_ALG_NOT_ALLOWED";
      }
      class a extends i {
        static code = "ERR_JOSE_NOT_SUPPORTED";
        code = "ERR_JOSE_NOT_SUPPORTED";
      }
      class l extends i {
        static code = "ERR_JWS_INVALID";
        code = "ERR_JWS_INVALID";
      }
      class c extends i {
        static code = "ERR_JWT_INVALID";
        code = "ERR_JWT_INVALID";
      }
      class d extends i {
        static code = "ERR_JWKS_INVALID";
        code = "ERR_JWKS_INVALID";
      }
      class u extends i {
        static code = "ERR_JWKS_NO_MATCHING_KEY";
        code = "ERR_JWKS_NO_MATCHING_KEY";
        constructor(e = "no applicable key found in the JSON Web Key Set", t) {
          super(e, t);
        }
      }
      class h extends i {
        [Symbol.asyncIterator];
        static code = "ERR_JWKS_MULTIPLE_MATCHING_KEYS";
        code = "ERR_JWKS_MULTIPLE_MATCHING_KEYS";
        constructor(
          e = "multiple matching keys found in the JSON Web Key Set",
          t
        ) {
          super(e, t);
        }
      }
      class p extends i {
        static code = "ERR_JWKS_TIMEOUT";
        code = "ERR_JWKS_TIMEOUT";
        constructor(e = "request timed out", t) {
          super(e, t);
        }
      }
      class f extends i {
        static code = "ERR_JWS_SIGNATURE_VERIFICATION_FAILED";
        code = "ERR_JWS_SIGNATURE_VERIFICATION_FAILED";
        constructor(e = "signature verification failed", t) {
          super(e, t);
        }
      }
    },
    42188: (e, t, r) => {
      r.d(t, { s: () => n });
      var i = r(96051);
      let n = (0, i.CN)({
        is: (e) => "AndNode" === e.kind,
        create: (e, t) => (0, i.CN)({ kind: "AndNode", left: e, right: t }),
      });
    },
    42918: (e, t, r) => {
      r.d(t, { FW: () => a });
      var i = r(19771),
        n = r(29021),
        s = r(55511);
      let o = { ...globalThis.$SST_LINKS };
      for (let [e, t] of Object.entries({
        ...i.env,
        ...globalThis.process?.env,
      }))
        e.startsWith("SST_RESOURCE_") && t && (o[e.slice(13)] = JSON.parse(t));
      if (
        i.env.SST_KEY_FILE &&
        i.env.SST_KEY &&
        !globalThis.SST_KEY_FILE_DATA
      ) {
        let e = Buffer.from(i.env.SST_KEY, "base64"),
          t = (0, n.readFileSync)(i.env.SST_KEY_FILE),
          r = Buffer.alloc(12, 0),
          a = s.createDecipheriv("aes-256-gcm", e, r),
          l = t.subarray(-16),
          c = t.subarray(0, -16);
        a.setAuthTag(l);
        let d = a.update(c);
        Object.assign(
          o,
          JSON.parse((d = Buffer.concat([d, a.final()])).toString())
        );
      }
      globalThis.SST_KEY_FILE_DATA &&
        Object.assign(o, globalThis.SST_KEY_FILE_DATA);
      let a = new Proxy(o, {
        get(e, t) {
          if (t in o) return o[t];
          if (!i.env.SST_RESOURCE_App)
            throw Error(
              "It does not look like SST links are active. If this is in local development and you are not starting this process through the multiplexer, wrap your command with `sst dev -- <command>`"
            );
          let r = `"${t}" is not linked in your sst.config.ts`;
          throw (
            (i.env.AWS_LAMBDA_FUNCTION_NAME &&
              (r += ` to ${i.env.AWS_LAMBDA_FUNCTION_NAME}`),
            Error(r))
          );
        },
      });
    },
    43005: (e, t, r) => {
      r.d(t, {
        J: () => p,
        G: () =>
          function e(t) {
            return (0, i.Tn)(t)
              ? e(t((0, u.A)()))
              : (0, i.MH)(t)
                ? t.map((e) => h(e))
                : [h(t)];
          },
      });
      var i = r(96051),
        n = r(81712),
        s = r(27759);
      let o = (0, i.CN)({
        is: (e) => "SelectionNode" === e.kind,
        create: (e) => (0, i.CN)({ kind: "SelectionNode", selection: e }),
        createSelectAll: () =>
          (0, i.CN)({ kind: "SelectionNode", selection: s.U.create() }),
        createSelectAllFromTable: (e) =>
          (0, i.CN)({
            kind: "SelectionNode",
            selection: n.q.createSelectAll(e),
          }),
      });
      var a = r(666),
        l = r(40928),
        c = r(75423),
        d = r(33669),
        u = r(95235);
      function h(e) {
        return (0, i.Kg)(e)
          ? o.create((0, a.DT)(e))
          : (0, l.C)(e)
            ? o.create(e.toOperationNode())
            : o.create((0, c.v0)(e));
      }
      function p(e) {
        return e
          ? Array.isArray(e)
            ? e.map(f)
            : [f(e)]
          : [o.createSelectAll()];
      }
      function f(e) {
        if ((0, i.Kg)(e)) return o.createSelectAllFromTable((0, d.M$)(e));
        throw Error(`invalid value selectAll expression: ${JSON.stringify(e)}`);
      }
    },
    43395: (e, t, r) => {
      r.d(t, { e: () => a });
      var i = r(96051),
        n = r(44401);
      let s = (0, i.CN)({
        is: (e) => "UsingNode" === e.kind,
        create: (e) => (0, i.CN)({ kind: "UsingNode", tables: (0, i.CN)(e) }),
        cloneWithTables: (e, t) =>
          (0, i.CN)({ ...e, tables: (0, i.CN)([...e.tables, ...t]) }),
      });
      var o = r(64992);
      let a = (0, i.CN)({
        is: (e) => "DeleteQueryNode" === e.kind,
        create: (e, t) =>
          (0, i.CN)({
            kind: "DeleteQueryNode",
            from: n.N.create(e),
            ...(t && { with: t }),
          }),
        cloneWithOrderByItems: (e, t) => o.L.cloneWithOrderByItems(e, t),
        cloneWithoutOrderBy: (e) => o.L.cloneWithoutOrderBy(e),
        cloneWithLimit: (e, t) => (0, i.CN)({ ...e, limit: t }),
        cloneWithoutLimit: (e) => (0, i.CN)({ ...e, limit: void 0 }),
        cloneWithUsing: (e, t) =>
          (0, i.CN)({
            ...e,
            using:
              void 0 !== e.using ? s.cloneWithTables(e.using, t) : s.create(t),
          }),
      });
    },
    44401: (e, t, r) => {
      r.d(t, { N: () => n });
      var i = r(96051);
      let n = (0, i.CN)({
        is: (e) => "FromNode" === e.kind,
        create: (e) => (0, i.CN)({ kind: "FromNode", froms: (0, i.CN)(e) }),
        cloneWithFroms: (e, t) =>
          (0, i.CN)({ ...e, froms: (0, i.CN)([...e.froms, ...t]) }),
      });
    },
    44851: (e, t, r) => {
      r.d(t, { O: () => n });
      var i = r(96051);
      let n = (0, i.CN)({
        is: (e) => "OrderByNode" === e.kind,
        create: (e) =>
          (0, i.CN)({ kind: "OrderByNode", items: (0, i.CN)([...e]) }),
        cloneWithItems: (e, t) =>
          (0, i.CN)({ ...e, items: (0, i.CN)([...e.items, ...t]) }),
      });
    },
    45391: (e, t, r) => {
      r.d(t, { g: () => o, p: () => a });
      var i = r(16151),
        n = r(30060);
      r(12486), r(51875), r(84941);
      var s = r(30377);
      async function o(e, t) {
        let r = e.body?.callbackURL || e.context.options.baseURL;
        if (!r)
          throw new n.LG("BAD_REQUEST", { message: "callbackURL is required" });
        let i = (0, s.g)(128),
          o = (0, s.g)(32),
          a = JSON.stringify({
            callbackURL: r,
            codeVerifier: i,
            errorURL: e.body?.errorCallbackURL,
            newUserURL: e.body?.newUserCallbackURL,
            link: t,
            expiresAt: Date.now() + 6e5,
            requestSignUp: e.body?.requestSignUp,
          }),
          l = new Date();
        l.setMinutes(l.getMinutes() + 10);
        let c = await e.context.internalAdapter.createVerificationValue(
          { value: a, identifier: o, expiresAt: l },
          e
        );
        if (!c)
          throw (
            (e.context.logger.error(
              "Unable to create verification. Make sure the database adapter is properly working and there is a verification table in the database"
            ),
            new n.LG("INTERNAL_SERVER_ERROR", {
              message: "Unable to create verification",
            }))
          );
        return { state: c.identifier, codeVerifier: i };
      }
      async function a(e) {
        let t = e.query.state || e.body.state,
          r = await e.context.internalAdapter.findVerificationValue(t);
        if (!r) {
          e.context.logger.error("State Mismatch. Verification not found", {
            state: t,
          });
          let r =
            e.context.options.onAPIError?.errorURL ||
            `${e.context.baseURL}/error`;
          throw e.redirect(`${r}?error=please_restart_the_process`);
        }
        let n = i.z
          .object({
            callbackURL: i.z.string(),
            codeVerifier: i.z.string(),
            errorURL: i.z.string().optional(),
            newUserURL: i.z.string().optional(),
            expiresAt: i.z.number(),
            link: i.z
              .object({ email: i.z.string(), userId: i.z.coerce.string() })
              .optional(),
            requestSignUp: i.z.boolean().optional(),
          })
          .parse(JSON.parse(r.value));
        if (
          (n.errorURL || (n.errorURL = `${e.context.baseURL}/error`),
          n.expiresAt < Date.now())
        ) {
          await e.context.internalAdapter.deleteVerificationValue(r.id);
          let t =
            e.context.options.onAPIError?.errorURL ||
            `${e.context.baseURL}/error`;
          throw e.redirect(`${t}?error=please_restart_the_process`);
        }
        return await e.context.internalAdapter.deleteVerificationValue(r.id), n;
      }
    },
    46742: (e, t, r) => {
      r.d(t, { V: () => E });
      var i = r(19984),
        n = r(77598),
        s = r(57975),
        o = r(12455),
        a = r(80602),
        l = r(76221),
        c = r(3520);
      let d = (0, s.promisify)(n.verify),
        u = async (e, t, r, i) => {
          let s = (0, c.A)(e, t, "verify");
          if (e.startsWith("HS")) {
            let t = await (0, l.A)(e, s, i);
            try {
              return n.timingSafeEqual(r, t);
            } catch {
              return !1;
            }
          }
          let u = (0, o.A)(e),
            h = (0, a.A)(e, s);
          try {
            return await d(u, i, h, r);
          } catch {
            return !1;
          }
        };
      var h = r(41321),
        p = r(3415),
        f = r(74338),
        m = r(81385),
        y = r(79338),
        g = r(30052);
      let w = (e, t) => {
        if (
          void 0 !== t &&
          (!Array.isArray(t) || t.some((e) => "string" != typeof e))
        )
          throw TypeError(`"${e}" option must be an array of strings`);
        if (t) return new Set(t);
      };
      var b = r(75456),
        v = r(56394);
      async function N(e, t, r) {
        let n, s;
        if (!(0, m.A)(e)) throw new h.Ye("Flattened JWS must be an object");
        if (void 0 === e.protected && void 0 === e.header)
          throw new h.Ye(
            'Flattened JWS must have either of the "protected" or "header" members'
          );
        if (void 0 !== e.protected && "string" != typeof e.protected)
          throw new h.Ye("JWS Protected Header incorrect type");
        if (void 0 === e.payload) throw new h.Ye("JWS Payload missing");
        if ("string" != typeof e.signature)
          throw new h.Ye("JWS Signature missing or incorrect type");
        if (void 0 !== e.header && !(0, m.A)(e.header))
          throw new h.Ye("JWS Unprotected Header incorrect type");
        let o = {};
        if (e.protected)
          try {
            let t = (0, i.D4)(e.protected);
            o = JSON.parse(p.D0.decode(t));
          } catch {
            throw new h.Ye("JWS Protected Header is invalid");
          }
        if (!(0, f.A)(o, e.header))
          throw new h.Ye(
            "JWS Protected and JWS Unprotected Header Parameter names must be disjoint"
          );
        let a = { ...o, ...e.header },
          l = (0, g.A)(h.Ye, new Map([["b64", !0]]), r?.crit, o, a),
          c = !0;
        if (l.has("b64") && "boolean" != typeof (c = o.b64))
          throw new h.Ye(
            'The "b64" (base64url-encode payload) Header Parameter must be a boolean'
          );
        let { alg: d } = a;
        if ("string" != typeof d || !d)
          throw new h.Ye(
            'JWS "alg" (Algorithm) Header Parameter missing or invalid'
          );
        let N = r && w("algorithms", r.algorithms);
        if (N && !N.has(d))
          throw new h.Rb(
            '"alg" (Algorithm) Header Parameter value not allowed'
          );
        if (c) {
          if ("string" != typeof e.payload)
            throw new h.Ye("JWS Payload must be a string");
        } else if (
          "string" != typeof e.payload &&
          !(e.payload instanceof Uint8Array)
        )
          throw new h.Ye(
            "JWS Payload must be a string or an Uint8Array instance"
          );
        let x = !1;
        "function" == typeof t
          ? ((t = await t(o, e)),
            (x = !0),
            (0, y.I)(d, t, "verify"),
            (0, b.ll)(t) && (t = await (0, v.Og)(t, d)))
          : (0, y.I)(d, t, "verify");
        let _ = (0, p.xW)(
          p.Rd.encode(e.protected ?? ""),
          p.Rd.encode("."),
          "string" == typeof e.payload ? p.Rd.encode(e.payload) : e.payload
        );
        try {
          n = (0, i.D4)(e.signature);
        } catch {
          throw new h.Ye("Failed to base64url decode the signature");
        }
        if (!(await u(d, t, n, _))) throw new h.h2();
        if (c)
          try {
            s = (0, i.D4)(e.payload);
          } catch {
            throw new h.Ye("Failed to base64url decode the payload");
          }
        else
          s = "string" == typeof e.payload ? p.Rd.encode(e.payload) : e.payload;
        let S = { payload: s };
        return (void 0 !== e.protected && (S.protectedHeader = o),
        void 0 !== e.header && (S.unprotectedHeader = e.header),
        x)
          ? { ...S, key: t }
          : S;
      }
      async function x(e, t, r) {
        if (
          (e instanceof Uint8Array && (e = p.D0.decode(e)),
          "string" != typeof e)
        )
          throw new h.Ye("Compact JWS must be a string or Uint8Array");
        let { 0: i, 1: n, 2: s, length: o } = e.split(".");
        if (3 !== o) throw new h.Ye("Invalid Compact JWS");
        let a = await N({ payload: n, protected: i, signature: s }, t, r),
          l = { payload: a.payload, protectedHeader: a.protectedHeader };
        return "function" == typeof t ? { ...l, key: a.key } : l;
      }
      var _ = r(88990),
        S = r(77345);
      let T = (e) => e.toLowerCase().replace(/^application\//, ""),
        k = (e, t) =>
          "string" == typeof e
            ? t.includes(e)
            : !!Array.isArray(e) && t.some(Set.prototype.has.bind(new Set(e))),
        A = (e, t, r = {}) => {
          let i, n;
          try {
            i = JSON.parse(p.D0.decode(t));
          } catch {}
          if (!(0, m.A)(i))
            throw new h.Dp("JWT Claims Set must be a top-level JSON object");
          let { typ: s } = r;
          if (s && ("string" != typeof e.typ || T(e.typ) !== T(s)))
            throw new h.ie(
              'unexpected "typ" JWT header value',
              i,
              "typ",
              "check_failed"
            );
          let {
              requiredClaims: o = [],
              issuer: a,
              subject: l,
              audience: c,
              maxTokenAge: d,
            } = r,
            u = [...o];
          for (let e of (void 0 !== d && u.push("iat"),
          void 0 !== c && u.push("aud"),
          void 0 !== l && u.push("sub"),
          void 0 !== a && u.push("iss"),
          new Set(u.reverse())))
            if (!(e in i))
              throw new h.ie(`missing required "${e}" claim`, i, e, "missing");
          if (a && !(Array.isArray(a) ? a : [a]).includes(i.iss))
            throw new h.ie(
              'unexpected "iss" claim value',
              i,
              "iss",
              "check_failed"
            );
          if (l && i.sub !== l)
            throw new h.ie(
              'unexpected "sub" claim value',
              i,
              "sub",
              "check_failed"
            );
          if (c && !k(i.aud, "string" == typeof c ? [c] : c))
            throw new h.ie(
              'unexpected "aud" claim value',
              i,
              "aud",
              "check_failed"
            );
          switch (typeof r.clockTolerance) {
            case "string":
              n = (0, S.A)(r.clockTolerance);
              break;
            case "number":
              n = r.clockTolerance;
              break;
            case "undefined":
              n = 0;
              break;
            default:
              throw TypeError("Invalid clockTolerance option type");
          }
          let { currentDate: f } = r,
            y = (0, _.A)(f || new Date());
          if ((void 0 !== i.iat || d) && "number" != typeof i.iat)
            throw new h.ie('"iat" claim must be a number', i, "iat", "invalid");
          if (void 0 !== i.nbf) {
            if ("number" != typeof i.nbf)
              throw new h.ie(
                '"nbf" claim must be a number',
                i,
                "nbf",
                "invalid"
              );
            if (i.nbf > y + n)
              throw new h.ie(
                '"nbf" claim timestamp check failed',
                i,
                "nbf",
                "check_failed"
              );
          }
          if (void 0 !== i.exp) {
            if ("number" != typeof i.exp)
              throw new h.ie(
                '"exp" claim must be a number',
                i,
                "exp",
                "invalid"
              );
            if (i.exp <= y - n)
              throw new h.n(
                '"exp" claim timestamp check failed',
                i,
                "exp",
                "check_failed"
              );
          }
          if (d) {
            let e = y - i.iat;
            if (e - n > ("number" == typeof d ? d : (0, S.A)(d)))
              throw new h.n(
                '"iat" claim timestamp check failed (too far in the past)',
                i,
                "iat",
                "check_failed"
              );
            if (e < 0 - n)
              throw new h.ie(
                '"iat" claim timestamp check failed (it should be in the past)',
                i,
                "iat",
                "check_failed"
              );
          }
          return i;
        };
      async function E(e, t, r) {
        let i = await x(e, t, r);
        if (
          i.protectedHeader.crit?.includes("b64") &&
          !1 === i.protectedHeader.b64
        )
          throw new h.Dp("JWTs MUST NOT use unencoded payload");
        let n = {
          payload: A(i.protectedHeader, i.payload, r),
          protectedHeader: i.protectedHeader,
        };
        return "function" == typeof t ? { ...n, key: i.key } : n;
      }
    },
    47590: (e, t, r) => {
      r.d(t, {
        HE: () => d,
        Io: () => f,
        Lf: () => m,
        Sj: () => s,
        XI: () => p,
        e: () => o,
      });
      var i = r(90211),
        n = r(1793);
      let s = Symbol.for("drizzle:Schema"),
        o = Symbol.for("drizzle:Columns"),
        a = Symbol.for("drizzle:ExtraConfigColumns"),
        l = Symbol.for("drizzle:OriginalName"),
        c = Symbol.for("drizzle:BaseName"),
        d = Symbol.for("drizzle:IsAlias"),
        u = Symbol.for("drizzle:ExtraConfigBuilder"),
        h = Symbol.for("drizzle:IsDrizzleTable");
      class p {
        static [i.i] = "Table";
        static Symbol = {
          Name: n.E,
          Schema: s,
          OriginalName: l,
          Columns: o,
          ExtraConfigColumns: a,
          BaseName: c,
          IsAlias: d,
          ExtraConfigBuilder: u,
        };
        [n.E];
        [l];
        [s];
        [o];
        [a];
        [c];
        [d] = !1;
        [h] = !0;
        [u] = void 0;
        constructor(e, t, r) {
          (this[n.E] = this[l] = e), (this[s] = t), (this[c] = r);
        }
      }
      function f(e) {
        return e[n.E];
      }
      function m(e) {
        return `${e[s] ?? "public"}.${e[n.E]}`;
      }
    },
    48675: (e, t, r) => {
      r.d(t, { b: () => a });
      var i = r(96051),
        n = r(42188),
        s = r(1518);
      let o = (0, i.CN)({
          is: (e) => "OnNode" === e.kind,
          create: (e) => (0, i.CN)({ kind: "OnNode", on: e }),
          cloneWithOperation: (e, t, r) =>
            (0, i.CN)({
              ...e,
              on: "And" === t ? n.s.create(e.on, r) : s.K.create(e.on, r),
            }),
        }),
        a = (0, i.CN)({
          is: (e) => "JoinNode" === e.kind,
          create: (e, t) =>
            (0, i.CN)({ kind: "JoinNode", joinType: e, table: t, on: void 0 }),
          createWithOn: (e, t, r) =>
            (0, i.CN)({
              kind: "JoinNode",
              joinType: e,
              table: t,
              on: o.create(r),
            }),
          cloneWithOn: (e, t) =>
            (0, i.CN)({
              ...e,
              on: e.on ? o.cloneWithOperation(e.on, "And", t) : o.create(t),
            }),
        });
    },
    49442: (e, t, r) => {
      r.d(t, { a: () => a, b: () => l, e: () => s, i: () => c });
      let i = Object.create(null),
        n = (e) =>
          globalThis.process?.env ||
          globalThis.Deno?.env.toObject() ||
          globalThis.__env__ ||
          (e ? i : globalThis),
        s = new Proxy(i, {
          get: (e, t) => n()[t] ?? i[t],
          has: (e, t) => t in n() || t in i,
          set: (e, t, r) => ((n(!0)[t] = r), !0),
          deleteProperty(e, t) {
            if (!t) return !1;
            let r = n(!0);
            return delete r[t], !0;
          },
          ownKeys: () => Object.keys(n(!0)),
        }),
        o =
          ("undefined" != typeof process && process.env && "production") || "",
        a = "production" === o,
        l = "dev" === o || "development" === o,
        c =
          "test" === o ||
          (function (e) {
            return !!e && "false" !== e;
          })(s.TEST);
    },
    49925: (e, t, r) => {
      r.d(t, { Y: () => s });
      var i = r(96051),
        n = r(17445);
      let s = (0, i.CN)({
        is: (e) => "CreateViewNode" === e.kind,
        create: (e) =>
          (0, i.CN)({ kind: "CreateViewNode", name: n.y.create(e) }),
        cloneWith: (e, t) => (0, i.CN)({ ...e, ...t }),
      });
    },
    50403: (e, t, r) => {
      r.d(t, { kQ: () => n, sy: () => s });
      var i = r(96051);
      let n = "kysely_migration",
        s = "kysely_migration_lock";
      (0, i.CN)({ __noMigrations__: !0 });
    },
    50698: (e, t, r) => {
      r.d(t, { a: () => n });
      var i = r(96051);
      let n = (0, i.CN)({
        is: (e) => "LimitNode" === e.kind,
        create: (e) => (0, i.CN)({ kind: "LimitNode", limit: e }),
      });
    },
    50983: (e, t, r) => {
      r.d(t, { c: () => d });
      var i = r(93818),
        n = r(16533),
        s = r(94349);
      r(30060), r(12486), r(51875), r(84941), r(30377);
      var o = r(37991);
      let a = [],
        l = -1,
        c = {
          reset: "\x1b[0m",
          bright: "\x1b[1m",
          dim: "\x1b[2m",
          fg: { yellow: "\x1b[33m", magenta: "\x1b[35m" },
          bg: { black: "\x1b[40m" },
        },
        d =
          ({ adapter: e, config: t }) =>
          (r) => {
            let c = {
              ...t,
              supportsBooleans: t.supportsBooleans ?? !0,
              supportsDates: t.supportsDates ?? !0,
              supportsJSON: t.supportsJSON ?? !1,
              adapterName: t.adapterName ?? t.adapterId,
              supportsNumericIds: t.supportsNumericIds ?? !0,
            };
            if (
              r.advanced?.database?.useNumberId === !0 &&
              !1 === c.supportsNumericIds
            )
              throw Error(
                `[${c.adapterName}] Your database or database adapter does not support numeric ids. Please disable "useNumberId" in your config.`
              );
            let d = (0, n.g)(r),
              m = ({ field: e, model: t }) => {
                if ("id" === e) return e;
                let r = y(t),
                  i = d[r]?.fields[e];
                if (
                  (i ||
                    (i = Object.values(d[r]?.fields).find(
                      (t) => t.fieldName === e
                    )),
                  !i)
                )
                  throw (
                    (b(`Field ${e} not found in model ${r}`),
                    b("Schema:", d),
                    Error(`Field ${e} not found in model ${r}`))
                  );
                return e;
              },
              y = (e) => {
                if (c.usePlural && "s" === e.charAt(e.length - 1)) {
                  let t = e.slice(0, -1),
                    r = d[t] ? t : void 0;
                  if (
                    (r ||
                      (r = Object.entries(d).find(
                        ([e, r]) => r.modelName === t
                      )?.[0]),
                    r)
                  )
                    return r;
                }
                let t = d[e] ? e : void 0;
                if (
                  (t ||
                    (t = Object.entries(d).find(
                      ([t, r]) => r.modelName === e
                    )?.[0]),
                  !t)
                )
                  throw (
                    (b(`Model "${e}" not found in schema`),
                    b("Schema:", d),
                    Error(`Model "${e}" not found in schema`))
                  );
                return t;
              },
              g = (e) =>
                d[y(e)].modelName !== e
                  ? d[y(e)].modelName
                  : c.usePlural
                    ? `${e}s`
                    : e;
            function w({ model: e, field: t }) {
              let r = y(e),
                i = m({ model: r, field: t });
              return d[r]?.fields[i]?.fieldName || i;
            }
            let b = (...e) => {
                if (!0 === c.debugLogs || "object" == typeof c.debugLogs) {
                  if (
                    "object" == typeof c.debugLogs &&
                    "isRunningAdapterTests" in c.debugLogs
                  ) {
                    c.debugLogs.isRunningAdapterTests && (e.shift(), a.push(e));
                    return;
                  }
                  if (
                    "object" != typeof c.debugLogs ||
                    !c.debugLogs.logCondition ||
                    c.debugLogs.logCondition?.()
                  )
                    if ("object" == typeof e[0] && "method" in e[0]) {
                      let t = e.shift().method;
                      if ("object" == typeof c.debugLogs) {
                        if ("create" === t && !c.debugLogs.create) return;
                        else if ("update" === t && !c.debugLogs.update) return;
                        else if ("updateMany" === t && !c.debugLogs.updateMany)
                          return;
                        else if ("findOne" === t && !c.debugLogs.findOne)
                          return;
                        else if ("findMany" === t && !c.debugLogs.findMany)
                          return;
                        else if ("delete" === t && !c.debugLogs.delete) return;
                        else if ("deleteMany" === t && !c.debugLogs.deleteMany)
                          return;
                        else if ("count" === t && !c.debugLogs.count) return;
                      }
                      o.l.info(`[${c.adapterName}]`, ...e);
                    } else o.l.info(`[${c.adapterName}]`, ...e);
                }
              },
              v = ({ customModelName: e, forceAllowId: t }) => {
                let i =
                    !c.disableIdGeneration &&
                    !r.advanced?.database?.useNumberId &&
                    !t,
                  n = y(e ?? "id");
                return {
                  type: r.advanced?.database?.useNumberId ? "number" : "string",
                  required: !!i,
                  ...(i
                    ? {
                        defaultValue() {
                          if (c.disableIdGeneration) return;
                          let e = r.advanced?.database?.useNumberId,
                            t = r.advanced?.database?.generateId;
                          if (
                            (r.advanced?.generateId !== void 0 &&
                              (o.l.warn(
                                "Your Better Auth config includes advanced.generateId which is deprecated. Please use advanced.database.generateId instead. This will be removed in future releases."
                              ),
                              (t = r.advanced?.generateId)),
                            !1 !== t && !e)
                          )
                            return t
                              ? t({ model: n })
                              : c.customIdGenerator
                                ? c.customIdGenerator({ model: n })
                                : (0, s.g)();
                        },
                      }
                    : {}),
                };
              },
              N = ({ model: e, field: t }) => {
                let r = y(e),
                  i = m({ field: t, model: e }),
                  n = d[r].fields;
                return (n.id = v({ customModelName: r })), n[i];
              },
              x = e({
                options: r,
                schema: d,
                debugLog: b,
                getFieldName: w,
                getModelName: g,
                getDefaultModelName: y,
                getDefaultFieldName: m,
                getFieldAttributes: N,
              }),
              _ = async (e, t, i, n) => {
                let s = {},
                  o = d[t].fields,
                  a = c.mapKeysTransformInput ?? {};
                for (let l in (c.disableIdGeneration ||
                  r.advanced?.database?.useNumberId ||
                  (o.id = v({
                    customModelName: t,
                    forceAllowId: n && "id" in e,
                  })),
                o)) {
                  let n = e[l],
                    u = o[l],
                    h = a[l] || o[l].fieldName || l;
                  if (
                    void 0 === n &&
                    ((!u.defaultValue && !u.transform?.input) || "update" === i)
                  )
                    continue;
                  let p = (function (e, t, r) {
                    return "update" === r
                      ? e
                      : null == e && void 0 !== t.defaultValue
                        ? "function" == typeof t.defaultValue
                          ? t.defaultValue()
                          : t.defaultValue
                        : e;
                  })(n, u, i);
                  u.transform?.input && (p = await u.transform.input(p)),
                    u.references?.field === "id" &&
                    r.advanced?.database?.useNumberId
                      ? (p = Array.isArray(p) ? p.map(Number) : Number(p))
                      : !1 === c.supportsJSON &&
                          "object" == typeof p &&
                          "json" === u.type
                        ? (p = JSON.stringify(p))
                        : !1 === c.supportsDates &&
                            p instanceof Date &&
                            "date" === u.type
                          ? (p = p.toISOString())
                          : !1 === c.supportsBooleans &&
                            "boolean" == typeof p &&
                            (p = +!!p),
                    c.customTransformInput &&
                      (p = c.customTransformInput({
                        data: p,
                        action: i,
                        field: h,
                        fieldAttributes: u,
                        model: t,
                        schema: d,
                        options: r,
                      })),
                    (s[h] = p);
                }
                return s;
              },
              S = async (e, t, n = []) => {
                if (!e) return null;
                let s = c.mapKeysTransformOutput ?? {},
                  o = {},
                  a = d[t].fields;
                for (let l in ((a[
                  Object.entries(s).find(([e, t]) => "id" === t)?.[0] ?? "id"
                ] = {
                  type: r.advanced?.database?.useNumberId ? "number" : "string",
                }),
                a)) {
                  if (n.length && !n.includes(l)) continue;
                  let u = a[l];
                  if (u) {
                    let a = u.fieldName || l,
                      h =
                        e[
                          Object.entries(s).find(([e, t]) => t === a)?.[0] || a
                        ];
                    u.transform?.output && (h = await u.transform.output(h));
                    let p = s[l] || l;
                    "id" === a || u.references?.field === "id"
                      ? void 0 !== h && (h = String(h))
                      : !1 === c.supportsJSON &&
                          "string" == typeof h &&
                          "json" === u.type
                        ? (h = (0, i.s)(h))
                        : !1 === c.supportsDates &&
                            "string" == typeof h &&
                            "date" === u.type
                          ? (h = new Date(h))
                          : !1 === c.supportsBooleans &&
                            "number" == typeof h &&
                            "boolean" === u.type &&
                            (h = 1 === h),
                      c.customTransformOutput &&
                        (h = c.customTransformOutput({
                          data: h,
                          field: p,
                          fieldAttributes: u,
                          select: n,
                          model: t,
                          schema: d,
                          options: r,
                        })),
                      (o[p] = h);
                  }
                }
                return o;
              },
              T = ({ model: e, where: t }) => {
                if (t)
                  return t.map((t) => {
                    let {
                      field: i,
                      value: n,
                      operator: s = "eq",
                      connector: o = "AND",
                    } = t;
                    if ("in" === s && !Array.isArray(n))
                      throw Error("Value must be an array");
                    let a = y(e),
                      l = m({ field: i, model: e }),
                      c = w({ field: l, model: a }),
                      d = N({ field: l, model: a });
                    return ("id" === l || d.references?.field === "id") &&
                      r.advanced?.database?.useNumberId
                      ? Array.isArray(n)
                        ? {
                            operator: s,
                            connector: o,
                            field: c,
                            value: n.map(Number),
                          }
                        : {
                            operator: s,
                            connector: o,
                            field: c,
                            value: Number(n),
                          }
                      : { operator: s, connector: o, field: c, value: n };
                  });
              };
            return {
              create: async ({
                data: e,
                model: t,
                select: r,
                forceAllowId: i = !1,
              }) => {
                let n = ++l,
                  s = g(t);
                if ("id" in e && !i) {
                  o.l.warn(
                    `[${c.adapterName}] - You are trying to create a record with an id. This is not allowed as we handle id generation for you, unless you pass in the \`forceAllowId\` parameter. The id will be ignored.`
                  );
                  let t = Error();
                  console.log(
                    t.stack
                      ?.split("\n")
                      .filter((e, t) => 1 !== t)
                      .join("\n")
                      .replace(
                        "Error:",
                        "Create method with `id` being called at:"
                      )
                  ),
                    (e.id = void 0);
                }
                b(
                  { method: "create" },
                  `${u(n)} ${h(1, 4)}`,
                  `${p("create")} ${f("Unsafe Input")}:`,
                  { model: s, data: e }
                );
                let a = await _(e, t, "create", i);
                b(
                  { method: "create" },
                  `${u(n)} ${h(2, 4)}`,
                  `${p("create")} ${f("Parsed Input")}:`,
                  { model: s, data: a }
                );
                let d = await x.create({ data: a, model: s });
                b(
                  { method: "create" },
                  `${u(n)} ${h(3, 4)}`,
                  `${p("create")} ${f("DB Result")}:`,
                  { model: s, res: d }
                );
                let m = await S(d, t, r);
                return (
                  b(
                    { method: "create" },
                    `${u(n)} ${h(4, 4)}`,
                    `${p("create")} ${f("Parsed Result")}:`,
                    { model: s, data: m }
                  ),
                  m
                );
              },
              update: async ({ model: e, where: t, update: r }) => {
                let i = ++l,
                  n = g(e),
                  s = T({ model: e, where: t });
                b(
                  { method: "update" },
                  `${u(i)} ${h(1, 4)}`,
                  `${p("update")} ${f("Unsafe Input")}:`,
                  { model: n, data: r }
                );
                let o = await _(r, e, "update");
                b(
                  { method: "update" },
                  `${u(i)} ${h(2, 4)}`,
                  `${p("update")} ${f("Parsed Input")}:`,
                  { model: n, data: o }
                );
                let a = await x.update({ model: n, where: s, update: o });
                b(
                  { method: "update" },
                  `${u(i)} ${h(3, 4)}`,
                  `${p("update")} ${f("DB Result")}:`,
                  { model: n, data: a }
                );
                let c = await S(a, e);
                return (
                  b(
                    { method: "update" },
                    `${u(i)} ${h(4, 4)}`,
                    `${p("update")} ${f("Parsed Result")}:`,
                    { model: n, data: c }
                  ),
                  c
                );
              },
              updateMany: async ({ model: e, where: t, update: r }) => {
                let i = ++l,
                  n = g(e),
                  s = T({ model: e, where: t });
                b(
                  { method: "updateMany" },
                  `${u(i)} ${h(1, 4)}`,
                  `${p("updateMany")} ${f("Unsafe Input")}:`,
                  { model: n, data: r }
                );
                let o = await _(r, e, "update");
                b(
                  { method: "updateMany" },
                  `${u(i)} ${h(2, 4)}`,
                  `${p("updateMany")} ${f("Parsed Input")}:`,
                  { model: n, data: o }
                );
                let a = await x.updateMany({ model: n, where: s, update: o });
                return (
                  b(
                    { method: "updateMany" },
                    `${u(i)} ${h(3, 4)}`,
                    `${p("updateMany")} ${f("DB Result")}:`,
                    { model: n, data: a }
                  ),
                  b(
                    { method: "updateMany" },
                    `${u(i)} ${h(4, 4)}`,
                    `${p("updateMany")} ${f("Parsed Result")}:`,
                    { model: n, data: a }
                  ),
                  a
                );
              },
              findOne: async ({ model: e, where: t, select: r }) => {
                let i = ++l,
                  n = g(e),
                  s = T({ model: e, where: t });
                b(
                  { method: "findOne" },
                  `${u(i)} ${h(1, 3)}`,
                  `${p("findOne")}:`,
                  { model: n, where: s, select: r }
                );
                let o = await x.findOne({ model: n, where: s, select: r });
                b(
                  { method: "findOne" },
                  `${u(i)} ${h(2, 3)}`,
                  `${p("findOne")} ${f("DB Result")}:`,
                  { model: n, data: o }
                );
                let a = await S(o, e, r);
                return (
                  b(
                    { method: "findOne" },
                    `${u(i)} ${h(3, 3)}`,
                    `${p("findOne")} ${f("Parsed Result")}:`,
                    { model: n, data: a }
                  ),
                  a
                );
              },
              findMany: async ({
                model: e,
                where: t,
                limit: i,
                sortBy: n,
                offset: s,
              }) => {
                let o = ++l,
                  a = i ?? r.advanced?.database?.defaultFindManyLimit ?? 100,
                  c = g(e),
                  d = T({ model: e, where: t });
                b(
                  { method: "findMany" },
                  `${u(o)} ${h(1, 3)}`,
                  `${p("findMany")}:`,
                  { model: c, where: d, limit: a, sortBy: n, offset: s }
                );
                let m = await x.findMany({
                  model: c,
                  where: d,
                  limit: a,
                  sortBy: n,
                  offset: s,
                });
                b(
                  { method: "findMany" },
                  `${u(o)} ${h(2, 3)}`,
                  `${p("findMany")} ${f("DB Result")}:`,
                  { model: c, data: m }
                );
                let y = await Promise.all(m.map(async (t) => await S(t, e)));
                return (
                  b(
                    { method: "findMany" },
                    `${u(o)} ${h(3, 3)}`,
                    `${p("findMany")} ${f("Parsed Result")}:`,
                    { model: c, data: y }
                  ),
                  y
                );
              },
              delete: async ({ model: e, where: t }) => {
                let r = ++l,
                  i = g(e),
                  n = T({ model: e, where: t });
                b(
                  { method: "delete" },
                  `${u(r)} ${h(1, 2)}`,
                  `${p("delete")}:`,
                  { model: i, where: n }
                ),
                  await x.delete({ model: i, where: n }),
                  b(
                    { method: "delete" },
                    `${u(r)} ${h(2, 2)}`,
                    `${p("delete")} ${f("DB Result")}:`,
                    { model: i }
                  );
              },
              deleteMany: async ({ model: e, where: t }) => {
                let r = ++l,
                  i = g(e),
                  n = T({ model: e, where: t });
                b(
                  { method: "deleteMany" },
                  `${u(r)} ${h(1, 2)}`,
                  `${p("deleteMany")} ${f("DeleteMany")}:`,
                  { model: i, where: n }
                );
                let s = await x.deleteMany({ model: i, where: n });
                return (
                  b(
                    { method: "deleteMany" },
                    `${u(r)} ${h(2, 2)}`,
                    `${p("deleteMany")} ${f("DB Result")}:`,
                    { model: i, data: s }
                  ),
                  s
                );
              },
              count: async ({ model: e, where: t }) => {
                let r = ++l,
                  i = g(e),
                  n = T({ model: e, where: t });
                b({ method: "count" }, `${u(r)} ${h(1, 2)}`, `${p("count")}:`, {
                  model: i,
                  where: n,
                });
                let s = await x.count({ model: i, where: n });
                return (
                  b(
                    { method: "count" },
                    `${u(r)} ${h(2, 2)}`,
                    `${p("count")}:`,
                    { model: i, data: s }
                  ),
                  s
                );
              },
              createSchema: x.createSchema
                ? async (e, t) => {
                    let i = (0, n.g)(r);
                    return (
                      r.secondaryStorage &&
                        !r.session?.storeSessionInDatabase &&
                        delete i.session,
                      r.rateLimit &&
                        "database" === r.rateLimit.storage &&
                        (void 0 === r.rateLimit.enabled ||
                          !0 === r.rateLimit.enabled) &&
                        (i.ratelimit = {
                          modelName: r.rateLimit.modelName ?? "ratelimit",
                          fields: {
                            key: {
                              type: "string",
                              unique: !0,
                              required: !0,
                              fieldName: r.rateLimit.fields?.key ?? "key",
                            },
                            count: {
                              type: "number",
                              required: !0,
                              fieldName: r.rateLimit.fields?.count ?? "count",
                            },
                            lastRequest: {
                              type: "number",
                              required: !0,
                              bigint: !0,
                              defaultValue: () => Date.now(),
                              fieldName:
                                r.rateLimit.fields?.lastRequest ??
                                "lastRequest",
                            },
                          },
                        }),
                      x.createSchema({ file: t, tables: i })
                    );
                  }
                : void 0,
              options: { adapterConfig: c, ...(x.options ?? {}) },
              id: c.adapterId,
              ...(c.debugLogs?.isRunningAdapterTests
                ? {
                    adapterTestDebugLogs: {
                      resetDebugLogs() {
                        a = [];
                      },
                      printDebugLogs() {
                        let e = `\u2500`.repeat(80);
                        console.log(
                          ...a
                            .reverse()
                            .map(
                              (e) => (
                                (e[0] = `
${e[0]}`),
                                [...e, "\n"]
                              )
                            )
                            .reduce(
                              (e, t) => [...t, ...e],
                              [
                                `
${e}`,
                              ]
                            )
                        );
                      },
                    },
                  }
                : {}),
            };
          };
      function u(e) {
        return `${c.fg.magenta}#${e}${c.reset}`;
      }
      function h(e, t) {
        return `${c.bg.black}${c.fg.yellow}[${e}/${t}]${c.reset}`;
      }
      function p(e) {
        return `${c.bright}${e}${c.reset}`;
      }
      function f(e) {
        return `${c.dim}(${e})${c.reset}`;
      }
    },
    51101: (e, t, r) => {
      r.d(t, { Y: () => n, i: () => s });
      var i = r(11916);
      function n(e) {
        return (0, i.ll)`${e} asc`;
      }
      function s(e) {
        return (0, i.ll)`${e} desc`;
      }
    },
    51875: (e, t, r) => {
      function i(e) {
        return e
          ? "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"
          : "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      }
      function n(e, t, r) {
        let i = "",
          n = 0,
          s = 0;
        for (let r of e)
          for (n = (n << 8) | r, s += 8; s >= 6; )
            (s -= 6), (i += t[(n >> s) & 63]);
        if ((s > 0 && (i += t[(n << (6 - s)) & 63]), r)) {
          let e = (4 - (i.length % 4)) % 4;
          i += "=".repeat(e);
        }
        return i;
      }
      function s(e, t) {
        let r = new Map();
        for (let e = 0; e < t.length; e++) r.set(t[e], e);
        let i = [],
          n = 0,
          s = 0;
        for (let t of e) {
          if ("=" === t) break;
          let e = r.get(t);
          if (void 0 === e) throw Error(`Invalid Base64 character: ${t}`);
          (n = (n << 6) | e),
            (s += 6) >= 8 && ((s -= 8), i.push((n >> s) & 255));
        }
        return Uint8Array.from(i);
      }
      r.d(t, { K: () => o, z: () => a });
      let o = {
          encode(e, t = {}) {
            let r = i(!1);
            return n(
              "string" == typeof e
                ? new TextEncoder().encode(e)
                : new Uint8Array(e),
              r,
              t.padding ?? !0
            );
          },
          decode(e) {
            "string" != typeof e && (e = new TextDecoder().decode(e));
            let t = i(e.includes("-") || e.includes("_"));
            return s(e, t);
          },
        },
        a = {
          encode(e, t = {}) {
            let r = i(!0);
            return n(
              "string" == typeof e
                ? new TextEncoder().encode(e)
                : new Uint8Array(e),
              r,
              t.padding ?? !0
            );
          },
          decode(e) {
            let t = i(e.includes("-") || e.includes("_"));
            return s(e, t);
          },
        };
    },
    52630: (e, t, r) => {
      r.d(t, { o: () => o });
      var i = r(96051),
        n = r(42188),
        s = r(1518);
      let o = (0, i.CN)({
        is: (e) => "WhereNode" === e.kind,
        create: (e) => (0, i.CN)({ kind: "WhereNode", where: e }),
        cloneWithOperation: (e, t, r) =>
          (0, i.CN)({
            ...e,
            where:
              "And" === t ? n.s.create(e.where, r) : s.K.create(e.where, r),
          }),
      });
    },
    53668: (e, t, r) => {
      r.d(t, { L: () => d });
      var i = r(96051),
        n = r(44401);
      let s = (0, i.CN)({
        is: (e) => "GroupByNode" === e.kind,
        create: (e) => (0, i.CN)({ kind: "GroupByNode", items: (0, i.CN)(e) }),
        cloneWithItems: (e, t) =>
          (0, i.CN)({ ...e, items: (0, i.CN)([...e.items, ...t]) }),
      });
      var o = r(42188),
        a = r(1518);
      let l = (0, i.CN)({
        is: (e) => "HavingNode" === e.kind,
        create: (e) => (0, i.CN)({ kind: "HavingNode", having: e }),
        cloneWithOperation: (e, t, r) =>
          (0, i.CN)({
            ...e,
            having:
              "And" === t ? o.s.create(e.having, r) : a.K.create(e.having, r),
          }),
      });
      var c = r(64992);
      let d = (0, i.CN)({
        is: (e) => "SelectQueryNode" === e.kind,
        create: (e) =>
          (0, i.CN)({ kind: "SelectQueryNode", ...(e && { with: e }) }),
        createFrom: (e, t) =>
          (0, i.CN)({
            kind: "SelectQueryNode",
            from: n.N.create(e),
            ...(t && { with: t }),
          }),
        cloneWithSelections: (e, t) =>
          (0, i.CN)({
            ...e,
            selections: e.selections
              ? (0, i.CN)([...e.selections, ...t])
              : (0, i.CN)(t),
          }),
        cloneWithDistinctOn: (e, t) =>
          (0, i.CN)({
            ...e,
            distinctOn: e.distinctOn
              ? (0, i.CN)([...e.distinctOn, ...t])
              : (0, i.CN)(t),
          }),
        cloneWithFrontModifier: (e, t) =>
          (0, i.CN)({
            ...e,
            frontModifiers: e.frontModifiers
              ? (0, i.CN)([...e.frontModifiers, t])
              : (0, i.CN)([t]),
          }),
        cloneWithOrderByItems: (e, t) => c.L.cloneWithOrderByItems(e, t),
        cloneWithGroupByItems: (e, t) =>
          (0, i.CN)({
            ...e,
            groupBy: e.groupBy ? s.cloneWithItems(e.groupBy, t) : s.create(t),
          }),
        cloneWithLimit: (e, t) => (0, i.CN)({ ...e, limit: t }),
        cloneWithOffset: (e, t) => (0, i.CN)({ ...e, offset: t }),
        cloneWithFetch: (e, t) => (0, i.CN)({ ...e, fetch: t }),
        cloneWithHaving: (e, t) =>
          (0, i.CN)({
            ...e,
            having: e.having
              ? l.cloneWithOperation(e.having, "And", t)
              : l.create(t),
          }),
        cloneWithSetOperations: (e, t) =>
          (0, i.CN)({
            ...e,
            setOperations: e.setOperations
              ? (0, i.CN)([...e.setOperations, ...t])
              : (0, i.CN)([...t]),
          }),
        cloneWithoutSelections: (e) => (0, i.CN)({ ...e, selections: [] }),
        cloneWithoutLimit: (e) => (0, i.CN)({ ...e, limit: void 0 }),
        cloneWithoutOffset: (e) => (0, i.CN)({ ...e, offset: void 0 }),
        cloneWithoutOrderBy: (e) => c.L.cloneWithoutOrderBy(e),
        cloneWithoutGroupBy: (e) => (0, i.CN)({ ...e, groupBy: void 0 }),
      });
    },
    54036: (e, t, r) => {
      r.d(t, { b: () => a, d: () => l, f: () => c });
      var i = r(16151),
        n = r(30060);
      function s(e, t) {
        let r = t.fields,
          i = {};
        for (let t in e) {
          let n = r[t];
          if (!n) {
            i[t] = e[t];
            continue;
          }
          !1 !== n.returned && (i[t] = e[t]);
        }
        return i;
      }
      function o(e, t) {
        let r = {
          ...("user" === t ? e.user?.additionalFields : {}),
          ...("session" === t ? e.session?.additionalFields : {}),
        };
        for (let i of e.plugins || [])
          i.schema && i.schema[t] && (r = { ...r, ...i.schema[t].fields });
        return r;
      }
      function a(e, t) {
        return s(t, { fields: o(e, "user") });
      }
      function l(e, t) {
        return s(t, { fields: o(e, "session") });
      }
      i.z.object({
        id: i.z.string(),
        providerId: i.z.string(),
        accountId: i.z.string(),
        userId: i.z.coerce.string(),
        accessToken: i.z.string().nullish(),
        refreshToken: i.z.string().nullish(),
        idToken: i.z.string().nullish(),
        accessTokenExpiresAt: i.z.date().nullish(),
        refreshTokenExpiresAt: i.z.date().nullish(),
        scope: i.z.string().nullish(),
        password: i.z.string().nullish(),
        createdAt: i.z.date().default(() => new Date()),
        updatedAt: i.z.date().default(() => new Date()),
      }),
        i.z.object({
          id: i.z.string(),
          email: i.z.string().transform((e) => e.toLowerCase()),
          emailVerified: i.z.boolean().default(!1),
          name: i.z.string(),
          image: i.z.string().nullish(),
          createdAt: i.z.date().default(() => new Date()),
          updatedAt: i.z.date().default(() => new Date()),
        }),
        i.z.object({
          id: i.z.string(),
          userId: i.z.coerce.string(),
          expiresAt: i.z.date(),
          createdAt: i.z.date().default(() => new Date()),
          updatedAt: i.z.date().default(() => new Date()),
          token: i.z.string(),
          ipAddress: i.z.string().nullish(),
          userAgent: i.z.string().nullish(),
        }),
        i.z.object({
          id: i.z.string(),
          value: i.z.string(),
          createdAt: i.z.date().default(() => new Date()),
          updatedAt: i.z.date().default(() => new Date()),
          expiresAt: i.z.date(),
          identifier: i.z.string(),
        });
      function c(e, t, r) {
        return (function (e, t) {
          let r = t.action || "create",
            i = t.fields,
            s = {};
          for (let t in i) {
            if (t in e) {
              if (!1 === i[t].input) {
                i[t].defaultValue && (s[t] = i[t].defaultValue);
                continue;
              }
              if (i[t].validator?.input && void 0 !== e[t]) {
                s[t] = i[t].validator.input.parse(e[t]);
                continue;
              }
              if (i[t].transform?.input && void 0 !== e[t]) {
                s[t] = i[t].transform?.input(e[t]);
                continue;
              }
              s[t] = e[t];
              continue;
            }
            if (i[t].defaultValue && "create" === r) {
              s[t] = i[t].defaultValue;
              continue;
            }
            if (i[t].required && "create" === r)
              throw new n.LG("BAD_REQUEST", { message: `${t} is required` });
          }
          return s;
        })(t || {}, { fields: o(e, "user"), action: r });
      }
    },
    55094: (e, t, r) => {
      r.d(t, { zZ: () => T });
      var i = Object.defineProperty,
        n = Object.defineProperties,
        s = Object.getOwnPropertyDescriptors,
        o = Object.getOwnPropertySymbols,
        a = Object.prototype.hasOwnProperty,
        l = Object.prototype.propertyIsEnumerable,
        c = (e, t, r) =>
          t in e
            ? i(e, t, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: r,
              })
            : (e[t] = r),
        d = (e, t) => {
          for (var r in t || (t = {})) a.call(t, r) && c(e, r, t[r]);
          if (o) for (var r of o(t)) l.call(t, r) && c(e, r, t[r]);
          return e;
        },
        u = (e, t) => n(e, s(t)),
        h = class extends Error {
          constructor(e, t, r) {
            super(t || e.toString(), { cause: r }),
              (this.status = e),
              (this.statusText = t),
              (this.error = r);
          }
        },
        p = async (e, t) => {
          var r, i, n, s, o, a;
          let l = t || {},
            c = {
              onRequest: [null == t ? void 0 : t.onRequest],
              onResponse: [null == t ? void 0 : t.onResponse],
              onSuccess: [null == t ? void 0 : t.onSuccess],
              onError: [null == t ? void 0 : t.onError],
              onRetry: [null == t ? void 0 : t.onRetry],
            };
          if (!t || !(null == t ? void 0 : t.plugins))
            return { url: e, options: l, hooks: c };
          for (let d of (null == t ? void 0 : t.plugins) || []) {
            if (d.init) {
              let i = await (null == (r = d.init)
                ? void 0
                : r.call(d, e.toString(), t));
              (l = i.options || l), (e = i.url);
            }
            c.onRequest.push(null == (i = d.hooks) ? void 0 : i.onRequest),
              c.onResponse.push(null == (n = d.hooks) ? void 0 : n.onResponse),
              c.onSuccess.push(null == (s = d.hooks) ? void 0 : s.onSuccess),
              c.onError.push(null == (o = d.hooks) ? void 0 : o.onError),
              c.onRetry.push(null == (a = d.hooks) ? void 0 : a.onRetry);
          }
          return { url: e, options: l, hooks: c };
        },
        f = class {
          constructor(e) {
            this.options = e;
          }
          shouldAttemptRetry(e, t) {
            return this.options.shouldRetry
              ? Promise.resolve(
                  e < this.options.attempts && this.options.shouldRetry(t)
                )
              : Promise.resolve(e < this.options.attempts);
          }
          getDelay() {
            return this.options.delay;
          }
        },
        m = class {
          constructor(e) {
            this.options = e;
          }
          shouldAttemptRetry(e, t) {
            return this.options.shouldRetry
              ? Promise.resolve(
                  e < this.options.attempts && this.options.shouldRetry(t)
                )
              : Promise.resolve(e < this.options.attempts);
          }
          getDelay(e) {
            return Math.min(
              this.options.maxDelay,
              this.options.baseDelay * 2 ** e
            );
          }
        },
        y = async (e) => {
          let t = {},
            r = async (e) => ("function" == typeof e ? await e() : e);
          if (null == e ? void 0 : e.auth) {
            if ("Bearer" === e.auth.type) {
              let i = await r(e.auth.token);
              if (!i) return t;
              t.authorization = `Bearer ${i}`;
            } else if ("Basic" === e.auth.type) {
              let i = r(e.auth.username),
                n = r(e.auth.password);
              if (!i || !n) return t;
              t.authorization = `Basic ${btoa(`${i}:${n}`)}`;
            } else if ("Custom" === e.auth.type) {
              let i = r(e.auth.value);
              if (!i) return t;
              t.authorization = `${r(e.auth.prefix)} ${i}`;
            }
          }
          return t;
        },
        g = /^application\/(?:[\w!#$%&*.^`~-]*\+)?json(;.+)?$/i;
      function w(e) {
        if (void 0 === e) return !1;
        let t = typeof e;
        return (
          "string" === t ||
          "number" === t ||
          "boolean" === t ||
          null === t ||
          ("object" === t &&
            (!!Array.isArray(e) ||
              (!e.buffer &&
                ((e.constructor && "Object" === e.constructor.name) ||
                  "function" == typeof e.toJSON))))
        );
      }
      function b(e) {
        try {
          return JSON.parse(e);
        } catch (t) {
          return e;
        }
      }
      function v(e) {
        return "function" == typeof e;
      }
      async function N(e) {
        let t = new Headers(null == e ? void 0 : e.headers);
        for (let [r, i] of Object.entries((await y(e)) || {})) t.set(r, i);
        if (!t.has("content-type")) {
          let r = w(null == e ? void 0 : e.body) ? "application/json" : null;
          r && t.set("content-type", r);
        }
        return t;
      }
      var x = class e extends Error {
        constructor(t, r) {
          super(r || JSON.stringify(t, null, 2)),
            (this.issues = t),
            Object.setPrototypeOf(this, e.prototype);
        }
      };
      async function _(e, t) {
        let r = await e["~standard"].validate(t);
        if (r.issues) throw new x(r.issues);
        return r.value;
      }
      var S = ["get", "post", "put", "patch", "delete"],
        T = async (e, t) => {
          var r, i, n, s, o, a, l, c;
          let { hooks: y, url: x, options: k } = await p(e, t),
            A = (function (e) {
              if (null == e ? void 0 : e.customFetchImpl)
                return e.customFetchImpl;
              if ("undefined" != typeof globalThis && v(globalThis.fetch))
                return globalThis.fetch;
              if ("undefined" != typeof window && v(window.fetch))
                return window.fetch;
              throw Error("No fetch implementation found");
            })(k),
            E = new AbortController(),
            C = null != (r = k.signal) ? r : E.signal,
            I = (function (e, t) {
              let {
                  baseURL: r,
                  params: i,
                  query: n,
                } = t || { query: {}, params: {}, baseURL: "" },
                s = e.startsWith("http")
                  ? e.split("/").slice(0, 3).join("/")
                  : r || "";
              if (e.startsWith("@")) {
                let t = e.toString().split("@")[1].split("/")[0];
                S.includes(t) && (e = e.replace(`@${t}/`, "/"));
              }
              s.endsWith("/") || (s += "/");
              let [o, a] = e.replace(s, "").split("?"),
                l = new URLSearchParams(a);
              for (let [e, t] of Object.entries(n || {}))
                null != t && l.set(e, String(t));
              if (i)
                if (Array.isArray(i))
                  for (let [e, t] of o
                    .split("/")
                    .filter((e) => e.startsWith(":"))
                    .entries()) {
                    let r = i[e];
                    o = o.replace(t, r);
                  }
                else
                  for (let [e, t] of Object.entries(i))
                    o = o.replace(`:${e}`, String(t));
              (o = o.split("/").map(encodeURIComponent).join("/")).startsWith(
                "/"
              ) && (o = o.slice(1));
              let c = l.toString();
              return ((c = c.length > 0 ? `?${c}`.replace(/\+/g, "%20") : ""),
              s.startsWith("http"))
                ? new URL(`${o}${c}`, s)
                : `${s}${o}${c}`;
            })(x, k),
            O = (function (e) {
              if (!(null == e ? void 0 : e.body)) return null;
              let t = new Headers(null == e ? void 0 : e.headers);
              if (w(e.body) && !t.has("content-type")) {
                for (let [t, r] of Object.entries(null == e ? void 0 : e.body))
                  r instanceof Date && (e.body[t] = r.toISOString());
                return JSON.stringify(e.body);
              }
              return e.body;
            })(k),
            L = await N(k),
            R = (function (e, t) {
              var r;
              if (null == t ? void 0 : t.method) return t.method.toUpperCase();
              if (e.startsWith("@")) {
                let i =
                  null == (r = e.split("@")[1]) ? void 0 : r.split("/")[0];
                return S.includes(i)
                  ? i.toUpperCase()
                  : (null == t ? void 0 : t.body)
                    ? "POST"
                    : "GET";
              }
              return (null == t ? void 0 : t.body) ? "POST" : "GET";
            })(x, k),
            P = u(d({}, k), {
              url: I,
              headers: L,
              body: O,
              method: R,
              signal: C,
            });
          for (let e of y.onRequest)
            if (e) {
              let t = await e(P);
              t instanceof Object && (P = t);
            }
          (("pipeTo" in P && "function" == typeof P.pipeTo) ||
            "function" ==
              typeof (null == (i = null == t ? void 0 : t.body)
                ? void 0
                : i.pipe)) &&
            !("duplex" in P) &&
            (P.duplex = "half");
          let { clearTimeout: D } = (function (e, t) {
              let r;
              return (
                !(null == e ? void 0 : e.signal) &&
                  (null == e ? void 0 : e.timeout) &&
                  (r = setTimeout(
                    () => (null == t ? void 0 : t.abort()),
                    null == e ? void 0 : e.timeout
                  )),
                {
                  abortTimeout: r,
                  clearTimeout: () => {
                    r && clearTimeout(r);
                  },
                }
              );
            })(k, E),
            q = await A(P.url, P);
          D();
          let U = { response: q, request: P };
          for (let e of y.onResponse)
            if (e) {
              let r = await e(
                u(d({}, U), {
                  response: (
                    null == (n = null == t ? void 0 : t.hookOptions)
                      ? void 0
                      : n.cloneResponse
                  )
                    ? q.clone()
                    : q,
                })
              );
              r instanceof Response
                ? (q = r)
                : r instanceof Object && (q = r.response);
            }
          if (q.ok) {
            if ("HEAD" === P.method) return { data: "", error: null };
            let e = (function (e) {
                let t = e.headers.get("content-type"),
                  r = new Set([
                    "image/svg",
                    "application/xml",
                    "application/xhtml",
                    "application/html",
                  ]);
                if (!t) return "json";
                let i = t.split(";").shift() || "";
                return g.test(i)
                  ? "json"
                  : r.has(i) || i.startsWith("text/")
                    ? "text"
                    : "blob";
              })(q),
              r = { data: "", response: q, request: P };
            if ("json" === e || "text" === e) {
              let e = await q.text(),
                t = null != (s = P.jsonParser) ? s : b;
              r.data = await t(e);
            } else r.data = await q[e]();
            for (let e of ((null == P ? void 0 : P.output) &&
              P.output &&
              !P.disableValidation &&
              (r.data = await _(P.output, r.data)),
            y.onSuccess))
              e &&
                (await e(
                  u(d({}, r), {
                    response: (
                      null == (o = null == t ? void 0 : t.hookOptions)
                        ? void 0
                        : o.cloneResponse
                    )
                      ? q.clone()
                      : q,
                  })
                ));
            return (null == t ? void 0 : t.throw)
              ? r.data
              : { data: r.data, error: null };
          }
          let $ = null != (a = null == t ? void 0 : t.jsonParser) ? a : b,
            B = await q.text(),
            M = (function (e) {
              try {
                return JSON.parse(e), !0;
              } catch (e) {
                return !1;
              }
            })(B),
            j = M ? await $(B) : null,
            W = {
              response: q,
              responseText: B,
              request: P,
              error: u(d({}, j), {
                status: q.status,
                statusText: q.statusText,
              }),
            };
          for (let e of y.onError)
            e &&
              (await e(
                u(d({}, W), {
                  response: (
                    null == (l = null == t ? void 0 : t.hookOptions)
                      ? void 0
                      : l.cloneResponse
                  )
                    ? q.clone()
                    : q,
                })
              ));
          if (null == t ? void 0 : t.retry) {
            let r = (function (e) {
                if ("number" == typeof e)
                  return new f({ type: "linear", attempts: e, delay: 1e3 });
                switch (e.type) {
                  case "linear":
                    return new f(e);
                  case "exponential":
                    return new m(e);
                  default:
                    throw Error("Invalid retry strategy");
                }
              })(t.retry),
              i = null != (c = t.retryAttempt) ? c : 0;
            if (await r.shouldAttemptRetry(i, q)) {
              for (let e of y.onRetry) e && (await e(U));
              let n = r.getDelay(i);
              return (
                await new Promise((e) => setTimeout(e, n)),
                await T(e, u(d({}, t), { retryAttempt: i + 1 }))
              );
            }
          }
          if (null == t ? void 0 : t.throw)
            throw new h(q.status, q.statusText, M ? j : B);
          return {
            data: null,
            error: u(d({}, j), { status: q.status, statusText: q.statusText }),
          };
        };
    },
    56394: (e, t, r) => {
      r.d(t, { Og: () => l });
      var i = r(19984),
        n = r(77598);
      let s = (e) =>
        e.d
          ? (0, n.createPrivateKey)({ format: "jwk", key: e })
          : (0, n.createPublicKey)({ format: "jwk", key: e });
      var o = r(41321),
        a = r(81385);
      async function l(e, t) {
        if (!(0, a.A)(e)) throw TypeError("JWK must be an object");
        switch (((t ||= e.alg), e.kty)) {
          case "oct":
            if ("string" != typeof e.k || !e.k)
              throw TypeError('missing "k" (Key Value) Parameter value');
            return (0, i.D4)(e.k);
          case "RSA":
            if ("oth" in e && void 0 !== e.oth)
              throw new o.T0(
                'RSA JWK "oth" (Other Primes Info) Parameter value is not supported'
              );
          case "EC":
          case "OKP":
            return s({ ...e, alg: t });
          default:
            throw new o.T0('Unsupported "kty" (Key Type) Parameter value');
        }
      }
    },
    57960: (e, t, r) => {
      r.d(t, { r: () => s });
      var i = r(96051),
        n = r(74465);
      let s = (0, i.CN)({
        is: (e) => "MergeQueryNode" === e.kind,
        create: (e, t) =>
          (0, i.CN)({ kind: "MergeQueryNode", into: e, ...(t && { with: t }) }),
        cloneWithUsing: (e, t) => (0, i.CN)({ ...e, using: t }),
        cloneWithWhen: (e, t) =>
          (0, i.CN)({
            ...e,
            whens: e.whens ? (0, i.CN)([...e.whens, t]) : (0, i.CN)([t]),
          }),
        cloneWithThen: (e, t) =>
          (0, i.CN)({
            ...e,
            whens: e.whens
              ? (0, i.CN)([
                  ...e.whens.slice(0, -1),
                  n.t.cloneWithResult(e.whens[e.whens.length - 1], t),
                ])
              : void 0,
          }),
      });
    },
    60218: (e, t, r) => {
      r.d(t, { Fx: () => a, kn: () => o });
      var i = r(90211),
        n = r(64055);
      class s extends n.pe {
        static [i.i] = "PgJsonbBuilder";
        constructor(e) {
          super(e, "json", "PgJsonb");
        }
        build(e) {
          return new o(e, this.config);
        }
      }
      class o extends n.Kl {
        static [i.i] = "PgJsonb";
        constructor(e, t) {
          super(e, t);
        }
        getSQLType() {
          return "jsonb";
        }
        mapToDriverValue(e) {
          return JSON.stringify(e);
        }
        mapFromDriverValue(e) {
          if ("string" == typeof e)
            try {
              return JSON.parse(e);
            } catch {}
          return e;
        }
      }
      function a(e) {
        return new s(e ?? "");
      }
    },
    61229: (e, t, r) => {
      r.d(t, { a: () => n });
      let i = new Map(),
        n = {
          decode: (e, t = "utf-8") => (
            i.has(t) || i.set(t, new TextDecoder(t)), i.get(t).decode(e)
          ),
          encode: new TextEncoder().encode,
        };
    },
    61495: (e, t, r) => {
      r.d(t, { G: () => s });
      var i = r(5807),
        n = r(96051);
      async function s(e) {
        let t = new i.c(),
          r = new i.c();
        return (
          e
            .provideConnection(async (e) => (t.resolve(e), await r.promise))
            .catch((e) => t.reject(e)),
          (0, n.CN)({ connection: await t.promise, release: r.resolve })
        );
      }
    },
    62055: (e, t, r) => {
      r.d(t, { s: () => o });
      var i = r(8126),
        n = r(84941),
        s = r(51875);
      let o = (e = "SHA-256", t = "none") => {
        let r = {
          importKey: async (t, r) =>
            i.aK.importKey(
              "raw",
              "string" == typeof t ? new TextEncoder().encode(t) : t,
              { name: "HMAC", hash: { name: e } },
              !1,
              [r]
            ),
          sign: async (e, o) => {
            "string" == typeof e && (e = await r.importKey(e, "sign"));
            let a = await i.aK.sign(
              "HMAC",
              e,
              "string" == typeof o ? new TextEncoder().encode(o) : o
            );
            return "hex" === t
              ? n.u.encode(a)
              : "base64" === t || "base64url" === t || "base64urlnopad" === t
                ? s.z.encode(a, { padding: "base64urlnopad" !== t })
                : a;
          },
          verify: async (e, o, a) => (
            "string" == typeof e && (e = await r.importKey(e, "verify")),
            "hex" === t && (a = n.u.decode(a)),
            ("base64" === t || "base64url" === t || "base64urlnopad" === t) &&
              (a = await s.K.decode(a)),
            i.aK.verify(
              "HMAC",
              e,
              "string" == typeof a ? new TextEncoder().encode(a) : a,
              "string" == typeof o ? new TextEncoder().encode(o) : o
            )
          ),
        };
        return r;
      };
    },
    62534: (e, t, r) => {
      r.d(t, { l: () => n });
      var i = r(96051);
      let n = (0, i.CN)({
        is: (e) => "BinaryOperationNode" === e.kind,
        create: (e, t, r) =>
          (0, i.CN)({
            kind: "BinaryOperationNode",
            leftOperand: e,
            operator: t,
            rightOperand: r,
          }),
      });
    },
    63309: (e, t, r) => {
      r.d(t, { U: () => o });
      var i = r(96051),
        n = r(44401),
        s = r(87389);
      let o = (0, i.CN)({
        is: (e) => "UpdateQueryNode" === e.kind,
        create: (e, t) =>
          (0, i.CN)({
            kind: "UpdateQueryNode",
            table: 1 === e.length ? e[0] : s.v.create(e),
            ...(t && { with: t }),
          }),
        createWithoutTable: () => (0, i.CN)({ kind: "UpdateQueryNode" }),
        cloneWithFromItems: (e, t) =>
          (0, i.CN)({
            ...e,
            from: e.from ? n.N.cloneWithFroms(e.from, t) : n.N.create(t),
          }),
        cloneWithUpdates: (e, t) =>
          (0, i.CN)({
            ...e,
            updates: e.updates ? (0, i.CN)([...e.updates, ...t]) : t,
          }),
        cloneWithLimit: (e, t) => (0, i.CN)({ ...e, limit: t }),
      });
    },
    64055: (e, t, r) => {
      r.d(t, { Kl: () => y, pe: () => m });
      var i = r(90211);
      class n {
        static [i.i] = "ColumnBuilder";
        config;
        constructor(e, t, r) {
          this.config = {
            name: e,
            keyAsName: "" === e,
            notNull: !1,
            default: void 0,
            hasDefault: !1,
            primaryKey: !1,
            isUnique: !1,
            uniqueName: void 0,
            uniqueType: void 0,
            dataType: t,
            columnType: r,
            generated: void 0,
          };
        }
        $type() {
          return this;
        }
        notNull() {
          return (this.config.notNull = !0), this;
        }
        default(e) {
          return (this.config.default = e), (this.config.hasDefault = !0), this;
        }
        $defaultFn(e) {
          return (
            (this.config.defaultFn = e), (this.config.hasDefault = !0), this
          );
        }
        $default = this.$defaultFn;
        $onUpdateFn(e) {
          return (
            (this.config.onUpdateFn = e), (this.config.hasDefault = !0), this
          );
        }
        $onUpdate = this.$onUpdateFn;
        primaryKey() {
          return (
            (this.config.primaryKey = !0), (this.config.notNull = !0), this
          );
        }
        setName(e) {
          "" === this.config.name && (this.config.name = e);
        }
      }
      var s = r(93994),
        o = r(1793);
      class a {
        static [i.i] = "PgForeignKeyBuilder";
        reference;
        _onUpdate = "no action";
        _onDelete = "no action";
        constructor(e, t) {
          (this.reference = () => {
            let { name: t, columns: r, foreignColumns: i } = e();
            return {
              name: t,
              columns: r,
              foreignTable: i[0].table,
              foreignColumns: i,
            };
          }),
            t && ((this._onUpdate = t.onUpdate), (this._onDelete = t.onDelete));
        }
        onUpdate(e) {
          return (this._onUpdate = void 0 === e ? "no action" : e), this;
        }
        onDelete(e) {
          return (this._onDelete = void 0 === e ? "no action" : e), this;
        }
        build(e) {
          return new l(e, this);
        }
      }
      class l {
        constructor(e, t) {
          (this.table = e),
            (this.reference = t.reference),
            (this.onUpdate = t._onUpdate),
            (this.onDelete = t._onDelete);
        }
        static [i.i] = "PgForeignKey";
        reference;
        onUpdate;
        onDelete;
        getName() {
          let { name: e, columns: t, foreignColumns: r } = this.reference(),
            i = t.map((e) => e.name),
            n = r.map((e) => e.name),
            s = [this.table[o.E], ...i, r[0].table[o.E], ...n];
          return e ?? `${s.join("_")}_fk`;
        }
      }
      var c = r(4304);
      function d(e, t) {
        return `${e[o.E]}_${t.join("_")}_unique`;
      }
      class u {
        constructor(e, t) {
          (this.name = t), (this.columns = e);
        }
        static [i.i] = null;
        columns;
        nullsNotDistinctConfig = !1;
        nullsNotDistinct() {
          return (this.nullsNotDistinctConfig = !0), this;
        }
        build(e) {
          return new p(e, this.columns, this.nullsNotDistinctConfig, this.name);
        }
      }
      class h {
        static [i.i] = null;
        name;
        constructor(e) {
          this.name = e;
        }
        on(...e) {
          return new u(e, this.name);
        }
      }
      class p {
        constructor(e, t, r, i) {
          (this.table = e),
            (this.columns = t),
            (this.name =
              i ??
              d(
                this.table,
                this.columns.map((e) => e.name)
              )),
            (this.nullsNotDistinct = r);
        }
        static [i.i] = null;
        columns;
        name;
        nullsNotDistinct = !1;
        getName() {
          return this.name;
        }
      }
      function f(e, t, r) {
        for (let i = t; i < e.length; i++) {
          let n = e[i];
          if ("\\" === n) {
            i++;
            continue;
          }
          if ('"' === n) return [e.slice(t, i).replace(/\\/g, ""), i + 1];
          if (!r && ("," === n || "}" === n))
            return [e.slice(t, i).replace(/\\/g, ""), i];
        }
        return [e.slice(t).replace(/\\/g, ""), e.length];
      }
      class m extends n {
        foreignKeyConfigs = [];
        static [i.i] = "PgColumnBuilder";
        array(e) {
          return new b(this.config.name, this, e);
        }
        references(e, t = {}) {
          return this.foreignKeyConfigs.push({ ref: e, actions: t }), this;
        }
        unique(e, t) {
          return (
            (this.config.isUnique = !0),
            (this.config.uniqueName = e),
            (this.config.uniqueType = t?.nulls),
            this
          );
        }
        generatedAlwaysAs(e) {
          return (
            (this.config.generated = { as: e, type: "always", mode: "stored" }),
            this
          );
        }
        buildForeignKeys(e, t) {
          return this.foreignKeyConfigs.map(({ ref: r, actions: i }) =>
            (0, c.i)(
              (r, i) => {
                let n = new a(() => ({ columns: [e], foreignColumns: [r()] }));
                return (
                  i.onUpdate && n.onUpdate(i.onUpdate),
                  i.onDelete && n.onDelete(i.onDelete),
                  n.build(t)
                );
              },
              r,
              i
            )
          );
        }
        buildExtraConfigColumn(e) {
          return new g(e, this.config);
        }
      }
      class y extends s.V {
        constructor(e, t) {
          t.uniqueName || (t.uniqueName = d(e, [t.name])),
            super(e, t),
            (this.table = e);
        }
        static [i.i] = "PgColumn";
      }
      class g extends y {
        static [i.i] = "ExtraConfigColumn";
        getSQLType() {
          return this.getSQLType();
        }
        indexConfig = {
          order: this.config.order ?? "asc",
          nulls: this.config.nulls ?? "last",
          opClass: this.config.opClass,
        };
        defaultConfig = { order: "asc", nulls: "last", opClass: void 0 };
        asc() {
          return (this.indexConfig.order = "asc"), this;
        }
        desc() {
          return (this.indexConfig.order = "desc"), this;
        }
        nullsFirst() {
          return (this.indexConfig.nulls = "first"), this;
        }
        nullsLast() {
          return (this.indexConfig.nulls = "last"), this;
        }
        op(e) {
          return (this.indexConfig.opClass = e), this;
        }
      }
      class w {
        static [i.i] = null;
        constructor(e, t, r, i) {
          (this.name = e),
            (this.keyAsName = t),
            (this.type = r),
            (this.indexConfig = i);
        }
        name;
        keyAsName;
        type;
        indexConfig;
      }
      class b extends m {
        static [i.i] = "PgArrayBuilder";
        constructor(e, t, r) {
          super(e, "array", "PgArray"),
            (this.config.baseBuilder = t),
            (this.config.size = r);
        }
        build(e) {
          let t = this.config.baseBuilder.build(e);
          return new v(e, this.config, t);
        }
      }
      class v extends y {
        constructor(e, t, r, i) {
          super(e, t),
            (this.baseColumn = r),
            (this.range = i),
            (this.size = t.size);
        }
        size;
        static [i.i] = "PgArray";
        getSQLType() {
          return `${this.baseColumn.getSQLType()}[${"number" == typeof this.size ? this.size : ""}]`;
        }
        mapFromDriverValue(e) {
          return (
            "string" == typeof e &&
              (e = (function (e) {
                let [t] = (function e(t, r = 0) {
                  let i = [],
                    n = r,
                    s = !1;
                  for (; n < t.length; ) {
                    let o = t[n];
                    if ("," === o) {
                      (s || n === r) && i.push(""), (s = !0), n++;
                      continue;
                    }
                    if (((s = !1), "\\" === o)) {
                      n += 2;
                      continue;
                    }
                    if ('"' === o) {
                      let [e, r] = f(t, n + 1, !0);
                      i.push(e), (n = r);
                      continue;
                    }
                    if ("}" === o) return [i, n + 1];
                    if ("{" === o) {
                      let [r, s] = e(t, n + 1);
                      i.push(r), (n = s);
                      continue;
                    }
                    let [a, l] = f(t, n, !1);
                    i.push(a), (n = l);
                  }
                  return [i, n];
                })(e, 1);
                return t;
              })(e)),
            e.map((e) => this.baseColumn.mapFromDriverValue(e))
          );
        }
        mapToDriverValue(e, t = !1) {
          let r = e.map((e) =>
            null === e
              ? null
              : (0, i.is)(this.baseColumn, v)
                ? this.baseColumn.mapToDriverValue(e, !0)
                : this.baseColumn.mapToDriverValue(e)
          );
          return t
            ? r
            : (function e(t) {
                return `{${t.map((t) => (Array.isArray(t) ? e(t) : "string" == typeof t ? `"${t.replace(/\\/g, "\\\\").replace(/"/g, '\\"')}"` : `${t}`)).join(",")}}`;
              })(r);
        }
      }
    },
    64992: (e, t, r) => {
      r.d(t, { L: () => f });
      var i = r(29597),
        n = r(53668),
        s = r(63309),
        o = r(43395),
        a = r(52630),
        l = r(96051);
      let c = (0, l.CN)({
          is: (e) => "ReturningNode" === e.kind,
          create: (e) =>
            (0, l.CN)({ kind: "ReturningNode", selections: (0, l.CN)(e) }),
          cloneWithSelections: (e, t) =>
            (0, l.CN)({
              ...e,
              selections: e.selections
                ? (0, l.CN)([...e.selections, ...t])
                : (0, l.CN)(t),
            }),
        }),
        d = (0, l.CN)({
          is: (e) => "ExplainNode" === e.kind,
          create: (e, t) =>
            (0, l.CN)({ kind: "ExplainNode", format: e, options: t }),
        });
      var u = r(57960);
      let h = (0, l.CN)({
        is: (e) => "OutputNode" === e.kind,
        create: (e) =>
          (0, l.CN)({ kind: "OutputNode", selections: (0, l.CN)(e) }),
        cloneWithSelections: (e, t) =>
          (0, l.CN)({
            ...e,
            selections: e.selections
              ? (0, l.CN)([...e.selections, ...t])
              : (0, l.CN)(t),
          }),
      });
      var p = r(44851);
      let f = (0, l.CN)({
        is: (e) =>
          n.L.is(e) || i.o.is(e) || s.U.is(e) || o.e.is(e) || u.r.is(e),
        cloneWithEndModifier: (e, t) =>
          (0, l.CN)({
            ...e,
            endModifiers: e.endModifiers
              ? (0, l.CN)([...e.endModifiers, t])
              : (0, l.CN)([t]),
          }),
        cloneWithWhere: (e, t) =>
          (0, l.CN)({
            ...e,
            where: e.where
              ? a.o.cloneWithOperation(e.where, "And", t)
              : a.o.create(t),
          }),
        cloneWithJoin: (e, t) =>
          (0, l.CN)({
            ...e,
            joins: e.joins ? (0, l.CN)([...e.joins, t]) : (0, l.CN)([t]),
          }),
        cloneWithReturning: (e, t) =>
          (0, l.CN)({
            ...e,
            returning: e.returning
              ? c.cloneWithSelections(e.returning, t)
              : c.create(t),
          }),
        cloneWithoutReturning: (e) => (0, l.CN)({ ...e, returning: void 0 }),
        cloneWithoutWhere: (e) => (0, l.CN)({ ...e, where: void 0 }),
        cloneWithExplain: (e, t, r) =>
          (0, l.CN)({ ...e, explain: d.create(t, r?.toOperationNode()) }),
        cloneWithTop: (e, t) => (0, l.CN)({ ...e, top: t }),
        cloneWithOutput: (e, t) =>
          (0, l.CN)({
            ...e,
            output: e.output ? h.cloneWithSelections(e.output, t) : h.create(t),
          }),
        cloneWithOrderByItems: (e, t) =>
          (0, l.CN)({
            ...e,
            orderBy: e.orderBy
              ? p.O.cloneWithItems(e.orderBy, t)
              : p.O.create(t),
          }),
        cloneWithoutOrderBy: (e) => (0, l.CN)({ ...e, orderBy: void 0 }),
      });
    },
    67872: (e, t, r) => {
      r.d(t, { O: () => n });
      var i = r(96051);
      let n = (0, i.CN)({
        is: (e) => "IdentifierNode" === e.kind,
        create: (e) => (0, i.CN)({ kind: "IdentifierNode", name: e }),
      });
    },
    69913: (e, t, r) => {
      r.d(t, { V: () => n });
      var i = r(96051);
      class n {
        nodeStack = [];
        #m = (0, i.CN)({
          AliasNode: this.transformAlias.bind(this),
          ColumnNode: this.transformColumn.bind(this),
          IdentifierNode: this.transformIdentifier.bind(this),
          SchemableIdentifierNode: this.transformSchemableIdentifier.bind(this),
          RawNode: this.transformRaw.bind(this),
          ReferenceNode: this.transformReference.bind(this),
          SelectQueryNode: this.transformSelectQuery.bind(this),
          SelectionNode: this.transformSelection.bind(this),
          TableNode: this.transformTable.bind(this),
          FromNode: this.transformFrom.bind(this),
          SelectAllNode: this.transformSelectAll.bind(this),
          AndNode: this.transformAnd.bind(this),
          OrNode: this.transformOr.bind(this),
          ValueNode: this.transformValue.bind(this),
          ValueListNode: this.transformValueList.bind(this),
          PrimitiveValueListNode: this.transformPrimitiveValueList.bind(this),
          ParensNode: this.transformParens.bind(this),
          JoinNode: this.transformJoin.bind(this),
          OperatorNode: this.transformOperator.bind(this),
          WhereNode: this.transformWhere.bind(this),
          InsertQueryNode: this.transformInsertQuery.bind(this),
          DeleteQueryNode: this.transformDeleteQuery.bind(this),
          ReturningNode: this.transformReturning.bind(this),
          CreateTableNode: this.transformCreateTable.bind(this),
          AddColumnNode: this.transformAddColumn.bind(this),
          ColumnDefinitionNode: this.transformColumnDefinition.bind(this),
          DropTableNode: this.transformDropTable.bind(this),
          DataTypeNode: this.transformDataType.bind(this),
          OrderByNode: this.transformOrderBy.bind(this),
          OrderByItemNode: this.transformOrderByItem.bind(this),
          GroupByNode: this.transformGroupBy.bind(this),
          GroupByItemNode: this.transformGroupByItem.bind(this),
          UpdateQueryNode: this.transformUpdateQuery.bind(this),
          ColumnUpdateNode: this.transformColumnUpdate.bind(this),
          LimitNode: this.transformLimit.bind(this),
          OffsetNode: this.transformOffset.bind(this),
          OnConflictNode: this.transformOnConflict.bind(this),
          OnDuplicateKeyNode: this.transformOnDuplicateKey.bind(this),
          CreateIndexNode: this.transformCreateIndex.bind(this),
          DropIndexNode: this.transformDropIndex.bind(this),
          ListNode: this.transformList.bind(this),
          PrimaryKeyConstraintNode:
            this.transformPrimaryKeyConstraint.bind(this),
          UniqueConstraintNode: this.transformUniqueConstraint.bind(this),
          ReferencesNode: this.transformReferences.bind(this),
          CheckConstraintNode: this.transformCheckConstraint.bind(this),
          WithNode: this.transformWith.bind(this),
          CommonTableExpressionNode:
            this.transformCommonTableExpression.bind(this),
          CommonTableExpressionNameNode:
            this.transformCommonTableExpressionName.bind(this),
          HavingNode: this.transformHaving.bind(this),
          CreateSchemaNode: this.transformCreateSchema.bind(this),
          DropSchemaNode: this.transformDropSchema.bind(this),
          AlterTableNode: this.transformAlterTable.bind(this),
          DropColumnNode: this.transformDropColumn.bind(this),
          RenameColumnNode: this.transformRenameColumn.bind(this),
          AlterColumnNode: this.transformAlterColumn.bind(this),
          ModifyColumnNode: this.transformModifyColumn.bind(this),
          AddConstraintNode: this.transformAddConstraint.bind(this),
          DropConstraintNode: this.transformDropConstraint.bind(this),
          RenameConstraintNode: this.transformRenameConstraint.bind(this),
          ForeignKeyConstraintNode:
            this.transformForeignKeyConstraint.bind(this),
          CreateViewNode: this.transformCreateView.bind(this),
          RefreshMaterializedViewNode:
            this.transformRefreshMaterializedView.bind(this),
          DropViewNode: this.transformDropView.bind(this),
          GeneratedNode: this.transformGenerated.bind(this),
          DefaultValueNode: this.transformDefaultValue.bind(this),
          OnNode: this.transformOn.bind(this),
          ValuesNode: this.transformValues.bind(this),
          SelectModifierNode: this.transformSelectModifier.bind(this),
          CreateTypeNode: this.transformCreateType.bind(this),
          DropTypeNode: this.transformDropType.bind(this),
          ExplainNode: this.transformExplain.bind(this),
          DefaultInsertValueNode: this.transformDefaultInsertValue.bind(this),
          AggregateFunctionNode: this.transformAggregateFunction.bind(this),
          OverNode: this.transformOver.bind(this),
          PartitionByNode: this.transformPartitionBy.bind(this),
          PartitionByItemNode: this.transformPartitionByItem.bind(this),
          SetOperationNode: this.transformSetOperation.bind(this),
          BinaryOperationNode: this.transformBinaryOperation.bind(this),
          UnaryOperationNode: this.transformUnaryOperation.bind(this),
          UsingNode: this.transformUsing.bind(this),
          FunctionNode: this.transformFunction.bind(this),
          CaseNode: this.transformCase.bind(this),
          WhenNode: this.transformWhen.bind(this),
          JSONReferenceNode: this.transformJSONReference.bind(this),
          JSONPathNode: this.transformJSONPath.bind(this),
          JSONPathLegNode: this.transformJSONPathLeg.bind(this),
          JSONOperatorChainNode: this.transformJSONOperatorChain.bind(this),
          TupleNode: this.transformTuple.bind(this),
          MergeQueryNode: this.transformMergeQuery.bind(this),
          MatchedNode: this.transformMatched.bind(this),
          AddIndexNode: this.transformAddIndex.bind(this),
          CastNode: this.transformCast.bind(this),
          FetchNode: this.transformFetch.bind(this),
          TopNode: this.transformTop.bind(this),
          OutputNode: this.transformOutput.bind(this),
          OrActionNode: this.transformOrAction.bind(this),
          CollateNode: this.transformCollate.bind(this),
        });
        transformNode(e, t) {
          if (!e) return e;
          this.nodeStack.push(e);
          let r = this.transformNodeImpl(e, t);
          return this.nodeStack.pop(), (0, i.CN)(r);
        }
        transformNodeImpl(e, t) {
          return this.#m[e.kind](e, t);
        }
        transformNodeList(e, t) {
          return e ? (0, i.CN)(e.map((e) => this.transformNode(e, t))) : e;
        }
        transformSelectQuery(e, t) {
          return {
            kind: "SelectQueryNode",
            from: this.transformNode(e.from, t),
            selections: this.transformNodeList(e.selections, t),
            distinctOn: this.transformNodeList(e.distinctOn, t),
            joins: this.transformNodeList(e.joins, t),
            groupBy: this.transformNode(e.groupBy, t),
            orderBy: this.transformNode(e.orderBy, t),
            where: this.transformNode(e.where, t),
            frontModifiers: this.transformNodeList(e.frontModifiers, t),
            endModifiers: this.transformNodeList(e.endModifiers, t),
            limit: this.transformNode(e.limit, t),
            offset: this.transformNode(e.offset, t),
            with: this.transformNode(e.with, t),
            having: this.transformNode(e.having, t),
            explain: this.transformNode(e.explain, t),
            setOperations: this.transformNodeList(e.setOperations, t),
            fetch: this.transformNode(e.fetch, t),
            top: this.transformNode(e.top, t),
          };
        }
        transformSelection(e, t) {
          return {
            kind: "SelectionNode",
            selection: this.transformNode(e.selection, t),
          };
        }
        transformColumn(e, t) {
          return {
            kind: "ColumnNode",
            column: this.transformNode(e.column, t),
          };
        }
        transformAlias(e, t) {
          return {
            kind: "AliasNode",
            node: this.transformNode(e.node, t),
            alias: this.transformNode(e.alias, t),
          };
        }
        transformTable(e, t) {
          return { kind: "TableNode", table: this.transformNode(e.table, t) };
        }
        transformFrom(e, t) {
          return {
            kind: "FromNode",
            froms: this.transformNodeList(e.froms, t),
          };
        }
        transformReference(e, t) {
          return {
            kind: "ReferenceNode",
            column: this.transformNode(e.column, t),
            table: this.transformNode(e.table, t),
          };
        }
        transformAnd(e, t) {
          return {
            kind: "AndNode",
            left: this.transformNode(e.left, t),
            right: this.transformNode(e.right, t),
          };
        }
        transformOr(e, t) {
          return {
            kind: "OrNode",
            left: this.transformNode(e.left, t),
            right: this.transformNode(e.right, t),
          };
        }
        transformValueList(e, t) {
          return {
            kind: "ValueListNode",
            values: this.transformNodeList(e.values, t),
          };
        }
        transformParens(e, t) {
          return { kind: "ParensNode", node: this.transformNode(e.node, t) };
        }
        transformJoin(e, t) {
          return {
            kind: "JoinNode",
            joinType: e.joinType,
            table: this.transformNode(e.table, t),
            on: this.transformNode(e.on, t),
          };
        }
        transformRaw(e, t) {
          return {
            kind: "RawNode",
            sqlFragments: (0, i.CN)([...e.sqlFragments]),
            parameters: this.transformNodeList(e.parameters, t),
          };
        }
        transformWhere(e, t) {
          return { kind: "WhereNode", where: this.transformNode(e.where, t) };
        }
        transformInsertQuery(e, t) {
          return {
            kind: "InsertQueryNode",
            into: this.transformNode(e.into, t),
            columns: this.transformNodeList(e.columns, t),
            values: this.transformNode(e.values, t),
            returning: this.transformNode(e.returning, t),
            onConflict: this.transformNode(e.onConflict, t),
            onDuplicateKey: this.transformNode(e.onDuplicateKey, t),
            endModifiers: this.transformNodeList(e.endModifiers, t),
            with: this.transformNode(e.with, t),
            ignore: e.ignore,
            orAction: this.transformNode(e.orAction, t),
            replace: e.replace,
            explain: this.transformNode(e.explain, t),
            defaultValues: e.defaultValues,
            top: this.transformNode(e.top, t),
            output: this.transformNode(e.output, t),
          };
        }
        transformValues(e, t) {
          return {
            kind: "ValuesNode",
            values: this.transformNodeList(e.values, t),
          };
        }
        transformDeleteQuery(e, t) {
          return {
            kind: "DeleteQueryNode",
            from: this.transformNode(e.from, t),
            using: this.transformNode(e.using, t),
            joins: this.transformNodeList(e.joins, t),
            where: this.transformNode(e.where, t),
            returning: this.transformNode(e.returning, t),
            endModifiers: this.transformNodeList(e.endModifiers, t),
            with: this.transformNode(e.with, t),
            orderBy: this.transformNode(e.orderBy, t),
            limit: this.transformNode(e.limit, t),
            explain: this.transformNode(e.explain, t),
            top: this.transformNode(e.top, t),
            output: this.transformNode(e.output, t),
          };
        }
        transformReturning(e, t) {
          return {
            kind: "ReturningNode",
            selections: this.transformNodeList(e.selections, t),
          };
        }
        transformCreateTable(e, t) {
          return {
            kind: "CreateTableNode",
            table: this.transformNode(e.table, t),
            columns: this.transformNodeList(e.columns, t),
            constraints: this.transformNodeList(e.constraints, t),
            temporary: e.temporary,
            ifNotExists: e.ifNotExists,
            onCommit: e.onCommit,
            frontModifiers: this.transformNodeList(e.frontModifiers, t),
            endModifiers: this.transformNodeList(e.endModifiers, t),
            selectQuery: this.transformNode(e.selectQuery, t),
          };
        }
        transformColumnDefinition(e, t) {
          return {
            kind: "ColumnDefinitionNode",
            column: this.transformNode(e.column, t),
            dataType: this.transformNode(e.dataType, t),
            references: this.transformNode(e.references, t),
            primaryKey: e.primaryKey,
            autoIncrement: e.autoIncrement,
            unique: e.unique,
            notNull: e.notNull,
            unsigned: e.unsigned,
            defaultTo: this.transformNode(e.defaultTo, t),
            check: this.transformNode(e.check, t),
            generated: this.transformNode(e.generated, t),
            frontModifiers: this.transformNodeList(e.frontModifiers, t),
            endModifiers: this.transformNodeList(e.endModifiers, t),
            nullsNotDistinct: e.nullsNotDistinct,
            identity: e.identity,
            ifNotExists: e.ifNotExists,
          };
        }
        transformAddColumn(e, t) {
          return {
            kind: "AddColumnNode",
            column: this.transformNode(e.column, t),
          };
        }
        transformDropTable(e, t) {
          return {
            kind: "DropTableNode",
            table: this.transformNode(e.table, t),
            ifExists: e.ifExists,
            cascade: e.cascade,
          };
        }
        transformOrderBy(e, t) {
          return {
            kind: "OrderByNode",
            items: this.transformNodeList(e.items, t),
          };
        }
        transformOrderByItem(e, t) {
          return {
            kind: "OrderByItemNode",
            orderBy: this.transformNode(e.orderBy, t),
            direction: this.transformNode(e.direction, t),
            collation: this.transformNode(e.collation, t),
            nulls: e.nulls,
          };
        }
        transformGroupBy(e, t) {
          return {
            kind: "GroupByNode",
            items: this.transformNodeList(e.items, t),
          };
        }
        transformGroupByItem(e, t) {
          return {
            kind: "GroupByItemNode",
            groupBy: this.transformNode(e.groupBy, t),
          };
        }
        transformUpdateQuery(e, t) {
          return {
            kind: "UpdateQueryNode",
            table: this.transformNode(e.table, t),
            from: this.transformNode(e.from, t),
            joins: this.transformNodeList(e.joins, t),
            where: this.transformNode(e.where, t),
            updates: this.transformNodeList(e.updates, t),
            returning: this.transformNode(e.returning, t),
            endModifiers: this.transformNodeList(e.endModifiers, t),
            with: this.transformNode(e.with, t),
            explain: this.transformNode(e.explain, t),
            limit: this.transformNode(e.limit, t),
            top: this.transformNode(e.top, t),
            output: this.transformNode(e.output, t),
            orderBy: this.transformNode(e.orderBy, t),
          };
        }
        transformColumnUpdate(e, t) {
          return {
            kind: "ColumnUpdateNode",
            column: this.transformNode(e.column, t),
            value: this.transformNode(e.value, t),
          };
        }
        transformLimit(e, t) {
          return { kind: "LimitNode", limit: this.transformNode(e.limit, t) };
        }
        transformOffset(e, t) {
          return {
            kind: "OffsetNode",
            offset: this.transformNode(e.offset, t),
          };
        }
        transformOnConflict(e, t) {
          return {
            kind: "OnConflictNode",
            columns: this.transformNodeList(e.columns, t),
            constraint: this.transformNode(e.constraint, t),
            indexExpression: this.transformNode(e.indexExpression, t),
            indexWhere: this.transformNode(e.indexWhere, t),
            updates: this.transformNodeList(e.updates, t),
            updateWhere: this.transformNode(e.updateWhere, t),
            doNothing: e.doNothing,
          };
        }
        transformOnDuplicateKey(e, t) {
          return {
            kind: "OnDuplicateKeyNode",
            updates: this.transformNodeList(e.updates, t),
          };
        }
        transformCreateIndex(e, t) {
          return {
            kind: "CreateIndexNode",
            name: this.transformNode(e.name, t),
            table: this.transformNode(e.table, t),
            columns: this.transformNodeList(e.columns, t),
            unique: e.unique,
            using: this.transformNode(e.using, t),
            ifNotExists: e.ifNotExists,
            where: this.transformNode(e.where, t),
            nullsNotDistinct: e.nullsNotDistinct,
          };
        }
        transformList(e, t) {
          return {
            kind: "ListNode",
            items: this.transformNodeList(e.items, t),
          };
        }
        transformDropIndex(e, t) {
          return {
            kind: "DropIndexNode",
            name: this.transformNode(e.name, t),
            table: this.transformNode(e.table, t),
            ifExists: e.ifExists,
            cascade: e.cascade,
          };
        }
        transformPrimaryKeyConstraint(e, t) {
          return {
            kind: "PrimaryKeyConstraintNode",
            columns: this.transformNodeList(e.columns, t),
            name: this.transformNode(e.name, t),
            deferrable: e.deferrable,
            initiallyDeferred: e.initiallyDeferred,
          };
        }
        transformUniqueConstraint(e, t) {
          return {
            kind: "UniqueConstraintNode",
            columns: this.transformNodeList(e.columns, t),
            name: this.transformNode(e.name, t),
            nullsNotDistinct: e.nullsNotDistinct,
            deferrable: e.deferrable,
            initiallyDeferred: e.initiallyDeferred,
          };
        }
        transformForeignKeyConstraint(e, t) {
          return {
            kind: "ForeignKeyConstraintNode",
            columns: this.transformNodeList(e.columns, t),
            references: this.transformNode(e.references, t),
            name: this.transformNode(e.name, t),
            onDelete: e.onDelete,
            onUpdate: e.onUpdate,
            deferrable: e.deferrable,
            initiallyDeferred: e.initiallyDeferred,
          };
        }
        transformSetOperation(e, t) {
          return {
            kind: "SetOperationNode",
            operator: e.operator,
            expression: this.transformNode(e.expression, t),
            all: e.all,
          };
        }
        transformReferences(e, t) {
          return {
            kind: "ReferencesNode",
            table: this.transformNode(e.table, t),
            columns: this.transformNodeList(e.columns, t),
            onDelete: e.onDelete,
            onUpdate: e.onUpdate,
          };
        }
        transformCheckConstraint(e, t) {
          return {
            kind: "CheckConstraintNode",
            expression: this.transformNode(e.expression, t),
            name: this.transformNode(e.name, t),
          };
        }
        transformWith(e, t) {
          return {
            kind: "WithNode",
            expressions: this.transformNodeList(e.expressions, t),
            recursive: e.recursive,
          };
        }
        transformCommonTableExpression(e, t) {
          return {
            kind: "CommonTableExpressionNode",
            name: this.transformNode(e.name, t),
            materialized: e.materialized,
            expression: this.transformNode(e.expression, t),
          };
        }
        transformCommonTableExpressionName(e, t) {
          return {
            kind: "CommonTableExpressionNameNode",
            table: this.transformNode(e.table, t),
            columns: this.transformNodeList(e.columns, t),
          };
        }
        transformHaving(e, t) {
          return {
            kind: "HavingNode",
            having: this.transformNode(e.having, t),
          };
        }
        transformCreateSchema(e, t) {
          return {
            kind: "CreateSchemaNode",
            schema: this.transformNode(e.schema, t),
            ifNotExists: e.ifNotExists,
          };
        }
        transformDropSchema(e, t) {
          return {
            kind: "DropSchemaNode",
            schema: this.transformNode(e.schema, t),
            ifExists: e.ifExists,
            cascade: e.cascade,
          };
        }
        transformAlterTable(e, t) {
          return {
            kind: "AlterTableNode",
            table: this.transformNode(e.table, t),
            renameTo: this.transformNode(e.renameTo, t),
            setSchema: this.transformNode(e.setSchema, t),
            columnAlterations: this.transformNodeList(e.columnAlterations, t),
            addConstraint: this.transformNode(e.addConstraint, t),
            dropConstraint: this.transformNode(e.dropConstraint, t),
            renameConstraint: this.transformNode(e.renameConstraint, t),
            addIndex: this.transformNode(e.addIndex, t),
            dropIndex: this.transformNode(e.dropIndex, t),
          };
        }
        transformDropColumn(e, t) {
          return {
            kind: "DropColumnNode",
            column: this.transformNode(e.column, t),
          };
        }
        transformRenameColumn(e, t) {
          return {
            kind: "RenameColumnNode",
            column: this.transformNode(e.column, t),
            renameTo: this.transformNode(e.renameTo, t),
          };
        }
        transformAlterColumn(e, t) {
          return {
            kind: "AlterColumnNode",
            column: this.transformNode(e.column, t),
            dataType: this.transformNode(e.dataType, t),
            dataTypeExpression: this.transformNode(e.dataTypeExpression, t),
            setDefault: this.transformNode(e.setDefault, t),
            dropDefault: e.dropDefault,
            setNotNull: e.setNotNull,
            dropNotNull: e.dropNotNull,
          };
        }
        transformModifyColumn(e, t) {
          return {
            kind: "ModifyColumnNode",
            column: this.transformNode(e.column, t),
          };
        }
        transformAddConstraint(e, t) {
          return {
            kind: "AddConstraintNode",
            constraint: this.transformNode(e.constraint, t),
          };
        }
        transformDropConstraint(e, t) {
          return {
            kind: "DropConstraintNode",
            constraintName: this.transformNode(e.constraintName, t),
            ifExists: e.ifExists,
            modifier: e.modifier,
          };
        }
        transformRenameConstraint(e, t) {
          return {
            kind: "RenameConstraintNode",
            oldName: this.transformNode(e.oldName, t),
            newName: this.transformNode(e.newName, t),
          };
        }
        transformCreateView(e, t) {
          return {
            kind: "CreateViewNode",
            name: this.transformNode(e.name, t),
            temporary: e.temporary,
            orReplace: e.orReplace,
            ifNotExists: e.ifNotExists,
            materialized: e.materialized,
            columns: this.transformNodeList(e.columns, t),
            as: this.transformNode(e.as, t),
          };
        }
        transformRefreshMaterializedView(e, t) {
          return {
            kind: "RefreshMaterializedViewNode",
            name: this.transformNode(e.name, t),
            concurrently: e.concurrently,
            withNoData: e.withNoData,
          };
        }
        transformDropView(e, t) {
          return {
            kind: "DropViewNode",
            name: this.transformNode(e.name, t),
            ifExists: e.ifExists,
            materialized: e.materialized,
            cascade: e.cascade,
          };
        }
        transformGenerated(e, t) {
          return {
            kind: "GeneratedNode",
            byDefault: e.byDefault,
            always: e.always,
            identity: e.identity,
            stored: e.stored,
            expression: this.transformNode(e.expression, t),
          };
        }
        transformDefaultValue(e, t) {
          return {
            kind: "DefaultValueNode",
            defaultValue: this.transformNode(e.defaultValue, t),
          };
        }
        transformOn(e, t) {
          return { kind: "OnNode", on: this.transformNode(e.on, t) };
        }
        transformSelectModifier(e, t) {
          return {
            kind: "SelectModifierNode",
            modifier: e.modifier,
            rawModifier: this.transformNode(e.rawModifier, t),
            of: this.transformNodeList(e.of, t),
          };
        }
        transformCreateType(e, t) {
          return {
            kind: "CreateTypeNode",
            name: this.transformNode(e.name, t),
            enum: this.transformNode(e.enum, t),
          };
        }
        transformDropType(e, t) {
          return {
            kind: "DropTypeNode",
            name: this.transformNode(e.name, t),
            ifExists: e.ifExists,
          };
        }
        transformExplain(e, t) {
          return {
            kind: "ExplainNode",
            format: e.format,
            options: this.transformNode(e.options, t),
          };
        }
        transformSchemableIdentifier(e, t) {
          return {
            kind: "SchemableIdentifierNode",
            schema: this.transformNode(e.schema, t),
            identifier: this.transformNode(e.identifier, t),
          };
        }
        transformAggregateFunction(e, t) {
          return {
            kind: "AggregateFunctionNode",
            func: e.func,
            aggregated: this.transformNodeList(e.aggregated, t),
            distinct: e.distinct,
            orderBy: this.transformNode(e.orderBy, t),
            withinGroup: this.transformNode(e.withinGroup, t),
            filter: this.transformNode(e.filter, t),
            over: this.transformNode(e.over, t),
          };
        }
        transformOver(e, t) {
          return {
            kind: "OverNode",
            orderBy: this.transformNode(e.orderBy, t),
            partitionBy: this.transformNode(e.partitionBy, t),
          };
        }
        transformPartitionBy(e, t) {
          return {
            kind: "PartitionByNode",
            items: this.transformNodeList(e.items, t),
          };
        }
        transformPartitionByItem(e, t) {
          return {
            kind: "PartitionByItemNode",
            partitionBy: this.transformNode(e.partitionBy, t),
          };
        }
        transformBinaryOperation(e, t) {
          return {
            kind: "BinaryOperationNode",
            leftOperand: this.transformNode(e.leftOperand, t),
            operator: this.transformNode(e.operator, t),
            rightOperand: this.transformNode(e.rightOperand, t),
          };
        }
        transformUnaryOperation(e, t) {
          return {
            kind: "UnaryOperationNode",
            operator: this.transformNode(e.operator, t),
            operand: this.transformNode(e.operand, t),
          };
        }
        transformUsing(e, t) {
          return {
            kind: "UsingNode",
            tables: this.transformNodeList(e.tables, t),
          };
        }
        transformFunction(e, t) {
          return {
            kind: "FunctionNode",
            func: e.func,
            arguments: this.transformNodeList(e.arguments, t),
          };
        }
        transformCase(e, t) {
          return {
            kind: "CaseNode",
            value: this.transformNode(e.value, t),
            when: this.transformNodeList(e.when, t),
            else: this.transformNode(e.else, t),
            isStatement: e.isStatement,
          };
        }
        transformWhen(e, t) {
          return {
            kind: "WhenNode",
            condition: this.transformNode(e.condition, t),
            result: this.transformNode(e.result, t),
          };
        }
        transformJSONReference(e, t) {
          return {
            kind: "JSONReferenceNode",
            reference: this.transformNode(e.reference, t),
            traversal: this.transformNode(e.traversal, t),
          };
        }
        transformJSONPath(e, t) {
          return {
            kind: "JSONPathNode",
            inOperator: this.transformNode(e.inOperator, t),
            pathLegs: this.transformNodeList(e.pathLegs, t),
          };
        }
        transformJSONPathLeg(e, t) {
          return { kind: "JSONPathLegNode", type: e.type, value: e.value };
        }
        transformJSONOperatorChain(e, t) {
          return {
            kind: "JSONOperatorChainNode",
            operator: this.transformNode(e.operator, t),
            values: this.transformNodeList(e.values, t),
          };
        }
        transformTuple(e, t) {
          return {
            kind: "TupleNode",
            values: this.transformNodeList(e.values, t),
          };
        }
        transformMergeQuery(e, t) {
          return {
            kind: "MergeQueryNode",
            into: this.transformNode(e.into, t),
            using: this.transformNode(e.using, t),
            whens: this.transformNodeList(e.whens, t),
            with: this.transformNode(e.with, t),
            top: this.transformNode(e.top, t),
            endModifiers: this.transformNodeList(e.endModifiers, t),
            output: this.transformNode(e.output, t),
            returning: this.transformNode(e.returning, t),
          };
        }
        transformMatched(e, t) {
          return { kind: "MatchedNode", not: e.not, bySource: e.bySource };
        }
        transformAddIndex(e, t) {
          return {
            kind: "AddIndexNode",
            name: this.transformNode(e.name, t),
            columns: this.transformNodeList(e.columns, t),
            unique: e.unique,
            using: this.transformNode(e.using, t),
            ifNotExists: e.ifNotExists,
          };
        }
        transformCast(e, t) {
          return {
            kind: "CastNode",
            expression: this.transformNode(e.expression, t),
            dataType: this.transformNode(e.dataType, t),
          };
        }
        transformFetch(e, t) {
          return {
            kind: "FetchNode",
            rowCount: this.transformNode(e.rowCount, t),
            modifier: e.modifier,
          };
        }
        transformTop(e, t) {
          return {
            kind: "TopNode",
            expression: e.expression,
            modifiers: e.modifiers,
          };
        }
        transformOutput(e, t) {
          return {
            kind: "OutputNode",
            selections: this.transformNodeList(e.selections, t),
          };
        }
        transformDataType(e, t) {
          return e;
        }
        transformSelectAll(e, t) {
          return e;
        }
        transformIdentifier(e, t) {
          return e;
        }
        transformValue(e, t) {
          return e;
        }
        transformPrimitiveValueList(e, t) {
          return e;
        }
        transformOperator(e, t) {
          return e;
        }
        transformDefaultInsertValue(e, t) {
          return e;
        }
        transformOrAction(e, t) {
          return e;
        }
        transformCollate(e, t) {
          return e;
        }
      }
    },
    72259: (e, t, r) => {
      r.d(t, {
        DV: () => d,
        He: () =>
          function e(t, r) {
            return Object.entries(t).reduce((t, [o, l]) => {
              if ("string" != typeof o) return t;
              let c = r ? [...r, o] : [o];
              return (
                (0, n.is)(l, i.V) ||
                (0, n.is)(l, s.Xs) ||
                (0, n.is)(l, s.Xs.Aliased)
                  ? t.push({ path: c, field: l })
                  : (0, n.is)(l, a.XI)
                    ? t.push(...e(l[a.XI.Symbol.Columns], c))
                    : t.push(...e(l, c)),
                t
              );
            }, []);
          },
        Ll: () => m,
        Lq: () => y,
        XJ: () => h,
        YD: () => p,
        a6: () => c,
        q: () => u,
        zN: () => f,
      });
      var i = r(93994),
        n = r(90211),
        s = r(11916),
        o = r(80382),
        a = r(47590),
        l = r(91631);
      function c(e, t, r) {
        let o = {},
          l = e.reduce((e, { path: l, field: c }, d) => {
            let u;
            u = (0, n.is)(c, i.V)
              ? c
              : (0, n.is)(c, s.Xs)
                ? c.decoder
                : c.sql.decoder;
            let h = e;
            for (let [e, s] of l.entries())
              if (e < l.length - 1) s in h || (h[s] = {}), (h = h[s]);
              else {
                let e = t[d],
                  p = (h[s] = null === e ? null : u.mapFromDriverValue(e));
                if (r && (0, n.is)(c, i.V) && 2 === l.length) {
                  let e = l[0];
                  e in o
                    ? "string" == typeof o[e] &&
                      o[e] !== (0, a.Io)(c.table) &&
                      (o[e] = !1)
                    : (o[e] = null === p && (0, a.Io)(c.table));
                }
              }
            return e;
          }, {});
        if (r && Object.keys(o).length > 0)
          for (let [e, t] of Object.entries(o))
            "string" != typeof t || r[t] || (l[e] = null);
        return l;
      }
      function d(e, t) {
        let r = Object.keys(e),
          i = Object.keys(t);
        if (r.length !== i.length) return !1;
        for (let [e, t] of r.entries()) if (t !== i[e]) return !1;
        return !0;
      }
      function u(e, t) {
        let r = Object.entries(t)
          .filter(([, e]) => void 0 !== e)
          .map(([t, r]) =>
            (0, n.is)(r, s.Xs) || (0, n.is)(r, i.V)
              ? [t, r]
              : [t, new s.Iw(r, e[a.XI.Symbol.Columns][t])]
          );
        if (0 === r.length) throw Error("No values to set");
        return Object.fromEntries(r);
      }
      function h(e, t) {
        for (let r of t)
          for (let t of Object.getOwnPropertyNames(r.prototype))
            "constructor" !== t &&
              Object.defineProperty(
                e.prototype,
                t,
                Object.getOwnPropertyDescriptor(r.prototype, t) ||
                  Object.create(null)
              );
      }
      function p(e) {
        return e[a.XI.Symbol.Columns];
      }
      function f(e) {
        return (0, n.is)(e, o.n)
          ? e._.alias
          : (0, n.is)(e, s.Ss)
            ? e[l.n].name
            : (0, n.is)(e, s.Xs)
              ? void 0
              : e[a.XI.Symbol.IsAlias]
                ? e[a.XI.Symbol.Name]
                : e[a.XI.Symbol.BaseName];
      }
      function m(e, t) {
        return {
          name: "string" == typeof e && e.length > 0 ? e : "",
          config: "object" == typeof e ? e : t,
        };
      }
      function y(e) {
        if (
          "object" != typeof e ||
          null === e ||
          "Object" !== e.constructor.name
        )
          return !1;
        if ("logger" in e) {
          let t = typeof e.logger;
          return (
            "boolean" === t ||
            ("object" === t && "function" == typeof e.logger.logQuery) ||
            "undefined" === t
          );
        }
        if ("schema" in e) {
          let t = typeof e.schema;
          return "object" === t || "undefined" === t;
        }
        if ("casing" in e) {
          let t = typeof e.casing;
          return "string" === t || "undefined" === t;
        }
        if ("mode" in e)
          return (
            "default" === e.mode &&
            "planetscale" === e.mode &&
            void 0 === e.mode
          );
        if ("connection" in e) {
          let t = typeof e.connection;
          return "string" === t || "object" === t || "undefined" === t;
        }
        if ("client" in e) {
          let t = typeof e.client;
          return "object" === t || "function" === t || "undefined" === t;
        }
        return 0 === Object.keys(e).length;
      }
    },
    72623: (e, t, r) => {
      r.d(t, { A: () => s, R: () => o });
      var i = r(77598),
        n = r(57975);
      let s = i.webcrypto,
        o = (e) => n.types.isCryptoKey(e);
    },
    73574: (e, t, r) => {
      r.d(t, { Q: () => l });
      var i = r(96051);
      let n = [
          "varchar",
          "char",
          "text",
          "integer",
          "int2",
          "int4",
          "int8",
          "smallint",
          "bigint",
          "boolean",
          "real",
          "double precision",
          "float4",
          "float8",
          "decimal",
          "numeric",
          "binary",
          "bytea",
          "date",
          "datetime",
          "time",
          "timetz",
          "timestamp",
          "timestamptz",
          "serial",
          "bigserial",
          "uuid",
          "json",
          "jsonb",
          "blob",
          "varbinary",
          "int4range",
          "int4multirange",
          "int8range",
          "int8multirange",
          "numrange",
          "nummultirange",
          "tsrange",
          "tsmultirange",
          "tstzrange",
          "tstzmultirange",
          "daterange",
          "datemultirange",
        ],
        s = [
          /^varchar\(\d+\)$/,
          /^char\(\d+\)$/,
          /^decimal\(\d+, \d+\)$/,
          /^numeric\(\d+, \d+\)$/,
          /^binary\(\d+\)$/,
          /^datetime\(\d+\)$/,
          /^time\(\d+\)$/,
          /^timetz\(\d+\)$/,
          /^timestamp\(\d+\)$/,
          /^timestamptz\(\d+\)$/,
          /^varbinary\(\d+\)$/,
        ],
        o = (0, i.CN)({
          is: (e) => "DataTypeNode" === e.kind,
          create: (e) => (0, i.CN)({ kind: "DataTypeNode", dataType: e }),
        });
      var a = r(10132);
      function l(e) {
        if ((0, a.N)(e)) return e.toOperationNode();
        if (n.includes(e) || s.some((t) => t.test(e))) return o.create(e);
        throw Error(`invalid column data type ${JSON.stringify(e)}`);
      }
    },
    74338: (e, t, r) => {
      r.d(t, { A: () => i });
      let i = (...e) => {
        let t,
          r = e.filter(Boolean);
        if (0 === r.length || 1 === r.length) return !0;
        for (let e of r) {
          let r = Object.keys(e);
          if (!t || 0 === t.size) {
            t = new Set(r);
            continue;
          }
          for (let e of r) {
            if (t.has(e)) return !1;
            t.add(e);
          }
        }
        return !0;
      };
    },
    74465: (e, t, r) => {
      r.d(t, { t: () => n });
      var i = r(96051);
      let n = (0, i.CN)({
        is: (e) => "WhenNode" === e.kind,
        create: (e) => (0, i.CN)({ kind: "WhenNode", condition: e }),
        cloneWithResult: (e, t) => (0, i.CN)({ ...e, result: t }),
      });
    },
    74850: (e, t, r) => {
      r.d(t, {
        GB: () => p,
        KN: () => g,
        Ve: () => y,
        ds: () => f,
        vC: () => m,
      });
      var i = r(62534),
        n = r(96051),
        s = r(10132),
        o = r(36357),
        a = r(666),
        l = r(11750),
        c = r(89400),
        d = r(42188),
        u = r(19334),
        h = r(1518);
      function p(e) {
        if (3 === e.length) return f(e[0], e[1], e[2]);
        if (1 === e.length) return (0, l.$s)(e[0]);
        throw Error(`invalid arguments: ${JSON.stringify(e)}`);
      }
      function f(e, t, r) {
        var n;
        return ("is" === (n = t) || "is not" === n) && w(r)
          ? i.l.create((0, a.$O)(e), b(t), c.q.createImmediate(r))
          : i.l.create((0, a.$O)(e), b(t), (0, l.U2)(r));
      }
      function m(e, t, r) {
        return i.l.create((0, a.$O)(e), b(t), (0, a.$O)(r));
      }
      function y(e, t) {
        return g(
          Object.entries(e)
            .filter(([, e]) => !(0, n.b0)(e))
            .map(([e, t]) => f(e, w(t) ? "is" : "=", t)),
          t
        );
      }
      function g(e, t, r = !0) {
        let n = "and" === t ? d.s.create : h.K.create;
        if (0 === e.length)
          return i.l.create(
            c.q.createImmediate(1),
            o.zX.create("="),
            c.q.createImmediate(+("and" === t))
          );
        let s = v(e[0]);
        for (let t = 1; t < e.length; ++t) s = n(s, v(e[t]));
        return e.length > 1 && r ? u.k.create(s) : s;
      }
      function w(e) {
        return (0, n.kZ)(e) || (0, n.Lm)(e);
      }
      function b(e) {
        if ((0, n.Kg)(e) && o.we.includes(e)) return o.zX.create(e);
        if ((0, s.N)(e)) return e.toOperationNode();
        throw Error(`invalid operator ${JSON.stringify(e)}`);
      }
      function v(e) {
        return (0, s.N)(e) ? e.toOperationNode() : e;
      }
    },
    74945: (e, t, r) => {
      r.d(t, { u: () => o });
      var i = r(90211),
        n = r(11916),
        s = r(64055);
      class o extends s.pe {
        static [i.i] = "PgDateColumnBaseBuilder";
        defaultNow() {
          return this.default((0, n.ll)`now()`);
        }
      }
    },
    75423: (e, t, r) => {
      r.d(t, { SS: () => c, YK: () => a, v0: () => l });
      var i = r(99144),
        n = r(10132),
        s = r(95235),
        o = r(96051);
      function a(e) {
        if ((0, n.N)(e)) return e.toOperationNode();
        if ((0, o.Tn)(e)) return e((0, s.A)()).toOperationNode();
        throw Error(`invalid expression: ${JSON.stringify(e)}`);
      }
      function l(e) {
        if ((0, n.N)(e)) return e.toOperationNode();
        if ((0, o.Tn)(e)) return e((0, s.A)()).toOperationNode();
        throw Error(`invalid aliased expression: ${JSON.stringify(e)}`);
      }
      function c(e) {
        return (0, i.B)(e) || (0, i.q)(e) || (0, o.Tn)(e);
      }
    },
    75456: (e, t, r) => {
      r.d(t, { M3: () => o, W2: () => s, ll: () => n, t9: () => a });
      var i = r(81385);
      function n(e) {
        return (0, i.A)(e) && "string" == typeof e.kty;
      }
      function s(e) {
        return "oct" !== e.kty && "string" == typeof e.d;
      }
      function o(e) {
        return "oct" !== e.kty && void 0 === e.d;
      }
      function a(e) {
        return n(e) && "oct" === e.kty && "string" == typeof e.k;
      }
    },
    76221: (e, t, r) => {
      r.d(t, { A: () => d });
      var i = r(77598),
        n = r(57975),
        s = r(12455),
        o = r(41321),
        a = r(80602),
        l = r(3520);
      let c = (0, n.promisify)(i.sign),
        d = async (e, t, r) => {
          let n = (0, l.A)(e, t, "sign");
          if (e.startsWith("HS")) {
            let t = i.createHmac(
              (function (e) {
                switch (e) {
                  case "HS256":
                    return "sha256";
                  case "HS384":
                    return "sha384";
                  case "HS512":
                    return "sha512";
                  default:
                    throw new o.T0(
                      `alg ${e} is not supported either by JOSE or your javascript runtime`
                    );
                }
              })(e),
              n
            );
            return t.update(r), t.digest();
          }
          return c((0, s.A)(e), r, (0, a.A)(e, n));
        };
    },
    77255: (e, t, r) => {
      r.d(t, { Z: () => s });
      var i = r(96051),
        n = r(67872);
      let s = (0, i.CN)({
        is: (e) => "ColumnNode" === e.kind,
        create: (e) => (0, i.CN)({ kind: "ColumnNode", column: n.O.create(e) }),
      });
    },
    77329: (e, t, r) => {
      r.d(t, { n: () => m });
      var i = r(30154),
        n = r(29597),
        s = r(96051);
      class o {
        nodeStack = [];
        get parentNode() {
          return this.nodeStack[this.nodeStack.length - 2];
        }
        #y = (0, s.CN)({
          AliasNode: this.visitAlias.bind(this),
          ColumnNode: this.visitColumn.bind(this),
          IdentifierNode: this.visitIdentifier.bind(this),
          SchemableIdentifierNode: this.visitSchemableIdentifier.bind(this),
          RawNode: this.visitRaw.bind(this),
          ReferenceNode: this.visitReference.bind(this),
          SelectQueryNode: this.visitSelectQuery.bind(this),
          SelectionNode: this.visitSelection.bind(this),
          TableNode: this.visitTable.bind(this),
          FromNode: this.visitFrom.bind(this),
          SelectAllNode: this.visitSelectAll.bind(this),
          AndNode: this.visitAnd.bind(this),
          OrNode: this.visitOr.bind(this),
          ValueNode: this.visitValue.bind(this),
          ValueListNode: this.visitValueList.bind(this),
          PrimitiveValueListNode: this.visitPrimitiveValueList.bind(this),
          ParensNode: this.visitParens.bind(this),
          JoinNode: this.visitJoin.bind(this),
          OperatorNode: this.visitOperator.bind(this),
          WhereNode: this.visitWhere.bind(this),
          InsertQueryNode: this.visitInsertQuery.bind(this),
          DeleteQueryNode: this.visitDeleteQuery.bind(this),
          ReturningNode: this.visitReturning.bind(this),
          CreateTableNode: this.visitCreateTable.bind(this),
          AddColumnNode: this.visitAddColumn.bind(this),
          ColumnDefinitionNode: this.visitColumnDefinition.bind(this),
          DropTableNode: this.visitDropTable.bind(this),
          DataTypeNode: this.visitDataType.bind(this),
          OrderByNode: this.visitOrderBy.bind(this),
          OrderByItemNode: this.visitOrderByItem.bind(this),
          GroupByNode: this.visitGroupBy.bind(this),
          GroupByItemNode: this.visitGroupByItem.bind(this),
          UpdateQueryNode: this.visitUpdateQuery.bind(this),
          ColumnUpdateNode: this.visitColumnUpdate.bind(this),
          LimitNode: this.visitLimit.bind(this),
          OffsetNode: this.visitOffset.bind(this),
          OnConflictNode: this.visitOnConflict.bind(this),
          OnDuplicateKeyNode: this.visitOnDuplicateKey.bind(this),
          CreateIndexNode: this.visitCreateIndex.bind(this),
          DropIndexNode: this.visitDropIndex.bind(this),
          ListNode: this.visitList.bind(this),
          PrimaryKeyConstraintNode: this.visitPrimaryKeyConstraint.bind(this),
          UniqueConstraintNode: this.visitUniqueConstraint.bind(this),
          ReferencesNode: this.visitReferences.bind(this),
          CheckConstraintNode: this.visitCheckConstraint.bind(this),
          WithNode: this.visitWith.bind(this),
          CommonTableExpressionNode: this.visitCommonTableExpression.bind(this),
          CommonTableExpressionNameNode:
            this.visitCommonTableExpressionName.bind(this),
          HavingNode: this.visitHaving.bind(this),
          CreateSchemaNode: this.visitCreateSchema.bind(this),
          DropSchemaNode: this.visitDropSchema.bind(this),
          AlterTableNode: this.visitAlterTable.bind(this),
          DropColumnNode: this.visitDropColumn.bind(this),
          RenameColumnNode: this.visitRenameColumn.bind(this),
          AlterColumnNode: this.visitAlterColumn.bind(this),
          ModifyColumnNode: this.visitModifyColumn.bind(this),
          AddConstraintNode: this.visitAddConstraint.bind(this),
          DropConstraintNode: this.visitDropConstraint.bind(this),
          RenameConstraintNode: this.visitRenameConstraint.bind(this),
          ForeignKeyConstraintNode: this.visitForeignKeyConstraint.bind(this),
          CreateViewNode: this.visitCreateView.bind(this),
          RefreshMaterializedViewNode:
            this.visitRefreshMaterializedView.bind(this),
          DropViewNode: this.visitDropView.bind(this),
          GeneratedNode: this.visitGenerated.bind(this),
          DefaultValueNode: this.visitDefaultValue.bind(this),
          OnNode: this.visitOn.bind(this),
          ValuesNode: this.visitValues.bind(this),
          SelectModifierNode: this.visitSelectModifier.bind(this),
          CreateTypeNode: this.visitCreateType.bind(this),
          DropTypeNode: this.visitDropType.bind(this),
          ExplainNode: this.visitExplain.bind(this),
          DefaultInsertValueNode: this.visitDefaultInsertValue.bind(this),
          AggregateFunctionNode: this.visitAggregateFunction.bind(this),
          OverNode: this.visitOver.bind(this),
          PartitionByNode: this.visitPartitionBy.bind(this),
          PartitionByItemNode: this.visitPartitionByItem.bind(this),
          SetOperationNode: this.visitSetOperation.bind(this),
          BinaryOperationNode: this.visitBinaryOperation.bind(this),
          UnaryOperationNode: this.visitUnaryOperation.bind(this),
          UsingNode: this.visitUsing.bind(this),
          FunctionNode: this.visitFunction.bind(this),
          CaseNode: this.visitCase.bind(this),
          WhenNode: this.visitWhen.bind(this),
          JSONReferenceNode: this.visitJSONReference.bind(this),
          JSONPathNode: this.visitJSONPath.bind(this),
          JSONPathLegNode: this.visitJSONPathLeg.bind(this),
          JSONOperatorChainNode: this.visitJSONOperatorChain.bind(this),
          TupleNode: this.visitTuple.bind(this),
          MergeQueryNode: this.visitMergeQuery.bind(this),
          MatchedNode: this.visitMatched.bind(this),
          AddIndexNode: this.visitAddIndex.bind(this),
          CastNode: this.visitCast.bind(this),
          FetchNode: this.visitFetch.bind(this),
          TopNode: this.visitTop.bind(this),
          OutputNode: this.visitOutput.bind(this),
          OrActionNode: this.visitOrAction.bind(this),
          CollateNode: this.visitCollate.bind(this),
        });
        visitNode = (e) => {
          this.nodeStack.push(e), this.#y[e.kind](e), this.nodeStack.pop();
        };
      }
      var a = r(36357),
        l = r(19334),
        c = r(64992),
        d = r(49925),
        u = r(82779),
        h = r(57960),
        p = r(2444);
      let f = /'/g;
      class m extends o {
        #g = "";
        #w = [];
        get numParameters() {
          return this.#w.length;
        }
        compileQuery(e, t) {
          return (
            (this.#g = ""),
            (this.#w = []),
            this.nodeStack.splice(0, this.nodeStack.length),
            this.visitNode(e),
            (0, s.CN)({
              query: e,
              queryId: t,
              sql: this.getSql(),
              parameters: [...this.#w],
            })
          );
        }
        getSql() {
          return this.#g;
        }
        visitSelectQuery(e) {
          let t =
            void 0 !== this.parentNode &&
            !l.k.is(this.parentNode) &&
            !n.o.is(this.parentNode) &&
            !i.B.is(this.parentNode) &&
            !d.Y.is(this.parentNode) &&
            !u.i.is(this.parentNode);
          void 0 === this.parentNode &&
            e.explain &&
            (this.visitNode(e.explain), this.append(" ")),
            t && this.append("("),
            e.with && (this.visitNode(e.with), this.append(" ")),
            this.append("select"),
            e.distinctOn &&
              (this.append(" "), this.compileDistinctOn(e.distinctOn)),
            e.frontModifiers?.length &&
              (this.append(" "), this.compileList(e.frontModifiers, " ")),
            e.top && (this.append(" "), this.visitNode(e.top)),
            e.selections && (this.append(" "), this.compileList(e.selections)),
            e.from && (this.append(" "), this.visitNode(e.from)),
            e.joins && (this.append(" "), this.compileList(e.joins, " ")),
            e.where && (this.append(" "), this.visitNode(e.where)),
            e.groupBy && (this.append(" "), this.visitNode(e.groupBy)),
            e.having && (this.append(" "), this.visitNode(e.having)),
            e.setOperations &&
              (this.append(" "), this.compileList(e.setOperations, " ")),
            e.orderBy && (this.append(" "), this.visitNode(e.orderBy)),
            e.limit && (this.append(" "), this.visitNode(e.limit)),
            e.offset && (this.append(" "), this.visitNode(e.offset)),
            e.fetch && (this.append(" "), this.visitNode(e.fetch)),
            e.endModifiers?.length &&
              (this.append(" "),
              this.compileList(
                this.sortSelectModifiers([...e.endModifiers]),
                " "
              )),
            t && this.append(")");
        }
        visitFrom(e) {
          this.append("from "), this.compileList(e.froms);
        }
        visitSelection(e) {
          this.visitNode(e.selection);
        }
        visitColumn(e) {
          this.visitNode(e.column);
        }
        compileDistinctOn(e) {
          this.append("distinct on ("), this.compileList(e), this.append(")");
        }
        compileList(e, t = ", ") {
          let r = e.length - 1;
          for (let i = 0; i <= r; i++)
            this.visitNode(e[i]), i < r && this.append(t);
        }
        visitWhere(e) {
          this.append("where "), this.visitNode(e.where);
        }
        visitHaving(e) {
          this.append("having "), this.visitNode(e.having);
        }
        visitInsertQuery(e) {
          let t = this.nodeStack.find(c.L.is),
            r = t !== e;
          !r && e.explain && (this.visitNode(e.explain), this.append(" ")),
            r && !h.r.is(t) && this.append("("),
            e.with && (this.visitNode(e.with), this.append(" ")),
            this.append(e.replace ? "replace" : "insert"),
            e.ignore &&
              ((0, p.u)(
                "`InsertQueryNode.ignore` is deprecated. Use `InsertQueryNode.orAction` instead."
              ),
              this.append(" ignore")),
            e.orAction && (this.append(" "), this.visitNode(e.orAction)),
            e.top && (this.append(" "), this.visitNode(e.top)),
            e.into && (this.append(" into "), this.visitNode(e.into)),
            e.columns &&
              (this.append(" ("),
              this.compileList(e.columns),
              this.append(")")),
            e.output && (this.append(" "), this.visitNode(e.output)),
            e.values && (this.append(" "), this.visitNode(e.values)),
            e.defaultValues &&
              (this.append(" "), this.append("default values")),
            e.onConflict && (this.append(" "), this.visitNode(e.onConflict)),
            e.onDuplicateKey &&
              (this.append(" "), this.visitNode(e.onDuplicateKey)),
            e.returning && (this.append(" "), this.visitNode(e.returning)),
            r && !h.r.is(t) && this.append(")"),
            e.endModifiers?.length &&
              (this.append(" "), this.compileList(e.endModifiers, " "));
        }
        visitValues(e) {
          this.append("values "), this.compileList(e.values);
        }
        visitDeleteQuery(e) {
          let t = this.nodeStack.find(c.L.is) !== e;
          !t && e.explain && (this.visitNode(e.explain), this.append(" ")),
            t && this.append("("),
            e.with && (this.visitNode(e.with), this.append(" ")),
            this.append("delete "),
            e.top && (this.visitNode(e.top), this.append(" ")),
            this.visitNode(e.from),
            e.output && (this.append(" "), this.visitNode(e.output)),
            e.using && (this.append(" "), this.visitNode(e.using)),
            e.joins && (this.append(" "), this.compileList(e.joins, " ")),
            e.where && (this.append(" "), this.visitNode(e.where)),
            e.orderBy && (this.append(" "), this.visitNode(e.orderBy)),
            e.limit && (this.append(" "), this.visitNode(e.limit)),
            e.returning && (this.append(" "), this.visitNode(e.returning)),
            t && this.append(")"),
            e.endModifiers?.length &&
              (this.append(" "), this.compileList(e.endModifiers, " "));
        }
        visitReturning(e) {
          this.append("returning "), this.compileList(e.selections);
        }
        visitAlias(e) {
          this.visitNode(e.node), this.append(" as "), this.visitNode(e.alias);
        }
        visitReference(e) {
          e.table && (this.visitNode(e.table), this.append(".")),
            this.visitNode(e.column);
        }
        visitSelectAll(e) {
          this.append("*");
        }
        visitIdentifier(e) {
          this.append(this.getLeftIdentifierWrapper()),
            this.compileUnwrappedIdentifier(e),
            this.append(this.getRightIdentifierWrapper());
        }
        compileUnwrappedIdentifier(e) {
          if (!(0, s.Kg)(e.name))
            throw Error(
              "a non-string identifier was passed to compileUnwrappedIdentifier."
            );
          this.append(this.sanitizeIdentifier(e.name));
        }
        visitAnd(e) {
          this.visitNode(e.left), this.append(" and "), this.visitNode(e.right);
        }
        visitOr(e) {
          this.visitNode(e.left), this.append(" or "), this.visitNode(e.right);
        }
        visitValue(e) {
          e.immediate
            ? this.appendImmediateValue(e.value)
            : this.appendValue(e.value);
        }
        visitValueList(e) {
          this.append("("), this.compileList(e.values), this.append(")");
        }
        visitTuple(e) {
          this.append("("), this.compileList(e.values), this.append(")");
        }
        visitPrimitiveValueList(e) {
          this.append("(");
          let { values: t } = e;
          for (let e = 0; e < t.length; ++e)
            this.appendValue(t[e]), e !== t.length - 1 && this.append(", ");
          this.append(")");
        }
        visitParens(e) {
          this.append("("), this.visitNode(e.node), this.append(")");
        }
        visitJoin(e) {
          this.append(w[e.joinType]),
            this.append(" "),
            this.visitNode(e.table),
            e.on && (this.append(" "), this.visitNode(e.on));
        }
        visitOn(e) {
          this.append("on "), this.visitNode(e.on);
        }
        visitRaw(e) {
          let { sqlFragments: t, parameters: r } = e;
          for (let e = 0; e < t.length; ++e)
            this.append(t[e]), r.length > e && this.visitNode(r[e]);
        }
        visitOperator(e) {
          this.append(e.operator);
        }
        visitTable(e) {
          this.visitNode(e.table);
        }
        visitSchemableIdentifier(e) {
          e.schema && (this.visitNode(e.schema), this.append(".")),
            this.visitNode(e.identifier);
        }
        visitCreateTable(e) {
          this.append("create "),
            e.frontModifiers &&
              e.frontModifiers.length > 0 &&
              (this.compileList(e.frontModifiers, " "), this.append(" ")),
            e.temporary && this.append("temporary "),
            this.append("table "),
            e.ifNotExists && this.append("if not exists "),
            this.visitNode(e.table),
            e.selectQuery
              ? (this.append(" as "), this.visitNode(e.selectQuery))
              : (this.append(" ("),
                this.compileList([...e.columns, ...(e.constraints ?? [])]),
                this.append(")"),
                e.onCommit &&
                  (this.append(" on commit "), this.append(e.onCommit)),
                e.endModifiers &&
                  e.endModifiers.length > 0 &&
                  (this.append(" "), this.compileList(e.endModifiers, " ")));
        }
        visitColumnDefinition(e) {
          e.ifNotExists && this.append("if not exists "),
            this.visitNode(e.column),
            this.append(" "),
            this.visitNode(e.dataType),
            e.unsigned && this.append(" unsigned"),
            e.frontModifiers &&
              e.frontModifiers.length > 0 &&
              (this.append(" "), this.compileList(e.frontModifiers, " ")),
            e.generated && (this.append(" "), this.visitNode(e.generated)),
            e.identity && this.append(" identity"),
            e.defaultTo && (this.append(" "), this.visitNode(e.defaultTo)),
            e.notNull && this.append(" not null"),
            e.unique && this.append(" unique"),
            e.nullsNotDistinct && this.append(" nulls not distinct"),
            e.primaryKey && this.append(" primary key"),
            e.autoIncrement &&
              (this.append(" "), this.append(this.getAutoIncrement())),
            e.references && (this.append(" "), this.visitNode(e.references)),
            e.check && (this.append(" "), this.visitNode(e.check)),
            e.endModifiers &&
              e.endModifiers.length > 0 &&
              (this.append(" "), this.compileList(e.endModifiers, " "));
        }
        getAutoIncrement() {
          return "auto_increment";
        }
        visitReferences(e) {
          this.append("references "),
            this.visitNode(e.table),
            this.append(" ("),
            this.compileList(e.columns),
            this.append(")"),
            e.onDelete && (this.append(" on delete "), this.append(e.onDelete)),
            e.onUpdate && (this.append(" on update "), this.append(e.onUpdate));
        }
        visitDropTable(e) {
          this.append("drop table "),
            e.ifExists && this.append("if exists "),
            this.visitNode(e.table),
            e.cascade && this.append(" cascade");
        }
        visitDataType(e) {
          this.append(e.dataType);
        }
        visitOrderBy(e) {
          this.append("order by "), this.compileList(e.items);
        }
        visitOrderByItem(e) {
          this.visitNode(e.orderBy),
            e.collation && (this.append(" "), this.visitNode(e.collation)),
            e.direction && (this.append(" "), this.visitNode(e.direction)),
            e.nulls && (this.append(" nulls "), this.append(e.nulls));
        }
        visitGroupBy(e) {
          this.append("group by "), this.compileList(e.items);
        }
        visitGroupByItem(e) {
          this.visitNode(e.groupBy);
        }
        visitUpdateQuery(e) {
          let t = this.nodeStack.find(c.L.is),
            r = t !== e;
          if (
            (!r && e.explain && (this.visitNode(e.explain), this.append(" ")),
            r && !h.r.is(t) && this.append("("),
            e.with && (this.visitNode(e.with), this.append(" ")),
            this.append("update "),
            e.top && (this.visitNode(e.top), this.append(" ")),
            e.table && (this.visitNode(e.table), this.append(" ")),
            this.append("set "),
            e.updates && this.compileList(e.updates),
            e.output && (this.append(" "), this.visitNode(e.output)),
            e.from && (this.append(" "), this.visitNode(e.from)),
            e.joins)
          ) {
            if (!e.from)
              throw Error(
                "Joins in an update query are only supported as a part of a PostgreSQL 'update set from join' query. If you want to create a MySQL 'update join set' query, see https://kysely.dev/docs/examples/update/my-sql-joins"
              );
            this.append(" "), this.compileList(e.joins, " ");
          }
          e.where && (this.append(" "), this.visitNode(e.where)),
            e.orderBy && (this.append(" "), this.visitNode(e.orderBy)),
            e.limit && (this.append(" "), this.visitNode(e.limit)),
            e.returning && (this.append(" "), this.visitNode(e.returning)),
            r && !h.r.is(t) && this.append(")"),
            e.endModifiers?.length &&
              (this.append(" "), this.compileList(e.endModifiers, " "));
        }
        visitColumnUpdate(e) {
          this.visitNode(e.column), this.append(" = "), this.visitNode(e.value);
        }
        visitLimit(e) {
          this.append("limit "), this.visitNode(e.limit);
        }
        visitOffset(e) {
          this.append("offset "), this.visitNode(e.offset);
        }
        visitOnConflict(e) {
          this.append("on conflict"),
            e.columns
              ? (this.append(" ("),
                this.compileList(e.columns),
                this.append(")"))
              : e.constraint
                ? (this.append(" on constraint "), this.visitNode(e.constraint))
                : e.indexExpression &&
                  (this.append(" ("),
                  this.visitNode(e.indexExpression),
                  this.append(")")),
            e.indexWhere && (this.append(" "), this.visitNode(e.indexWhere)),
            !0 === e.doNothing
              ? this.append(" do nothing")
              : e.updates &&
                (this.append(" do update set "),
                this.compileList(e.updates),
                e.updateWhere &&
                  (this.append(" "), this.visitNode(e.updateWhere)));
        }
        visitOnDuplicateKey(e) {
          this.append("on duplicate key update "), this.compileList(e.updates);
        }
        visitCreateIndex(e) {
          this.append("create "),
            e.unique && this.append("unique "),
            this.append("index "),
            e.ifNotExists && this.append("if not exists "),
            this.visitNode(e.name),
            e.table && (this.append(" on "), this.visitNode(e.table)),
            e.using && (this.append(" using "), this.visitNode(e.using)),
            e.columns &&
              (this.append(" ("),
              this.compileList(e.columns),
              this.append(")")),
            e.nullsNotDistinct && this.append(" nulls not distinct"),
            e.where && (this.append(" "), this.visitNode(e.where));
        }
        visitDropIndex(e) {
          this.append("drop index "),
            e.ifExists && this.append("if exists "),
            this.visitNode(e.name),
            e.table && (this.append(" on "), this.visitNode(e.table)),
            e.cascade && this.append(" cascade");
        }
        visitCreateSchema(e) {
          this.append("create schema "),
            e.ifNotExists && this.append("if not exists "),
            this.visitNode(e.schema);
        }
        visitDropSchema(e) {
          this.append("drop schema "),
            e.ifExists && this.append("if exists "),
            this.visitNode(e.schema),
            e.cascade && this.append(" cascade");
        }
        visitPrimaryKeyConstraint(e) {
          e.name &&
            (this.append("constraint "),
            this.visitNode(e.name),
            this.append(" ")),
            this.append("primary key ("),
            this.compileList(e.columns),
            this.append(")"),
            this.buildDeferrable(e);
        }
        buildDeferrable(e) {
          void 0 !== e.deferrable &&
            (e.deferrable
              ? this.append(" deferrable")
              : this.append(" not deferrable")),
            void 0 !== e.initiallyDeferred &&
              (e.initiallyDeferred
                ? this.append(" initially deferred")
                : this.append(" initially immediate"));
        }
        visitUniqueConstraint(e) {
          e.name &&
            (this.append("constraint "),
            this.visitNode(e.name),
            this.append(" ")),
            this.append("unique"),
            e.nullsNotDistinct && this.append(" nulls not distinct"),
            this.append(" ("),
            this.compileList(e.columns),
            this.append(")"),
            this.buildDeferrable(e);
        }
        visitCheckConstraint(e) {
          e.name &&
            (this.append("constraint "),
            this.visitNode(e.name),
            this.append(" ")),
            this.append("check ("),
            this.visitNode(e.expression),
            this.append(")");
        }
        visitForeignKeyConstraint(e) {
          e.name &&
            (this.append("constraint "),
            this.visitNode(e.name),
            this.append(" ")),
            this.append("foreign key ("),
            this.compileList(e.columns),
            this.append(") "),
            this.visitNode(e.references),
            e.onDelete && (this.append(" on delete "), this.append(e.onDelete)),
            e.onUpdate && (this.append(" on update "), this.append(e.onUpdate)),
            this.buildDeferrable(e);
        }
        visitList(e) {
          this.compileList(e.items);
        }
        visitWith(e) {
          this.append("with "),
            e.recursive && this.append("recursive "),
            this.compileList(e.expressions);
        }
        visitCommonTableExpression(e) {
          this.visitNode(e.name),
            this.append(" as "),
            (0, s.Lm)(e.materialized) &&
              (e.materialized || this.append("not "),
              this.append("materialized ")),
            this.visitNode(e.expression);
        }
        visitCommonTableExpressionName(e) {
          this.visitNode(e.table),
            e.columns &&
              (this.append("("), this.compileList(e.columns), this.append(")"));
        }
        visitAlterTable(e) {
          this.append("alter table "),
            this.visitNode(e.table),
            this.append(" "),
            e.renameTo &&
              (this.append("rename to "), this.visitNode(e.renameTo)),
            e.setSchema &&
              (this.append("set schema "), this.visitNode(e.setSchema)),
            e.addConstraint && this.visitNode(e.addConstraint),
            e.dropConstraint && this.visitNode(e.dropConstraint),
            e.renameConstraint && this.visitNode(e.renameConstraint),
            e.columnAlterations &&
              this.compileColumnAlterations(e.columnAlterations),
            e.addIndex && this.visitNode(e.addIndex),
            e.dropIndex && this.visitNode(e.dropIndex);
        }
        visitAddColumn(e) {
          this.append("add column "), this.visitNode(e.column);
        }
        visitRenameColumn(e) {
          this.append("rename column "),
            this.visitNode(e.column),
            this.append(" to "),
            this.visitNode(e.renameTo);
        }
        visitDropColumn(e) {
          this.append("drop column "), this.visitNode(e.column);
        }
        visitAlterColumn(e) {
          this.append("alter column "),
            this.visitNode(e.column),
            this.append(" "),
            e.dataType &&
              (this.announcesNewColumnDataType() && this.append("type "),
              this.visitNode(e.dataType),
              e.dataTypeExpression &&
                (this.append("using "), this.visitNode(e.dataTypeExpression))),
            e.setDefault &&
              (this.append("set default "), this.visitNode(e.setDefault)),
            e.dropDefault && this.append("drop default"),
            e.setNotNull && this.append("set not null"),
            e.dropNotNull && this.append("drop not null");
        }
        visitModifyColumn(e) {
          this.append("modify column "), this.visitNode(e.column);
        }
        visitAddConstraint(e) {
          this.append("add "), this.visitNode(e.constraint);
        }
        visitDropConstraint(e) {
          this.append("drop constraint "),
            e.ifExists && this.append("if exists "),
            this.visitNode(e.constraintName),
            "cascade" === e.modifier
              ? this.append(" cascade")
              : "restrict" === e.modifier && this.append(" restrict");
        }
        visitRenameConstraint(e) {
          this.append("rename constraint "),
            this.visitNode(e.oldName),
            this.append(" to "),
            this.visitNode(e.newName);
        }
        visitSetOperation(e) {
          this.append(e.operator),
            this.append(" "),
            e.all && this.append("all "),
            this.visitNode(e.expression);
        }
        visitCreateView(e) {
          this.append("create "),
            e.orReplace && this.append("or replace "),
            e.materialized && this.append("materialized "),
            e.temporary && this.append("temporary "),
            this.append("view "),
            e.ifNotExists && this.append("if not exists "),
            this.visitNode(e.name),
            this.append(" "),
            e.columns &&
              (this.append("("),
              this.compileList(e.columns),
              this.append(") ")),
            e.as && (this.append("as "), this.visitNode(e.as));
        }
        visitRefreshMaterializedView(e) {
          this.append("refresh materialized view "),
            e.concurrently && this.append("concurrently "),
            this.visitNode(e.name),
            e.withNoData
              ? this.append(" with no data")
              : this.append(" with data");
        }
        visitDropView(e) {
          this.append("drop "),
            e.materialized && this.append("materialized "),
            this.append("view "),
            e.ifExists && this.append("if exists "),
            this.visitNode(e.name),
            e.cascade && this.append(" cascade");
        }
        visitGenerated(e) {
          this.append("generated "),
            e.always && this.append("always "),
            e.byDefault && this.append("by default "),
            this.append("as "),
            e.identity && this.append("identity"),
            e.expression &&
              (this.append("("),
              this.visitNode(e.expression),
              this.append(")")),
            e.stored && this.append(" stored");
        }
        visitDefaultValue(e) {
          this.append("default "), this.visitNode(e.defaultValue);
        }
        visitSelectModifier(e) {
          e.rawModifier
            ? this.visitNode(e.rawModifier)
            : this.append(y[e.modifier]),
            e.of && (this.append(" of "), this.compileList(e.of, ", "));
        }
        visitCreateType(e) {
          this.append("create type "),
            this.visitNode(e.name),
            e.enum && (this.append(" as enum "), this.visitNode(e.enum));
        }
        visitDropType(e) {
          this.append("drop type "),
            e.ifExists && this.append("if exists "),
            this.visitNode(e.name);
        }
        visitExplain(e) {
          this.append("explain"),
            (e.options || e.format) &&
              (this.append(" "),
              this.append(this.getLeftExplainOptionsWrapper()),
              e.options &&
                (this.visitNode(e.options),
                e.format && this.append(this.getExplainOptionsDelimiter())),
              e.format &&
                (this.append("format"),
                this.append(this.getExplainOptionAssignment()),
                this.append(e.format)),
              this.append(this.getRightExplainOptionsWrapper()));
        }
        visitDefaultInsertValue(e) {
          this.append("default");
        }
        visitAggregateFunction(e) {
          this.append(e.func),
            this.append("("),
            e.distinct && this.append("distinct "),
            this.compileList(e.aggregated),
            e.orderBy && (this.append(" "), this.visitNode(e.orderBy)),
            this.append(")"),
            e.withinGroup &&
              (this.append(" within group ("),
              this.visitNode(e.withinGroup),
              this.append(")")),
            e.filter &&
              (this.append(" filter("),
              this.visitNode(e.filter),
              this.append(")")),
            e.over && (this.append(" "), this.visitNode(e.over));
        }
        visitOver(e) {
          this.append("over("),
            e.partitionBy &&
              (this.visitNode(e.partitionBy), e.orderBy && this.append(" ")),
            e.orderBy && this.visitNode(e.orderBy),
            this.append(")");
        }
        visitPartitionBy(e) {
          this.append("partition by "), this.compileList(e.items);
        }
        visitPartitionByItem(e) {
          this.visitNode(e.partitionBy);
        }
        visitBinaryOperation(e) {
          this.visitNode(e.leftOperand),
            this.append(" "),
            this.visitNode(e.operator),
            this.append(" "),
            this.visitNode(e.rightOperand);
        }
        visitUnaryOperation(e) {
          this.visitNode(e.operator),
            this.isMinusOperator(e.operator) || this.append(" "),
            this.visitNode(e.operand);
        }
        isMinusOperator(e) {
          return a.zX.is(e) && "-" === e.operator;
        }
        visitUsing(e) {
          this.append("using "), this.compileList(e.tables);
        }
        visitFunction(e) {
          this.append(e.func),
            this.append("("),
            this.compileList(e.arguments),
            this.append(")");
        }
        visitCase(e) {
          this.append("case"),
            e.value && (this.append(" "), this.visitNode(e.value)),
            e.when && (this.append(" "), this.compileList(e.when, " ")),
            e.else && (this.append(" else "), this.visitNode(e.else)),
            this.append(" end"),
            e.isStatement && this.append(" case");
        }
        visitWhen(e) {
          this.append("when "),
            this.visitNode(e.condition),
            e.result && (this.append(" then "), this.visitNode(e.result));
        }
        visitJSONReference(e) {
          this.visitNode(e.reference), this.visitNode(e.traversal);
        }
        visitJSONPath(e) {
          for (let t of (e.inOperator && this.visitNode(e.inOperator),
          this.append("'$"),
          e.pathLegs))
            this.visitNode(t);
          this.append("'");
        }
        visitJSONPathLeg(e) {
          let t = "ArrayLocation" === e.type;
          this.append(t ? "[" : "."),
            this.append(String(e.value)),
            t && this.append("]");
        }
        visitJSONOperatorChain(e) {
          for (let t = 0, r = e.values.length; t < r; t++)
            t === r - 1 ? this.visitNode(e.operator) : this.append("->"),
              this.visitNode(e.values[t]);
        }
        visitMergeQuery(e) {
          e.with && (this.visitNode(e.with), this.append(" ")),
            this.append("merge "),
            e.top && (this.visitNode(e.top), this.append(" ")),
            this.append("into "),
            this.visitNode(e.into),
            e.using && (this.append(" "), this.visitNode(e.using)),
            e.whens && (this.append(" "), this.compileList(e.whens, " ")),
            e.returning && (this.append(" "), this.visitNode(e.returning)),
            e.output && (this.append(" "), this.visitNode(e.output)),
            e.endModifiers?.length &&
              (this.append(" "), this.compileList(e.endModifiers, " "));
        }
        visitMatched(e) {
          e.not && this.append("not "),
            this.append("matched"),
            e.bySource && this.append(" by source");
        }
        visitAddIndex(e) {
          this.append("add "),
            e.unique && this.append("unique "),
            this.append("index "),
            this.visitNode(e.name),
            e.columns &&
              (this.append(" ("),
              this.compileList(e.columns),
              this.append(")")),
            e.using && (this.append(" using "), this.visitNode(e.using));
        }
        visitCast(e) {
          this.append("cast("),
            this.visitNode(e.expression),
            this.append(" as "),
            this.visitNode(e.dataType),
            this.append(")");
        }
        visitFetch(e) {
          this.append("fetch next "),
            this.visitNode(e.rowCount),
            this.append(` rows ${e.modifier}`);
        }
        visitOutput(e) {
          this.append("output "), this.compileList(e.selections);
        }
        visitTop(e) {
          this.append(`top(${e.expression})`),
            e.modifiers && this.append(` ${e.modifiers}`);
        }
        visitOrAction(e) {
          this.append(e.action);
        }
        visitCollate(e) {
          this.append("collate "), this.visitNode(e.collation);
        }
        append(e) {
          this.#g += e;
        }
        appendValue(e) {
          this.addParameter(e),
            this.append(this.getCurrentParameterPlaceholder());
        }
        getLeftIdentifierWrapper() {
          return '"';
        }
        getRightIdentifierWrapper() {
          return '"';
        }
        getCurrentParameterPlaceholder() {
          return "$" + this.numParameters;
        }
        getLeftExplainOptionsWrapper() {
          return "(";
        }
        getExplainOptionAssignment() {
          return " ";
        }
        getExplainOptionsDelimiter() {
          return ", ";
        }
        getRightExplainOptionsWrapper() {
          return ")";
        }
        sanitizeIdentifier(e) {
          let t = this.getLeftIdentifierWrapper(),
            r = this.getRightIdentifierWrapper(),
            i = "";
          for (let n of e) (i += n), n === t ? (i += t) : n === r && (i += r);
          return i;
        }
        sanitizeStringLiteral(e) {
          return e.replace(f, "''");
        }
        addParameter(e) {
          this.#w.push(e);
        }
        appendImmediateValue(e) {
          if ((0, s.Kg)(e)) this.appendStringLiteral(e);
          else if ((0, s.Et)(e) || (0, s.Lm)(e)) this.append(e.toString());
          else if ((0, s.kZ)(e)) this.append("null");
          else if ((0, s.$P)(e)) this.appendImmediateValue(e.toISOString());
          else if ((0, s.sI)(e)) this.appendImmediateValue(e.toString());
          else throw Error(`invalid immediate value ${e}`);
        }
        appendStringLiteral(e) {
          this.append("'"),
            this.append(this.sanitizeStringLiteral(e)),
            this.append("'");
        }
        sortSelectModifiers(e) {
          return (
            e.sort((e, t) =>
              e.modifier && t.modifier ? g[e.modifier] - g[t.modifier] : 1
            ),
            (0, s.CN)(e)
          );
        }
        compileColumnAlterations(e) {
          this.compileList(e);
        }
        announcesNewColumnDataType() {
          return !0;
        }
      }
      let y = (0, s.CN)({
          ForKeyShare: "for key share",
          ForNoKeyUpdate: "for no key update",
          ForUpdate: "for update",
          ForShare: "for share",
          NoWait: "nowait",
          SkipLocked: "skip locked",
          Distinct: "distinct",
        }),
        g = (0, s.CN)({
          ForKeyShare: 1,
          ForNoKeyUpdate: 1,
          ForUpdate: 1,
          ForShare: 1,
          NoWait: 2,
          SkipLocked: 2,
          Distinct: 0,
        }),
        w = (0, s.CN)({
          InnerJoin: "inner join",
          LeftJoin: "left join",
          RightJoin: "right join",
          FullJoin: "full join",
          CrossJoin: "cross join",
          LateralInnerJoin: "inner join lateral",
          LateralLeftJoin: "left join lateral",
          LateralCrossJoin: "cross join lateral",
          OuterApply: "outer apply",
          CrossApply: "cross apply",
          Using: "using",
        });
    },
    77345: (e, t, r) => {
      r.d(t, { A: () => n });
      let i =
          /^(\+|\-)? ?(\d+|\d+\.\d+) ?(seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)(?: (ago|from now))?$/i,
        n = (e) => {
          let t,
            r = i.exec(e);
          if (!r || (r[4] && r[1]))
            throw TypeError("Invalid time period format");
          let n = parseFloat(r[2]);
          switch (r[3].toLowerCase()) {
            case "sec":
            case "secs":
            case "second":
            case "seconds":
            case "s":
              t = Math.round(n);
              break;
            case "minute":
            case "minutes":
            case "min":
            case "mins":
            case "m":
              t = Math.round(60 * n);
              break;
            case "hour":
            case "hours":
            case "hr":
            case "hrs":
            case "h":
              t = Math.round(3600 * n);
              break;
            case "day":
            case "days":
            case "d":
              t = Math.round(86400 * n);
              break;
            case "week":
            case "weeks":
            case "w":
              t = Math.round(604800 * n);
              break;
            default:
              t = Math.round(0x1e187e0 * n);
          }
          return "-" === r[1] || "ago" === r[4] ? -t : t;
        };
    },
    78116: (e, t, r) => {
      r.d(t, { li: () => rH });
      var i = r(30060),
        n = r(3536),
        s = r(16151),
        o = r(33746),
        a = r(54036),
        l = r(49442),
        c = r(37991);
      function d(e, t) {
        if (t.advanced?.ipAddress?.disableIpTracking) return null;
        if (l.i) return "127.0.0.1";
        let r = "headers" in e ? e.headers : e;
        for (let e of t.advanced?.ipAddress?.ipAddressHeaders || [
          "x-forwarded-for",
        ]) {
          let t = "get" in r ? r.get(e) : r[e];
          if ("string" == typeof t) {
            var i;
            let e = t.split(",")[0].trim();
            if (
              ((i = e),
              /^(\d{1,3}\.){3}\d{1,3}$/.test(i)
                ? i
                    .split(".")
                    .map(Number)
                    .every((e) => e >= 0 && e <= 255)
                : /^([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}$/.test(i))
            )
              return e;
          }
        }
        return null;
      }
      var u = r(39773);
      r(45391), r(12486), r(51875);
      var h = r(84941);
      r(30377);
      var p = r(7125);
      r(55094), r(2595);
      var f = r(10257);
      r(62055), r(61229);
      var m = r(98196);
      let y = () =>
          (0, n.a)(
            "/sign-up/email",
            {
              method: "POST",
              body: s.z.record(s.z.string(), s.z.any()),
              metadata: {
                $Infer: { body: {} },
                openapi: {
                  description: "Sign up a user using email and password",
                  requestBody: {
                    content: {
                      "application/json": {
                        schema: {
                          type: "object",
                          properties: {
                            name: {
                              type: "string",
                              description: "The name of the user",
                            },
                            email: {
                              type: "string",
                              description: "The email of the user",
                            },
                            password: {
                              type: "string",
                              description: "The password of the user",
                            },
                            callbackURL: {
                              type: "string",
                              description:
                                "The URL to use for email verification callback",
                            },
                          },
                          required: ["name", "email", "password"],
                        },
                      },
                    },
                  },
                  responses: {
                    200: {
                      description: "Successfully created user",
                      content: {
                        "application/json": {
                          schema: {
                            type: "object",
                            properties: {
                              token: {
                                type: "string",
                                nullable: !0,
                                description:
                                  "Authentication token for the session",
                              },
                              user: {
                                type: "object",
                                properties: {
                                  id: {
                                    type: "string",
                                    description:
                                      "The unique identifier of the user",
                                  },
                                  email: {
                                    type: "string",
                                    format: "email",
                                    description:
                                      "The email address of the user",
                                  },
                                  name: {
                                    type: "string",
                                    description: "The name of the user",
                                  },
                                  image: {
                                    type: "string",
                                    format: "uri",
                                    nullable: !0,
                                    description:
                                      "The profile image URL of the user",
                                  },
                                  emailVerified: {
                                    type: "boolean",
                                    description:
                                      "Whether the email has been verified",
                                  },
                                  createdAt: {
                                    type: "string",
                                    format: "date-time",
                                    description: "When the user was created",
                                  },
                                  updatedAt: {
                                    type: "string",
                                    format: "date-time",
                                    description:
                                      "When the user was last updated",
                                  },
                                },
                                required: [
                                  "id",
                                  "email",
                                  "name",
                                  "emailVerified",
                                  "createdAt",
                                  "updatedAt",
                                ],
                              },
                            },
                            required: ["user"],
                          },
                        },
                      },
                    },
                  },
                },
              },
            },
            async (e) => {
              let t;
              if (
                !e.context.options.emailAndPassword?.enabled ||
                e.context.options.emailAndPassword?.disableSignUp
              )
                throw new i.LG("BAD_REQUEST", {
                  message: "Email and password sign up is not enabled",
                });
              let r = e.body,
                {
                  name: c,
                  email: d,
                  password: u,
                  image: h,
                  callbackURL: p,
                  ...f
                } = r;
              if (!s.z.string().email().safeParse(d).success)
                throw new i.LG("BAD_REQUEST", { message: n.B.INVALID_EMAIL });
              let m = e.context.password.config.minPasswordLength;
              if (u.length < m)
                throw (
                  (e.context.logger.error("Password is too short"),
                  new i.LG("BAD_REQUEST", { message: n.B.PASSWORD_TOO_SHORT }))
                );
              let y = e.context.password.config.maxPasswordLength;
              if (u.length > y)
                throw (
                  (e.context.logger.error("Password is too long"),
                  new i.LG("BAD_REQUEST", { message: n.B.PASSWORD_TOO_LONG }))
                );
              let g = await e.context.internalAdapter.findUserByEmail(d);
              if (g?.user)
                throw (
                  (e.context.logger.info(
                    `Sign-up attempt for existing email: ${d}`
                  ),
                  new i.LG("UNPROCESSABLE_ENTITY", {
                    message: n.B.USER_ALREADY_EXISTS,
                  }))
                );
              let w = (0, a.f)(e.context.options, f),
                b = await e.context.password.hash(u);
              try {
                if (
                  !(t = await e.context.internalAdapter.createUser(
                    {
                      email: d.toLowerCase(),
                      name: c,
                      image: h,
                      ...w,
                      emailVerified: !1,
                    },
                    e
                  ))
                )
                  throw new i.LG("BAD_REQUEST", {
                    message: n.B.FAILED_TO_CREATE_USER,
                  });
              } catch (t) {
                if (
                  (l.b && e.context.logger.error("Failed to create user", t),
                  t instanceof i.LG)
                )
                  throw t;
                throw new i.LG("UNPROCESSABLE_ENTITY", {
                  message: n.B.FAILED_TO_CREATE_USER,
                  details: t,
                });
              }
              if (!t)
                throw new i.LG("UNPROCESSABLE_ENTITY", {
                  message: n.B.FAILED_TO_CREATE_USER,
                });
              if (
                (await e.context.internalAdapter.linkAccount(
                  {
                    userId: t.id,
                    providerId: "credential",
                    accountId: t.id,
                    password: b,
                  },
                  e
                ),
                e.context.options.emailVerification?.sendOnSignUp ||
                  e.context.options.emailAndPassword.requireEmailVerification)
              ) {
                let i = await (0, n.e)(
                    e.context.secret,
                    t.email,
                    void 0,
                    e.context.options.emailVerification?.expiresIn
                  ),
                  s = `${e.context.baseURL}/verify-email?token=${i}&callbackURL=${r.callbackURL || "/"}`;
                await e.context.options.emailVerification?.sendVerificationEmail?.(
                  { user: t, url: s, token: i },
                  e.request
                );
              }
              if (
                !1 === e.context.options.emailAndPassword.autoSignIn ||
                e.context.options.emailAndPassword.requireEmailVerification
              )
                return e.json({
                  token: null,
                  user: {
                    id: t.id,
                    email: t.email,
                    name: t.name,
                    image: t.image,
                    emailVerified: t.emailVerified,
                    createdAt: t.createdAt,
                    updatedAt: t.updatedAt,
                  },
                });
              let v = await e.context.internalAdapter.createSession(t.id, e);
              if (!v)
                throw new i.LG("BAD_REQUEST", {
                  message: n.B.FAILED_TO_CREATE_SESSION,
                });
              return (
                await (0, o.$G)(e, { session: v, user: t }),
                e.json({
                  token: v.token,
                  user: {
                    id: t.id,
                    email: t.email,
                    name: t.name,
                    image: t.image,
                    emailVerified: t.emailVerified,
                    createdAt: t.createdAt,
                    updatedAt: t.updatedAt,
                  },
                })
              );
            }
          ),
        g = new Map();
      async function w(e, t) {
        if (!t.rateLimit.enabled) return;
        let r = new URL(e.url).pathname.replace(
            t.options.basePath || "/api/auth",
            ""
          ),
          i = t.rateLimit.window,
          s = t.rateLimit.max,
          o = d(e, t.options);
        if (!o) return;
        let a = o + r,
          l = [
            {
              pathMatcher: (e) =>
                e.startsWith("/sign-in") ||
                e.startsWith("/sign-up") ||
                e.startsWith("/change-password") ||
                e.startsWith("/change-email"),
              window: 10,
              max: 3,
            },
          ].find((e) => e.pathMatcher(r));
        for (let e of (l && ((i = l.window), (s = l.max)),
        t.options.plugins || []))
          if (e.rateLimit) {
            let t = e.rateLimit.find((e) => e.pathMatcher(r));
            if (t) {
              (i = t.window), (s = t.max);
              break;
            }
          }
        if (t.rateLimit.customRules) {
          let o = Object.keys(t.rateLimit.customRules).find((e) =>
            e.includes("*") ? (0, n.w)(e)(r) : e === r
          );
          if (o) {
            let r = t.rateLimit.customRules[o],
              n = "function" == typeof r ? await r(e) : r;
            n && ((i = n.window), (s = n.max));
          }
        }
        let c = (function (e) {
            if (e.options.rateLimit?.customStorage)
              return e.options.rateLimit.customStorage;
            if ("secondary-storage" === e.rateLimit.storage)
              return {
                get: async (t) => {
                  let r = await e.options.secondaryStorage?.get(t);
                  return r ? JSON.parse(r) : void 0;
                },
                set: async (t, r) => {
                  await e.options.secondaryStorage?.set?.(t, JSON.stringify(r));
                },
              };
            if ("memory" === e.rateLimit.storage)
              return {
                get: async (e) => g.get(e),
                async set(e, t, r) {
                  g.set(e, t);
                },
              };
            e.rateLimit.modelName;
            let t = e.options.rateLimit?.modelName || "rateLimit",
              r = e.adapter;
            return {
              get: async (e) => {
                let i = (
                  await r.findMany({
                    model: t,
                    where: [{ field: "key", value: e }],
                  })
                )[0];
                return (
                  "bigint" == typeof i?.lastRequest &&
                    (i.lastRequest = Number(i.lastRequest)),
                  i
                );
              },
              set: async (t, i, n) => {
                try {
                  n
                    ? await r.updateMany({
                        model: "rateLimit",
                        where: [{ field: "key", value: t }],
                        update: { count: i.count, lastRequest: i.lastRequest },
                      })
                    : await r.create({
                        model: "rateLimit",
                        data: {
                          key: t,
                          count: i.count,
                          lastRequest: i.lastRequest,
                        },
                      });
                } catch (t) {
                  e.logger.error("Error setting rate limit", t);
                }
              },
            };
          })(t),
          u = await c.get(a),
          h = Date.now();
        if (u) {
          var p, f, m, y;
          let e = h - u.lastRequest;
          if (
            ((p = s),
            (f = i),
            (m = u),
            Date.now() - m.lastRequest < 1e3 * f && m.count >= p)
          ) {
            return (
              (y = Math.ceil((u.lastRequest + 1e3 * i - Date.now()) / 1e3)),
              new Response(
                JSON.stringify({
                  message: "Too many requests. Please try again later.",
                }),
                {
                  status: 429,
                  statusText: "Too Many Requests",
                  headers: { "X-Retry-After": y.toString() },
                }
              )
            );
          }
          e > 1e3 * i
            ? await c.set(a, { ...u, count: 1, lastRequest: h }, !0)
            : await c.set(a, { ...u, count: u.count + 1, lastRequest: h }, !0);
        } else await c.set(a, { key: a, count: 1, lastRequest: h });
      }
      async function b(e, t) {
        let r = {};
        for (let i of t)
          if (i.matcher(e)) {
            let t = await i.handler({ ...e, returnHeaders: !1 });
            if (t && "object" == typeof t) {
              if ("context" in t && "object" == typeof t.context) {
                let { headers: e, ...i } = t.context;
                e instanceof Headers &&
                  (r.headers
                    ? e.forEach((e, t) => {
                        r.headers?.set(t, e);
                      })
                    : (r.headers = e)),
                  (r = (0, u.Ay)(i, r));
                continue;
              }
              return t;
            }
          }
        return { context: r };
      }
      async function v(e, t) {
        for (let r of t)
          if (r.matcher(e)) {
            let t = await r.handler(e).catch((e) => {
              if (e instanceof i.LG)
                return {
                  response: e,
                  headers: e.headers ? new Headers(e.headers) : null,
                };
              throw e;
            });
            t.headers &&
              t.headers.forEach((t, r) => {
                e.context.responseHeaders
                  ? "set-cookie" === r.toLowerCase()
                    ? e.context.responseHeaders.append(r, t)
                    : e.context.responseHeaders.set(r, t)
                  : (e.context.responseHeaders = new Headers({ [r]: t }));
              }),
              t.response && (e.context.returned = t.response);
          }
        return {
          response: e.context.returned,
          headers: e.context.responseHeaders,
        };
      }
      function N(e, t) {
        let r = t.plugins?.reduce((e, t) => ({ ...e, ...t.endpoints }), {}),
          s =
            t.plugins
              ?.map((t) =>
                t.middlewares?.map((t) => {
                  let r = async (r) =>
                    t.middleware({ ...r, context: { ...e, ...r.context } });
                  return (
                    (r.options = t.middleware.options),
                    { path: t.path, middleware: r }
                  );
                })
              )
              .filter((e) => void 0 !== e)
              .flat() || [];
        return {
          api: (function (e, t) {
            let r = {};
            for (let [n, s] of Object.entries(e))
              (r[n] = async (e) => {
                let r = await t,
                  n = {
                    ...e,
                    context: {
                      ...r,
                      returned: void 0,
                      responseHeaders: void 0,
                      session: null,
                    },
                    path: s.path,
                    headers: e?.headers ? new Headers(e?.headers) : void 0,
                  },
                  { beforeHooks: o, afterHooks: a } = (function (e) {
                    let t = e.options.plugins || [],
                      r = [],
                      i = [];
                    e.options.hooks?.before &&
                      r.push({
                        matcher: () => !0,
                        handler: e.options.hooks.before,
                      }),
                      e.options.hooks?.after &&
                        i.push({
                          matcher: () => !0,
                          handler: e.options.hooks.after,
                        });
                    let n = t
                        .map((e) => {
                          if (e.hooks?.before) return e.hooks.before;
                        })
                        .filter((e) => void 0 !== e)
                        .flat(),
                      s = t
                        .map((e) => {
                          if (e.hooks?.after) return e.hooks.after;
                        })
                        .filter((e) => void 0 !== e)
                        .flat();
                    return (
                      n.length && r.push(...n),
                      s.length && i.push(...s),
                      { beforeHooks: r, afterHooks: i }
                    );
                  })(r),
                  l = await b(n, o);
                if (
                  "context" in l &&
                  l.context &&
                  "object" == typeof l.context
                ) {
                  let { headers: e, ...t } = l.context;
                  e &&
                    e.forEach((e, t) => {
                      n.headers.set(t, e);
                    }),
                    (n = (0, u.Ay)(t, n));
                } else if (l) return l;
                (n.asResponse = !1), (n.returnHeaders = !0);
                let c = await s(n).catch((e) => {
                  if (e instanceof i.LG)
                    return {
                      response: e,
                      headers: e.headers ? new Headers(e.headers) : null,
                    };
                  throw e;
                });
                (n.context.returned = c.response),
                  (n.context.responseHeaders = c.headers);
                let d = await v(n, a);
                if (
                  (d.response && (c.response = d.response),
                  c.response instanceof i.LG && !e?.asResponse)
                )
                  throw c.response;
                return e?.asResponse
                  ? (0, i.Zr)(c.response, { headers: c.headers })
                  : e?.returnHeaders
                    ? { headers: c.headers, response: c.response }
                    : c.response;
              }),
                (r[n].path = s.path),
                (r[n].options = s.options);
            return r;
          })(
            {
              ...{
                signInSocial: n.Q,
                callbackOAuth: n.P,
                getSession: (0, n.b)(),
                signOut: n.O,
                signUpEmail: y(),
                signInEmail: n.N,
                forgetPassword: n.M,
                resetPassword: n.L,
                verifyEmail: n.K,
                sendVerificationEmail: n.J,
                changeEmail: n.I,
                changePassword: n.G,
                setPassword: n.F,
                updateUser: (0, n.u)(),
                deleteUser: n.E,
                forgetPasswordCallback: n.D,
                requestPasswordReset: n.C,
                requestPasswordResetCallback: n.A,
                listSessions: (0, n.l)(),
                revokeSession: n.z,
                revokeSessions: n.y,
                revokeOtherSessions: n.x,
                linkSocialAccount: n.v,
                listUserAccounts: n.t,
                deleteUserCallback: n.q,
                unlinkAccount: n.p,
                refreshToken: n.r,
                getAccessToken: n.n,
                accountInfo: n.m,
              },
              ...r,
              ok: n.k,
              error: n.j,
            },
            e
          ),
          middlewares: s,
        };
      }
      let x = (e, t) => {
        let { api: r, middlewares: s } = N(e, t),
          o = new URL(e.baseURL).pathname;
        return (0, i.aE)(r, {
          routerContext: e,
          openapi: { disabled: !0 },
          basePath: o,
          routerMiddleware: [{ path: "/**", middleware: n.i }, ...s],
          async onRequest(t) {
            let r = e.options.disabledPaths || [],
              i = new URL(t.url).pathname.replace(o, "");
            if (r.includes(i))
              return new Response("Not Found", { status: 404 });
            for (let r of e.options.plugins || [])
              if (r.onRequest) {
                let i = await r.onRequest(t, e);
                if (i && "response" in i) return i.response;
              }
            return w(t, e);
          },
          async onResponse(t) {
            for (let r of e.options.plugins || [])
              if (r.onResponse) {
                let i = await r.onResponse(t, e);
                if (i) return i.response;
              }
            return t;
          },
          onError(r) {
            if (r instanceof i.LG && "FOUND" === r.status) return;
            if (t.onAPIError?.throw) throw r;
            if (t.onAPIError?.onError) return void t.onAPIError.onError(r, e);
            let n = t.logger?.level,
              s = "error" === n || "warn" === n || "debug" === n ? c.l : void 0;
            if (t.logger?.disabled !== !0) {
              if (
                r &&
                "object" == typeof r &&
                "message" in r &&
                "string" == typeof r.message &&
                (r.message.includes("no column") ||
                  r.message.includes("column") ||
                  r.message.includes("relation") ||
                  r.message.includes("table") ||
                  r.message.includes("does not exist"))
              )
                return void e.logger?.error(r.message);
              r instanceof i.LG
                ? ("INTERNAL_SERVER_ERROR" === r.status &&
                    e.logger.error(r.status, r),
                  s?.error(r.message))
                : e.logger?.error(
                    r && "object" == typeof r && "name" in r ? r.name : "",
                    r
                  );
            }
          },
        });
      };
      function _(e) {
        if (!Number.isSafeInteger(e) || e < 0)
          throw Error("positive integer expected, got " + e);
      }
      function S(e, ...t) {
        if (
          !(
            e instanceof Uint8Array ||
            (ArrayBuffer.isView(e) && "Uint8Array" === e.constructor.name)
          )
        )
          throw Error("Uint8Array expected");
        if (t.length > 0 && !t.includes(e.length))
          throw Error(
            "Uint8Array expected of length " + t + ", got length=" + e.length
          );
      }
      function T(e) {
        if ("function" != typeof e || "function" != typeof e.create)
          throw Error("Hash should be wrapped by utils.createHasher");
        _(e.outputLen), _(e.blockLen);
      }
      function k(e, t = !0) {
        if (e.destroyed) throw Error("Hash instance has been destroyed");
        if (t && e.finished)
          throw Error("Hash#digest() has already been called");
      }
      function A(e) {
        return new Uint32Array(
          e.buffer,
          e.byteOffset,
          Math.floor(e.byteLength / 4)
        );
      }
      function E(...e) {
        for (let t = 0; t < e.length; t++) e[t].fill(0);
      }
      function C(e) {
        return new DataView(e.buffer, e.byteOffset, e.byteLength);
      }
      function I(e, t) {
        return (e << (32 - t)) | (e >>> t);
      }
      function O(e, t) {
        return (e << t) | ((e >>> (32 - t)) >>> 0);
      }
      let L =
          68 === new Uint8Array(new Uint32Array([0x11223344]).buffer)[0]
            ? (e) => e
            : function (e) {
                for (let r = 0; r < e.length; r++) {
                  var t;
                  e[r] =
                    (((t = e[r]) << 24) & 0xff000000) |
                    ((t << 8) & 0xff0000) |
                    ((t >>> 8) & 65280) |
                    ((t >>> 24) & 255);
                }
                return e;
              },
        R =
          "function" == typeof Uint8Array.from([]).toHex &&
          "function" == typeof Uint8Array.fromHex,
        P =
          ((e, t) => t.toString(16).padStart(2, "0"),
          { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 });
      function D(e) {
        return e >= P._0 && e <= P._9
          ? e - P._0
          : e >= P.A && e <= P.F
            ? e - (P.A - 10)
            : e >= P.a && e <= P.f
              ? e - (P.a - 10)
              : void 0;
      }
      let q = async () => {};
      async function U(e, t, r) {
        let i = Date.now();
        for (let n = 0; n < e; n++) {
          r(n);
          let e = Date.now() - i;
          (e >= 0 && e < t) || (await q(), (i += e));
        }
      }
      function $(e) {
        if ("string" != typeof e) throw Error("string expected");
        return new Uint8Array(new TextEncoder().encode(e));
      }
      function B(e) {
        return "string" == typeof e && (e = $(e)), S(e), e;
      }
      function M(e) {
        return "string" == typeof e && (e = $(e)), S(e), e;
      }
      function j(e, t) {
        if (void 0 !== t && "[object Object]" !== {}.toString.call(t))
          throw Error("options should be object or undefined");
        return Object.assign(e, t);
      }
      class W {}
      class F extends W {
        constructor(e, t) {
          super(), (this.finished = !1), (this.destroyed = !1), T(e);
          let r = B(t);
          if (
            ((this.iHash = e.create()), "function" != typeof this.iHash.update)
          )
            throw Error("Expected instance of class which extends utils.Hash");
          (this.blockLen = this.iHash.blockLen),
            (this.outputLen = this.iHash.outputLen);
          let i = this.blockLen,
            n = new Uint8Array(i);
          n.set(r.length > i ? e.create().update(r).digest() : r);
          for (let e = 0; e < n.length; e++) n[e] ^= 54;
          this.iHash.update(n), (this.oHash = e.create());
          for (let e = 0; e < n.length; e++) n[e] ^= 106;
          this.oHash.update(n), E(n);
        }
        update(e) {
          return k(this), this.iHash.update(e), this;
        }
        digestInto(e) {
          k(this),
            S(e, this.outputLen),
            (this.finished = !0),
            this.iHash.digestInto(e),
            this.oHash.update(e),
            this.oHash.digestInto(e),
            this.destroy();
        }
        digest() {
          let e = new Uint8Array(this.oHash.outputLen);
          return this.digestInto(e), e;
        }
        _cloneInto(e) {
          e || (e = Object.create(Object.getPrototypeOf(this), {}));
          let {
            oHash: t,
            iHash: r,
            finished: i,
            destroyed: n,
            blockLen: s,
            outputLen: o,
          } = this;
          return (
            (e.finished = i),
            (e.destroyed = n),
            (e.blockLen = s),
            (e.outputLen = o),
            (e.oHash = t._cloneInto(e.oHash)),
            (e.iHash = r._cloneInto(e.iHash)),
            e
          );
        }
        clone() {
          return this._cloneInto();
        }
        destroy() {
          (this.destroyed = !0), this.oHash.destroy(), this.iHash.destroy();
        }
      }
      let Q = (e, t, r) => new F(e, t).update(r).digest();
      function z(e, t, r, i) {
        var n, s, o, a, l;
        let c,
          {
            c: d,
            dkLen: u,
            DK: h,
            PRF: p,
            PRFSalt: f,
          } = (function (e, t, r, i) {
            T(e);
            let {
              c: n,
              dkLen: s,
              asyncTick: o,
            } = j({ dkLen: 32, asyncTick: 10 }, i);
            if ((_(n), _(s), _(o), n < 1))
              throw Error("iterations (c) should be >= 1");
            let a = M(t),
              l = M(r),
              c = new Uint8Array(s),
              d = Q.create(e, a),
              u = d._cloneInto().update(l);
            return { c: n, dkLen: s, asyncTick: o, DK: c, PRF: d, PRFSalt: u };
          })(e, t, r, i),
          m = new Uint8Array(4),
          y = C(m),
          g = new Uint8Array(p.outputLen);
        for (let e = 1, t = 0; t < u; e++, t += p.outputLen) {
          let r = h.subarray(t, t + p.outputLen);
          y.setInt32(0, e, !1),
            (c = f._cloneInto(c)).update(m).digestInto(g),
            r.set(g.subarray(0, r.length));
          for (let e = 1; e < d; e++) {
            p._cloneInto(c).update(g).digestInto(g);
            for (let e = 0; e < r.length; e++) r[e] ^= g[e];
          }
        }
        return (
          (n = p),
          (s = f),
          (o = h),
          (a = c),
          (l = g),
          n.destroy(),
          s.destroy(),
          a && a.destroy(),
          E(l),
          o
        );
      }
      Q.create = (e, t) => new F(e, t);
      class V extends W {
        constructor(e, t, r, i) {
          super(),
            (this.finished = !1),
            (this.length = 0),
            (this.pos = 0),
            (this.destroyed = !1),
            (this.blockLen = e),
            (this.outputLen = t),
            (this.padOffset = r),
            (this.isLE = i),
            (this.buffer = new Uint8Array(e)),
            (this.view = C(this.buffer));
        }
        update(e) {
          k(this), S((e = B(e)));
          let { view: t, buffer: r, blockLen: i } = this,
            n = e.length;
          for (let s = 0; s < n; ) {
            let o = Math.min(i - this.pos, n - s);
            if (o === i) {
              let t = C(e);
              for (; i <= n - s; s += i) this.process(t, s);
              continue;
            }
            r.set(e.subarray(s, s + o), this.pos),
              (this.pos += o),
              (s += o),
              this.pos === i && (this.process(t, 0), (this.pos = 0));
          }
          return (this.length += e.length), this.roundClean(), this;
        }
        digestInto(e) {
          k(this);
          S(e);
          let t = this.outputLen;
          if (e.length < t)
            throw Error(
              "digestInto() expects output buffer of length at least " + t
            );
          this.finished = !0;
          let { buffer: r, view: i, blockLen: n, isLE: s } = this,
            { pos: o } = this;
          (r[o++] = 128),
            E(this.buffer.subarray(o)),
            this.padOffset > n - o && (this.process(i, 0), (o = 0));
          for (let e = o; e < n; e++) r[e] = 0;
          !(function (e, t, r, i) {
            if ("function" == typeof e.setBigUint64)
              return e.setBigUint64(t, r, i);
            let n = BigInt(32),
              s = BigInt(0xffffffff),
              o = Number((r >> n) & s),
              a = Number(r & s),
              l = 4 * !!i,
              c = 4 * !i;
            e.setUint32(t + l, o, i), e.setUint32(t + c, a, i);
          })(i, n - 8, BigInt(8 * this.length), s),
            this.process(i, 0);
          let a = C(e),
            l = this.outputLen;
          if (l % 4) throw Error("_sha2: outputLen should be aligned to 32bit");
          let c = l / 4,
            d = this.get();
          if (c > d.length) throw Error("_sha2: outputLen bigger than state");
          for (let e = 0; e < c; e++) a.setUint32(4 * e, d[e], s);
        }
        digest() {
          let { buffer: e, outputLen: t } = this;
          this.digestInto(e);
          let r = e.slice(0, t);
          return this.destroy(), r;
        }
        _cloneInto(e) {
          e || (e = new this.constructor()), e.set(...this.get());
          let {
            blockLen: t,
            buffer: r,
            length: i,
            finished: n,
            destroyed: s,
            pos: o,
          } = this;
          return (
            (e.destroyed = s),
            (e.finished = n),
            (e.length = i),
            (e.pos = o),
            i % t && e.buffer.set(r),
            e
          );
        }
        clone() {
          return this._cloneInto();
        }
      }
      let K = Uint32Array.from([
          0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f,
          0x9b05688c, 0x1f83d9ab, 0x5be0cd19,
        ]),
        G = BigInt(0x100000000 - 1),
        H = BigInt(32),
        J = Uint32Array.from([
          0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b,
          0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01,
          0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7,
          0xc19bf174, 0xe49b69c1, 0xefbe4786, 0xfc19dc6, 0x240ca1cc, 0x2de92c6f,
          0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152, 0xa831c66d,
          0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x6ca6351, 0x14292967,
          0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354,
          0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b,
          0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585,
          0x106aa070, 0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
          0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3, 0x748f82ee,
          0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb,
          0xbef9a3f7, 0xc67178f2,
        ]),
        Z = new Uint32Array(64);
      class Y extends V {
        constructor(e = 32) {
          super(64, e, 8, !1),
            (this.A = 0 | K[0]),
            (this.B = 0 | K[1]),
            (this.C = 0 | K[2]),
            (this.D = 0 | K[3]),
            (this.E = 0 | K[4]),
            (this.F = 0 | K[5]),
            (this.G = 0 | K[6]),
            (this.H = 0 | K[7]);
        }
        get() {
          let { A: e, B: t, C: r, D: i, E: n, F: s, G: o, H: a } = this;
          return [e, t, r, i, n, s, o, a];
        }
        set(e, t, r, i, n, s, o, a) {
          (this.A = 0 | e),
            (this.B = 0 | t),
            (this.C = 0 | r),
            (this.D = 0 | i),
            (this.E = 0 | n),
            (this.F = 0 | s),
            (this.G = 0 | o),
            (this.H = 0 | a);
        }
        process(e, t) {
          for (let r = 0; r < 16; r++, t += 4) Z[r] = e.getUint32(t, !1);
          for (let e = 16; e < 64; e++) {
            let t = Z[e - 15],
              r = Z[e - 2],
              i = I(t, 7) ^ I(t, 18) ^ (t >>> 3),
              n = I(r, 17) ^ I(r, 19) ^ (r >>> 10);
            Z[e] = (n + Z[e - 7] + i + Z[e - 16]) | 0;
          }
          let { A: r, B: i, C: n, D: s, E: o, F: a, G: l, H: c } = this;
          for (let e = 0; e < 64; e++) {
            var d, u, h, p;
            let t =
                (c +
                  (I(o, 6) ^ I(o, 11) ^ I(o, 25)) +
                  (((d = o) & a) ^ (~d & l)) +
                  J[e] +
                  Z[e]) |
                0,
              f =
                ((I(r, 2) ^ I(r, 13) ^ I(r, 22)) +
                  (((u = r) & (h = i)) ^ (u & (p = n)) ^ (h & p))) |
                0;
            (c = l),
              (l = a),
              (a = o),
              (o = (s + t) | 0),
              (s = n),
              (n = i),
              (i = r),
              (r = (t + f) | 0);
          }
          (r = (r + this.A) | 0),
            (i = (i + this.B) | 0),
            (n = (n + this.C) | 0),
            (s = (s + this.D) | 0),
            (o = (o + this.E) | 0),
            (a = (a + this.F) | 0),
            (l = (l + this.G) | 0),
            (c = (c + this.H) | 0),
            this.set(r, i, n, s, o, a, l, c);
        }
        roundClean() {
          E(Z);
        }
        destroy() {
          this.set(0, 0, 0, 0, 0, 0, 0, 0), E(this.buffer);
        }
      }
      !(function (e, t = !1) {
        let r = e.length,
          i = new Uint32Array(r),
          n = new Uint32Array(r);
        for (let s = 0; s < r; s++) {
          let { h: r, l: o } = (function (e, t = !1) {
            return t
              ? { h: Number(e & G), l: Number((e >> H) & G) }
              : { h: 0 | Number((e >> H) & G), l: 0 | Number(e & G) };
          })(e[s], t);
          [i[s], n[s]] = [r, o];
        }
      })(
        [
          "0x428a2f98d728ae22",
          "0x7137449123ef65cd",
          "0xb5c0fbcfec4d3b2f",
          "0xe9b5dba58189dbbc",
          "0x3956c25bf348b538",
          "0x59f111f1b605d019",
          "0x923f82a4af194f9b",
          "0xab1c5ed5da6d8118",
          "0xd807aa98a3030242",
          "0x12835b0145706fbe",
          "0x243185be4ee4b28c",
          "0x550c7dc3d5ffb4e2",
          "0x72be5d74f27b896f",
          "0x80deb1fe3b1696b1",
          "0x9bdc06a725c71235",
          "0xc19bf174cf692694",
          "0xe49b69c19ef14ad2",
          "0xefbe4786384f25e3",
          "0x0fc19dc68b8cd5b5",
          "0x240ca1cc77ac9c65",
          "0x2de92c6f592b0275",
          "0x4a7484aa6ea6e483",
          "0x5cb0a9dcbd41fbd4",
          "0x76f988da831153b5",
          "0x983e5152ee66dfab",
          "0xa831c66d2db43210",
          "0xb00327c898fb213f",
          "0xbf597fc7beef0ee4",
          "0xc6e00bf33da88fc2",
          "0xd5a79147930aa725",
          "0x06ca6351e003826f",
          "0x142929670a0e6e70",
          "0x27b70a8546d22ffc",
          "0x2e1b21385c26c926",
          "0x4d2c6dfc5ac42aed",
          "0x53380d139d95b3df",
          "0x650a73548baf63de",
          "0x766a0abb3c77b2a8",
          "0x81c2c92e47edaee6",
          "0x92722c851482353b",
          "0xa2bfe8a14cf10364",
          "0xa81a664bbc423001",
          "0xc24b8b70d0f89791",
          "0xc76c51a30654be30",
          "0xd192e819d6ef5218",
          "0xd69906245565a910",
          "0xf40e35855771202a",
          "0x106aa07032bbd1b8",
          "0x19a4c116b8d2d0c8",
          "0x1e376c085141ab53",
          "0x2748774cdf8eeb99",
          "0x34b0bcb5e19b48a8",
          "0x391c0cb3c5c95a63",
          "0x4ed8aa4ae3418acb",
          "0x5b9cca4f7763e373",
          "0x682e6ff3d6b2b8a3",
          "0x748f82ee5defb2fc",
          "0x78a5636f43172f60",
          "0x84c87814a1f0ab72",
          "0x8cc702081a6439ec",
          "0x90befffa23631e28",
          "0xa4506cebde82bde9",
          "0xbef9a3f7b2c67915",
          "0xc67178f2e372532b",
          "0xca273eceea26619c",
          "0xd186b8c721c0c207",
          "0xeada7dd6cde0eb1e",
          "0xf57d4f7fee6ed178",
          "0x06f067aa72176fba",
          "0x0a637dc5a2c898a6",
          "0x113f9804bef90dae",
          "0x1b710b35131c471b",
          "0x28db77f523047d84",
          "0x32caab7b40c72493",
          "0x3c9ebe0a15c9bebc",
          "0x431d67c49c100d4c",
          "0x4cc5d4becb3e42b6",
          "0x597f299cfc657e2a",
          "0x5fcb6fab3ad6faec",
          "0x6c44198c4a475817",
        ].map((e) => BigInt(e))
      );
      let X = (function (e) {
        let t = (t) => e().update(B(t)).digest(),
          r = e();
        return (
          (t.outputLen = r.outputLen),
          (t.blockLen = r.blockLen),
          (t.create = () => e()),
          t
        );
      })(() => new Y());
      function ee(e, t, r, i, n, s) {
        let o = e[t++] ^ r[i++],
          a = e[t++] ^ r[i++],
          l = e[t++] ^ r[i++],
          c = e[t++] ^ r[i++],
          d = e[t++] ^ r[i++],
          u = e[t++] ^ r[i++],
          h = e[t++] ^ r[i++],
          p = e[t++] ^ r[i++],
          f = e[t++] ^ r[i++],
          m = e[t++] ^ r[i++],
          y = e[t++] ^ r[i++],
          g = e[t++] ^ r[i++],
          w = e[t++] ^ r[i++],
          b = e[t++] ^ r[i++],
          v = e[t++] ^ r[i++],
          N = e[t++] ^ r[i++],
          x = o,
          _ = a,
          S = l,
          T = c,
          k = d,
          A = u,
          E = h,
          C = p,
          I = f,
          L = m,
          R = y,
          P = g,
          D = w,
          q = b,
          U = v,
          $ = N;
        for (let e = 0; e < 8; e += 2)
          (k ^= O((x + D) | 0, 7)),
            (I ^= O((k + x) | 0, 9)),
            (D ^= O((I + k) | 0, 13)),
            (x ^= O((D + I) | 0, 18)),
            (L ^= O((A + _) | 0, 7)),
            (q ^= O((L + A) | 0, 9)),
            (_ ^= O((q + L) | 0, 13)),
            (A ^= O((_ + q) | 0, 18)),
            (U ^= O((R + E) | 0, 7)),
            (S ^= O((U + R) | 0, 9)),
            (E ^= O((S + U) | 0, 13)),
            (R ^= O((E + S) | 0, 18)),
            (T ^= O(($ + P) | 0, 7)),
            (C ^= O((T + $) | 0, 9)),
            (P ^= O((C + T) | 0, 13)),
            ($ ^= O((P + C) | 0, 18)),
            (_ ^= O((x + T) | 0, 7)),
            (S ^= O((_ + x) | 0, 9)),
            (T ^= O((S + _) | 0, 13)),
            (x ^= O((T + S) | 0, 18)),
            (E ^= O((A + k) | 0, 7)),
            (C ^= O((E + A) | 0, 9)),
            (k ^= O((C + E) | 0, 13)),
            (A ^= O((k + C) | 0, 18)),
            (P ^= O((R + L) | 0, 7)),
            (I ^= O((P + R) | 0, 9)),
            (L ^= O((I + P) | 0, 13)),
            (R ^= O((L + I) | 0, 18)),
            (D ^= O(($ + U) | 0, 7)),
            (q ^= O((D + $) | 0, 9)),
            (U ^= O((q + D) | 0, 13)),
            ($ ^= O((U + q) | 0, 18));
        (n[s++] = (o + x) | 0),
          (n[s++] = (a + _) | 0),
          (n[s++] = (l + S) | 0),
          (n[s++] = (c + T) | 0),
          (n[s++] = (d + k) | 0),
          (n[s++] = (u + A) | 0),
          (n[s++] = (h + E) | 0),
          (n[s++] = (p + C) | 0),
          (n[s++] = (f + I) | 0),
          (n[s++] = (m + L) | 0),
          (n[s++] = (y + R) | 0),
          (n[s++] = (g + P) | 0),
          (n[s++] = (w + D) | 0),
          (n[s++] = (b + q) | 0),
          (n[s++] = (v + U) | 0),
          (n[s++] = (N + $) | 0);
      }
      function et(e, t, r, i, n) {
        let s = i + 0,
          o = i + 16 * n;
        for (let i = 0; i < 16; i++) r[o + i] = e[t + (2 * n - 1) * 16 + i];
        for (let i = 0; i < n; i++, s += 16, t += 16)
          ee(r, o, e, t, r, s),
            i > 0 && (o += 16),
            ee(r, s, e, (t += 16), r, o);
      }
      async function er(e, t, r) {
        let {
          N: i,
          r: n,
          p: s,
          dkLen: o,
          blockSize32: a,
          V: l,
          B32: c,
          B: d,
          tmp: u,
          blockMixCb: h,
          asyncTick: p,
        } = (function (e, t, r) {
          let {
            N: i,
            r: n,
            p: s,
            dkLen: o,
            asyncTick: a,
            maxmem: l,
            onProgress: c,
          } = j({ dkLen: 32, asyncTick: 10, maxmem: 0x40000400 }, r);
          if (
            (_(i),
            _(n),
            _(s),
            _(o),
            _(a),
            _(l),
            void 0 !== c && "function" != typeof c)
          )
            throw Error("progressCb should be function");
          let d = 128 * n,
            u = d / 4;
          if (i <= 1 || (i & (i - 1)) != 0 || i > 0x100000000)
            throw Error(
              "Scrypt: N must be larger than 1, a power of 2, and less than 2^32"
            );
          if (s < 0 || s > 0x1fffffffe0 / d)
            throw Error(
              "Scrypt: p must be a positive integer less than or equal to ((2^32 - 1) * 32) / (128 * r)"
            );
          if (o < 0 || o > 0x1fffffffe0)
            throw Error(
              "Scrypt: dkLen should be positive integer less than or equal to (2^32 - 1) * 32"
            );
          if (d * (i + s) > l)
            throw Error(
              "Scrypt: memused is bigger than maxMem. Expected 128 * r * (N + p) > maxmem of " +
                l
            );
          let h = z(X, e, t, { c: 1, dkLen: d * s }),
            p = A(h),
            f = A(new Uint8Array(d * i)),
            m = A(new Uint8Array(d)),
            y = () => {};
          if (c) {
            let e = 2 * i * s,
              t = Math.max(Math.floor(e / 1e4), 1),
              r = 0;
            y = () => {
              r++, c && (!(r % t) || r === e) && c(r / e);
            };
          }
          return {
            N: i,
            r: n,
            p: s,
            dkLen: o,
            blockSize32: u,
            V: f,
            B32: p,
            B: h,
            tmp: m,
            blockMixCb: y,
            asyncTick: a,
          };
        })(e, t, r);
        L(c);
        for (let e = 0; e < s; e++) {
          let t = a * e;
          for (let e = 0; e < a; e++) l[e] = c[t + e];
          let r = 0;
          await U(i - 1, p, () => {
            et(l, r, l, (r += a), n), h();
          }),
            et(l, (i - 1) * a, c, t, n),
            h(),
            await U(i, p, () => {
              let e = c[t + a - 16] % i;
              for (let r = 0; r < a; r++) u[r] = c[t + r] ^ l[e * a + r];
              et(u, 0, c, t, n), h();
            });
        }
        return (
          L(c),
          (function (e, t, r, i, n) {
            let s = z(X, e, r, { c: 1, dkLen: t });
            return E(r, i, n), s;
          })(e, o, d, l, u)
        );
      }
      var ei = r(8126);
      let en = { N: 16384, r: 16, p: 1, dkLen: 64 };
      async function es(e, t) {
        return await er(e.normalize("NFKC"), t, {
          N: en.N,
          p: en.p,
          r: en.r,
          dkLen: en.dkLen,
          maxmem: 128 * en.N * en.r * 2,
        });
      }
      let eo = async (e) => {
          let t = h.u.encode((0, ei.UY)(new Uint8Array(16))),
            r = await es(e, t);
          return `${t}:${h.u.encode(r)}`;
        },
        ea = async ({ hash: e, password: t }) => {
          let [r, i] = e.split(":");
          return (function (e, t) {
            let r = new Uint8Array(e),
              i = new Uint8Array(t);
            if (r.length !== i.length) return !1;
            let n = 0;
            for (let e = 0; e < r.length; e++) n |= r[e] ^ i[e];
            return 0 === n;
          })(
            await es(t, r),
            (function (e) {
              if ("string" != typeof e)
                throw Error("hex string expected, got " + typeof e);
              if (R) return Uint8Array.fromHex(e);
              let t = e.length,
                r = t / 2;
              if (t % 2)
                throw Error(
                  "hex string expected, got unpadded hex of length " + t
                );
              let i = new Uint8Array(r);
              for (let t = 0, n = 0; t < r; t++, n += 2) {
                let r = D(e.charCodeAt(n)),
                  s = D(e.charCodeAt(n + 1));
                if (void 0 === r || void 0 === s)
                  throw Error(
                    'hex string expected, got non-hex character "' +
                      (e[n] + e[n + 1]) +
                      '" at index ' +
                      n
                  );
                i[t] = 16 * r + s;
              }
              return i;
            })(i)
          );
        };
      var el = r(7846),
        ec = r(93818),
        ed = r(94349),
        eu = r(16533),
        eh = r(53668),
        ep = r(67872),
        ef = r(1045);
      function em(e, t) {
        return ef.z.createWithChildren([
          ef.z.createWithSql(`${e} `),
          ep.O.create(t),
        ]);
      }
      var ey = r(29900),
        eg = r(96051),
        ew = r(6710);
      class eb {
        #b;
        #v = new eN();
        #N;
        #x;
        constructor(e) {
          this.#b = (0, eg.CN)({ ...e });
        }
        async init() {
          (this.#N = (0, eg.Tn)(this.#b.database)
            ? await this.#b.database()
            : this.#b.database),
            (this.#x = new ev(this.#N)),
            this.#b.onCreateConnection &&
              (await this.#b.onCreateConnection(this.#x));
        }
        async acquireConnection() {
          return await this.#v.lock(), this.#x;
        }
        async beginTransaction(e) {
          await e.executeQuery(ey.E.raw("begin"));
        }
        async commitTransaction(e) {
          await e.executeQuery(ey.E.raw("commit"));
        }
        async rollbackTransaction(e) {
          await e.executeQuery(ey.E.raw("rollback"));
        }
        async savepoint(e, t, r) {
          await e.executeQuery(r(em("savepoint", t), (0, ew.a)()));
        }
        async rollbackToSavepoint(e, t, r) {
          await e.executeQuery(r(em("rollback to", t), (0, ew.a)()));
        }
        async releaseSavepoint(e, t, r) {
          await e.executeQuery(r(em("release", t), (0, ew.a)()));
        }
        async releaseConnection() {
          this.#v.unlock();
        }
        async destroy() {
          this.#N?.close();
        }
      }
      class ev {
        #N;
        constructor(e) {
          this.#N = e;
        }
        executeQuery(e) {
          let { sql: t, parameters: r } = e,
            i = this.#N.prepare(t);
          if (i.reader) return Promise.resolve({ rows: i.all(r) });
          let { changes: n, lastInsertRowid: s } = i.run(r);
          return Promise.resolve({
            numAffectedRows: null != n ? BigInt(n) : void 0,
            insertId: null != s ? BigInt(s) : void 0,
            rows: [],
          });
        }
        async *streamQuery(e, t) {
          let { sql: r, parameters: i, query: n } = e,
            s = this.#N.prepare(r);
          if (eh.L.is(n)) for (let e of s.iterate(i)) yield { rows: [e] };
          else
            throw Error(
              "Sqlite driver only supports streaming of select queries"
            );
        }
      }
      class eN {
        #n;
        #s;
        async lock() {
          for (; this.#n; ) await this.#n;
          this.#n = new Promise((e) => {
            this.#s = e;
          });
        }
        unlock() {
          let e = this.#s;
          (this.#n = void 0), (this.#s = void 0), e?.();
        }
      }
      var ex = r(77329);
      let e_ = /"/g;
      class eS extends ex.n {
        visitOrAction(e) {
          this.append("or "), this.append(e.action);
        }
        getCurrentParameterPlaceholder() {
          return "?";
        }
        getLeftExplainOptionsWrapper() {
          return "";
        }
        getRightExplainOptionsWrapper() {
          return "";
        }
        getLeftIdentifierWrapper() {
          return '"';
        }
        getRightIdentifierWrapper() {
          return '"';
        }
        getAutoIncrement() {
          return "autoincrement";
        }
        sanitizeIdentifier(e) {
          return e.replace(e_, '""');
        }
        visitDefaultInsertValue(e) {
          this.append("null");
        }
      }
      var eT = r(50403),
        ek = r(38537);
      class eA {
        #N;
        constructor(e) {
          this.#N = e;
        }
        async getSchemas() {
          return [];
        }
        async getTables(e = { withInternalKyselyTables: !1 }) {
          return await this.#_(e);
        }
        async getMetadata(e) {
          return { tables: await this.getTables(e) };
        }
        #S(e, t) {
          let r = e
            .selectFrom("sqlite_master")
            .where("type", "in", ["table", "view"])
            .where("name", "not like", "sqlite_%")
            .select(["name", "sql", "type"])
            .orderBy("name");
          return (
            t.withInternalKyselyTables ||
              (r = r.where("name", "!=", eT.kQ).where("name", "!=", eT.sy)),
            r
          );
        }
        async #_(e) {
          let t = await this.#S(this.#N, e).execute(),
            r = await this.#N
              .with("table_list", (t) => this.#S(t, e))
              .selectFrom([
                "table_list as tl",
                (0, ek.l)`pragma_table_info(tl.name)`.as("p"),
              ])
              .select([
                "tl.name as table",
                "p.cid",
                "p.name",
                "p.type",
                "p.notnull",
                "p.dflt_value",
                "p.pk",
              ])
              .orderBy("tl.name")
              .orderBy("p.cid")
              .execute(),
            i = {};
          for (let e of r) (i[e.table] ??= []), i[e.table].push(e);
          return t.map(({ name: e, sql: t, type: r }) => {
            let n = t
                ?.split(/[\(\),]/)
                ?.find((e) => e.toLowerCase().includes("autoincrement"))
                ?.trimStart()
                ?.split(/\s+/)?.[0]
                ?.replace(/["`]/g, ""),
              s = i[e] ?? [];
            if (!n) {
              let e = s.filter((e) => e.pk > 0);
              1 === e.length &&
                "integer" === e[0].type.toLowerCase() &&
                (n = e[0].name);
            }
            return {
              name: e,
              isView: "view" === r,
              columns: s.map((e) => ({
                name: e.name,
                dataType: e.type,
                isNullable: !e.notnull,
                isAutoIncrementing: e.name === n,
                hasDefaultValue: null != e.dflt_value,
                comment: void 0,
              })),
            };
          });
        }
      }
      class eE {
        get supportsCreateIfNotExists() {
          return !0;
        }
        get supportsTransactionalDdl() {
          return !1;
        }
        get supportsReturning() {
          return !1;
        }
        get supportsOutput() {
          return !1;
        }
      }
      class eC extends eE {
        get supportsTransactionalDdl() {
          return !1;
        }
        get supportsReturning() {
          return !0;
        }
        async acquireMigrationLock(e, t) {}
        async releaseMigrationLock(e, t) {}
      }
      class eI {
        #b;
        constructor(e) {
          this.#b = (0, eg.CN)({ ...e });
        }
        createDriver() {
          return new eb(this.#b);
        }
        createQueryCompiler() {
          return new eS();
        }
        createAdapter() {
          return new eC();
        }
        createIntrospector(e) {
          return new eA(e);
        }
      }
      function eO(e, t) {
        var r;
        if (((r = e), (0, eg.Gv)(r) && (0, eg.Kg)(r.stack) && t.stack)) {
          let r = t.stack.split("\n").slice(1).join("\n");
          e.stack += `
${r}`;
        }
        return e;
      }
      let eL = Symbol();
      class eR {
        #b;
        #T = new WeakMap();
        #k;
        constructor(e) {
          this.#b = (0, eg.CN)({ ...e });
        }
        async init() {
          this.#k = (0, eg.Tn)(this.#b.pool)
            ? await this.#b.pool()
            : this.#b.pool;
        }
        async acquireConnection() {
          let e = await this.#A(),
            t = this.#T.get(e);
          return (
            !t &&
              ((t = new eP(e)),
              this.#T.set(e, t),
              this.#b?.onCreateConnection &&
                (await this.#b.onCreateConnection(t))),
            this.#b?.onReserveConnection &&
              (await this.#b.onReserveConnection(t)),
            t
          );
        }
        async #A() {
          return new Promise((e, t) => {
            this.#k.getConnection(async (r, i) => {
              r ? t(r) : e(i);
            });
          });
        }
        async beginTransaction(e, t) {
          if (t.isolationLevel || t.accessMode) {
            let r = [];
            t.isolationLevel && r.push(`isolation level ${t.isolationLevel}`),
              t.accessMode && r.push(t.accessMode);
            let i = `set transaction ${r.join(", ")}`;
            await e.executeQuery(ey.E.raw(i));
          }
          await e.executeQuery(ey.E.raw("begin"));
        }
        async commitTransaction(e) {
          await e.executeQuery(ey.E.raw("commit"));
        }
        async rollbackTransaction(e) {
          await e.executeQuery(ey.E.raw("rollback"));
        }
        async savepoint(e, t, r) {
          await e.executeQuery(r(em("savepoint", t), (0, ew.a)()));
        }
        async rollbackToSavepoint(e, t, r) {
          await e.executeQuery(r(em("rollback to", t), (0, ew.a)()));
        }
        async releaseSavepoint(e, t, r) {
          await e.executeQuery(r(em("release savepoint", t), (0, ew.a)()));
        }
        async releaseConnection(e) {
          e[eL]();
        }
        async destroy() {
          return new Promise((e, t) => {
            this.#k.end((r) => {
              r ? t(r) : e();
            });
          });
        }
      }
      class eP {
        #E;
        constructor(e) {
          this.#E = e;
        }
        async executeQuery(e) {
          try {
            let t = await this.#C(e);
            if ((0, eg.Gv)(t) && "insertId" in t && "affectedRows" in t) {
              let { insertId: e, affectedRows: r, changedRows: i } = t;
              return {
                insertId:
                  null != e && "0" !== e.toString() ? BigInt(e) : void 0,
                numAffectedRows: null != r ? BigInt(r) : void 0,
                numChangedRows: null != i ? BigInt(i) : void 0,
                rows: [],
              };
            }
            if (Array.isArray(t)) return { rows: t };
            return { rows: [] };
          } catch (e) {
            throw eO(e, Error());
          }
        }
        #C(e) {
          return new Promise((t, r) => {
            this.#E.query(e.sql, e.parameters, (e, i) => {
              e ? r(e) : t(i);
            });
          });
        }
        async *streamQuery(e, t) {
          let r = this.#E.query(e.sql, e.parameters).stream({ objectMode: !0 });
          try {
            for await (let e of r) yield { rows: [e] };
          } catch (e) {
            if (
              e &&
              "object" == typeof e &&
              "code" in e &&
              "ERR_STREAM_PREMATURE_CLOSE" === e.code
            )
              return;
            throw e;
          }
        }
        [eL]() {
          this.#E.release();
        }
      }
      let eD = /`/g;
      class eq extends ex.n {
        getCurrentParameterPlaceholder() {
          return "?";
        }
        getLeftExplainOptionsWrapper() {
          return "";
        }
        getExplainOptionAssignment() {
          return "=";
        }
        getExplainOptionsDelimiter() {
          return " ";
        }
        getRightExplainOptionsWrapper() {
          return "";
        }
        getLeftIdentifierWrapper() {
          return "`";
        }
        getRightIdentifierWrapper() {
          return "`";
        }
        sanitizeIdentifier(e) {
          return e.replace(eD, "``");
        }
        visitCreateIndex(e) {
          this.append("create "),
            e.unique && this.append("unique "),
            this.append("index "),
            e.ifNotExists && this.append("if not exists "),
            this.visitNode(e.name),
            e.using && (this.append(" using "), this.visitNode(e.using)),
            e.table && (this.append(" on "), this.visitNode(e.table)),
            e.columns &&
              (this.append(" ("),
              this.compileList(e.columns),
              this.append(")")),
            e.where && (this.append(" "), this.visitNode(e.where));
        }
      }
      class eU {
        #N;
        constructor(e) {
          this.#N = e;
        }
        async getSchemas() {
          return (
            await this.#N
              .selectFrom("information_schema.schemata")
              .select("schema_name")
              .$castTo()
              .execute()
          ).map((e) => ({ name: e.SCHEMA_NAME }));
        }
        async getTables(e = { withInternalKyselyTables: !1 }) {
          let t = this.#N
            .selectFrom("information_schema.columns as columns")
            .innerJoin("information_schema.tables as tables", (e) =>
              e
                .onRef("columns.TABLE_CATALOG", "=", "tables.TABLE_CATALOG")
                .onRef("columns.TABLE_SCHEMA", "=", "tables.TABLE_SCHEMA")
                .onRef("columns.TABLE_NAME", "=", "tables.TABLE_NAME")
            )
            .select([
              "columns.COLUMN_NAME",
              "columns.COLUMN_DEFAULT",
              "columns.TABLE_NAME",
              "columns.TABLE_SCHEMA",
              "tables.TABLE_TYPE",
              "columns.IS_NULLABLE",
              "columns.DATA_TYPE",
              "columns.EXTRA",
              "columns.COLUMN_COMMENT",
            ])
            .where("columns.TABLE_SCHEMA", "=", (0, ek.l)`database()`)
            .orderBy("columns.TABLE_NAME")
            .orderBy("columns.ORDINAL_POSITION")
            .$castTo();
          e.withInternalKyselyTables ||
            (t = t
              .where("columns.TABLE_NAME", "!=", eT.kQ)
              .where("columns.TABLE_NAME", "!=", eT.sy));
          let r = await t.execute();
          return this.#I(r);
        }
        async getMetadata(e) {
          return { tables: await this.getTables(e) };
        }
        #I(e) {
          return e.reduce((e, t) => {
            let r = e.find((e) => e.name === t.TABLE_NAME);
            return (
              r ||
                ((r = (0, eg.CN)({
                  name: t.TABLE_NAME,
                  isView: "VIEW" === t.TABLE_TYPE,
                  schema: t.TABLE_SCHEMA,
                  columns: [],
                })),
                e.push(r)),
              r.columns.push(
                (0, eg.CN)({
                  name: t.COLUMN_NAME,
                  dataType: t.DATA_TYPE,
                  isNullable: "YES" === t.IS_NULLABLE,
                  isAutoIncrementing:
                    t.EXTRA.toLowerCase().includes("auto_increment"),
                  hasDefaultValue: null !== t.COLUMN_DEFAULT,
                  comment: "" === t.COLUMN_COMMENT ? void 0 : t.COLUMN_COMMENT,
                })
              ),
              e
            );
          }, []);
        }
      }
      let e$ = "ea586330-2c93-47c8-908d-981d9d270f9d";
      class eB extends eE {
        get supportsTransactionalDdl() {
          return !1;
        }
        get supportsReturning() {
          return !1;
        }
        async acquireMigrationLock(e, t) {
          await (0,
          ek.l)`select get_lock(${ek.l.lit(e$)}, ${ek.l.lit(3600)})`.execute(e);
        }
        async releaseMigrationLock(e, t) {
          await (0, ek.l)`select release_lock(${ek.l.lit(e$)})`.execute(e);
        }
      }
      class eM {
        #b;
        constructor(e) {
          this.#b = e;
        }
        createDriver() {
          return new eR(this.#b);
        }
        createQueryCompiler() {
          return new eq();
        }
        createAdapter() {
          return new eB();
        }
        createIntrospector(e) {
          return new eU(e);
        }
      }
      let ej = Symbol();
      class eW {
        #b;
        #T = new WeakMap();
        #k;
        constructor(e) {
          this.#b = (0, eg.CN)({ ...e });
        }
        async init() {
          this.#k = (0, eg.Tn)(this.#b.pool)
            ? await this.#b.pool()
            : this.#b.pool;
        }
        async acquireConnection() {
          let e = await this.#k.connect(),
            t = this.#T.get(e);
          return (
            !t &&
              ((t = new eF(e, { cursor: this.#b.cursor ?? null })),
              this.#T.set(e, t),
              this.#b.onCreateConnection &&
                (await this.#b.onCreateConnection(t))),
            this.#b.onReserveConnection &&
              (await this.#b.onReserveConnection(t)),
            t
          );
        }
        async beginTransaction(e, t) {
          if (t.isolationLevel || t.accessMode) {
            let r = "start transaction";
            t.isolationLevel && (r += ` isolation level ${t.isolationLevel}`),
              t.accessMode && (r += ` ${t.accessMode}`),
              await e.executeQuery(ey.E.raw(r));
          } else await e.executeQuery(ey.E.raw("begin"));
        }
        async commitTransaction(e) {
          await e.executeQuery(ey.E.raw("commit"));
        }
        async rollbackTransaction(e) {
          await e.executeQuery(ey.E.raw("rollback"));
        }
        async savepoint(e, t, r) {
          await e.executeQuery(r(em("savepoint", t), (0, ew.a)()));
        }
        async rollbackToSavepoint(e, t, r) {
          await e.executeQuery(r(em("rollback to", t), (0, ew.a)()));
        }
        async releaseSavepoint(e, t, r) {
          await e.executeQuery(r(em("release", t), (0, ew.a)()));
        }
        async releaseConnection(e) {
          e[ej]();
        }
        async destroy() {
          if (this.#k) {
            let e = this.#k;
            (this.#k = void 0), await e.end();
          }
        }
      }
      class eF {
        #O;
        #L;
        constructor(e, t) {
          (this.#O = e), (this.#L = t);
        }
        async executeQuery(e) {
          try {
            let {
              command: t,
              rowCount: r,
              rows: i,
            } = await this.#O.query(e.sql, [...e.parameters]);
            return {
              numAffectedRows:
                "INSERT" === t ||
                "UPDATE" === t ||
                "DELETE" === t ||
                "MERGE" === t
                  ? BigInt(r)
                  : void 0,
              rows: i ?? [],
            };
          } catch (e) {
            throw eO(e, Error());
          }
        }
        async *streamQuery(e, t) {
          if (!this.#L.cursor)
            throw Error(
              "'cursor' is not present in your postgres dialect config. It's required to make streaming work in postgres."
            );
          if (!Number.isInteger(t) || t <= 0)
            throw Error("chunkSize must be a positive integer");
          let r = this.#O.query(
            new this.#L.cursor(e.sql, e.parameters.slice())
          );
          try {
            for (;;) {
              let e = await r.read(t);
              if (0 === e.length) break;
              yield { rows: e };
            }
          } finally {
            await r.close();
          }
        }
        [ej]() {
          this.#O.release();
        }
      }
      class eQ {
        #N;
        constructor(e) {
          this.#N = e;
        }
        async getSchemas() {
          return (
            await this.#N
              .selectFrom("pg_catalog.pg_namespace")
              .select("nspname")
              .$castTo()
              .execute()
          ).map((e) => ({ name: e.nspname }));
        }
        async getTables(e = { withInternalKyselyTables: !1 }) {
          let t = this.#N
            .selectFrom("pg_catalog.pg_attribute as a")
            .innerJoin("pg_catalog.pg_class as c", "a.attrelid", "c.oid")
            .innerJoin(
              "pg_catalog.pg_namespace as ns",
              "c.relnamespace",
              "ns.oid"
            )
            .innerJoin("pg_catalog.pg_type as typ", "a.atttypid", "typ.oid")
            .innerJoin(
              "pg_catalog.pg_namespace as dtns",
              "typ.typnamespace",
              "dtns.oid"
            )
            .select([
              "a.attname as column",
              "a.attnotnull as not_null",
              "a.atthasdef as has_default",
              "c.relname as table",
              "c.relkind as table_type",
              "ns.nspname as schema",
              "typ.typname as type",
              "dtns.nspname as type_schema",
              (0, ek.l)`col_description(a.attrelid, a.attnum)`.as(
                "column_description"
              ),
              (0,
              ek.l)`pg_get_serial_sequence(quote_ident(ns.nspname) || '.' || quote_ident(c.relname), a.attname)`.as(
                "auto_incrementing"
              ),
            ])
            .where("c.relkind", "in", ["r", "v", "p"])
            .where("ns.nspname", "!~", "^pg_")
            .where("ns.nspname", "!=", "information_schema")
            .where("a.attnum", ">=", 0)
            .where("a.attisdropped", "!=", !0)
            .orderBy("ns.nspname")
            .orderBy("c.relname")
            .orderBy("a.attnum")
            .$castTo();
          e.withInternalKyselyTables ||
            (t = t
              .where("c.relname", "!=", eT.kQ)
              .where("c.relname", "!=", eT.sy));
          let r = await t.execute();
          return this.#I(r);
        }
        async getMetadata(e) {
          return { tables: await this.getTables(e) };
        }
        #I(e) {
          return e.reduce((e, t) => {
            let r = e.find((e) => e.name === t.table && e.schema === t.schema);
            return (
              r ||
                ((r = (0, eg.CN)({
                  name: t.table,
                  isView: "v" === t.table_type,
                  schema: t.schema,
                  columns: [],
                })),
                e.push(r)),
              r.columns.push(
                (0, eg.CN)({
                  name: t.column,
                  dataType: t.type,
                  dataTypeSchema: t.type_schema,
                  isNullable: !t.not_null,
                  isAutoIncrementing: null !== t.auto_incrementing,
                  hasDefaultValue: t.has_default,
                  comment: t.column_description ?? void 0,
                })
              ),
              e
            );
          }, []);
        }
      }
      let ez = /"/g;
      class eV extends ex.n {
        sanitizeIdentifier(e) {
          return e.replace(ez, '""');
        }
      }
      let eK = BigInt("3853314791062309107");
      class eG extends eE {
        get supportsTransactionalDdl() {
          return !0;
        }
        get supportsReturning() {
          return !0;
        }
        async acquireMigrationLock(e, t) {
          await (0,
          ek.l)`select pg_advisory_xact_lock(${ek.l.lit(eK)})`.execute(e);
        }
        async releaseMigrationLock(e, t) {}
      }
      class eH {
        #b;
        constructor(e) {
          this.#b = e;
        }
        createDriver() {
          return new eW(this.#b);
        }
        createQueryCompiler() {
          return new eV();
        }
        createAdapter() {
          return new eG();
        }
        createIntrospector(e) {
          return new eQ(e);
        }
      }
      class eJ extends eE {
        get supportsCreateIfNotExists() {
          return !1;
        }
        get supportsTransactionalDdl() {
          return !0;
        }
        get supportsOutput() {
          return !0;
        }
        async acquireMigrationLock(e) {
          await (0,
          ek.l)`exec sp_getapplock @DbPrincipal = ${ek.l.lit("dbo")}, @Resource = ${ek.l.lit(eT.kQ)}, @LockMode = ${ek.l.lit("Exclusive")}`.execute(
            e
          );
        }
        async releaseMigrationLock() {}
      }
      var eZ = r(9625),
        eY = r(5807);
      let eX = Symbol(),
        e0 = Symbol();
      class e1 {
        #b;
        #k;
        constructor(e) {
          this.#b = (0, eg.CN)({ ...e });
          let { tarn: t, tedious: r, validateConnections: i } = this.#b,
            { validateConnections: n, ...s } = t.options;
          this.#k = new t.Pool({
            ...s,
            create: async () => {
              let e = await r.connectionFactory();
              return await new e2(e, r).connect();
            },
            destroy: async (e) => {
              await e[e0]();
            },
            validate: !1 === i || !1 === n ? void 0 : (e) => e.validate(),
          });
        }
        async init() {}
        async acquireConnection() {
          return await this.#k.acquire().promise;
        }
        async beginTransaction(e, t) {
          await e.beginTransaction(t);
        }
        async commitTransaction(e) {
          await e.commitTransaction();
        }
        async rollbackTransaction(e) {
          await e.rollbackTransaction();
        }
        async savepoint(e, t) {
          await e.savepoint(t);
        }
        async rollbackToSavepoint(e, t) {
          await e.rollbackTransaction(t);
        }
        async releaseConnection(e) {
          (this.#b.resetConnectionsOnRelease ||
            this.#b.tedious.resetConnectionOnRelease) &&
            (await e[eX]()),
            this.#k.release(e);
        }
        async destroy() {
          await this.#k.destroy();
        }
      }
      class e2 {
        #x;
        #R;
        constructor(e, t) {
          (this.#x = e),
            (this.#R = t),
            this.#x.on("error", console.error),
            this.#x.once("end", () => {
              this.#x.off("error", console.error);
            });
        }
        async beginTransaction(e) {
          let { isolationLevel: t } = e;
          await new Promise((e, r) =>
            this.#x.beginTransaction(
              (t) => {
                t ? r(t) : e(void 0);
              },
              t ? (0, eZ.D)(8) : void 0,
              t ? this.#P(t) : void 0
            )
          );
        }
        async commitTransaction() {
          await new Promise((e, t) =>
            this.#x.commitTransaction((r) => {
              r ? t(r) : e(void 0);
            })
          );
        }
        async connect() {
          return (
            await new Promise((e, t) => {
              this.#x.connect((r) => {
                r ? (console.error(r), t(r)) : e(void 0);
              });
            }),
            this
          );
        }
        async executeQuery(e) {
          try {
            let t = new eY.c(),
              r = new e5({ compiledQuery: e, tedious: this.#R, onDone: t });
            this.#x.execSql(r.request);
            let { rowCount: i, rows: n } = await t.promise;
            return {
              numAffectedRows: void 0 !== i ? BigInt(i) : void 0,
              rows: n,
            };
          } catch (e) {
            throw eO(e, Error());
          }
        }
        async rollbackTransaction(e) {
          await new Promise((t, r) =>
            this.#x.rollbackTransaction((e) => {
              e ? r(e) : t(void 0);
            }, e)
          );
        }
        async savepoint(e) {
          await new Promise((t, r) =>
            this.#x.saveTransaction((e) => {
              e ? r(e) : t(void 0);
            }, e)
          );
        }
        async *streamQuery(e, t) {
          if (!Number.isInteger(t) || t <= 0)
            throw Error("chunkSize must be a positive integer");
          let r = new e5({
            compiledQuery: e,
            streamChunkSize: t,
            tedious: this.#R,
          });
          this.#x.execSql(r.request);
          try {
            for (;;) {
              let e = await r.readChunk();
              if (0 === e.length || (yield { rows: e }, e.length < t)) break;
            }
          } finally {
            await this.#D(r);
          }
        }
        async validate() {
          try {
            let e = new eY.c(),
              t = new e5({
                compiledQuery: ey.E.raw("select 1"),
                onDone: e,
                tedious: this.#R,
              });
            return this.#x.execSql(t.request), await e.promise, !0;
          } catch {
            return !1;
          }
        }
        #P(e) {
          let { ISOLATION_LEVEL: t } = this.#R,
            r = {
              "read committed": t.READ_COMMITTED,
              "read uncommitted": t.READ_UNCOMMITTED,
              "repeatable read": t.REPEATABLE_READ,
              serializable: t.SERIALIZABLE,
              snapshot: t.SNAPSHOT,
            }[e];
          if (void 0 === r) throw Error(`Unknown isolation level: ${e}`);
          return r;
        }
        #D(e) {
          return new Promise((t) => {
            e.request.once("requestCompleted", t),
              this.#x.cancel() ||
                (e.request.off("requestCompleted", t), t(void 0));
          });
        }
        async [eX]() {
          await new Promise((e, t) => {
            this.#x.reset((r) => {
              r ? t(r) : e(void 0);
            });
          });
        }
        [e0]() {
          return new Promise((e) => {
            this.#x.once("end", () => {
              e(void 0);
            }),
              this.#x.close();
          });
        }
      }
      class e5 {
        #q;
        #U;
        #$;
        #B;
        #R;
        #M;
        constructor(e) {
          let {
            compiledQuery: t,
            onDone: r,
            streamChunkSize: i,
            tedious: n,
          } = e;
          if (
            ((this.#U = []), (this.#$ = i), (this.#B = {}), (this.#R = n), r)
          ) {
            let e = "onDone";
            this.#B[e] = (t, i) => {
              "chunkReady" !== t &&
                (delete this.#B[e],
                "error" === t
                  ? r.reject(i)
                  : r.resolve({ rowCount: this.#M, rows: this.#U }));
            };
          }
          (this.#q = new this.#R.Request(t.sql, (e, t) => {
            e
              ? Object.values(this.#B).forEach((t) =>
                  t("error", e instanceof AggregateError ? e.errors : e)
                )
              : (this.#M = t);
          })),
            this.#j(t.parameters),
            this.#W();
        }
        get request() {
          return this.#q;
        }
        readChunk() {
          let e = this.readChunk.name;
          return new Promise((t, r) => {
            (this.#B[e] = (i, n) => {
              delete this.#B[e],
                "error" === i ? r(n) : t(this.#U.splice(0, this.#$));
            }),
              this.#q.resume();
          });
        }
        #j(e) {
          for (let t = 0; t < e.length; t++) {
            let r = e[t];
            this.#q.addParameter(String(t + 1), this.#F(r), r);
          }
        }
        #W() {
          let e = this.#$
              ? () => {
                  this.#$ <= this.#U.length &&
                    (this.#q.pause(),
                    Object.values(this.#B).forEach((e) => e("chunkReady")));
                }
              : () => {},
            t = (t) => {
              let r = {};
              for (let e of t) r[e.metadata.colName] = e.value;
              this.#U.push(r), e();
            };
          this.#q.on("row", t),
            this.#q.once("requestCompleted", () => {
              Object.values(this.#B).forEach((e) => e("completed")),
                this.#q.off("row", t);
            });
        }
        #F(e) {
          if ((0, eg.kZ)(e) || (0, eg.b0)(e) || (0, eg.Kg)(e))
            return this.#R.TYPES.NVarChar;
          if ((0, eg.sI)(e) || ((0, eg.Et)(e) && e % 1 == 0))
            if (e < -0x80000000 || e > 0x7fffffff) return this.#R.TYPES.BigInt;
            else return this.#R.TYPES.Int;
          return (0, eg.Et)(e)
            ? this.#R.TYPES.Float
            : (0, eg.Lm)(e)
              ? this.#R.TYPES.Bit
              : (0, eg.$P)(e)
                ? this.#R.TYPES.DateTime
                : (0, eg.Pe)(e)
                  ? this.#R.TYPES.VarBinary
                  : this.#R.TYPES.NVarChar;
        }
      }
      class e6 {
        #N;
        constructor(e) {
          this.#N = e;
        }
        async getSchemas() {
          return await this.#N
            .selectFrom("sys.schemas")
            .select("name")
            .execute();
        }
        async getTables(e = { withInternalKyselyTables: !1 }) {
          let t = await this.#N
              .selectFrom("sys.tables as tables")
              .leftJoin(
                "sys.schemas as table_schemas",
                "table_schemas.schema_id",
                "tables.schema_id"
              )
              .innerJoin(
                "sys.columns as columns",
                "columns.object_id",
                "tables.object_id"
              )
              .innerJoin(
                "sys.types as types",
                "types.user_type_id",
                "columns.user_type_id"
              )
              .leftJoin(
                "sys.schemas as type_schemas",
                "type_schemas.schema_id",
                "types.schema_id"
              )
              .leftJoin("sys.extended_properties as comments", (e) =>
                e
                  .onRef("comments.major_id", "=", "tables.object_id")
                  .onRef("comments.minor_id", "=", "columns.column_id")
                  .on("comments.name", "=", "MS_Description")
              )
              .$if(!e.withInternalKyselyTables, (e) =>
                e
                  .where("tables.name", "!=", eT.kQ)
                  .where("tables.name", "!=", eT.sy)
              )
              .select([
                "tables.name as table_name",
                (e) => e.ref("tables.type").$castTo().as("table_type"),
                "table_schemas.name as table_schema_name",
                "columns.default_object_id as column_default_object_id",
                "columns.generated_always_type_desc as column_generated_always_type",
                "columns.is_computed as column_is_computed",
                "columns.is_identity as column_is_identity",
                "columns.is_nullable as column_is_nullable",
                "columns.is_rowguidcol as column_is_rowguidcol",
                "columns.name as column_name",
                "types.is_nullable as type_is_nullable",
                "types.name as type_name",
                "type_schemas.name as type_schema_name",
                "comments.value as column_comment",
              ])
              .unionAll(
                this.#N
                  .selectFrom("sys.views as views")
                  .leftJoin(
                    "sys.schemas as view_schemas",
                    "view_schemas.schema_id",
                    "views.schema_id"
                  )
                  .innerJoin(
                    "sys.columns as columns",
                    "columns.object_id",
                    "views.object_id"
                  )
                  .innerJoin(
                    "sys.types as types",
                    "types.user_type_id",
                    "columns.user_type_id"
                  )
                  .leftJoin(
                    "sys.schemas as type_schemas",
                    "type_schemas.schema_id",
                    "types.schema_id"
                  )
                  .leftJoin("sys.extended_properties as comments", (e) =>
                    e
                      .onRef("comments.major_id", "=", "views.object_id")
                      .onRef("comments.minor_id", "=", "columns.column_id")
                      .on("comments.name", "=", "MS_Description")
                  )
                  .select([
                    "views.name as table_name",
                    "views.type as table_type",
                    "view_schemas.name as table_schema_name",
                    "columns.default_object_id as column_default_object_id",
                    "columns.generated_always_type_desc as column_generated_always_type",
                    "columns.is_computed as column_is_computed",
                    "columns.is_identity as column_is_identity",
                    "columns.is_nullable as column_is_nullable",
                    "columns.is_rowguidcol as column_is_rowguidcol",
                    "columns.name as column_name",
                    "types.is_nullable as type_is_nullable",
                    "types.name as type_name",
                    "type_schemas.name as type_schema_name",
                    "comments.value as column_comment",
                  ])
              )
              .orderBy("table_schema_name")
              .orderBy("table_name")
              .orderBy("column_name")
              .execute(),
            r = {};
          for (let e of t) {
            let t = `${e.table_schema_name}.${e.table_name}`;
            (r[t] =
              r[t] ||
              (0, eg.CN)({
                columns: [],
                isView: "V " === e.table_type,
                name: e.table_name,
                schema: e.table_schema_name ?? void 0,
              })).columns.push(
              (0, eg.CN)({
                dataType: e.type_name,
                dataTypeSchema: e.type_schema_name ?? void 0,
                hasDefaultValue:
                  e.column_default_object_id > 0 ||
                  "NOT_APPLICABLE" !== e.column_generated_always_type ||
                  e.column_is_identity ||
                  e.column_is_computed ||
                  e.column_is_rowguidcol,
                isAutoIncrementing: e.column_is_identity,
                isNullable: e.column_is_nullable && e.type_is_nullable,
                name: e.column_name,
                comment: e.column_comment ?? void 0,
              })
            );
          }
          return Object.values(r);
        }
        async getMetadata(e) {
          return { tables: await this.getTables(e) };
        }
      }
      let e4 = /^[a-z0-9_]$/i;
      class e3 extends ex.n {
        getCurrentParameterPlaceholder() {
          return `@${this.numParameters}`;
        }
        visitOffset(e) {
          super.visitOffset(e), this.append(" rows");
        }
        compileColumnAlterations(e) {
          let t = {};
          for (let r of e) t[r.kind] || (t[r.kind] = []), t[r.kind].push(r);
          let r = !0;
          t.AddColumnNode &&
            (this.append("add "), this.compileList(t.AddColumnNode), (r = !1)),
            t.AlterColumnNode &&
              (r || this.append(", "), this.compileList(t.AlterColumnNode)),
            t.DropColumnNode &&
              (r || this.append(", "),
              this.append("drop column "),
              this.compileList(t.DropColumnNode)),
            t.ModifyColumnNode &&
              (r || this.append(", "), this.compileList(t.ModifyColumnNode)),
            t.RenameColumnNode &&
              (r || this.append(", "), this.compileList(t.RenameColumnNode));
        }
        visitAddColumn(e) {
          this.visitNode(e.column);
        }
        visitDropColumn(e) {
          this.visitNode(e.column);
        }
        visitMergeQuery(e) {
          super.visitMergeQuery(e), this.append(";");
        }
        visitCollate(e) {
          this.append("collate ");
          let { name: t } = e.collation;
          for (let e of t)
            if (!e4.test(e)) throw Error(`Invalid collation: ${t}`);
          this.append(t);
        }
        announcesNewColumnDataType() {
          return !1;
        }
      }
      class e8 {
        #b;
        constructor(e) {
          this.#b = e;
        }
        createDriver() {
          return new e1(this.#b);
        }
        createQueryCompiler() {
          return new e3();
        }
        createAdapter() {
          return new eJ();
        }
        createIntrospector(e) {
          return new e6(e);
        }
      }
      let e9 = (0, eg.CN)({
          is: (e) => "AlterTableNode" === e.kind,
          create: (e) => (0, eg.CN)({ kind: "AlterTableNode", table: e }),
          cloneWithTableProps: (e, t) => (0, eg.CN)({ ...e, ...t }),
          cloneWithColumnAlteration: (e, t) =>
            (0, eg.CN)({
              ...e,
              columnAlterations: e.columnAlterations
                ? [...e.columnAlterations, t]
                : [t],
            }),
        }),
        e7 = (0, eg.CN)({
          is: (e) => "CreateIndexNode" === e.kind,
          create: (e) =>
            (0, eg.CN)({ kind: "CreateIndexNode", name: ep.O.create(e) }),
          cloneWith: (e, t) => (0, eg.CN)({ ...e, ...t }),
          cloneWithColumns: (e, t) =>
            (0, eg.CN)({ ...e, columns: [...(e.columns || []), ...t] }),
        }),
        te = (0, eg.CN)({
          is: (e) => "CreateSchemaNode" === e.kind,
          create: (e, t) =>
            (0, eg.CN)({
              kind: "CreateSchemaNode",
              schema: ep.O.create(e),
              ...t,
            }),
          cloneWith: (e, t) => (0, eg.CN)({ ...e, ...t }),
        });
      var tt = r(30154),
        tr = r(17445);
      let ti = (0, eg.CN)({
          is: (e) => "DropIndexNode" === e.kind,
          create: (e, t) =>
            (0, eg.CN)({ kind: "DropIndexNode", name: tr.y.create(e), ...t }),
          cloneWith: (e, t) => (0, eg.CN)({ ...e, ...t }),
        }),
        tn = (0, eg.CN)({
          is: (e) => "DropSchemaNode" === e.kind,
          create: (e, t) =>
            (0, eg.CN)({
              kind: "DropSchemaNode",
              schema: ep.O.create(e),
              ...t,
            }),
          cloneWith: (e, t) => (0, eg.CN)({ ...e, ...t }),
        }),
        ts = (0, eg.CN)({
          is: (e) => "DropTableNode" === e.kind,
          create: (e, t) =>
            (0, eg.CN)({ kind: "DropTableNode", table: e, ...t }),
          cloneWith: (e, t) => (0, eg.CN)({ ...e, ...t }),
        });
      var to = r(33669);
      let ta = (0, eg.CN)({
        is: (e) => "AddColumnNode" === e.kind,
        create: (e) => (0, eg.CN)({ kind: "AddColumnNode", column: e }),
      });
      var tl = r(77255);
      let tc = (0, eg.CN)({
          is: (e) => "ColumnDefinitionNode" === e.kind,
          create: (e, t) =>
            (0, eg.CN)({
              kind: "ColumnDefinitionNode",
              column: tl.Z.create(e),
              dataType: t,
            }),
          cloneWithFrontModifier: (e, t) =>
            (0, eg.CN)({
              ...e,
              frontModifiers: e.frontModifiers
                ? (0, eg.CN)([...e.frontModifiers, t])
                : [t],
            }),
          cloneWithEndModifier: (e, t) =>
            (0, eg.CN)({
              ...e,
              endModifiers: e.endModifiers
                ? (0, eg.CN)([...e.endModifiers, t])
                : [t],
            }),
          cloneWith: (e, t) => (0, eg.CN)({ ...e, ...t }),
        }),
        td = (0, eg.CN)({
          is: (e) => "DropColumnNode" === e.kind,
          create: (e) =>
            (0, eg.CN)({ kind: "DropColumnNode", column: tl.Z.create(e) }),
        }),
        tu = (0, eg.CN)({
          is: (e) => "RenameColumnNode" === e.kind,
          create: (e, t) =>
            (0, eg.CN)({
              kind: "RenameColumnNode",
              column: tl.Z.create(e),
              renameTo: tl.Z.create(t),
            }),
        }),
        th = (0, eg.CN)({
          is: (e) => "CheckConstraintNode" === e.kind,
          create: (e, t) =>
            (0, eg.CN)({
              kind: "CheckConstraintNode",
              expression: e,
              name: t ? ep.O.create(t) : void 0,
            }),
        }),
        tp = ["no action", "restrict", "cascade", "set null", "set default"],
        tf = (0, eg.CN)({
          is: (e) => "ReferencesNode" === e.kind,
          create: (e, t) =>
            (0, eg.CN)({
              kind: "ReferencesNode",
              table: e,
              columns: (0, eg.CN)([...t]),
            }),
          cloneWithOnDelete: (e, t) => (0, eg.CN)({ ...e, onDelete: t }),
          cloneWithOnUpdate: (e, t) => (0, eg.CN)({ ...e, onUpdate: t }),
        });
      var tm = r(27759),
        ty = r(666),
        tg = r(10132),
        tw = r(89400);
      function tb(e) {
        return (0, tg.N)(e) ? e.toOperationNode() : tw.q.createImmediate(e);
      }
      let tv = (0, eg.CN)({
          is: (e) => "GeneratedNode" === e.kind,
          create: (e) => (0, eg.CN)({ kind: "GeneratedNode", ...e }),
          createWithExpression: (e) =>
            (0, eg.CN)({ kind: "GeneratedNode", always: !0, expression: e }),
          cloneWith: (e, t) => (0, eg.CN)({ ...e, ...t }),
        }),
        tN = (0, eg.CN)({
          is: (e) => "DefaultValueNode" === e.kind,
          create: (e) =>
            (0, eg.CN)({ kind: "DefaultValueNode", defaultValue: e }),
        });
      function tx(e) {
        if (tp.includes(e)) return e;
        throw Error(`invalid OnModifyForeignAction ${e}`);
      }
      class t_ {
        #Q;
        constructor(e) {
          this.#Q = e;
        }
        autoIncrement() {
          return new t_(tc.cloneWith(this.#Q, { autoIncrement: !0 }));
        }
        identity() {
          return new t_(tc.cloneWith(this.#Q, { identity: !0 }));
        }
        primaryKey() {
          return new t_(tc.cloneWith(this.#Q, { primaryKey: !0 }));
        }
        references(e) {
          let t = (0, ty.q5)(e);
          if (!t.table || tm.U.is(t.column))
            throw Error(
              `invalid call references('${e}'). The reference must have format table.column or schema.table.column`
            );
          return new t_(
            tc.cloneWith(this.#Q, {
              references: tf.create(t.table, [t.column]),
            })
          );
        }
        onDelete(e) {
          if (!this.#Q.references)
            throw Error(
              "on delete constraint can only be added for foreign keys"
            );
          return new t_(
            tc.cloneWith(this.#Q, {
              references: tf.cloneWithOnDelete(this.#Q.references, tx(e)),
            })
          );
        }
        onUpdate(e) {
          if (!this.#Q.references)
            throw Error(
              "on update constraint can only be added for foreign keys"
            );
          return new t_(
            tc.cloneWith(this.#Q, {
              references: tf.cloneWithOnUpdate(this.#Q.references, tx(e)),
            })
          );
        }
        unique() {
          return new t_(tc.cloneWith(this.#Q, { unique: !0 }));
        }
        notNull() {
          return new t_(tc.cloneWith(this.#Q, { notNull: !0 }));
        }
        unsigned() {
          return new t_(tc.cloneWith(this.#Q, { unsigned: !0 }));
        }
        defaultTo(e) {
          return new t_(tc.cloneWith(this.#Q, { defaultTo: tN.create(tb(e)) }));
        }
        check(e) {
          return new t_(
            tc.cloneWith(this.#Q, { check: th.create(e.toOperationNode()) })
          );
        }
        generatedAlwaysAs(e) {
          return new t_(
            tc.cloneWith(this.#Q, {
              generated: tv.createWithExpression(e.toOperationNode()),
            })
          );
        }
        generatedAlwaysAsIdentity() {
          return new t_(
            tc.cloneWith(this.#Q, {
              generated: tv.create({ identity: !0, always: !0 }),
            })
          );
        }
        generatedByDefaultAsIdentity() {
          return new t_(
            tc.cloneWith(this.#Q, {
              generated: tv.create({ identity: !0, byDefault: !0 }),
            })
          );
        }
        stored() {
          if (!this.#Q.generated)
            throw Error("stored() can only be called after generatedAlwaysAs");
          return new t_(
            tc.cloneWith(this.#Q, {
              generated: tv.cloneWith(this.#Q.generated, { stored: !0 }),
            })
          );
        }
        modifyFront(e) {
          return new t_(
            tc.cloneWithFrontModifier(this.#Q, e.toOperationNode())
          );
        }
        nullsNotDistinct() {
          return new t_(tc.cloneWith(this.#Q, { nullsNotDistinct: !0 }));
        }
        ifNotExists() {
          return new t_(tc.cloneWith(this.#Q, { ifNotExists: !0 }));
        }
        modifyEnd(e) {
          return new t_(tc.cloneWithEndModifier(this.#Q, e.toOperationNode()));
        }
        $call(e) {
          return e(this);
        }
        toOperationNode() {
          return this.#Q;
        }
      }
      let tS = (0, eg.CN)({
        is: (e) => "ModifyColumnNode" === e.kind,
        create: (e) => (0, eg.CN)({ kind: "ModifyColumnNode", column: e }),
      });
      var tT = r(73574);
      let tk = (0, eg.CN)({
        is: (e) => "ForeignKeyConstraintNode" === e.kind,
        create: (e, t, r, i) =>
          (0, eg.CN)({
            kind: "ForeignKeyConstraintNode",
            columns: e,
            references: tf.create(t, r),
            name: i ? ep.O.create(i) : void 0,
          }),
        cloneWith: (e, t) => (0, eg.CN)({ ...e, ...t }),
      });
      class tA {
        #Q;
        constructor(e) {
          this.#Q = e;
        }
        onDelete(e) {
          return new tA(tk.cloneWith(this.#Q, { onDelete: tx(e) }));
        }
        onUpdate(e) {
          return new tA(tk.cloneWith(this.#Q, { onUpdate: tx(e) }));
        }
        deferrable() {
          return new tA(tk.cloneWith(this.#Q, { deferrable: !0 }));
        }
        notDeferrable() {
          return new tA(tk.cloneWith(this.#Q, { deferrable: !1 }));
        }
        initiallyDeferred() {
          return new tA(tk.cloneWith(this.#Q, { initiallyDeferred: !0 }));
        }
        initiallyImmediate() {
          return new tA(tk.cloneWith(this.#Q, { initiallyDeferred: !1 }));
        }
        $call(e) {
          return e(this);
        }
        toOperationNode() {
          return this.#Q;
        }
      }
      let tE = (0, eg.CN)({
          is: (e) => "AddConstraintNode" === e.kind,
          create: (e) =>
            (0, eg.CN)({ kind: "AddConstraintNode", constraint: e }),
        }),
        tC = (0, eg.CN)({
          is: (e) => "UniqueConstraintNode" === e.kind,
          create: (e, t, r) =>
            (0, eg.CN)({
              kind: "UniqueConstraintNode",
              columns: (0, eg.CN)(e.map(tl.Z.create)),
              name: t ? ep.O.create(t) : void 0,
              nullsNotDistinct: r,
            }),
          cloneWith: (e, t) => (0, eg.CN)({ ...e, ...t }),
        }),
        tI = (0, eg.CN)({
          is: (e) => "DropConstraintNode" === e.kind,
          create: (e) =>
            (0, eg.CN)({
              kind: "DropConstraintNode",
              constraintName: ep.O.create(e),
            }),
          cloneWith: (e, t) => (0, eg.CN)({ ...e, ...t }),
        }),
        tO = (0, eg.CN)({
          is: (e) => "AlterColumnNode" === e.kind,
          create: (e, t, r) =>
            (0, eg.CN)({
              kind: "AlterColumnNode",
              column: tl.Z.create(e),
              [t]: r,
            }),
        });
      class tL {
        #z;
        constructor(e) {
          this.#z = e;
        }
        setDataType(e) {
          return new tR(tO.create(this.#z, "dataType", (0, tT.Q)(e)));
        }
        setDefault(e) {
          return new tR(tO.create(this.#z, "setDefault", tb(e)));
        }
        dropDefault() {
          return new tR(tO.create(this.#z, "dropDefault", !0));
        }
        setNotNull() {
          return new tR(tO.create(this.#z, "setNotNull", !0));
        }
        dropNotNull() {
          return new tR(tO.create(this.#z, "dropNotNull", !0));
        }
        $call(e) {
          return e(this);
        }
      }
      class tR {
        #V;
        constructor(e) {
          this.#V = e;
        }
        toOperationNode() {
          return this.#V;
        }
      }
      class tP {
        #e;
        constructor(e) {
          this.#e = (0, eg.CN)(e);
        }
        toOperationNode() {
          return this.#e.executor.transformQuery(this.#e.node, this.#e.queryId);
        }
        compile() {
          return this.#e.executor.compileQuery(
            this.toOperationNode(),
            this.#e.queryId
          );
        }
        async execute() {
          await this.#e.executor.executeQuery(this.compile(), this.#e.queryId);
        }
      }
      class tD {
        #e;
        constructor(e) {
          this.#e = (0, eg.CN)(e);
        }
        onDelete(e) {
          return new tD({
            ...this.#e,
            constraintBuilder: this.#e.constraintBuilder.onDelete(e),
          });
        }
        onUpdate(e) {
          return new tD({
            ...this.#e,
            constraintBuilder: this.#e.constraintBuilder.onUpdate(e),
          });
        }
        deferrable() {
          return new tD({
            ...this.#e,
            constraintBuilder: this.#e.constraintBuilder.deferrable(),
          });
        }
        notDeferrable() {
          return new tD({
            ...this.#e,
            constraintBuilder: this.#e.constraintBuilder.notDeferrable(),
          });
        }
        initiallyDeferred() {
          return new tD({
            ...this.#e,
            constraintBuilder: this.#e.constraintBuilder.initiallyDeferred(),
          });
        }
        initiallyImmediate() {
          return new tD({
            ...this.#e,
            constraintBuilder: this.#e.constraintBuilder.initiallyImmediate(),
          });
        }
        $call(e) {
          return e(this);
        }
        toOperationNode() {
          return this.#e.executor.transformQuery(
            e9.cloneWithTableProps(this.#e.node, {
              addConstraint: tE.create(
                this.#e.constraintBuilder.toOperationNode()
              ),
            }),
            this.#e.queryId
          );
        }
        compile() {
          return this.#e.executor.compileQuery(
            this.toOperationNode(),
            this.#e.queryId
          );
        }
        async execute() {
          await this.#e.executor.executeQuery(this.compile(), this.#e.queryId);
        }
      }
      class tq {
        #e;
        constructor(e) {
          this.#e = (0, eg.CN)(e);
        }
        ifExists() {
          return new tq({
            ...this.#e,
            node: e9.cloneWithTableProps(this.#e.node, {
              dropConstraint: tI.cloneWith(this.#e.node.dropConstraint, {
                ifExists: !0,
              }),
            }),
          });
        }
        cascade() {
          return new tq({
            ...this.#e,
            node: e9.cloneWithTableProps(this.#e.node, {
              dropConstraint: tI.cloneWith(this.#e.node.dropConstraint, {
                modifier: "cascade",
              }),
            }),
          });
        }
        restrict() {
          return new tq({
            ...this.#e,
            node: e9.cloneWithTableProps(this.#e.node, {
              dropConstraint: tI.cloneWith(this.#e.node.dropConstraint, {
                modifier: "restrict",
              }),
            }),
          });
        }
        $call(e) {
          return e(this);
        }
        toOperationNode() {
          return this.#e.executor.transformQuery(this.#e.node, this.#e.queryId);
        }
        compile() {
          return this.#e.executor.compileQuery(
            this.toOperationNode(),
            this.#e.queryId
          );
        }
        async execute() {
          await this.#e.executor.executeQuery(this.compile(), this.#e.queryId);
        }
      }
      let tU = (0, eg.CN)({
          is: (e) => "PrimaryKeyConstraintNode" === e.kind,
          create: (e, t) =>
            (0, eg.CN)({
              kind: "PrimaryKeyConstraintNode",
              columns: (0, eg.CN)(e.map(tl.Z.create)),
              name: t ? ep.O.create(t) : void 0,
            }),
          cloneWith: (e, t) => (0, eg.CN)({ ...e, ...t }),
        }),
        t$ = (0, eg.CN)({
          is: (e) => "AddIndexNode" === e.kind,
          create: (e) =>
            (0, eg.CN)({ kind: "AddIndexNode", name: ep.O.create(e) }),
          cloneWith: (e, t) => (0, eg.CN)({ ...e, ...t }),
          cloneWithColumns: (e, t) =>
            (0, eg.CN)({ ...e, columns: [...(e.columns || []), ...t] }),
        });
      class tB {
        #e;
        constructor(e) {
          this.#e = (0, eg.CN)(e);
        }
        unique() {
          return new tB({
            ...this.#e,
            node: e9.cloneWithTableProps(this.#e.node, {
              addIndex: t$.cloneWith(this.#e.node.addIndex, { unique: !0 }),
            }),
          });
        }
        column(e) {
          return new tB({
            ...this.#e,
            node: e9.cloneWithTableProps(this.#e.node, {
              addIndex: t$.cloneWithColumns(this.#e.node.addIndex, [
                (0, ty.Ow)(e),
              ]),
            }),
          });
        }
        columns(e) {
          return new tB({
            ...this.#e,
            node: e9.cloneWithTableProps(this.#e.node, {
              addIndex: t$.cloneWithColumns(
                this.#e.node.addIndex,
                e.map(ty.Ow)
              ),
            }),
          });
        }
        expression(e) {
          return new tB({
            ...this.#e,
            node: e9.cloneWithTableProps(this.#e.node, {
              addIndex: t$.cloneWithColumns(this.#e.node.addIndex, [
                e.toOperationNode(),
              ]),
            }),
          });
        }
        using(e) {
          return new tB({
            ...this.#e,
            node: e9.cloneWithTableProps(this.#e.node, {
              addIndex: t$.cloneWith(this.#e.node.addIndex, {
                using: ef.z.createWithSql(e),
              }),
            }),
          });
        }
        $call(e) {
          return e(this);
        }
        toOperationNode() {
          return this.#e.executor.transformQuery(this.#e.node, this.#e.queryId);
        }
        compile() {
          return this.#e.executor.compileQuery(
            this.toOperationNode(),
            this.#e.queryId
          );
        }
        async execute() {
          await this.#e.executor.executeQuery(this.compile(), this.#e.queryId);
        }
      }
      class tM {
        #Q;
        constructor(e) {
          this.#Q = e;
        }
        nullsNotDistinct() {
          return new tM(tC.cloneWith(this.#Q, { nullsNotDistinct: !0 }));
        }
        deferrable() {
          return new tM(tC.cloneWith(this.#Q, { deferrable: !0 }));
        }
        notDeferrable() {
          return new tM(tC.cloneWith(this.#Q, { deferrable: !1 }));
        }
        initiallyDeferred() {
          return new tM(tC.cloneWith(this.#Q, { initiallyDeferred: !0 }));
        }
        initiallyImmediate() {
          return new tM(tC.cloneWith(this.#Q, { initiallyDeferred: !1 }));
        }
        $call(e) {
          return e(this);
        }
        toOperationNode() {
          return this.#Q;
        }
      }
      class tj {
        #Q;
        constructor(e) {
          this.#Q = e;
        }
        deferrable() {
          return new tj(tU.cloneWith(this.#Q, { deferrable: !0 }));
        }
        notDeferrable() {
          return new tj(tU.cloneWith(this.#Q, { deferrable: !1 }));
        }
        initiallyDeferred() {
          return new tj(tU.cloneWith(this.#Q, { initiallyDeferred: !0 }));
        }
        initiallyImmediate() {
          return new tj(tU.cloneWith(this.#Q, { initiallyDeferred: !1 }));
        }
        $call(e) {
          return e(this);
        }
        toOperationNode() {
          return this.#Q;
        }
      }
      class tW {
        #Q;
        constructor(e) {
          this.#Q = e;
        }
        $call(e) {
          return e(this);
        }
        toOperationNode() {
          return this.#Q;
        }
      }
      let tF = (0, eg.CN)({
        is: (e) => "RenameConstraintNode" === e.kind,
        create: (e, t) =>
          (0, eg.CN)({
            kind: "RenameConstraintNode",
            oldName: ep.O.create(e),
            newName: ep.O.create(t),
          }),
      });
      class tQ {
        #e;
        constructor(e) {
          this.#e = (0, eg.CN)(e);
        }
        renameTo(e) {
          return new tP({
            ...this.#e,
            node: e9.cloneWithTableProps(this.#e.node, {
              renameTo: (0, to.M$)(e),
            }),
          });
        }
        setSchema(e) {
          return new tP({
            ...this.#e,
            node: e9.cloneWithTableProps(this.#e.node, {
              setSchema: ep.O.create(e),
            }),
          });
        }
        alterColumn(e, t) {
          let r = t(new tL(e));
          return new tz({
            ...this.#e,
            node: e9.cloneWithColumnAlteration(
              this.#e.node,
              r.toOperationNode()
            ),
          });
        }
        dropColumn(e) {
          return new tz({
            ...this.#e,
            node: e9.cloneWithColumnAlteration(this.#e.node, td.create(e)),
          });
        }
        renameColumn(e, t) {
          return new tz({
            ...this.#e,
            node: e9.cloneWithColumnAlteration(this.#e.node, tu.create(e, t)),
          });
        }
        addColumn(e, t, r = eg.lQ) {
          let i = r(new t_(tc.create(e, (0, tT.Q)(t))));
          return new tz({
            ...this.#e,
            node: e9.cloneWithColumnAlteration(
              this.#e.node,
              ta.create(i.toOperationNode())
            ),
          });
        }
        modifyColumn(e, t, r = eg.lQ) {
          let i = r(new t_(tc.create(e, (0, tT.Q)(t))));
          return new tz({
            ...this.#e,
            node: e9.cloneWithColumnAlteration(
              this.#e.node,
              tS.create(i.toOperationNode())
            ),
          });
        }
        addUniqueConstraint(e, t, r = eg.lQ) {
          let i = r(new tM(tC.create(t, e)));
          return new tP({
            ...this.#e,
            node: e9.cloneWithTableProps(this.#e.node, {
              addConstraint: tE.create(i.toOperationNode()),
            }),
          });
        }
        addCheckConstraint(e, t, r = eg.lQ) {
          let i = r(new tW(th.create(t.toOperationNode(), e)));
          return new tP({
            ...this.#e,
            node: e9.cloneWithTableProps(this.#e.node, {
              addConstraint: tE.create(i.toOperationNode()),
            }),
          });
        }
        addForeignKeyConstraint(e, t, r, i, n = eg.lQ) {
          let s = n(
            new tA(
              tk.create(
                t.map(tl.Z.create),
                (0, to.M$)(r),
                i.map(tl.Z.create),
                e
              )
            )
          );
          return new tD({ ...this.#e, constraintBuilder: s });
        }
        addPrimaryKeyConstraint(e, t, r = eg.lQ) {
          let i = r(new tj(tU.create(t, e)));
          return new tP({
            ...this.#e,
            node: e9.cloneWithTableProps(this.#e.node, {
              addConstraint: tE.create(i.toOperationNode()),
            }),
          });
        }
        dropConstraint(e) {
          return new tq({
            ...this.#e,
            node: e9.cloneWithTableProps(this.#e.node, {
              dropConstraint: tI.create(e),
            }),
          });
        }
        renameConstraint(e, t) {
          return new tq({
            ...this.#e,
            node: e9.cloneWithTableProps(this.#e.node, {
              renameConstraint: tF.create(e, t),
            }),
          });
        }
        addIndex(e) {
          return new tB({
            ...this.#e,
            node: e9.cloneWithTableProps(this.#e.node, {
              addIndex: t$.create(e),
            }),
          });
        }
        dropIndex(e) {
          return new tP({
            ...this.#e,
            node: e9.cloneWithTableProps(this.#e.node, {
              dropIndex: ti.create(e),
            }),
          });
        }
        $call(e) {
          return e(this);
        }
      }
      class tz {
        #e;
        constructor(e) {
          this.#e = (0, eg.CN)(e);
        }
        alterColumn(e, t) {
          let r = t(new tL(e));
          return new tz({
            ...this.#e,
            node: e9.cloneWithColumnAlteration(
              this.#e.node,
              r.toOperationNode()
            ),
          });
        }
        dropColumn(e) {
          return new tz({
            ...this.#e,
            node: e9.cloneWithColumnAlteration(this.#e.node, td.create(e)),
          });
        }
        renameColumn(e, t) {
          return new tz({
            ...this.#e,
            node: e9.cloneWithColumnAlteration(this.#e.node, tu.create(e, t)),
          });
        }
        addColumn(e, t, r = eg.lQ) {
          let i = r(new t_(tc.create(e, (0, tT.Q)(t))));
          return new tz({
            ...this.#e,
            node: e9.cloneWithColumnAlteration(
              this.#e.node,
              ta.create(i.toOperationNode())
            ),
          });
        }
        modifyColumn(e, t, r = eg.lQ) {
          let i = r(new t_(tc.create(e, (0, tT.Q)(t))));
          return new tz({
            ...this.#e,
            node: e9.cloneWithColumnAlteration(
              this.#e.node,
              tS.create(i.toOperationNode())
            ),
          });
        }
        toOperationNode() {
          return this.#e.executor.transformQuery(this.#e.node, this.#e.queryId);
        }
        compile() {
          return this.#e.executor.compileQuery(
            this.toOperationNode(),
            this.#e.queryId
          );
        }
        async execute() {
          await this.#e.executor.executeQuery(this.compile(), this.#e.queryId);
        }
      }
      var tV = r(74850),
        tK = r(64992),
        tG = r(69913),
        tH = r(99313);
      class tJ extends tG.V {
        transformPrimitiveValueList(e) {
          return tH.s.create(e.values.map(tw.q.createImmediate));
        }
        transformValue(e) {
          return tw.q.createImmediate(e.value);
        }
      }
      class tZ {
        #e;
        constructor(e) {
          this.#e = (0, eg.CN)(e);
        }
        ifNotExists() {
          return new tZ({
            ...this.#e,
            node: e7.cloneWith(this.#e.node, { ifNotExists: !0 }),
          });
        }
        unique() {
          return new tZ({
            ...this.#e,
            node: e7.cloneWith(this.#e.node, { unique: !0 }),
          });
        }
        nullsNotDistinct() {
          return new tZ({
            ...this.#e,
            node: e7.cloneWith(this.#e.node, { nullsNotDistinct: !0 }),
          });
        }
        on(e) {
          return new tZ({
            ...this.#e,
            node: e7.cloneWith(this.#e.node, { table: (0, to.M$)(e) }),
          });
        }
        column(e) {
          return new tZ({
            ...this.#e,
            node: e7.cloneWithColumns(this.#e.node, [(0, ty.Ow)(e)]),
          });
        }
        columns(e) {
          return new tZ({
            ...this.#e,
            node: e7.cloneWithColumns(this.#e.node, e.map(ty.Ow)),
          });
        }
        expression(e) {
          return new tZ({
            ...this.#e,
            node: e7.cloneWithColumns(this.#e.node, [e.toOperationNode()]),
          });
        }
        using(e) {
          return new tZ({
            ...this.#e,
            node: e7.cloneWith(this.#e.node, { using: ef.z.createWithSql(e) }),
          });
        }
        where(...e) {
          let t = new tJ();
          return new tZ({
            ...this.#e,
            node: tK.L.cloneWithWhere(
              this.#e.node,
              t.transformNode((0, tV.GB)(e), this.#e.queryId)
            ),
          });
        }
        $call(e) {
          return e(this);
        }
        toOperationNode() {
          return this.#e.executor.transformQuery(this.#e.node, this.#e.queryId);
        }
        compile() {
          return this.#e.executor.compileQuery(
            this.toOperationNode(),
            this.#e.queryId
          );
        }
        async execute() {
          await this.#e.executor.executeQuery(this.compile(), this.#e.queryId);
        }
      }
      class tY {
        #e;
        constructor(e) {
          this.#e = (0, eg.CN)(e);
        }
        ifNotExists() {
          return new tY({
            ...this.#e,
            node: te.cloneWith(this.#e.node, { ifNotExists: !0 }),
          });
        }
        $call(e) {
          return e(this);
        }
        toOperationNode() {
          return this.#e.executor.transformQuery(this.#e.node, this.#e.queryId);
        }
        compile() {
          return this.#e.executor.compileQuery(
            this.toOperationNode(),
            this.#e.queryId
          );
        }
        async execute() {
          await this.#e.executor.executeQuery(this.compile(), this.#e.queryId);
        }
      }
      var tX = r(75423);
      class t0 {
        #e;
        constructor(e) {
          this.#e = (0, eg.CN)(e);
        }
        temporary() {
          return new t0({
            ...this.#e,
            node: tt.B.cloneWith(this.#e.node, { temporary: !0 }),
          });
        }
        onCommit(e) {
          return new t0({
            ...this.#e,
            node: tt.B.cloneWith(this.#e.node, {
              onCommit: (function (e) {
                if (tt.o.includes(e)) return e;
                throw Error(`invalid OnCommitAction ${e}`);
              })(e),
            }),
          });
        }
        ifNotExists() {
          return new t0({
            ...this.#e,
            node: tt.B.cloneWith(this.#e.node, { ifNotExists: !0 }),
          });
        }
        addColumn(e, t, r = eg.lQ) {
          let i = r(new t_(tc.create(e, (0, tT.Q)(t))));
          return new t0({
            ...this.#e,
            node: tt.B.cloneWithColumn(this.#e.node, i.toOperationNode()),
          });
        }
        addPrimaryKeyConstraint(e, t, r = eg.lQ) {
          let i = r(new tj(tU.create(t, e)));
          return new t0({
            ...this.#e,
            node: tt.B.cloneWithConstraint(this.#e.node, i.toOperationNode()),
          });
        }
        addUniqueConstraint(e, t, r = eg.lQ) {
          let i = r(new tM(tC.create(t, e)));
          return new t0({
            ...this.#e,
            node: tt.B.cloneWithConstraint(this.#e.node, i.toOperationNode()),
          });
        }
        addCheckConstraint(e, t, r = eg.lQ) {
          let i = r(new tW(th.create(t.toOperationNode(), e)));
          return new t0({
            ...this.#e,
            node: tt.B.cloneWithConstraint(this.#e.node, i.toOperationNode()),
          });
        }
        addForeignKeyConstraint(e, t, r, i, n = eg.lQ) {
          let s = n(
            new tA(
              tk.create(
                t.map(tl.Z.create),
                (0, to.M$)(r),
                i.map(tl.Z.create),
                e
              )
            )
          );
          return new t0({
            ...this.#e,
            node: tt.B.cloneWithConstraint(this.#e.node, s.toOperationNode()),
          });
        }
        modifyFront(e) {
          return new t0({
            ...this.#e,
            node: tt.B.cloneWithFrontModifier(
              this.#e.node,
              e.toOperationNode()
            ),
          });
        }
        modifyEnd(e) {
          return new t0({
            ...this.#e,
            node: tt.B.cloneWithEndModifier(this.#e.node, e.toOperationNode()),
          });
        }
        as(e) {
          return new t0({
            ...this.#e,
            node: tt.B.cloneWith(this.#e.node, { selectQuery: (0, tX.YK)(e) }),
          });
        }
        $call(e) {
          return e(this);
        }
        toOperationNode() {
          return this.#e.executor.transformQuery(this.#e.node, this.#e.queryId);
        }
        compile() {
          return this.#e.executor.compileQuery(
            this.toOperationNode(),
            this.#e.queryId
          );
        }
        async execute() {
          await this.#e.executor.executeQuery(this.compile(), this.#e.queryId);
        }
      }
      class t1 {
        #e;
        constructor(e) {
          this.#e = (0, eg.CN)(e);
        }
        on(e) {
          return new t1({
            ...this.#e,
            node: ti.cloneWith(this.#e.node, { table: (0, to.M$)(e) }),
          });
        }
        ifExists() {
          return new t1({
            ...this.#e,
            node: ti.cloneWith(this.#e.node, { ifExists: !0 }),
          });
        }
        cascade() {
          return new t1({
            ...this.#e,
            node: ti.cloneWith(this.#e.node, { cascade: !0 }),
          });
        }
        $call(e) {
          return e(this);
        }
        toOperationNode() {
          return this.#e.executor.transformQuery(this.#e.node, this.#e.queryId);
        }
        compile() {
          return this.#e.executor.compileQuery(
            this.toOperationNode(),
            this.#e.queryId
          );
        }
        async execute() {
          await this.#e.executor.executeQuery(this.compile(), this.#e.queryId);
        }
      }
      class t2 {
        #e;
        constructor(e) {
          this.#e = (0, eg.CN)(e);
        }
        ifExists() {
          return new t2({
            ...this.#e,
            node: tn.cloneWith(this.#e.node, { ifExists: !0 }),
          });
        }
        cascade() {
          return new t2({
            ...this.#e,
            node: tn.cloneWith(this.#e.node, { cascade: !0 }),
          });
        }
        $call(e) {
          return e(this);
        }
        toOperationNode() {
          return this.#e.executor.transformQuery(this.#e.node, this.#e.queryId);
        }
        compile() {
          return this.#e.executor.compileQuery(
            this.toOperationNode(),
            this.#e.queryId
          );
        }
        async execute() {
          await this.#e.executor.executeQuery(this.compile(), this.#e.queryId);
        }
      }
      class t5 {
        #e;
        constructor(e) {
          this.#e = (0, eg.CN)(e);
        }
        ifExists() {
          return new t5({
            ...this.#e,
            node: ts.cloneWith(this.#e.node, { ifExists: !0 }),
          });
        }
        cascade() {
          return new t5({
            ...this.#e,
            node: ts.cloneWith(this.#e.node, { cascade: !0 }),
          });
        }
        $call(e) {
          return e(this);
        }
        toOperationNode() {
          return this.#e.executor.transformQuery(this.#e.node, this.#e.queryId);
        }
        compile() {
          return this.#e.executor.compileQuery(
            this.toOperationNode(),
            this.#e.queryId
          );
        }
        async execute() {
          await this.#e.executor.executeQuery(this.compile(), this.#e.queryId);
        }
      }
      var t6 = r(83500),
        t4 = r(49925);
      class t3 {
        #K = new tJ();
        transformQuery(e) {
          return this.#K.transformNode(e.node, e.queryId);
        }
        transformResult(e) {
          return Promise.resolve(e.result);
        }
      }
      class t8 {
        #e;
        constructor(e) {
          this.#e = (0, eg.CN)(e);
        }
        temporary() {
          return new t8({
            ...this.#e,
            node: t4.Y.cloneWith(this.#e.node, { temporary: !0 }),
          });
        }
        materialized() {
          return new t8({
            ...this.#e,
            node: t4.Y.cloneWith(this.#e.node, { materialized: !0 }),
          });
        }
        ifNotExists() {
          return new t8({
            ...this.#e,
            node: t4.Y.cloneWith(this.#e.node, { ifNotExists: !0 }),
          });
        }
        orReplace() {
          return new t8({
            ...this.#e,
            node: t4.Y.cloneWith(this.#e.node, { orReplace: !0 }),
          });
        }
        columns(e) {
          return new t8({
            ...this.#e,
            node: t4.Y.cloneWith(this.#e.node, { columns: e.map(ty.RY) }),
          });
        }
        as(e) {
          let t = e.withPlugin(new t3()).toOperationNode();
          return new t8({
            ...this.#e,
            node: t4.Y.cloneWith(this.#e.node, { as: t }),
          });
        }
        $call(e) {
          return e(this);
        }
        toOperationNode() {
          return this.#e.executor.transformQuery(this.#e.node, this.#e.queryId);
        }
        compile() {
          return this.#e.executor.compileQuery(
            this.toOperationNode(),
            this.#e.queryId
          );
        }
        async execute() {
          await this.#e.executor.executeQuery(this.compile(), this.#e.queryId);
        }
      }
      let t9 = (0, eg.CN)({
        is: (e) => "DropViewNode" === e.kind,
        create: (e) =>
          (0, eg.CN)({ kind: "DropViewNode", name: tr.y.create(e) }),
        cloneWith: (e, t) => (0, eg.CN)({ ...e, ...t }),
      });
      class t7 {
        #e;
        constructor(e) {
          this.#e = (0, eg.CN)(e);
        }
        materialized() {
          return new t7({
            ...this.#e,
            node: t9.cloneWith(this.#e.node, { materialized: !0 }),
          });
        }
        ifExists() {
          return new t7({
            ...this.#e,
            node: t9.cloneWith(this.#e.node, { ifExists: !0 }),
          });
        }
        cascade() {
          return new t7({
            ...this.#e,
            node: t9.cloneWith(this.#e.node, { cascade: !0 }),
          });
        }
        $call(e) {
          return e(this);
        }
        toOperationNode() {
          return this.#e.executor.transformQuery(this.#e.node, this.#e.queryId);
        }
        compile() {
          return this.#e.executor.compileQuery(
            this.toOperationNode(),
            this.#e.queryId
          );
        }
        async execute() {
          await this.#e.executor.executeQuery(this.compile(), this.#e.queryId);
        }
      }
      let re = (0, eg.CN)({
        is: (e) => "CreateTypeNode" === e.kind,
        create: (e) => (0, eg.CN)({ kind: "CreateTypeNode", name: e }),
        cloneWithEnum: (e, t) =>
          (0, eg.CN)({ ...e, enum: tH.s.create(t.map(tw.q.createImmediate)) }),
      });
      class rt {
        #e;
        constructor(e) {
          this.#e = (0, eg.CN)(e);
        }
        toOperationNode() {
          return this.#e.executor.transformQuery(this.#e.node, this.#e.queryId);
        }
        asEnum(e) {
          return new rt({
            ...this.#e,
            node: re.cloneWithEnum(this.#e.node, e),
          });
        }
        $call(e) {
          return e(this);
        }
        compile() {
          return this.#e.executor.compileQuery(
            this.toOperationNode(),
            this.#e.queryId
          );
        }
        async execute() {
          await this.#e.executor.executeQuery(this.compile(), this.#e.queryId);
        }
      }
      let rr = (0, eg.CN)({
        is: (e) => "DropTypeNode" === e.kind,
        create: (e) => (0, eg.CN)({ kind: "DropTypeNode", name: e }),
        cloneWith: (e, t) => (0, eg.CN)({ ...e, ...t }),
      });
      class ri {
        #e;
        constructor(e) {
          this.#e = (0, eg.CN)(e);
        }
        ifExists() {
          return new ri({
            ...this.#e,
            node: rr.cloneWith(this.#e.node, { ifExists: !0 }),
          });
        }
        $call(e) {
          return e(this);
        }
        toOperationNode() {
          return this.#e.executor.transformQuery(this.#e.node, this.#e.queryId);
        }
        compile() {
          return this.#e.executor.compileQuery(
            this.toOperationNode(),
            this.#e.queryId
          );
        }
        async execute() {
          await this.#e.executor.executeQuery(this.compile(), this.#e.queryId);
        }
      }
      function rn(e) {
        if (!e.includes(".")) return tr.y.create(e);
        {
          let t = e.split(".").map(rs);
          if (2 === t.length) return tr.y.createWithSchema(t[0], t[1]);
          throw Error(`invalid schemable identifier ${e}`);
        }
      }
      function rs(e) {
        return e.trim();
      }
      let ro = (0, eg.CN)({
        is: (e) => "RefreshMaterializedViewNode" === e.kind,
        create: (e) =>
          (0, eg.CN)({
            kind: "RefreshMaterializedViewNode",
            name: tr.y.create(e),
          }),
        cloneWith: (e, t) => (0, eg.CN)({ ...e, ...t }),
      });
      class ra {
        #e;
        constructor(e) {
          this.#e = (0, eg.CN)(e);
        }
        concurrently() {
          return new ra({
            ...this.#e,
            node: ro.cloneWith(this.#e.node, {
              concurrently: !0,
              withNoData: !1,
            }),
          });
        }
        withData() {
          return new ra({
            ...this.#e,
            node: ro.cloneWith(this.#e.node, { withNoData: !1 }),
          });
        }
        withNoData() {
          return new ra({
            ...this.#e,
            node: ro.cloneWith(this.#e.node, {
              withNoData: !0,
              concurrently: !1,
            }),
          });
        }
        $call(e) {
          return e(this);
        }
        toOperationNode() {
          return this.#e.executor.transformQuery(this.#e.node, this.#e.queryId);
        }
        compile() {
          return this.#e.executor.compileQuery(
            this.toOperationNode(),
            this.#e.queryId
          );
        }
        async execute() {
          await this.#e.executor.executeQuery(this.compile(), this.#e.queryId);
        }
      }
      class rl {
        #G;
        constructor(e) {
          this.#G = e;
        }
        createTable(e) {
          return new t0({
            queryId: (0, ew.a)(),
            executor: this.#G,
            node: tt.B.create((0, to.M$)(e)),
          });
        }
        dropTable(e) {
          return new t5({
            queryId: (0, ew.a)(),
            executor: this.#G,
            node: ts.create((0, to.M$)(e)),
          });
        }
        createIndex(e) {
          return new tZ({
            queryId: (0, ew.a)(),
            executor: this.#G,
            node: e7.create(e),
          });
        }
        dropIndex(e) {
          return new t1({
            queryId: (0, ew.a)(),
            executor: this.#G,
            node: ti.create(e),
          });
        }
        createSchema(e) {
          return new tY({
            queryId: (0, ew.a)(),
            executor: this.#G,
            node: te.create(e),
          });
        }
        dropSchema(e) {
          return new t2({
            queryId: (0, ew.a)(),
            executor: this.#G,
            node: tn.create(e),
          });
        }
        alterTable(e) {
          return new tQ({
            queryId: (0, ew.a)(),
            executor: this.#G,
            node: e9.create((0, to.M$)(e)),
          });
        }
        createView(e) {
          return new t8({
            queryId: (0, ew.a)(),
            executor: this.#G,
            node: t4.Y.create(e),
          });
        }
        refreshMaterializedView(e) {
          return new ra({
            queryId: (0, ew.a)(),
            executor: this.#G,
            node: ro.create(e),
          });
        }
        dropView(e) {
          return new t7({
            queryId: (0, ew.a)(),
            executor: this.#G,
            node: t9.create(e),
          });
        }
        createType(e) {
          return new rt({
            queryId: (0, ew.a)(),
            executor: this.#G,
            node: re.create(rn(e)),
          });
        }
        dropType(e) {
          return new ri({
            queryId: (0, ew.a)(),
            executor: this.#G,
            node: rr.create(rn(e)),
          });
        }
        withPlugin(e) {
          return new rl(this.#G.withPlugin(e));
        }
        withoutPlugins() {
          return new rl(this.#G.withoutPlugins());
        }
        withSchema(e) {
          return new rl(this.#G.withPluginAtFront(new t6.B(e)));
        }
      }
      var rc = r(40928),
        rd = r(6193);
      class ru {
        ref(e) {
          return new rc.g(e);
        }
        table(e) {
          return new rd.bj(e);
        }
      }
      class rh {
        #H;
        constructor(e) {
          this.#H = e;
        }
        async provideConnection(e) {
          let t = await this.#H.acquireConnection();
          try {
            return await e(t);
          } finally {
            await this.#H.releaseConnection(t);
          }
        }
      }
      var rp = r(96350),
        rf = r(83260);
      class rm extends rf.R {
        #J;
        #Z;
        #Y;
        constructor(e, t, r, i = []) {
          super(i), (this.#J = e), (this.#Z = t), (this.#Y = r);
        }
        get adapter() {
          return this.#Z;
        }
        compileQuery(e, t) {
          return this.#J.compileQuery(e, t);
        }
        provideConnection(e) {
          return this.#Y.provideConnection(e);
        }
        withPlugins(e) {
          return new rm(this.#J, this.#Z, this.#Y, [...this.plugins, ...e]);
        }
        withPlugin(e) {
          return new rm(this.#J, this.#Z, this.#Y, [...this.plugins, e]);
        }
        withPluginAtFront(e) {
          return new rm(this.#J, this.#Z, this.#Y, [e, ...this.plugins]);
        }
        withConnectionProvider(e) {
          return new rm(this.#J, this.#Z, e, [...this.plugins]);
        }
        withoutPlugins() {
          return new rm(this.#J, this.#Z, this.#Y, []);
        }
      }
      function ry() {
        return "undefined" != typeof performance && (0, eg.Tn)(performance.now)
          ? performance.now()
          : Date.now();
      }
      class rg {
        #H;
        #X;
        #ee;
        #et;
        #er;
        #T = new WeakSet();
        constructor(e, t) {
          (this.#et = !1), (this.#H = e), (this.#X = t);
        }
        async init() {
          if (this.#er) throw Error("driver has already been destroyed");
          this.#ee ||
            (this.#ee = this.#H
              .init()
              .then(() => {
                this.#et = !0;
              })
              .catch((e) => ((this.#ee = void 0), Promise.reject(e)))),
            await this.#ee;
        }
        async acquireConnection() {
          if (this.#er) throw Error("driver has already been destroyed");
          this.#et || (await this.init());
          let e = await this.#H.acquireConnection();
          return (
            this.#T.has(e) || (this.#ei() && this.#en(e), this.#T.add(e)), e
          );
        }
        async releaseConnection(e) {
          await this.#H.releaseConnection(e);
        }
        beginTransaction(e, t) {
          return this.#H.beginTransaction(e, t);
        }
        commitTransaction(e) {
          return this.#H.commitTransaction(e);
        }
        rollbackTransaction(e) {
          return this.#H.rollbackTransaction(e);
        }
        savepoint(e, t, r) {
          if (this.#H.savepoint) return this.#H.savepoint(e, t, r);
          throw Error("The `savepoint` method is not supported by this driver");
        }
        rollbackToSavepoint(e, t, r) {
          if (this.#H.rollbackToSavepoint)
            return this.#H.rollbackToSavepoint(e, t, r);
          throw Error(
            "The `rollbackToSavepoint` method is not supported by this driver"
          );
        }
        releaseSavepoint(e, t, r) {
          if (this.#H.releaseSavepoint)
            return this.#H.releaseSavepoint(e, t, r);
          throw Error(
            "The `releaseSavepoint` method is not supported by this driver"
          );
        }
        async destroy() {
          this.#ee &&
            (await this.#ee,
            this.#er ||
              (this.#er = this.#H
                .destroy()
                .catch((e) => ((this.#er = void 0), Promise.reject(e)))),
            await this.#er);
        }
        #ei() {
          return (
            this.#X.isLevelEnabled("query") || this.#X.isLevelEnabled("error")
          );
        }
        #en(e) {
          let t = e.executeQuery,
            r = e.streamQuery,
            i = this;
          (e.executeQuery = async (r) => {
            let n,
              s = ry();
            try {
              return await t.call(e, r);
            } catch (e) {
              throw ((n = e), await i.#es(e, r, s), e);
            } finally {
              n || (await i.#eo(r, s));
            }
          }),
            (e.streamQuery = async function* (t, n) {
              let s,
                o = ry();
              try {
                for await (let i of r.call(e, t, n)) yield i;
              } catch (e) {
                throw ((s = e), await i.#es(e, t, o), e);
              } finally {
                s || (await i.#eo(t, o, !0));
              }
            });
        }
        async #es(e, t, r) {
          await this.#X.error(() => ({
            level: "error",
            error: e,
            query: t,
            queryDurationMillis: this.#ea(r),
          }));
        }
        async #eo(e, t, r = !1) {
          await this.#X.query(() => ({
            level: "query",
            isStream: r,
            query: e,
            queryDurationMillis: this.#ea(t),
          }));
        }
        #ea(e) {
          return ry() - e;
        }
      }
      let rw = () => {};
      class rb {
        #x;
        #el;
        constructor(e) {
          this.#x = e;
        }
        async provideConnection(e) {
          for (; this.#el; ) await this.#el.catch(rw);
          return (
            (this.#el = this.#ec(e).finally(() => {
              this.#el = void 0;
            })),
            this.#el
          );
        }
        async #ec(e) {
          return await e(this.#x);
        }
      }
      let rv = ["read only", "read write"],
        rN = [
          "read uncommitted",
          "read committed",
          "repeatable read",
          "serializable",
          "snapshot",
        ];
      function rx(e) {
        if (e.accessMode && !rv.includes(e.accessMode))
          throw Error(`invalid transaction access mode ${e.accessMode}`);
        if (e.isolationLevel && !rN.includes(e.isolationLevel))
          throw Error(
            `invalid transaction isolation level ${e.isolationLevel}`
          );
      }
      var r_ = r(9490);
      (0, eg.CN)(["query", "error"]);
      class rS {
        #ed;
        #eu;
        constructor(e) {
          (0, eg.Tn)(e)
            ? ((this.#eu = e),
              (this.#ed = (0, eg.CN)({ query: !0, error: !0 })))
            : ((this.#eu = rT),
              (this.#ed = (0, eg.CN)({
                query: e.includes("query"),
                error: e.includes("error"),
              })));
        }
        isLevelEnabled(e) {
          return this.#ed[e];
        }
        async query(e) {
          this.#ed.query && (await this.#eu(e()));
        }
        async error(e) {
          this.#ed.error && (await this.#eu(e()));
        }
      }
      function rT(e) {
        if ("query" === e.level) {
          let t = `kysely:query:${e.isStream ? "stream:" : ""}`;
          console.log(`${t} ${e.query.sql}`),
            console.log(`${t} duration: ${e.queryDurationMillis.toFixed(1)}ms`);
        } else
          "error" === e.level &&
            (e.error instanceof Error
              ? console.error(
                  `kysely:error: ${e.error.stack ?? e.error.message}`
                )
              : console.error(
                  `kysely:error: ${JSON.stringify({ error: e.error, query: e.query.sql, queryDurationMillis: e.queryDurationMillis })}`
                ));
      }
      var rk = r(1116),
        rA = r(35665),
        rE = r(61495);
      Symbol.asyncDispose ??= Symbol("Symbol.asyncDispose");
      class rC extends rp.n {
        #e;
        constructor(e) {
          let t, r;
          if (
            (function (e) {
              return (
                (0, eg.Gv)(e) &&
                (0, eg.Gv)(e.config) &&
                (0, eg.Gv)(e.driver) &&
                (0, eg.Gv)(e.executor) &&
                (0, eg.Gv)(e.dialect)
              );
            })(e)
          )
            (t = { executor: e.executor }), (r = { ...e });
          else {
            let i = e.dialect,
              n = i.createDriver(),
              s = i.createQueryCompiler(),
              o = i.createAdapter(),
              a = new rg(n, new rS(e.log ?? [])),
              l = new rm(s, o, new rh(a), e.plugins ?? []);
            (t = { executor: l }),
              (r = { config: e, executor: l, dialect: i, driver: a });
          }
          super(t), (this.#e = (0, eg.CN)(r));
        }
        get schema() {
          return new rl(this.#e.executor);
        }
        get dynamic() {
          return new ru();
        }
        get introspection() {
          return this.#e.dialect.createIntrospector(this.withoutPlugins());
        }
        case(e) {
          return new rk.OU({
            node: rA.P.create((0, eg.b0)(e) ? void 0 : (0, tX.YK)(e)),
          });
        }
        get fn() {
          return (0, r_.t)();
        }
        transaction() {
          return new rL({ ...this.#e });
        }
        startTransaction() {
          return new rR({ ...this.#e });
        }
        connection() {
          return new rO({ ...this.#e });
        }
        withPlugin(e) {
          return new rC({
            ...this.#e,
            executor: this.#e.executor.withPlugin(e),
          });
        }
        withoutPlugins() {
          return new rC({
            ...this.#e,
            executor: this.#e.executor.withoutPlugins(),
          });
        }
        withSchema(e) {
          return new rC({
            ...this.#e,
            executor: this.#e.executor.withPluginAtFront(new t6.B(e)),
          });
        }
        withTables() {
          return new rC({ ...this.#e });
        }
        async destroy() {
          await this.#e.driver.destroy();
        }
        get isTransaction() {
          return !1;
        }
        getExecutor() {
          return this.#e.executor;
        }
        executeQuery(e, t = (0, ew.a)()) {
          let r = (0, eg.Gv)(e) && (0, eg.Tn)(e.compile) ? e.compile() : e;
          return this.getExecutor().executeQuery(r, t);
        }
        async [Symbol.asyncDispose]() {
          await this.destroy();
        }
      }
      class rI extends rC {
        #e;
        constructor(e) {
          super(e), (this.#e = e);
        }
        get isTransaction() {
          return !0;
        }
        transaction() {
          throw Error(
            "calling the transaction method for a Transaction is not supported"
          );
        }
        connection() {
          throw Error(
            "calling the connection method for a Transaction is not supported"
          );
        }
        async destroy() {
          throw Error(
            "calling the destroy method for a Transaction is not supported"
          );
        }
        withPlugin(e) {
          return new rI({
            ...this.#e,
            executor: this.#e.executor.withPlugin(e),
          });
        }
        withoutPlugins() {
          return new rI({
            ...this.#e,
            executor: this.#e.executor.withoutPlugins(),
          });
        }
        withSchema(e) {
          return new rI({
            ...this.#e,
            executor: this.#e.executor.withPluginAtFront(new t6.B(e)),
          });
        }
        withTables() {
          return new rI({ ...this.#e });
        }
      }
      class rO {
        #e;
        constructor(e) {
          this.#e = (0, eg.CN)(e);
        }
        async execute(e) {
          return this.#e.executor.provideConnection(async (t) => {
            let r = this.#e.executor.withConnectionProvider(new rb(t)),
              i = new rC({ ...this.#e, executor: r });
            return await e(i);
          });
        }
      }
      class rL {
        #e;
        constructor(e) {
          this.#e = (0, eg.CN)(e);
        }
        setAccessMode(e) {
          return new rL({ ...this.#e, accessMode: e });
        }
        setIsolationLevel(e) {
          return new rL({ ...this.#e, isolationLevel: e });
        }
        async execute(e) {
          let { isolationLevel: t, accessMode: r, ...i } = this.#e,
            n = { isolationLevel: t, accessMode: r };
          return (
            rx(n),
            this.#e.executor.provideConnection(async (t) => {
              let r = this.#e.executor.withConnectionProvider(new rb(t)),
                s = new rI({ ...i, executor: r });
              try {
                await this.#e.driver.beginTransaction(t, n);
                let r = await e(s);
                return await this.#e.driver.commitTransaction(t), r;
              } catch (e) {
                throw (await this.#e.driver.rollbackTransaction(t), e);
              }
            })
          );
        }
      }
      class rR {
        #e;
        constructor(e) {
          this.#e = (0, eg.CN)(e);
        }
        setAccessMode(e) {
          return new rR({ ...this.#e, accessMode: e });
        }
        setIsolationLevel(e) {
          return new rR({ ...this.#e, isolationLevel: e });
        }
        async execute() {
          let { isolationLevel: e, accessMode: t, ...r } = this.#e,
            i = { isolationLevel: e, accessMode: t };
          rx(i);
          let n = await (0, rE.G)(this.#e.executor);
          return (
            await this.#e.driver.beginTransaction(n.connection, i),
            new rP({
              ...r,
              connection: n,
              executor: this.#e.executor.withConnectionProvider(
                new rb(n.connection)
              ),
            })
          );
        }
      }
      class rP extends rI {
        #e;
        #eh;
        #ep;
        constructor(e) {
          let t = { isCommitted: !1, isRolledBack: !1 },
            { connection: r, ...i } = (e = {
              ...e,
              executor: new rU(e.executor, t),
            });
          super(i), (this.#e = (0, eg.CN)(e)), (this.#ep = t);
          let n = (0, ew.a)();
          this.#eh = (t) => e.executor.compileQuery(t, n);
        }
        get isCommitted() {
          return this.#ep.isCommitted;
        }
        get isRolledBack() {
          return this.#ep.isRolledBack;
        }
        commit() {
          return (
            rq(this.#ep),
            new rD(async () => {
              await this.#e.driver.commitTransaction(
                this.#e.connection.connection
              ),
                (this.#ep.isCommitted = !0),
                this.#e.connection.release();
            })
          );
        }
        rollback() {
          return (
            rq(this.#ep),
            new rD(async () => {
              await this.#e.driver.rollbackTransaction(
                this.#e.connection.connection
              ),
                (this.#ep.isRolledBack = !0),
                this.#e.connection.release();
            })
          );
        }
        savepoint(e) {
          return (
            rq(this.#ep),
            new rD(
              async () => (
                await this.#e.driver.savepoint?.(
                  this.#e.connection.connection,
                  e,
                  this.#eh
                ),
                new rP({ ...this.#e })
              )
            )
          );
        }
        rollbackToSavepoint(e) {
          return (
            rq(this.#ep),
            new rD(
              async () => (
                await this.#e.driver.rollbackToSavepoint?.(
                  this.#e.connection.connection,
                  e,
                  this.#eh
                ),
                new rP({ ...this.#e })
              )
            )
          );
        }
        releaseSavepoint(e) {
          return (
            rq(this.#ep),
            new rD(
              async () => (
                await this.#e.driver.releaseSavepoint?.(
                  this.#e.connection.connection,
                  e,
                  this.#eh
                ),
                new rP({ ...this.#e })
              )
            )
          );
        }
        withPlugin(e) {
          return new rP({
            ...this.#e,
            executor: this.#e.executor.withPlugin(e),
          });
        }
        withoutPlugins() {
          return new rP({
            ...this.#e,
            executor: this.#e.executor.withoutPlugins(),
          });
        }
        withSchema(e) {
          return new rP({
            ...this.#e,
            executor: this.#e.executor.withPluginAtFront(new t6.B(e)),
          });
        }
        withTables() {
          return new rP({ ...this.#e });
        }
      }
      class rD {
        #ef;
        constructor(e) {
          this.#ef = e;
        }
        async execute() {
          return await this.#ef();
        }
      }
      function rq(e) {
        if (e.isCommitted) throw Error("Transaction is already committed");
        if (e.isRolledBack) throw Error("Transaction is already rolled back");
      }
      class rU {
        #G;
        #ep;
        constructor(e, t) {
          e instanceof rU ? (this.#G = e.#G) : (this.#G = e), (this.#ep = t);
        }
        get adapter() {
          return this.#G.adapter;
        }
        get plugins() {
          return this.#G.plugins;
        }
        transformQuery(e, t) {
          return this.#G.transformQuery(e, t);
        }
        compileQuery(e, t) {
          return this.#G.compileQuery(e, t);
        }
        provideConnection(e) {
          return this.#G.provideConnection(e);
        }
        executeQuery(e, t) {
          return rq(this.#ep), this.#G.executeQuery(e, t);
        }
        stream(e, t, r) {
          return rq(this.#ep), this.#G.stream(e, t, r);
        }
        withConnectionProvider(e) {
          return new rU(this.#G.withConnectionProvider(e), this.#ep);
        }
        withPlugin(e) {
          return new rU(this.#G.withPlugin(e), this.#ep);
        }
        withPlugins(e) {
          return new rU(this.#G.withPlugins(e), this.#ep);
        }
        withPluginAtFront(e) {
          return new rU(this.#G.withPluginAtFront(e), this.#ep);
        }
        withoutPlugins() {
          return new rU(this.#G.withoutPlugins(), this.#ep);
        }
      }
      var r$ = r(50983);
      let rB = async (e) => {
          let t,
            i = e.database;
          if (!i) return { kysely: null, databaseType: null };
          if ("db" in i) return { kysely: i.db, databaseType: i.type };
          if ("dialect" in i)
            return {
              kysely: new rC({ dialect: i.dialect }),
              databaseType: i.type,
            };
          let n = (function e(t) {
            if (!t) return null;
            if ("dialect" in t) return e(t.dialect);
            if ("createDriver" in t) {
              if (t instanceof eI) return "sqlite";
              if (t instanceof eM) return "mysql";
              if (t instanceof eH) return "postgres";
              if (t instanceof e8) return "mssql";
            }
            return "aggregate" in t
              ? "sqlite"
              : "getConnection" in t
                ? "mysql"
                : "connect" in t
                  ? "postgres"
                  : "fileControl" in t
                    ? "sqlite"
                    : null;
          })(i);
          if (
            ("createDriver" in i && (t = i),
            "aggregate" in i && (t = new eI({ database: i })),
            "getConnection" in i && (t = new eM(i)),
            "connect" in i && (t = new eH({ pool: i })),
            "fileControl" in i)
          ) {
            let { BunSqliteDialect: e } = await r.e(58).then(r.bind(r, 66058));
            t = new e({ database: i });
          }
          return { kysely: t ? new rC({ dialect: t }) : null, databaseType: n };
        },
        rM = (e, t) =>
          (0, r$.c)({
            config: {
              adapterId: "kysely",
              adapterName: "Kysely Adapter",
              usePlural: t?.usePlural,
              debugLogs: t?.debugLogs,
              supportsBooleans:
                t?.type !== "sqlite" && t?.type !== "mssql" && !!t?.type,
              supportsDates:
                t?.type !== "sqlite" && t?.type !== "mssql" && !!t?.type,
              supportsJSON: !1,
            },
            adapter: ({ getFieldName: r, schema: i }) => {
              let n = async (i, n, s, o) => {
                let a;
                if (t?.type === "mysql") {
                  await n.execute();
                  let t = i.id
                    ? "id"
                    : o.length > 0 && o[0].field
                      ? o[0].field
                      : "id";
                  if (!i.id && 0 === o.length)
                    return await e
                      .selectFrom(s)
                      .selectAll()
                      .orderBy(r({ model: s, field: t }), "desc")
                      .limit(1)
                      .executeTakeFirst();
                  let a = i[t] || o[0].value;
                  return await e
                    .selectFrom(s)
                    .selectAll()
                    .orderBy(r({ model: s, field: t }), "desc")
                    .where(r({ model: s, field: t }), "=", a)
                    .limit(1)
                    .executeTakeFirst();
                }
                return t?.type === "mssql"
                  ? await n.outputAll("inserted").executeTakeFirst()
                  : await n.returningAll().executeTakeFirst();
              };
              function s(e, n) {
                if (!n) return { and: null, or: null };
                let s = { and: [], or: [] };
                return (
                  n.forEach((n) => {
                    let {
                        field: o,
                        value: a,
                        operator: l = "=",
                        connector: c = "AND",
                      } = n,
                      d = r({ model: e, field: o });
                    a = (function (e, r, n) {
                      if ("id" === n) return e;
                      let { type: s = "sqlite" } = t || {},
                        o = i[r]?.fields[n];
                      return (o ||
                        (o = Object.values(i).find((e) => e.modelName === r)),
                      "boolean" === o.type &&
                        ("sqlite" === s || "mssql" === s) &&
                        null != e)
                        ? +!!e
                        : "date" === o.type &&
                            e &&
                            e instanceof Date &&
                            "sqlite" === s
                          ? e.toISOString()
                          : e;
                    })(a, e, o);
                    let u = (e) =>
                      "in" === l.toLowerCase()
                        ? e(d, "in", Array.isArray(a) ? a : [a])
                        : "contains" === l
                          ? e(d, "like", `%${a}%`)
                          : "starts_with" === l
                            ? e(d, "like", `${a}%`)
                            : "ends_with" === l
                              ? e(d, "like", `%${a}`)
                              : e(
                                  d,
                                  "eq" === l
                                    ? "="
                                    : "ne" === l
                                      ? "<>"
                                      : "gt" === l
                                        ? ">"
                                        : "gte" === l
                                          ? ">="
                                          : "lt" === l
                                            ? "<"
                                            : "lte" === l
                                              ? "<="
                                              : l,
                                  a
                                );
                    "OR" === c ? s.or.push(u) : s.and.push(u);
                  }),
                  {
                    and: s.and.length ? s.and : null,
                    or: s.or.length ? s.or : null,
                  }
                );
              }
              return {
                async create({ data: t, model: r }) {
                  let i = e.insertInto(r).values(t);
                  return await n(t, i, r, []);
                },
                async findOne({ model: t, where: r, select: i }) {
                  let { and: n, or: o } = s(t, r),
                    a = e.selectFrom(t).selectAll();
                  n && (a = a.where((e) => e.and(n.map((t) => t(e))))),
                    o && (a = a.where((e) => e.or(o.map((t) => t(e)))));
                  let l = await a.executeTakeFirst();
                  return l || null;
                },
                async findMany({
                  model: i,
                  where: n,
                  limit: o,
                  offset: a,
                  sortBy: l,
                }) {
                  let { and: c, or: d } = s(i, n),
                    u = e.selectFrom(i);
                  c && (u = u.where((e) => e.and(c.map((t) => t(e))))),
                    d && (u = u.where((e) => e.or(d.map((t) => t(e))))),
                    t?.type === "mssql"
                      ? a || (u = u.top(o || 100))
                      : (u = u.limit(o || 100)),
                    l &&
                      (u = u.orderBy(
                        r({ model: i, field: l.field }),
                        l.direction
                      )),
                    a &&
                      (t?.type === "mssql"
                        ? (l || (u = u.orderBy(r({ model: i, field: "id" }))),
                          (u = u.offset(a).fetch(o || 100)))
                        : (u = u.offset(a)));
                  let h = await u.selectAll().execute();
                  return h || [];
                },
                async update({ model: t, where: r, update: i }) {
                  let { and: o, or: a } = s(t, r),
                    l = e.updateTable(t).set(i);
                  return (
                    o && (l = l.where((e) => e.and(o.map((t) => t(e))))),
                    a && (l = l.where((e) => e.or(a.map((t) => t(e))))),
                    await n(i, l, t, r)
                  );
                },
                async updateMany({ model: t, where: r, update: i }) {
                  let { and: n, or: o } = s(t, r),
                    a = e.updateTable(t).set(i);
                  return (
                    n && (a = a.where((e) => e.and(n.map((t) => t(e))))),
                    o && (a = a.where((e) => e.or(o.map((t) => t(e))))),
                    (await a.execute()).length
                  );
                },
                async count({ model: t, where: r }) {
                  let { and: i, or: n } = s(t, r),
                    o = e.selectFrom(t).select(e.fn.count("id").as("count"));
                  return (
                    i && (o = o.where((e) => e.and(i.map((t) => t(e))))),
                    n && (o = o.where((e) => e.or(n.map((t) => t(e))))),
                    (await o.execute())[0].count
                  );
                },
                async delete({ model: t, where: r }) {
                  let { and: i, or: n } = s(t, r),
                    o = e.deleteFrom(t);
                  i && (o = o.where((e) => e.and(i.map((t) => t(e))))),
                    n && (o = o.where((e) => e.or(n.map((t) => t(e))))),
                    await o.execute();
                },
                async deleteMany({ model: t, where: r }) {
                  let { and: i, or: n } = s(t, r),
                    o = e.deleteFrom(t);
                  return (
                    i && (o = o.where((e) => e.and(i.map((t) => t(e))))),
                    n && (o = o.where((e) => e.or(n.map((t) => t(e))))),
                    (await o.execute()).length
                  );
                },
                options: t,
              };
            },
          }),
        rj = (e, t) =>
          (0, r$.c)({
            config: {
              adapterId: "memory",
              adapterName: "Memory Adapter",
              usePlural: !1,
              debugLogs: t?.debugLogs || !1,
              customTransformInput: (t) =>
                t.options.advanced?.database?.useNumberId &&
                "id" === t.field &&
                "create" === t.action
                  ? e[t.model].length + 1
                  : t.data,
            },
            adapter: ({ getFieldName: t, options: r }) => {
              function i(e, t) {
                return t.filter((t) =>
                  e.every((e) => {
                    let { field: r, value: i, operator: n } = e;
                    if ("in" === n) {
                      if (!Array.isArray(i))
                        throw Error("Value must be an array");
                      return i.includes(t[r]);
                    }
                    return "contains" === n
                      ? t[r].includes(i)
                      : "starts_with" === n
                        ? t[r].startsWith(i)
                        : "ends_with" === n
                          ? t[r].endsWith(i)
                          : t[r] === i;
                  })
                );
              }
              return {
                create: async ({ model: t, data: i }) => (
                  r.advanced?.database?.useNumberId && (i.id = e[t].length + 1),
                  e[t].push(i),
                  i
                ),
                findOne: async ({ model: t, where: r }) =>
                  i(r, e[t])[0] || null,
                findMany: async ({
                  model: r,
                  where: n,
                  sortBy: s,
                  limit: o,
                  offset: a,
                }) => {
                  let l = e[r];
                  return (
                    n && (l = i(n, l)),
                    s &&
                      (l = l.sort((e, i) => {
                        let n = t({ model: r, field: s.field });
                        return "asc" === s.direction
                          ? e[n] > i[n]
                            ? 1
                            : -1
                          : e[n] < i[n]
                            ? 1
                            : -1;
                      })),
                    void 0 !== a && (l = l.slice(a)),
                    void 0 !== o && (l = l.slice(0, o)),
                    l
                  );
                },
                count: async ({ model: t }) => e[t].length,
                update: async ({ model: t, where: r, update: n }) => {
                  let s = i(r, e[t]);
                  return (
                    s.forEach((e) => {
                      Object.assign(e, n);
                    }),
                    s[0] || null
                  );
                },
                delete: async ({ model: t, where: r }) => {
                  let n = e[t],
                    s = i(r, n);
                  e[t] = n.filter((e) => !s.includes(e));
                },
                deleteMany: async ({ model: t, where: r }) => {
                  let n = e[t],
                    s = i(r, n),
                    o = 0;
                  return (
                    (e[t] = n.filter((e) =>
                      s.includes(e) ? (o++, !1) : !s.includes(e)
                    )),
                    o
                  );
                },
                updateMany({ model: t, where: r, update: n }) {
                  let s = i(r, e[t]);
                  return (
                    s.forEach((e) => {
                      Object.assign(e, n);
                    }),
                    s[0] || null
                  );
                },
              };
            },
          }),
        rW = (e, t) => {
          let r = t.options,
            i = r.secondaryStorage,
            n = r.session?.expiresIn || 604800,
            {
              createWithHooks: s,
              updateWithHooks: o,
              updateManyWithHooks: l,
            } = (function (e, t) {
              let r = t.hooks;
              return {
                createWithHooks: async function (t, i, n, s) {
                  let o = t;
                  for (let e of r || []) {
                    let t = e[i]?.create?.before;
                    if (t) {
                      let e = await t(o, s);
                      if (!1 === e) return null;
                      "object" == typeof e &&
                        "data" in e &&
                        (o = { ...o, ...e.data });
                    }
                  }
                  let a = n ? await n.fn(o) : null,
                    l =
                      !n || n.executeMainFn
                        ? await e.create({
                            model: i,
                            data: o,
                            forceAllowId: !0,
                          })
                        : a;
                  for (let e of r || []) {
                    let t = e[i]?.create?.after;
                    t && (await t(l, s));
                  }
                  return l;
                },
                updateWithHooks: async function (t, i, n, s, o) {
                  let a = t;
                  for (let e of r || []) {
                    let r = e[n]?.update?.before;
                    if (r) {
                      let e = await r(t, o);
                      if (!1 === e) return null;
                      a = "object" == typeof e ? e.data : e;
                    }
                  }
                  let l = s ? await s.fn(a) : null,
                    c =
                      !s || s.executeMainFn
                        ? await e.update({ model: n, update: a, where: i })
                        : l;
                  for (let e of r || []) {
                    let t = e[n]?.update?.after;
                    t && (await t(c, o));
                  }
                  return c;
                },
                updateManyWithHooks: async function (t, i, n, s, o) {
                  let a = t;
                  for (let e of r || []) {
                    let r = e[n]?.update?.before;
                    if (r) {
                      let e = await r(t, o);
                      if (!1 === e) return null;
                      a = "object" == typeof e ? e.data : e;
                    }
                  }
                  let l = s ? await s.fn(a) : null,
                    c =
                      !s || s.executeMainFn
                        ? await e.updateMany({ model: n, update: a, where: i })
                        : l;
                  for (let e of r || []) {
                    let t = e[n]?.update?.after;
                    t && (await t(c, o));
                  }
                  return c;
                },
              };
            })(e, t);
          return {
            createOAuthUser: async (e, t, r) => {
              let i = await s(
                  { createdAt: new Date(), updatedAt: new Date(), ...e },
                  "user",
                  void 0,
                  r
                ),
                n = await s(
                  {
                    ...t,
                    userId: i.id || e.id,
                    createdAt: new Date(),
                    updatedAt: new Date(),
                  },
                  "account",
                  void 0,
                  r
                );
              return { user: i, account: n };
            },
            createUser: async (e, t) =>
              await s(
                {
                  createdAt: new Date(),
                  updatedAt: new Date(),
                  emailVerified: !1,
                  ...e,
                  email: e.email?.toLowerCase(),
                },
                "user",
                void 0,
                t
              ),
            createAccount: async (e, t) =>
              await s(
                { createdAt: new Date(), updatedAt: new Date(), ...e },
                "account",
                void 0,
                t
              ),
            listSessions: async (r) => {
              if (i) {
                let e = await i.get(`active-sessions-${r}`);
                if (!e) return [];
                let n = (0, ec.s)(e) || [],
                  s = Date.now(),
                  o = n.filter((e) => e.expiresAt > s),
                  l = [];
                for (let e of o) {
                  let r = await i.get(e.token);
                  if (r) {
                    let e = JSON.parse(r),
                      i = (0, a.d)(t.options, {
                        ...e.session,
                        expiresAt: new Date(e.session.expiresAt),
                      });
                    l.push(i);
                  }
                }
                return l;
              }
              return await e.findMany({
                model: "session",
                where: [{ field: "userId", value: r }],
              });
            },
            listUsers: async (t, r, i, n) =>
              await e.findMany({
                model: "user",
                limit: t,
                offset: r,
                sortBy: i,
                where: n,
              }),
            countTotalUsers: async (t) => {
              let r = await e.count({ model: "user", where: t });
              return "string" == typeof r ? parseInt(r) : r;
            },
            deleteUser: async (t) => {
              i && (await i.delete(`active-sessions-${t}`)),
                (!i || r.session?.storeSessionInDatabase) &&
                  (await e.deleteMany({
                    model: "session",
                    where: [{ field: "userId", value: t }],
                  })),
                await e.deleteMany({
                  model: "account",
                  where: [{ field: "userId", value: t }],
                }),
                await e.delete({
                  model: "user",
                  where: [{ field: "id", value: t }],
                });
            },
            createSession: async (e, t, o, a, l) => {
              let c = t.headers || t.request?.headers,
                { id: u, ...h } = a || {},
                p = {
                  ipAddress:
                    ((t.request || t.headers) &&
                      d(t.request || t.headers, t.context.options)) ||
                    "",
                  userAgent: c?.get("user-agent") || "",
                  ...h,
                  expiresAt: o ? (0, el.g)(86400, "sec") : (0, el.g)(n, "sec"),
                  userId: e,
                  token: (0, ed.g)(32),
                  createdAt: new Date(),
                  updatedAt: new Date(),
                  ...(l ? h : {}),
                };
              return await s(
                p,
                "session",
                i
                  ? {
                      fn: async (t) => {
                        let r = await i.get(`active-sessions-${e}`),
                          s = [],
                          o = Date.now();
                        return (
                          r &&
                            (s = (s = (0, ec.s)(r) || []).filter(
                              (e) => e.expiresAt > o
                            )),
                          s.push({ token: p.token, expiresAt: o + 1e3 * n }),
                          await i.set(
                            `active-sessions-${e}`,
                            JSON.stringify(s),
                            n
                          ),
                          t
                        );
                      },
                      executeMainFn: r.session?.storeSessionInDatabase,
                    }
                  : void 0,
                t
              );
            },
            findSession: async (n) => {
              if (i) {
                let e = await i.get(n);
                if (!e && !r.session?.storeSessionInDatabase) return null;
                if (e) {
                  let r = JSON.parse(e);
                  return {
                    session: (0, a.d)(t.options, {
                      ...r.session,
                      expiresAt: new Date(r.session.expiresAt),
                      createdAt: new Date(r.session.createdAt),
                      updatedAt: new Date(r.session.updatedAt),
                    }),
                    user: (0, a.b)(t.options, {
                      ...r.user,
                      createdAt: new Date(r.user.createdAt),
                      updatedAt: new Date(r.user.updatedAt),
                    }),
                  };
                }
              }
              let s = await e.findOne({
                model: "session",
                where: [{ value: n, field: "token" }],
              });
              if (!s) return null;
              let o = await e.findOne({
                model: "user",
                where: [{ value: s.userId, field: "id" }],
              });
              return o
                ? {
                    session: (0, a.d)(t.options, s),
                    user: (0, a.b)(t.options, o),
                  }
                : null;
            },
            findSessions: async (t) => {
              if (i) {
                let e = [];
                for (let r of t) {
                  let t = await i.get(r);
                  if (t) {
                    let r = JSON.parse(t),
                      i = {
                        session: {
                          ...r.session,
                          expiresAt: new Date(r.session.expiresAt),
                        },
                        user: {
                          ...r.user,
                          createdAt: new Date(r.user.createdAt),
                          updatedAt: new Date(r.user.updatedAt),
                        },
                      };
                    e.push(i);
                  }
                }
                return e;
              }
              let r = await e.findMany({
                  model: "session",
                  where: [{ field: "token", value: t, operator: "in" }],
                }),
                n = r.map((e) => e.userId);
              if (!n.length) return [];
              let s = await e.findMany({
                model: "user",
                where: [{ field: "id", value: n, operator: "in" }],
              });
              return r.map((e) => {
                let t = s.find((t) => t.id === e.userId);
                return t ? { session: e, user: t } : null;
              });
            },
            updateSession: async (e, t, n) =>
              await o(
                t,
                [{ field: "token", value: e }],
                "session",
                i
                  ? {
                      async fn(t) {
                        let r = await i.get(e),
                          n = null;
                        return r ? { ...JSON.parse(r).session, ...t } : null;
                      },
                      executeMainFn: r.session?.storeSessionInDatabase,
                    }
                  : void 0,
                n
              ),
            deleteSession: async (n) => {
              (i &&
                (await i.delete(n),
                !r.session?.storeSessionInDatabase ||
                  t.options.session?.preserveSessionInDatabase)) ||
                (await e.delete({
                  model: "session",
                  where: [{ field: "token", value: n }],
                }));
            },
            deleteAccounts: async (t) => {
              await e.deleteMany({
                model: "account",
                where: [{ field: "userId", value: t }],
              });
            },
            deleteAccount: async (t) => {
              await e.delete({
                model: "account",
                where: [{ field: "id", value: t }],
              });
            },
            deleteSessions: async (n) => {
              if (i) {
                if ("string" == typeof n) {
                  let e = await i.get(`active-sessions-${n}`),
                    t = e ? (0, ec.s)(e) : [];
                  if (!t) return;
                  for (let e of t) await i.delete(e.token);
                } else for (let e of n) (await i.get(e)) && (await i.delete(e));
                if (
                  !r.session?.storeSessionInDatabase ||
                  t.options.session?.preserveSessionInDatabase
                )
                  return;
              }
              await e.deleteMany({
                model: "session",
                where: [
                  {
                    field: Array.isArray(n) ? "token" : "userId",
                    value: n,
                    operator: Array.isArray(n) ? "in" : void 0,
                  },
                ],
              });
            },
            findOAuthUser: async (t, r, i) => {
              let n = await e
                .findMany({
                  model: "account",
                  where: [{ value: r, field: "accountId" }],
                })
                .then((e) => e.find((e) => e.providerId === i));
              if (n) {
                let r = await e.findOne({
                  model: "user",
                  where: [{ value: n.userId, field: "id" }],
                });
                if (r) return { user: r, accounts: [n] };
                {
                  let r = await e.findOne({
                    model: "user",
                    where: [{ value: t.toLowerCase(), field: "email" }],
                  });
                  return r ? { user: r, accounts: [n] } : null;
                }
              }
              {
                let r = await e.findOne({
                  model: "user",
                  where: [{ value: t.toLowerCase(), field: "email" }],
                });
                if (!r) return null;
                {
                  let t = await e.findMany({
                    model: "account",
                    where: [{ value: r.id, field: "userId" }],
                  });
                  return { user: r, accounts: t || [] };
                }
              }
            },
            findUserByEmail: async (t, r) => {
              let i = await e.findOne({
                model: "user",
                where: [{ value: t.toLowerCase(), field: "email" }],
              });
              if (!i) return null;
              if (r?.includeAccounts) {
                let t = await e.findMany({
                  model: "account",
                  where: [{ value: i.id, field: "userId" }],
                });
                return { user: i, accounts: t };
              }
              return { user: i, accounts: [] };
            },
            findUserById: async (t) =>
              await e.findOne({
                model: "user",
                where: [{ field: "id", value: t }],
              }),
            linkAccount: async (e, t) =>
              await s(
                { ...e, createdAt: new Date(), updatedAt: new Date() },
                "account",
                void 0,
                t
              ),
            updateUser: async (e, t, r) => {
              let n = await o(
                t,
                [{ field: "id", value: e }],
                "user",
                void 0,
                r
              );
              if (i && n) {
                let t = await i.get(`active-sessions-${e}`);
                if (t) {
                  let e = Date.now(),
                    r = ((0, ec.s)(t) || []).filter((t) => t.expiresAt > e);
                  await Promise.all(
                    r.map(async ({ token: t }) => {
                      let r = await i.get(t);
                      if (!r) return;
                      let s = (0, ec.s)(r);
                      if (!s) return;
                      let o = Math.max(
                        Math.floor(
                          (new Date(s.session.expiresAt).getTime() - e) / 1e3
                        ),
                        0
                      );
                      await i.set(
                        t,
                        JSON.stringify({ session: s.session, user: n }),
                        o
                      );
                    })
                  );
                }
              }
              return n;
            },
            updateUserByEmail: async (e, t, r) =>
              await o(
                t,
                [{ field: "email", value: e.toLowerCase() }],
                "user",
                void 0,
                r
              ),
            updatePassword: async (e, t, r) => {
              await l(
                { password: t },
                [
                  { field: "userId", value: e },
                  { field: "providerId", value: "credential" },
                ],
                "account",
                void 0,
                r
              );
            },
            findAccounts: async (t) =>
              await e.findMany({
                model: "account",
                where: [{ field: "userId", value: t }],
              }),
            findAccount: async (t) =>
              await e.findOne({
                model: "account",
                where: [{ field: "accountId", value: t }],
              }),
            findAccountByProviderId: async (t, r) =>
              await e.findOne({
                model: "account",
                where: [
                  { field: "accountId", value: t },
                  { field: "providerId", value: r },
                ],
              }),
            findAccountByUserId: async (t) =>
              await e.findMany({
                model: "account",
                where: [{ field: "userId", value: t }],
              }),
            updateAccount: async (e, t, r) =>
              await o(t, [{ field: "id", value: e }], "account", void 0, r),
            createVerificationValue: async (e, t) =>
              await s(
                { createdAt: new Date(), updatedAt: new Date(), ...e },
                "verification",
                void 0,
                t
              ),
            findVerificationValue: async (t) => {
              let i = await e.findMany({
                model: "verification",
                where: [{ field: "identifier", value: t }],
                sortBy: { field: "createdAt", direction: "desc" },
                limit: 1,
              });
              return (
                r.verification?.disableCleanup ||
                  (await e.deleteMany({
                    model: "verification",
                    where: [
                      { field: "expiresAt", value: new Date(), operator: "lt" },
                    ],
                  })),
                i[0]
              );
            },
            deleteVerificationValue: async (t) => {
              await e.delete({
                model: "verification",
                where: [{ field: "id", value: t }],
              });
            },
            deleteVerificationByIdentifier: async (t) => {
              await e.delete({
                model: "verification",
                where: [{ field: "identifier", value: t }],
              });
            },
            updateVerificationValue: async (e, t, r) =>
              await o(
                t,
                [{ field: "id", value: e }],
                "verification",
                void 0,
                r
              ),
          };
        };
      async function rF(e) {
        if (!e.database) {
          let t = Object.keys((0, eu.g)(e)).reduce(
            (e, t) => ((e[t] = []), e),
            {}
          );
          return (
            c.l.warn(
              "No database configuration provided. Using memory adapter in development"
            ),
            rj(t)(e)
          );
        }
        if ("function" == typeof e.database) return e.database(e);
        let { kysely: t, databaseType: r } = await rB(e);
        if (!t) throw new f.B("Failed to initialize database adapter");
        return rM(t, {
          type: r || "sqlite",
          debugLogs: "debugLogs" in e.database && e.database.debugLogs,
        })(e);
      }
      let rQ = {
        postgres: {
          string: ["character varying", "text"],
          number: [
            "int4",
            "integer",
            "bigint",
            "smallint",
            "numeric",
            "real",
            "double precision",
          ],
          boolean: ["bool", "boolean"],
          date: ["timestamp", "date"],
        },
        mysql: {
          string: ["varchar", "text"],
          number: [
            "integer",
            "int",
            "bigint",
            "smallint",
            "decimal",
            "float",
            "double",
          ],
          boolean: ["boolean", "tinyint"],
          date: ["timestamp", "datetime", "date"],
        },
        sqlite: {
          string: ["TEXT"],
          number: ["INTEGER", "REAL"],
          boolean: ["INTEGER", "BOOLEAN"],
          date: ["DATE", "INTEGER"],
        },
        mssql: {
          string: ["text", "varchar"],
          number: ["int", "bigint", "smallint", "decimal", "float", "double"],
          boolean: ["bit", "smallint"],
          date: ["datetime", "date"],
        },
      };
      async function rz(e) {
        let t = (function (e) {
            let t = (0, eu.g)(e),
              r = {};
            for (let e in t) {
              let i = t[e],
                n = i.fields,
                s = {};
              if (
                (Object.entries(n).forEach(([e, r]) => {
                  if (((s[r.fieldName || e] = r), r.references)) {
                    let i = t[r.references.model];
                    i &&
                      (s[r.fieldName || e].references = {
                        model: i.modelName,
                        field: r.references.field,
                      });
                  }
                }),
                r[i.modelName])
              ) {
                r[i.modelName].fields = { ...r[i.modelName].fields, ...s };
                continue;
              }
              r[i.modelName] = { fields: s, order: i.order || 1 / 0 };
            }
            return r;
          })(e),
          r = (0, c.c)(e.logger),
          { kysely: i, databaseType: n } = await rB(e);
        n ||
          (r.warn(
            "Could not determine database type, defaulting to sqlite. Please provide a type in the database options to avoid this."
          ),
          (n = "sqlite")),
          i ||
            (r.error(
              "Only kysely adapter is supported for migrations. You can use `generate` command to generate the schema, if you're using a different adapter."
            ),
            process.exit(1));
        let s = await i.introspection.getTables(),
          o = [],
          a = [];
        for (let [e, i] of Object.entries(t)) {
          let t = s.find((t) => t.name === e);
          if (!t) {
            let t = o.findIndex((t) => t.table === e),
              r = { table: e, fields: i.fields, order: i.order || 1 / 0 },
              n = o.findIndex((e) => (e.order || 1 / 0) > r.order);
            -1 === n
              ? -1 === t
                ? o.push(r)
                : (o[t].fields = { ...o[t].fields, ...i.fields })
              : o.splice(n, 0, r);
            continue;
          }
          let l = {};
          for (let [s, o] of Object.entries(i.fields)) {
            let i = t.columns.find((e) => e.name === s);
            if (!i) {
              l[s] = o;
              continue;
            }
            !(function (e, t, r) {
              if ("string[]" === t || "number[]" === t)
                return e.toLowerCase().includes("json");
              let i = rQ[r];
              return (
                Array.isArray(t)
                  ? i.string.map((e) => e.toLowerCase())
                  : i[t].map((e) => e.toLowerCase())
              ).includes(e.toLowerCase());
            })(i.dataType, o.type, n) &&
              r.warn(
                `Field ${s} in table ${e} has a different type in the database. Expected ${o.type} but got ${i.dataType}.`
              );
          }
          Object.keys(l).length > 0 &&
            a.push({ table: e, fields: l, order: i.order || 1 / 0 });
        }
        let l = [];
        function d(t, r) {
          let i = t.type,
            s = {
              string: {
                sqlite: "text",
                postgres: "text",
                mysql: t.unique
                  ? "varchar(255)"
                  : t.references
                    ? "varchar(36)"
                    : "text",
                mssql:
                  t.unique || t.sortable
                    ? "varchar(255)"
                    : t.references
                      ? "varchar(36)"
                      : "text",
              },
              boolean: {
                sqlite: "integer",
                postgres: "boolean",
                mysql: "boolean",
                mssql: "smallint",
              },
              number: {
                sqlite: t.bigint ? "bigint" : "integer",
                postgres: t.bigint ? "bigint" : "integer",
                mysql: t.bigint ? "bigint" : "integer",
                mssql: t.bigint ? "bigint" : "integer",
              },
              date: {
                sqlite: "date",
                postgres: "timestamp",
                mysql: "datetime",
                mssql: "datetime",
              },
              id: {
                postgres: e.advanced?.database?.useNumberId ? "serial" : "text",
                mysql: e.advanced?.database?.useNumberId
                  ? "integer"
                  : "varchar(36)",
                mssql: e.advanced?.database?.useNumberId
                  ? "integer"
                  : "varchar(36)",
                sqlite: e.advanced?.database?.useNumberId ? "integer" : "text",
              },
            };
          return "id" === r || t.references?.field === "id"
            ? s.id[n]
            : "sqlite" === n && ("string[]" === i || "number[]" === i)
              ? "text"
              : "string[]" === i || "number[]" === i
                ? "jsonb"
                : Array.isArray(i)
                  ? "text"
                  : s[i][n || "sqlite"];
        }
        if (a.length)
          for (let e of a)
            for (let [t, r] of Object.entries(e.fields)) {
              let n = d(r, t),
                s = i.schema
                  .alterTable(e.table)
                  .addColumn(
                    t,
                    n,
                    (e) => (
                      (e = !1 !== r.required ? e.notNull() : e),
                      r.references &&
                        (e = e.references(
                          `${r.references.model}.${r.references.field}`
                        )),
                      r.unique && (e = e.unique()),
                      e
                    )
                  );
              l.push(s);
            }
        if (o.length)
          for (let t of o) {
            let r = i.schema
              .createTable(t.table)
              .addColumn(
                "id",
                e.advanced?.database?.useNumberId
                  ? "postgres" === n
                    ? "serial"
                    : "integer"
                  : "mysql" === n || "mssql" === n
                    ? "varchar(36)"
                    : "text",
                (t) =>
                  e.advanced?.database?.useNumberId
                    ? "postgres" === n
                      ? t.primaryKey().notNull()
                      : t.autoIncrement().primaryKey().notNull()
                    : t.primaryKey().notNull()
              );
            for (let [e, i] of Object.entries(t.fields)) {
              let t = d(i, e);
              r = r.addColumn(
                e,
                t,
                (e) => (
                  (e = !1 !== i.required ? e.notNull() : e),
                  i.references &&
                    (e = e.references(
                      `${i.references.model}.${i.references.field}`
                    )),
                  i.unique && (e = e.unique()),
                  e
                )
              );
            }
            l.push(r);
          }
        return {
          toBeCreated: o,
          toBeAdded: a,
          runMigrations: async function () {
            for (let e of l) await e.execute();
          },
          compileMigrations: async function () {
            return l.map((e) => e.compile().sql).join(";\n\n") + ";";
          },
        };
      }
      async function rV(e, t) {
        let r = await t.context.internalAdapter.findAccounts(e),
          n = r?.find((e) => "credential" === e.providerId),
          s = n?.password;
        if (!n || !s || !t.body.password)
          throw new i.LG("BAD_REQUEST", {
            message: "No password credential found",
          });
        if (
          !(await t.context.password.verify({
            hash: s,
            password: t.body.password,
          }))
        )
          throw new i.LG("BAD_REQUEST", { message: "Invalid password" });
        return !0;
      }
      let rK = "better-auth-secret-123456789",
        rG = async (e) => {
          var t;
          let r = await rF(e),
            i = e.plugins || [],
            n = ((t = e), t.advanced?.crossSubDomainCookies?.enabled, []),
            s = (0, c.c)(e.logger),
            a = (0, m.a)(e.baseURL, e.basePath),
            d = e.secret || l.e.BETTER_AUTH_SECRET || l.e.AUTH_SECRET || rK;
          d === rK &&
            l.a &&
            s.error(
              "You are using the default secret. Please set `BETTER_AUTH_SECRET` in your environment variables or pass `secret` in your auth config."
            ),
            (e = {
              ...e,
              secret: d,
              baseURL: a ? new URL(a).origin : "",
              basePath: e.basePath || "/api/auth",
              plugins: i.concat(n),
            });
          let h = (0, o.OR)(e),
            y = (0, eu.g)(e),
            g = Object.keys(e.socialProviders || {})
              .map((t) => {
                let r = e.socialProviders?.[t];
                if (!r || !1 === r.enabled) return null;
                r.clientId ||
                  s.warn(
                    `Social provider ${t} is missing clientId or clientSecret`
                  );
                let i = p.GY[t](r);
                return (i.disableImplicitSignUp = r.disableImplicitSignUp), i;
              })
              .filter((e) => null !== e),
            { context: w } = (function (e) {
              let t = e.options,
                r = t.plugins || [],
                i = e,
                n = [];
              for (let e of r)
                if (e.init) {
                  let r = e.init(i);
                  if ("object" == typeof r) {
                    if (r.options) {
                      let { databaseHooks: e, ...i } = r.options;
                      e && n.push(e), (t = (0, u.$Q)(t, i));
                    }
                    r.context && (i = { ...i, ...r.context });
                  }
                }
              return (
                n.push(t.databaseHooks),
                (i.internalAdapter = rW(e.adapter, {
                  options: t,
                  hooks: n.filter((e) => void 0 !== e),
                  generateId: e.generateId,
                })),
                (i.options = t),
                { context: i }
              );
            })({
              appName: e.appName || "Better Auth",
              socialProviders: g,
              options: e,
              tables: y,
              trustedOrigins: (function (e) {
                let t = (0, m.a)(e.baseURL, e.basePath);
                if (!t) return [];
                let r = [new URL(t).origin];
                e.trustedOrigins &&
                  Array.isArray(e.trustedOrigins) &&
                  r.push(...e.trustedOrigins);
                let i = l.e.BETTER_AUTH_TRUSTED_ORIGINS;
                if ((i && r.push(...i.split(",")), r.filter((e) => !e).length))
                  throw new f.B(
                    "A provided trusted origin is invalid, make sure your trusted origins list is properly defined."
                  );
                return r;
              })(e),
              baseURL: a || "",
              sessionConfig: {
                updateAge:
                  e.session?.updateAge !== void 0 ? e.session.updateAge : 86400,
                expiresIn: e.session?.expiresIn || 604800,
                freshAge:
                  e.session?.freshAge === void 0 ? 86400 : e.session.freshAge,
              },
              secret: d,
              rateLimit: {
                ...e.rateLimit,
                enabled: e.rateLimit?.enabled ?? l.a,
                window: e.rateLimit?.window || 10,
                max: e.rateLimit?.max || 100,
                storage:
                  e.rateLimit?.storage ||
                  (e.secondaryStorage ? "secondary-storage" : "memory"),
              },
              authCookies: h,
              logger: s,
              generateId: ({ model: t, size: r }) =>
                "function" == typeof e.advanced?.generateId
                  ? e.advanced.generateId({ model: t, size: r })
                  : "function" == typeof e?.advanced?.database?.generateId
                    ? e.advanced.database.generateId({ model: t, size: r })
                    : (0, ed.g)(r),
              session: null,
              secondaryStorage: e.secondaryStorage,
              password: {
                hash: e.emailAndPassword?.password?.hash || eo,
                verify: e.emailAndPassword?.password?.verify || ea,
                config: {
                  minPasswordLength: e.emailAndPassword?.minPasswordLength || 8,
                  maxPasswordLength:
                    e.emailAndPassword?.maxPasswordLength || 128,
                },
                checkPassword: rV,
              },
              setNewSession(e) {
                this.newSession = e;
              },
              newSession: null,
              adapter: r,
              internalAdapter: rW(r, {
                options: e,
                hooks: e.databaseHooks ? [e.databaseHooks] : [],
              }),
              createAuthCookie: (0, o.a6)(e),
              async runMigrations() {
                if (!e.database || "updateMany" in e.database)
                  throw new f.B(
                    "Database is not provided or it's an adapter. Migrations are only supported with a database instance."
                  );
                let { runMigrations: t } = await rz(e);
                await t();
              },
            });
          return w;
        },
        rH = (e) => {
          let t = rG(e),
            { api: r } = N(t, e),
            i = e.plugins?.reduce(
              (e, t) => (t.$ERROR_CODES ? { ...e, ...t.$ERROR_CODES } : e),
              {}
            );
          return {
            handler: async (r) => {
              let i = await t,
                n = i.options.basePath || "/api/auth";
              if (!i.options.baseURL) {
                let e = (0, m.a)(void 0, n, r);
                if (e)
                  (i.baseURL = e),
                    (i.options.baseURL = (0, m.g)(i.baseURL) || void 0);
                else
                  throw new f.B(
                    "Could not get base URL from request. Please provide a valid base URL."
                  );
              }
              i.trustedOrigins = [
                ...(e.trustedOrigins
                  ? Array.isArray(e.trustedOrigins)
                    ? e.trustedOrigins
                    : await e.trustedOrigins(r)
                  : []),
                i.options.baseURL,
              ];
              let { handler: s } = x(i, e);
              return s(r);
            },
            api: r,
            options: e,
            $context: t,
            $Infer: {},
            $ERROR_CODES: { ...i, ...n.B },
          };
        };
    },
    79338: (e, t, r) => {
      r.d(t, { I: () => u });
      var i = r(93247),
        n = r(29194),
        s = r(75456);
      let o = (e) => e?.[Symbol.toStringTag],
        a = (e, t, r) => {
          if (void 0 !== t.use && "sig" !== t.use)
            throw TypeError(
              "Invalid key for this operation, when present its use must be sig"
            );
          if (void 0 !== t.key_ops && t.key_ops.includes?.(r) !== !0)
            throw TypeError(
              `Invalid key for this operation, when present its key_ops must include ${r}`
            );
          if (void 0 !== t.alg && t.alg !== e)
            throw TypeError(
              `Invalid key for this operation, when present its alg must be ${e}`
            );
          return !0;
        },
        l = (e, t, r, l) => {
          if (!(t instanceof Uint8Array)) {
            if (l && s.ll(t)) {
              if (s.t9(t) && a(e, t, r)) return;
              throw TypeError(
                'JSON Web Key for symmetric algorithms must have JWK "kty" (Key Type) equal to "oct" and the JWK "k" (Key Value) present'
              );
            }
            if (!(0, n.A)(t))
              throw TypeError(
                (0, i.t)(e, t, ...n.g, "Uint8Array", l ? "JSON Web Key" : null)
              );
            if ("secret" !== t.type)
              throw TypeError(
                `${o(t)} instances for symmetric algorithms must be of type "secret"`
              );
          }
        },
        c = (e, t, r, l) => {
          if (l && s.ll(t))
            switch (r) {
              case "sign":
                if (s.W2(t) && a(e, t, r)) return;
                throw TypeError(
                  "JSON Web Key for this operation be a private JWK"
                );
              case "verify":
                if (s.M3(t) && a(e, t, r)) return;
                throw TypeError(
                  "JSON Web Key for this operation be a public JWK"
                );
            }
          if (!(0, n.A)(t))
            throw TypeError((0, i.t)(e, t, ...n.g, l ? "JSON Web Key" : null));
          if ("secret" === t.type)
            throw TypeError(
              `${o(t)} instances for asymmetric algorithms must not be of type "secret"`
            );
          if ("sign" === r && "public" === t.type)
            throw TypeError(
              `${o(t)} instances for asymmetric algorithm signing must be of type "private"`
            );
          if ("decrypt" === r && "public" === t.type)
            throw TypeError(
              `${o(t)} instances for asymmetric algorithm decryption must be of type "private"`
            );
          if (t.algorithm && "verify" === r && "private" === t.type)
            throw TypeError(
              `${o(t)} instances for asymmetric algorithm verifying must be of type "public"`
            );
          if (t.algorithm && "encrypt" === r && "private" === t.type)
            throw TypeError(
              `${o(t)} instances for asymmetric algorithm encryption must be of type "public"`
            );
        };
      function d(e, t, r, i) {
        t.startsWith("HS") ||
        "dir" === t ||
        t.startsWith("PBES2") ||
        /^A\d{3}(?:GCM)?KW$/.test(t)
          ? l(t, r, i, e)
          : c(t, r, i, e);
      }
      d.bind(void 0, !1);
      let u = d.bind(void 0, !0);
    },
    80382: (e, t, r) => {
      r.d(t, { J: () => s, n: () => n });
      var i = r(90211);
      class n {
        static [i.i] = "Subquery";
        constructor(e, t, r, i = !1, n = []) {
          this._ = {
            brand: "Subquery",
            sql: e,
            selectedFields: t,
            alias: r,
            isWith: i,
            usedTables: n,
          };
        }
      }
      class s extends n {
        static [i.i] = "WithSubquery";
      }
    },
    80525: (e, t, r) => {
      r.d(t, { a: () => a });
      var i = r(48675),
        n = r(74850),
        s = r(8036),
        o = r(33669);
      function a(e, t) {
        var r, a, l, c, d, u, h, p;
        if (3 === t.length) {
          return (
            (r = e),
            (a = t[0]),
            (l = t[1]),
            (c = t[2]),
            i.b.createWithOn(r, (0, o.uJ)(a), (0, n.vC)(l, "=", c))
          );
        }
        if (2 === t.length) {
          return (
            (d = e), (u = t[0]), (0, t[1])((0, s.GQ)(d, u)).toOperationNode()
          );
        }
        if (1 === t.length) {
          return (h = e), (p = t[0]), i.b.create(h, (0, o.uJ)(p));
        }
        throw Error("not implemented");
      }
    },
    80602: (e, t, r) => {
      r.d(t, { A: () => f });
      var i = r(77598),
        n = r(41321),
        s = r(72623),
        o = r(29882),
        a = r(93247),
        l = r(29194),
        c = r(75456);
      new WeakMap();
      let d = (e) => {
          switch (e) {
            case "prime256v1":
              return "P-256";
            case "secp384r1":
              return "P-384";
            case "secp521r1":
              return "P-521";
            case "secp256k1":
              return "secp256k1";
            default:
              throw new n.T0("Unsupported key curve for this operation");
          }
        },
        u = (e, t) => {
          let r;
          if ((0, s.R)(e)) r = i.KeyObject.from(e);
          else if ((0, o.A)(e)) r = e;
          else if ((0, c.ll)(e)) return e.crv;
          else throw TypeError((0, a.A)(e, ...l.g));
          if ("secret" === r.type)
            throw TypeError(
              'only "private" or "public" type keys can be used for this operation'
            );
          switch (r.asymmetricKeyType) {
            case "ed25519":
            case "ed448":
              return `Ed${r.asymmetricKeyType.slice(2)}`;
            case "x25519":
            case "x448":
              return `X${r.asymmetricKeyType.slice(1)}`;
            case "ec": {
              let e = r.asymmetricKeyDetails.namedCurve;
              if (t) return e;
              return d(e);
            }
            default:
              throw TypeError("Invalid asymmetric key type for this operation");
          }
        },
        h = (e, t) => {
          let r;
          try {
            r =
              e instanceof i.KeyObject
                ? e.asymmetricKeyDetails?.modulusLength
                : Buffer.from(e.n, "base64url").byteLength << 3;
          } catch {}
          if ("number" != typeof r || r < 2048)
            throw TypeError(
              `${t} requires key modulusLength to be 2048 bits or larger`
            );
        },
        p = new Map([
          ["ES256", "P-256"],
          ["ES256K", "secp256k1"],
          ["ES384", "P-384"],
          ["ES512", "P-521"],
        ]);
      function f(e, t) {
        let r, s, o, a;
        if (t instanceof i.KeyObject)
          (r = t.asymmetricKeyType), (s = t.asymmetricKeyDetails);
        else
          switch (((o = !0), t.kty)) {
            case "RSA":
              r = "rsa";
              break;
            case "EC":
              r = "ec";
              break;
            case "OKP":
              if ("Ed25519" === t.crv) {
                r = "ed25519";
                break;
              }
              if ("Ed448" === t.crv) {
                r = "ed448";
                break;
              }
              throw TypeError(
                "Invalid key for this operation, its crv must be Ed25519 or Ed448"
              );
            default:
              throw TypeError(
                "Invalid key for this operation, its kty must be RSA, OKP, or EC"
              );
          }
        switch (e) {
          case "Ed25519":
            if ("ed25519" !== r)
              throw TypeError(
                "Invalid key for this operation, its asymmetricKeyType must be ed25519"
              );
            break;
          case "EdDSA":
            if (!["ed25519", "ed448"].includes(r))
              throw TypeError(
                "Invalid key for this operation, its asymmetricKeyType must be ed25519 or ed448"
              );
            break;
          case "RS256":
          case "RS384":
          case "RS512":
            if ("rsa" !== r)
              throw TypeError(
                "Invalid key for this operation, its asymmetricKeyType must be rsa"
              );
            h(t, e);
            break;
          case "PS256":
          case "PS384":
          case "PS512":
            if ("rsa-pss" === r) {
              let { hashAlgorithm: t, mgf1HashAlgorithm: r, saltLength: i } = s,
                n = parseInt(e.slice(-3), 10);
              if (void 0 !== t && (t !== `sha${n}` || r !== t))
                throw TypeError(
                  `Invalid key for this operation, its RSA-PSS parameters do not meet the requirements of "alg" ${e}`
                );
              if (void 0 !== i && i > n >> 3)
                throw TypeError(
                  `Invalid key for this operation, its RSA-PSS parameter saltLength does not meet the requirements of "alg" ${e}`
                );
            } else if ("rsa" !== r)
              throw TypeError(
                "Invalid key for this operation, its asymmetricKeyType must be rsa or rsa-pss"
              );
            h(t, e),
              (a = {
                padding: i.constants.RSA_PKCS1_PSS_PADDING,
                saltLength: i.constants.RSA_PSS_SALTLEN_DIGEST,
              });
            break;
          case "ES256":
          case "ES256K":
          case "ES384":
          case "ES512": {
            if ("ec" !== r)
              throw TypeError(
                "Invalid key for this operation, its asymmetricKeyType must be ec"
              );
            let i = u(t),
              n = p.get(e);
            if (i !== n)
              throw TypeError(
                `Invalid key curve for the algorithm, its curve must be ${n}, got ${i}`
              );
            a = { dsaEncoding: "ieee-p1363" };
            break;
          }
          default:
            throw new n.T0(
              `alg ${e} is not supported either by JOSE or your javascript runtime`
            );
        }
        return o ? { format: "jwk", key: t, ...a } : a ? { ...a, key: t } : t;
      }
    },
    81385: (e, t, r) => {
      r.d(t, { A: () => i });
      function i(e) {
        if (
          "object" != typeof e ||
          null === e ||
          "[object Object]" !== Object.prototype.toString.call(e)
        )
          return !1;
        if (null === Object.getPrototypeOf(e)) return !0;
        let t = e;
        for (; null !== Object.getPrototypeOf(t); )
          t = Object.getPrototypeOf(t);
        return Object.getPrototypeOf(e) === t;
      }
    },
    81712: (e, t, r) => {
      r.d(t, { q: () => s });
      var i = r(27759),
        n = r(96051);
      let s = (0, n.CN)({
        is: (e) => "ReferenceNode" === e.kind,
        create: (e, t) =>
          (0, n.CN)({ kind: "ReferenceNode", table: t, column: e }),
        createSelectAll: (e) =>
          (0, n.CN)({ kind: "ReferenceNode", table: e, column: i.U.create() }),
      });
    },
    82099: (e, t, r) => {
      r.d(t, { H: () => s });
      var i = r(96051),
        n = r(17445);
      let s = (0, i.CN)({
        is: (e) => "TableNode" === e.kind,
        create: (e) => (0, i.CN)({ kind: "TableNode", table: n.y.create(e) }),
        createWithSchema: (e, t) =>
          (0, i.CN)({ kind: "TableNode", table: n.y.createWithSchema(e, t) }),
      });
    },
    82658: (e, t, r) => {
      r.d(t, { zM: () => a });
      var i = r(90211),
        n = r(64055);
      class s extends n.pe {
        static [i.i] = "PgBooleanBuilder";
        constructor(e) {
          super(e, "boolean", "PgBoolean");
        }
        build(e) {
          return new o(e, this.config);
        }
      }
      class o extends n.Kl {
        static [i.i] = "PgBoolean";
        getSQLType() {
          return "boolean";
        }
      }
      function a(e) {
        return new s(e ?? "");
      }
    },
    82779: (e, t, r) => {
      r.d(t, { i: () => n });
      var i = r(96051);
      let n = (0, i.CN)({
        is: (e) => "SetOperationNode" === e.kind,
        create: (e, t, r) =>
          (0, i.CN)({
            kind: "SetOperationNode",
            operator: e,
            expression: t,
            all: r,
          }),
      });
    },
    83260: (e, t, r) => {
      r.d(t, { R: () => a });
      var i = r(96051),
        n = r(61495),
        s = r(2444);
      let o = (0, i.CN)([]);
      class a {
        #em;
        constructor(e = o) {
          this.#em = e;
        }
        get plugins() {
          return this.#em;
        }
        transformQuery(e, t) {
          for (let r of this.#em) {
            let i = r.transformQuery({ node: e, queryId: t });
            if (i.kind === e.kind) e = i;
            else
              throw Error(
                `KyselyPlugin.transformQuery must return a node of the same kind that was given to it. The plugin was given a ${e.kind} but it returned a ${i.kind}`
              );
          }
          return e;
        }
        async executeQuery(e, t) {
          return await this.provideConnection(async (r) => {
            let i = await r.executeQuery(e);
            return (
              "numUpdatedOrDeletedRows" in i &&
                (0, s.u)(
                  "kysely:warning: outdated driver/plugin detected! `QueryResult.numUpdatedOrDeletedRows` has been replaced with `QueryResult.numAffectedRows`."
                ),
              await this.#ey(i, t)
            );
          });
        }
        async *stream(e, t, r) {
          let { connection: i, release: s } = await (0, n.G)(this);
          try {
            for await (let n of i.streamQuery(e, t)) yield await this.#ey(n, r);
          } finally {
            s();
          }
        }
        async #ey(e, t) {
          for (let r of this.#em)
            e = await r.transformResult({ result: e, queryId: t });
          return e;
        }
      }
    },
    83500: (e, t, r) => {
      r.d(t, { B: () => h });
      var i = r(83755),
        n = r(67872),
        s = r(87389),
        o = r(69913),
        a = r(17445),
        l = r(82099);
      let c = (0, r(96051).CN)({
          AlterTableNode: !0,
          CreateIndexNode: !0,
          CreateSchemaNode: !0,
          CreateTableNode: !0,
          CreateTypeNode: !0,
          CreateViewNode: !0,
          RefreshMaterializedViewNode: !0,
          DeleteQueryNode: !0,
          DropIndexNode: !0,
          DropSchemaNode: !0,
          DropTableNode: !0,
          DropTypeNode: !0,
          DropViewNode: !0,
          InsertQueryNode: !0,
          RawNode: !0,
          SelectQueryNode: !0,
          UpdateQueryNode: !0,
          MergeQueryNode: !0,
        }),
        d = { json_agg: !0, to_json: !0 };
      class u extends o.V {
        #eg;
        #ew = new Set();
        #eb = new Set();
        constructor(e) {
          super(), (this.#eg = e);
        }
        transformNodeImpl(e, t) {
          if (!this.#ev(e)) return super.transformNodeImpl(e, t);
          let r = this.#eN(e);
          for (let e of r) this.#eb.add(e);
          let i = this.#ex(e);
          for (let e of i) this.#ew.add(e);
          let n = super.transformNodeImpl(e, t);
          for (let e of i) this.#ew.delete(e);
          for (let e of r) this.#eb.delete(e);
          return n;
        }
        transformSchemableIdentifier(e, t) {
          let r = super.transformSchemableIdentifier(e, t);
          return r.schema || !this.#ew.has(e.identifier.name)
            ? r
            : { ...r, schema: n.O.create(this.#eg) };
        }
        transformReferences(e, t) {
          let r = super.transformReferences(e, t);
          return r.table.table.schema
            ? r
            : {
                ...r,
                table: l.H.createWithSchema(
                  this.#eg,
                  r.table.table.identifier.name
                ),
              };
        }
        transformAggregateFunction(e, t) {
          return {
            ...super.transformAggregateFunction({ ...e, aggregated: [] }, t),
            aggregated: this.#e_(e, t, "aggregated"),
          };
        }
        transformFunction(e, t) {
          return {
            ...super.transformFunction({ ...e, arguments: [] }, t),
            arguments: this.#e_(e, t, "arguments"),
          };
        }
        #e_(e, t, r) {
          return d[e.func]
            ? e[r].map((e) =>
                !l.H.is(e) || e.table.schema
                  ? this.transformNode(e, t)
                  : {
                      ...e,
                      table: this.transformIdentifier(e.table.identifier, t),
                    }
              )
            : this.transformNodeList(e[r], t);
        }
        #ev(e) {
          return e.kind in c;
        }
        #ex(e) {
          let t = new Set();
          if (
            ("name" in e && e.name && a.y.is(e.name) && this.#eS(e.name, t),
            "from" in e && e.from)
          )
            for (let r of e.from.froms) this.#eT(r, t);
          if (
            ("into" in e && e.into && this.#eT(e.into, t),
            "table" in e && e.table && this.#eT(e.table, t),
            "joins" in e && e.joins)
          )
            for (let r of e.joins) this.#eT(r.table, t);
          return "using" in e && e.using && this.#eT(e.using, t), t;
        }
        #eN(e) {
          let t = new Set();
          return "with" in e && e.with && this.#ek(e.with, t), t;
        }
        #eT(e, t) {
          if (l.H.is(e)) this.#eS(e.table, t);
          else if (i.N.is(e) && l.H.is(e.node)) this.#eS(e.node.table, t);
          else if (s.v.is(e)) for (let r of e.items) this.#eT(r, t);
        }
        #eS(e, t) {
          let r = e.identifier.name;
          this.#ew.has(r) || this.#eb.has(r) || t.add(r);
        }
        #ek(e, t) {
          for (let r of e.expressions) {
            let e = r.name.table.table.identifier.name;
            this.#eb.has(e) || t.add(e);
          }
        }
      }
      class h {
        #K;
        constructor(e) {
          this.#K = new u(e);
        }
        transformQuery(e) {
          return this.#K.transformNode(e.node, e.queryId);
        }
        async transformResult(e) {
          return e.result;
        }
      }
    },
    83755: (e, t, r) => {
      r.d(t, { N: () => n });
      var i = r(96051);
      let n = (0, i.CN)({
        is: (e) => "AliasNode" === e.kind,
        create: (e, t) => (0, i.CN)({ kind: "AliasNode", node: e, alias: t }),
      });
    },
    84941: (e, t, r) => {
      r.d(t, { u: () => i });
      let i = {
        encode: (e) => {
          if (
            ("string" == typeof e && (e = new TextEncoder().encode(e)),
            0 === e.byteLength)
          )
            return "";
          let t = new Uint8Array(e),
            r = "";
          for (let e of t) r += e.toString(16).padStart(2, "0");
          return r;
        },
        decode: (e) => {
          if (!e) return "";
          if ("string" == typeof e) {
            if (e.length % 2 != 0 || !RegExp("^[0123456789abcdef]+$").test(e))
              throw Error("Invalid hexadecimal string");
            let t = new Uint8Array(e.length / 2);
            for (let r = 0; r < e.length; r += 2)
              t[r / 2] = parseInt(e.slice(r, r + 2), 16);
            return new TextDecoder().decode(t);
          }
          return new TextDecoder().decode(e);
        },
      };
    },
    87201: (e, t, r) => {
      r.d(t, { W: () => s });
      var i = r(83260);
      class n extends i.R {
        get adapter() {
          throw Error("this query cannot be compiled to SQL");
        }
        compileQuery() {
          throw Error("this query cannot be compiled to SQL");
        }
        provideConnection() {
          throw Error("this query cannot be executed");
        }
        withConnectionProvider() {
          throw Error("this query cannot have a connection provider");
        }
        withPlugin(e) {
          return new n([...this.plugins, e]);
        }
        withPlugins(e) {
          return new n([...this.plugins, ...e]);
        }
        withPluginAtFront(e) {
          return new n([e, ...this.plugins]);
        }
        withoutPlugins() {
          return new n([]);
        }
      }
      let s = new n();
    },
    87389: (e, t, r) => {
      r.d(t, { v: () => n });
      var i = r(96051);
      let n = (0, i.CN)({
        is: (e) => "ListNode" === e.kind,
        create: (e) => (0, i.CN)({ kind: "ListNode", items: (0, i.CN)(e) }),
      });
    },
    88990: (e, t, r) => {
      r.d(t, { A: () => i });
      let i = (e) => Math.floor(e.getTime() / 1e3);
    },
    89400: (e, t, r) => {
      r.d(t, { q: () => n });
      var i = r(96051);
      let n = (0, i.CN)({
        is: (e) => "ValueNode" === e.kind,
        create: (e) => (0, i.CN)({ kind: "ValueNode", value: e }),
        createImmediate: (e) =>
          (0, i.CN)({ kind: "ValueNode", value: e, immediate: !0 }),
      });
    },
    89649: (e, t, r) => {
      r.d(t, { Xd: () => l, kB: () => c });
      var i = r(90211),
        n = r(72259),
        s = r(64055),
        o = r(74945);
      class a extends o.u {
        constructor(e, t, r) {
          super(e, "string", "PgTime"),
            (this.withTimezone = t),
            (this.precision = r),
            (this.config.withTimezone = t),
            (this.config.precision = r);
        }
        static [i.i] = "PgTimeBuilder";
        build(e) {
          return new l(e, this.config);
        }
      }
      class l extends s.Kl {
        static [i.i] = "PgTime";
        withTimezone;
        precision;
        constructor(e, t) {
          super(e, t),
            (this.withTimezone = t.withTimezone),
            (this.precision = t.precision);
        }
        getSQLType() {
          let e = void 0 === this.precision ? "" : `(${this.precision})`;
          return `time${e}${this.withTimezone ? " with time zone" : ""}`;
        }
      }
      function c(e, t = {}) {
        let { name: r, config: i } = (0, n.Ll)(e, t);
        return new a(r, i.withTimezone ?? !1, i.precision);
      }
    },
    90211: (e, t, r) => {
      r.d(t, { i: () => i, is: () => n });
      let i = Symbol.for("drizzle:entityKind");
      function n(e, t) {
        if (!e || "object" != typeof e) return !1;
        if (e instanceof t) return !0;
        if (!Object.prototype.hasOwnProperty.call(t, i))
          throw Error(
            `Class "${t.name ?? "<unknown>"}" doesn't look like a Drizzle entity. If this is incorrect and the class is provided by Drizzle, please report this as a bug.`
          );
        let r = Object.getPrototypeOf(e).constructor;
        if (r)
          for (; r; ) {
            if (i in r && r[i] === t[i]) return !0;
            r = Object.getPrototypeOf(r);
          }
        return !1;
      }
      Symbol.for("drizzle:hasOwnEntityKind");
    },
    91631: (e, t, r) => {
      r.d(t, { n: () => i });
      let i = Symbol.for("drizzle:ViewBaseConfig");
    },
    93136: (e, t, r) => {
      r.d(t, { dw: () => d, p6: () => u, qw: () => l });
      var i = r(90211),
        n = r(72259),
        s = r(64055),
        o = r(74945);
      class a extends o.u {
        static [i.i] = "PgDateBuilder";
        constructor(e) {
          super(e, "date", "PgDate");
        }
        build(e) {
          return new l(e, this.config);
        }
      }
      class l extends s.Kl {
        static [i.i] = "PgDate";
        getSQLType() {
          return "date";
        }
        mapFromDriverValue(e) {
          return new Date(e);
        }
        mapToDriverValue(e) {
          return e.toISOString();
        }
      }
      class c extends o.u {
        static [i.i] = "PgDateStringBuilder";
        constructor(e) {
          super(e, "string", "PgDateString");
        }
        build(e) {
          return new d(e, this.config);
        }
      }
      class d extends s.Kl {
        static [i.i] = "PgDateString";
        getSQLType() {
          return "date";
        }
      }
      function u(e, t) {
        let { name: r, config: i } = (0, n.Ll)(e, t);
        return i?.mode === "date" ? new a(r) : new c(r);
      }
    },
    93247: (e, t, r) => {
      function i(e, t, ...r) {
        if ((r = r.filter(Boolean)).length > 2) {
          let t = r.pop();
          e += `one of type ${r.join(", ")}, or ${t}.`;
        } else
          2 === r.length
            ? (e += `one of type ${r[0]} or ${r[1]}.`)
            : (e += `of type ${r[0]}.`);
        return (
          null == t
            ? (e += ` Received ${t}`)
            : "function" == typeof t && t.name
              ? (e += ` Received function ${t.name}`)
              : "object" == typeof t &&
                null != t &&
                t.constructor?.name &&
                (e += ` Received an instance of ${t.constructor.name}`),
          e
        );
      }
      r.d(t, { A: () => n, t: () => s });
      let n = (e, ...t) => i("Key must be ", e, ...t);
      function s(e, t, ...r) {
        return i(`Key for the ${e} algorithm must be `, t, ...r);
      }
    },
    93298: (e, t, r) => {
      r.d(t, { Is: () => d });
      var i = r(83755),
        n = r(42188),
        s = r(67872),
        o = r(10132),
        a = r(1518),
        l = r(19334),
        c = r(74850);
      class d {
        #Q;
        constructor(e) {
          this.#Q = e;
        }
        get expressionType() {}
        as(e) {
          return new u(this, e);
        }
        or(...e) {
          return new h(a.K.create(this.#Q, (0, c.GB)(e)));
        }
        and(...e) {
          return new p(n.s.create(this.#Q, (0, c.GB)(e)));
        }
        $castTo() {
          return new d(this.#Q);
        }
        $notNull() {
          return new d(this.#Q);
        }
        toOperationNode() {
          return this.#Q;
        }
      }
      class u {
        #eA;
        #i;
        constructor(e, t) {
          (this.#eA = e), (this.#i = t);
        }
        get expression() {
          return this.#eA;
        }
        get alias() {
          return this.#i;
        }
        toOperationNode() {
          return i.N.create(
            this.#eA.toOperationNode(),
            (0, o.N)(this.#i) ? this.#i.toOperationNode() : s.O.create(this.#i)
          );
        }
      }
      class h {
        #Q;
        constructor(e) {
          this.#Q = e;
        }
        get expressionType() {}
        as(e) {
          return new u(this, e);
        }
        or(...e) {
          return new h(a.K.create(this.#Q, (0, c.GB)(e)));
        }
        $castTo() {
          return new h(this.#Q);
        }
        toOperationNode() {
          return l.k.create(this.#Q);
        }
      }
      class p {
        #Q;
        constructor(e) {
          this.#Q = e;
        }
        get expressionType() {}
        as(e) {
          return new u(this, e);
        }
        and(...e) {
          return new p(n.s.create(this.#Q, (0, c.GB)(e)));
        }
        $castTo() {
          return new p(this.#Q);
        }
        toOperationNode() {
          return l.k.create(this.#Q);
        }
      }
    },
    93403: (e, t, r) => {
      r.d(t, { bE: () => f, xk: () => m });
      var i = r(40928),
        n = r(99144),
        s = r(96051);
      let o = (0, s.CN)({
        is: (e) => "OrderByItemNode" === e.kind,
        create: (e, t) =>
          (0, s.CN)({ kind: "OrderByItemNode", orderBy: e, direction: t }),
        cloneWith: (e, t) => (0, s.CN)({ ...e, ...t }),
      });
      var a = r(1045),
        l = r(67872);
      let c = {
        create: (e) =>
          (0, s.CN)({ kind: "CollateNode", collation: l.O.create(e) }),
      };
      class d {
        #e;
        constructor(e) {
          this.#e = (0, s.CN)(e);
        }
        desc() {
          return new d({
            node: o.cloneWith(this.#e.node, {
              direction: a.z.createWithSql("desc"),
            }),
          });
        }
        asc() {
          return new d({
            node: o.cloneWith(this.#e.node, {
              direction: a.z.createWithSql("asc"),
            }),
          });
        }
        nullsLast() {
          return new d({ node: o.cloneWith(this.#e.node, { nulls: "last" }) });
        }
        nullsFirst() {
          return new d({ node: o.cloneWith(this.#e.node, { nulls: "first" }) });
        }
        collate(e) {
          return new d({
            node: o.cloneWith(this.#e.node, { collation: c.create(e) }),
          });
        }
        toOperationNode() {
          return this.#e.node;
        }
      }
      var u = r(2444),
        h = r(75423),
        p = r(666);
      function f(e) {
        return "asc" === e || "desc" === e;
      }
      function m(e) {
        if (2 === e.length) return [y(e[0], e[1])];
        if (1 === e.length) {
          let [t] = e;
          return Array.isArray(t)
            ? ((0, u.u)(
                "orderBy(array) is deprecated, use multiple orderBy calls instead."
              ),
              t.map((e) => y(e)))
            : [y(t)];
        }
        throw Error(
          `Invalid number of arguments at order by! expected 1-2, received ${e.length}`
        );
      }
      function y(e, t) {
        let r = (function (e) {
          if ((0, h.SS)(e)) return (0, h.YK)(e);
          if ((0, i.C)(e)) return e.toOperationNode();
          let [t, r] = e.split(" ");
          return r
            ? ((0, u.u)(
                "`orderBy('column asc')` is deprecated. Use `orderBy('column', 'asc')` instead."
              ),
              g((0, p.q5)(t), r))
            : (0, p.q5)(e);
        })(e);
        if (o.is(r)) {
          if (t) throw Error("Cannot specify direction twice!");
          return r;
        }
        return g(r, t);
      }
      function g(e, t) {
        if ("string" == typeof t) {
          if (!f(t)) throw Error(`Invalid order by direction: ${t}`);
          return o.create(e, a.z.createWithSql(t));
        }
        if ((0, n.B)(t))
          return (
            (0, u.u)(
              "`orderBy(..., expr)` is deprecated. Use `orderBy(..., 'asc')` or `orderBy(..., (ob) => ...)` instead."
            ),
            o.create(e, t.toOperationNode())
          );
        let r = o.create(e);
        return t ? t(new d({ node: r })).toOperationNode() : r;
      }
    },
    93818: (e, t, r) => {
      r.d(t, { s: () => i });
      function i(e) {
        try {
          return JSON.parse(e, function (e, t) {
            if (
              "string" == typeof t &&
              /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(?:\.\d+)?Z$/.test(t)
            ) {
              let e = new Date(t);
              if (!isNaN(e.getTime())) return e;
            }
            return t;
          });
        } catch {
          return null;
        }
      }
    },
    93994: (e, t, r) => {
      r.d(t, { V: () => n });
      var i = r(90211);
      class n {
        constructor(e, t) {
          (this.table = e),
            (this.config = t),
            (this.name = t.name),
            (this.keyAsName = t.keyAsName),
            (this.notNull = t.notNull),
            (this.default = t.default),
            (this.defaultFn = t.defaultFn),
            (this.onUpdateFn = t.onUpdateFn),
            (this.hasDefault = t.hasDefault),
            (this.primary = t.primaryKey),
            (this.isUnique = t.isUnique),
            (this.uniqueName = t.uniqueName),
            (this.uniqueType = t.uniqueType),
            (this.dataType = t.dataType),
            (this.columnType = t.columnType),
            (this.generated = t.generated),
            (this.generatedIdentity = t.generatedIdentity);
        }
        static [i.i] = "Column";
        name;
        keyAsName;
        primary;
        notNull;
        default;
        defaultFn;
        onUpdateFn;
        hasDefault;
        isUnique;
        uniqueName;
        uniqueType;
        dataType;
        columnType;
        enumValues = void 0;
        generated = void 0;
        generatedIdentity = void 0;
        config;
        mapFromDriverValue(e) {
          return e;
        }
        mapToDriverValue(e) {
          return e;
        }
        shouldDisableInsert() {
          return (
            void 0 !== this.config.generated &&
            "byDefault" !== this.config.generated.type
          );
        }
      }
    },
    94349: (e, t, r) => {
      r.d(t, { g: () => n });
      var i = r(16459);
      let n = (e) => (0, i.q)("a-z", "A-Z", "0-9")(e || 32);
    },
    95235: (e, t, r) => {
      r.d(t, { O: () => q, A: () => U });
      var i = r(1815),
        n = r(53668),
        s = r(33669),
        o = r(83500),
        a = r(6710),
        l = r(9490),
        c = r(666),
        d = r(74850),
        u = r(19334),
        h = r(93298),
        p = r(36357),
        f = r(96051);
      let m = (0, f.CN)({
        is: (e) => "UnaryOperationNode" === e.kind,
        create: (e, t) =>
          (0, f.CN)({ kind: "UnaryOperationNode", operator: e, operand: t }),
      });
      var y = r(11750),
        g = r(87201),
        w = r(1116),
        b = r(35665),
        v = r(83755),
        N = r(67872),
        x = r(2520);
      let _ = (0, f.CN)({
        is: (e) => "JSONPathLegNode" === e.kind,
        create: (e, t) =>
          (0, f.CN)({ kind: "JSONPathLegNode", type: e, value: t }),
      });
      var S = r(293),
        T = r(6711),
        k = r(10132),
        A = r(89400);
      class E {
        #Q;
        constructor(e) {
          this.#Q = e;
        }
        at(e) {
          return this.#eE("ArrayLocation", e);
        }
        key(e) {
          return this.#eE("Member", e);
        }
        #eE(e, t) {
          return new C(
            T.Q.is(this.#Q)
              ? T.Q.cloneWithTraversal(
                  this.#Q,
                  S.c.is(this.#Q.traversal)
                    ? S.c.cloneWithLeg(this.#Q.traversal, _.create(e, t))
                    : x.k.cloneWithValue(
                        this.#Q.traversal,
                        A.q.createImmediate(t)
                      )
                )
              : S.c.cloneWithLeg(this.#Q, _.create(e, t))
          );
        }
      }
      class C extends E {
        #Q;
        constructor(e) {
          super(e), (this.#Q = e);
        }
        get expressionType() {}
        as(e) {
          return new I(this, e);
        }
        $castTo() {
          return new C(this.#Q);
        }
        $notNull() {
          return new C(this.#Q);
        }
        toOperationNode() {
          return this.#Q;
        }
      }
      class I {
        #eC;
        #i;
        constructor(e, t) {
          (this.#eC = e), (this.#i = t);
        }
        get expression() {
          return this.#eC;
        }
        get alias() {
          return this.#i;
        }
        toOperationNode() {
          return v.N.create(
            this.#eC.toOperationNode(),
            (0, k.N)(this.#i) ? this.#i.toOperationNode() : N.O.create(this.#i)
          );
        }
      }
      var O = r(62534),
        L = r(42188);
      let R = (0, f.CN)({
        is: (e) => "TupleNode" === e.kind,
        create: (e) => (0, f.CN)({ kind: "TupleNode", values: (0, f.CN)(e) }),
      });
      var P = r(73574);
      let D = (0, f.CN)({
        is: (e) => "CastNode" === e.kind,
        create: (e, t) =>
          (0, f.CN)({ kind: "CastNode", expression: e, dataType: t }),
      });
      function q(e = g.W) {
        function t(e, t) {
          var r, i;
          return new h.Is(
            ((r = e), (i = t), m.create(p.zX.create(r), (0, c.$O)(i)))
          );
        }
        let r = Object.assign(
          function (e, t, r) {
            return new h.Is((0, d.ds)(e, t, r));
          },
          {
            fn: void 0,
            eb: void 0,
            selectFrom: (t) =>
              (0, i.c)({
                queryId: (0, a.a)(),
                executor: e,
                queryNode: n.L.createFrom((0, s.JB)(t)),
              }),
            case: (e) =>
              new w.OU({
                node: b.P.create((0, f.b0)(e) ? void 0 : (0, c.$O)(e)),
              }),
            ref: (e, t) =>
              (0, f.b0)(t) ? new h.Is((0, c.q5)(e)) : new E((0, c.NF)(e, t)),
            jsonPath: () => new E(S.c.create()),
            table: (e) => new h.Is((0, s.M$)(e)),
            val: (e) => new h.Is((0, y.$s)(e)),
            refTuple: (...e) => new h.Is(R.create(e.map(c.$O))),
            tuple: (...e) => new h.Is(R.create(e.map(y.$s))),
            lit: (e) => new h.Is((0, y.dJ)(e)),
            unary: t,
            not: (e) => t("not", e),
            exists: (e) => t("exists", e),
            neg: (e) => t("-", e),
            between: (e, t, r) =>
              new h.Is(
                O.l.create(
                  (0, c.$O)(e),
                  p.zX.create("between"),
                  L.s.create((0, y.$s)(t), (0, y.$s)(r))
                )
              ),
            betweenSymmetric: (e, t, r) =>
              new h.Is(
                O.l.create(
                  (0, c.$O)(e),
                  p.zX.create("between symmetric"),
                  L.s.create((0, y.$s)(t), (0, y.$s)(r))
                )
              ),
            and: (e) =>
              new h.Is(
                (0, f.MH)(e) ? (0, d.KN)(e, "and") : (0, d.Ve)(e, "and")
              ),
            or: (e) =>
              new h.Is((0, f.MH)(e) ? (0, d.KN)(e, "or") : (0, d.Ve)(e, "or")),
            parens(...e) {
              let t = (0, d.GB)(e);
              return new h.Is(u.k.is(t) ? t : u.k.create(t));
            },
            cast: (e, t) => new h.Is(D.create((0, c.$O)(e), (0, P.Q)(t))),
            withSchema: (t) => q(e.withPluginAtFront(new o.B(t))),
          }
        );
        return (r.fn = (0, l.t)()), (r.eb = r), r;
      }
      function U(e) {
        return q();
      }
    },
    96051: (e, t, r) => {
      function i(e) {
        return void 0 === e || void 0 === e;
      }
      function n(e) {
        return "string" == typeof e;
      }
      function s(e) {
        return "number" == typeof e;
      }
      function o(e) {
        return "boolean" == typeof e;
      }
      function a(e) {
        return null === e;
      }
      function l(e) {
        return e instanceof Date;
      }
      function c(e) {
        return "bigint" == typeof e;
      }
      function d(e) {
        return "undefined" != typeof Buffer && Buffer.isBuffer(e);
      }
      function u(e) {
        return "function" == typeof e;
      }
      function h(e) {
        return "object" == typeof e && null !== e;
      }
      function p(e) {
        return Object.freeze(e);
      }
      function f(e) {
        return m(e) ? e : [e];
      }
      function m(e) {
        return Array.isArray(e);
      }
      function y(e) {
        return e;
      }
      r.d(t, {
        $P: () => l,
        CN: () => p,
        Et: () => s,
        Gv: () => h,
        Kg: () => n,
        Lm: () => o,
        MH: () => m,
        Pe: () => d,
        Tn: () => u,
        _j: () => f,
        b0: () => i,
        kZ: () => a,
        lQ: () => y,
        sI: () => c,
      });
      Object.prototype.toString;
    },
    96350: (e, t, r) => {
      r.d(t, { n: () => ep });
      var i = r(1815),
        n = r(43005),
        s = r(77255),
        o = r(31437),
        a = r(99313),
        l = r(96051),
        c = r(11750);
      let d = (0, l.CN)({
        is: (e) => "ValuesNode" === e.kind,
        create: (e) => (0, l.CN)({ kind: "ValuesNode", values: (0, l.CN)(e) }),
      });
      var u = r(75423);
      let h = (0, l.CN)({
        is: (e) => "DefaultInsertValueNode" === e.kind,
        create: () => (0, l.CN)({ kind: "DefaultInsertValueNode" }),
      });
      var p = r(95235);
      function f(e) {
        let t = (0, l.Tn)(e) ? e((0, p.A)()) : e;
        var r = (0, l.MH)(t) ? t : (0, l.CN)([t]);
        let i = (function (e) {
          let t = new Map();
          for (let r of e)
            for (let e of Object.keys(r))
              t.has(e) || void 0 === r[e] || t.set(e, t.size);
          return t;
        })(r);
        return [
          (0, l.CN)([...i.keys()].map(s.Z.create)),
          d.create(
            r.map((e) =>
              (function (e, t) {
                let r = Object.keys(e),
                  i = Array.from({ length: t.size }),
                  n = !1,
                  s = r.length;
                for (let o of r) {
                  let r = t.get(o);
                  if ((0, l.b0)(r)) {
                    s--;
                    continue;
                  }
                  let a = e[o];
                  ((0, l.b0)(a) || (0, u.SS)(a)) && (n = !0), (i[r] = a);
                }
                if (s < t.size || n) {
                  let e = h.create();
                  return a.s.create(
                    i.map((t) => ((0, l.b0)(t) ? e : (0, c.$s)(t)))
                  );
                }
                return o.h.create(i);
              })(e, i)
            )
          ),
        ];
      }
      var m = r(29597),
        y = r(64992);
      let g = (0, l.CN)({
        is: (e) => "ColumnUpdateNode" === e.kind,
        create: (e, t) =>
          (0, l.CN)({ kind: "ColumnUpdateNode", column: e, value: t }),
      });
      var w = r(666);
      function b(e) {
        return Object.entries((0, l.Tn)(e) ? e((0, p.A)()) : e)
          .filter(([e, t]) => void 0 !== t)
          .map(([e, t]) => g.create(s.Z.create(e), (0, c.$s)(t)));
      }
      let v = (0, l.CN)({
        is: (e) => "OnDuplicateKeyNode" === e.kind,
        create: (e) => (0, l.CN)({ kind: "OnDuplicateKeyNode", updates: e }),
      });
      class N {
        insertId;
        numInsertedOrUpdatedRows;
        constructor(e, t) {
          (this.insertId = e), (this.numInsertedOrUpdatedRows = t);
        }
      }
      var x = r(38508),
        _ = r(67872),
        S = r(52630);
      let T = (0, l.CN)({
        is: (e) => "OnConflictNode" === e.kind,
        create: () => (0, l.CN)({ kind: "OnConflictNode" }),
        cloneWith: (e, t) => (0, l.CN)({ ...e, ...t }),
        cloneWithIndexWhere: (e, t) =>
          (0, l.CN)({
            ...e,
            indexWhere: e.indexWhere
              ? S.o.cloneWithOperation(e.indexWhere, "And", t)
              : S.o.create(t),
          }),
        cloneWithIndexOrWhere: (e, t) =>
          (0, l.CN)({
            ...e,
            indexWhere: e.indexWhere
              ? S.o.cloneWithOperation(e.indexWhere, "Or", t)
              : S.o.create(t),
          }),
        cloneWithUpdateWhere: (e, t) =>
          (0, l.CN)({
            ...e,
            updateWhere: e.updateWhere
              ? S.o.cloneWithOperation(e.updateWhere, "And", t)
              : S.o.create(t),
          }),
        cloneWithUpdateOrWhere: (e, t) =>
          (0, l.CN)({
            ...e,
            updateWhere: e.updateWhere
              ? S.o.cloneWithOperation(e.updateWhere, "Or", t)
              : S.o.create(t),
          }),
        cloneWithoutIndexWhere: (e) => (0, l.CN)({ ...e, indexWhere: void 0 }),
        cloneWithoutUpdateWhere: (e) =>
          (0, l.CN)({ ...e, updateWhere: void 0 }),
      });
      var k = r(74850);
      class A {
        #e;
        constructor(e) {
          this.#e = (0, l.CN)(e);
        }
        column(e) {
          let t = s.Z.create(e);
          return new A({
            ...this.#e,
            onConflictNode: T.cloneWith(this.#e.onConflictNode, {
              columns: this.#e.onConflictNode.columns
                ? (0, l.CN)([...this.#e.onConflictNode.columns, t])
                : (0, l.CN)([t]),
            }),
          });
        }
        columns(e) {
          let t = e.map(s.Z.create);
          return new A({
            ...this.#e,
            onConflictNode: T.cloneWith(this.#e.onConflictNode, {
              columns: this.#e.onConflictNode.columns
                ? (0, l.CN)([...this.#e.onConflictNode.columns, ...t])
                : (0, l.CN)(t),
            }),
          });
        }
        constraint(e) {
          return new A({
            ...this.#e,
            onConflictNode: T.cloneWith(this.#e.onConflictNode, {
              constraint: _.O.create(e),
            }),
          });
        }
        expression(e) {
          return new A({
            ...this.#e,
            onConflictNode: T.cloneWith(this.#e.onConflictNode, {
              indexExpression: e.toOperationNode(),
            }),
          });
        }
        where(...e) {
          return new A({
            ...this.#e,
            onConflictNode: T.cloneWithIndexWhere(
              this.#e.onConflictNode,
              (0, k.GB)(e)
            ),
          });
        }
        whereRef(e, t, r) {
          return new A({
            ...this.#e,
            onConflictNode: T.cloneWithIndexWhere(
              this.#e.onConflictNode,
              (0, k.vC)(e, t, r)
            ),
          });
        }
        clearWhere() {
          return new A({
            ...this.#e,
            onConflictNode: T.cloneWithoutIndexWhere(this.#e.onConflictNode),
          });
        }
        doNothing() {
          return new E({
            ...this.#e,
            onConflictNode: T.cloneWith(this.#e.onConflictNode, {
              doNothing: !0,
            }),
          });
        }
        doUpdateSet(e) {
          return new C({
            ...this.#e,
            onConflictNode: T.cloneWith(this.#e.onConflictNode, {
              updates: b(e),
            }),
          });
        }
        $call(e) {
          return e(this);
        }
      }
      class E {
        #e;
        constructor(e) {
          this.#e = (0, l.CN)(e);
        }
        toOperationNode() {
          return this.#e.onConflictNode;
        }
      }
      class C {
        #e;
        constructor(e) {
          this.#e = (0, l.CN)(e);
        }
        where(...e) {
          return new C({
            ...this.#e,
            onConflictNode: T.cloneWithUpdateWhere(
              this.#e.onConflictNode,
              (0, k.GB)(e)
            ),
          });
        }
        whereRef(e, t, r) {
          return new C({
            ...this.#e,
            onConflictNode: T.cloneWithUpdateWhere(
              this.#e.onConflictNode,
              (0, k.vC)(e, t, r)
            ),
          });
        }
        clearWhere() {
          return new C({
            ...this.#e,
            onConflictNode: T.cloneWithoutUpdateWhere(this.#e.onConflictNode),
          });
        }
        $call(e) {
          return e(this);
        }
        toOperationNode() {
          return this.#e.onConflictNode;
        }
      }
      var I = r(257);
      let O = (0, l.CN)({
        is: (e) => "OrActionNode" === e.kind,
        create: (e) => (0, l.CN)({ kind: "OrActionNode", action: e }),
      });
      class L {
        #e;
        constructor(e) {
          this.#e = (0, l.CN)(e);
        }
        values(e) {
          let [t, r] = f(e);
          return new L({
            ...this.#e,
            queryNode: m.o.cloneWith(this.#e.queryNode, {
              columns: t,
              values: r,
            }),
          });
        }
        columns(e) {
          return new L({
            ...this.#e,
            queryNode: m.o.cloneWith(this.#e.queryNode, {
              columns: (0, l.CN)(e.map(s.Z.create)),
            }),
          });
        }
        expression(e) {
          return new L({
            ...this.#e,
            queryNode: m.o.cloneWith(this.#e.queryNode, {
              values: (0, u.YK)(e),
            }),
          });
        }
        defaultValues() {
          return new L({
            ...this.#e,
            queryNode: m.o.cloneWith(this.#e.queryNode, { defaultValues: !0 }),
          });
        }
        modifyEnd(e) {
          return new L({
            ...this.#e,
            queryNode: y.L.cloneWithEndModifier(
              this.#e.queryNode,
              e.toOperationNode()
            ),
          });
        }
        ignore() {
          return new L({
            ...this.#e,
            queryNode: m.o.cloneWith(this.#e.queryNode, {
              orAction: O.create("ignore"),
            }),
          });
        }
        orIgnore() {
          return new L({
            ...this.#e,
            queryNode: m.o.cloneWith(this.#e.queryNode, {
              orAction: O.create("ignore"),
            }),
          });
        }
        orAbort() {
          return new L({
            ...this.#e,
            queryNode: m.o.cloneWith(this.#e.queryNode, {
              orAction: O.create("abort"),
            }),
          });
        }
        orFail() {
          return new L({
            ...this.#e,
            queryNode: m.o.cloneWith(this.#e.queryNode, {
              orAction: O.create("fail"),
            }),
          });
        }
        orReplace() {
          return new L({
            ...this.#e,
            queryNode: m.o.cloneWith(this.#e.queryNode, {
              orAction: O.create("replace"),
            }),
          });
        }
        orRollback() {
          return new L({
            ...this.#e,
            queryNode: m.o.cloneWith(this.#e.queryNode, {
              orAction: O.create("rollback"),
            }),
          });
        }
        top(e, t) {
          return new L({
            ...this.#e,
            queryNode: y.L.cloneWithTop(this.#e.queryNode, (0, I.f)(e, t)),
          });
        }
        onConflict(e) {
          return new L({
            ...this.#e,
            queryNode: m.o.cloneWith(this.#e.queryNode, {
              onConflict: e(
                new A({ onConflictNode: T.create() })
              ).toOperationNode(),
            }),
          });
        }
        onDuplicateKeyUpdate(e) {
          return new L({
            ...this.#e,
            queryNode: m.o.cloneWith(this.#e.queryNode, {
              onDuplicateKey: v.create(b(e)),
            }),
          });
        }
        returning(e) {
          return new L({
            ...this.#e,
            queryNode: y.L.cloneWithReturning(this.#e.queryNode, (0, n.G)(e)),
          });
        }
        returningAll() {
          return new L({
            ...this.#e,
            queryNode: y.L.cloneWithReturning(this.#e.queryNode, (0, n.J)()),
          });
        }
        output(e) {
          return new L({
            ...this.#e,
            queryNode: y.L.cloneWithOutput(this.#e.queryNode, (0, n.G)(e)),
          });
        }
        outputAll(e) {
          return new L({
            ...this.#e,
            queryNode: y.L.cloneWithOutput(this.#e.queryNode, (0, n.J)(e)),
          });
        }
        clearReturning() {
          return new L({
            ...this.#e,
            queryNode: y.L.cloneWithoutReturning(this.#e.queryNode),
          });
        }
        $call(e) {
          return e(this);
        }
        $if(e, t) {
          return e ? t(this) : new L({ ...this.#e });
        }
        $castTo() {
          return new L(this.#e);
        }
        $narrowType() {
          return new L(this.#e);
        }
        $assertType() {
          return new L(this.#e);
        }
        withPlugin(e) {
          return new L({
            ...this.#e,
            executor: this.#e.executor.withPlugin(e),
          });
        }
        toOperationNode() {
          return this.#e.executor.transformQuery(
            this.#e.queryNode,
            this.#e.queryId
          );
        }
        compile() {
          return this.#e.executor.compileQuery(
            this.toOperationNode(),
            this.#e.queryId
          );
        }
        async execute() {
          let e = this.compile(),
            t = await this.#e.executor.executeQuery(e, this.#e.queryId),
            { adapter: r } = this.#e.executor,
            i = e.query;
          return (i.returning && r.supportsReturning) ||
            (i.output && r.supportsOutput)
            ? t.rows
            : [new N(t.insertId, t.numAffectedRows ?? BigInt(0))];
        }
        async executeTakeFirst() {
          let [e] = await this.execute();
          return e;
        }
        async executeTakeFirstOrThrow(e = x.F) {
          let t = await this.executeTakeFirst();
          if (void 0 === t)
            throw (0, x.x)(e)
              ? new e(this.toOperationNode())
              : e(this.toOperationNode());
          return t;
        }
        async *stream(e = 100) {
          let t = this.compile();
          for await (let r of this.#e.executor.stream(t, e, this.#e.queryId))
            yield* r.rows;
        }
        async explain(e, t) {
          let r = new L({
            ...this.#e,
            queryNode: y.L.cloneWithExplain(this.#e.queryNode, e, t),
          });
          return await r.execute();
        }
      }
      var R = r(80525),
        P = r(33669);
      class D {
        numDeletedRows;
        constructor(e) {
          this.numDeletedRows = e;
        }
      }
      var q = r(43395),
        U = r(50698),
        $ = r(93403);
      class B {
        #e;
        constructor(e) {
          this.#e = (0, l.CN)(e);
        }
        where(...e) {
          return new B({
            ...this.#e,
            queryNode: y.L.cloneWithWhere(this.#e.queryNode, (0, k.GB)(e)),
          });
        }
        whereRef(e, t, r) {
          return new B({
            ...this.#e,
            queryNode: y.L.cloneWithWhere(
              this.#e.queryNode,
              (0, k.vC)(e, t, r)
            ),
          });
        }
        clearWhere() {
          return new B({
            ...this.#e,
            queryNode: y.L.cloneWithoutWhere(this.#e.queryNode),
          });
        }
        top(e, t) {
          return new B({
            ...this.#e,
            queryNode: y.L.cloneWithTop(this.#e.queryNode, (0, I.f)(e, t)),
          });
        }
        using(e) {
          return new B({
            ...this.#e,
            queryNode: q.e.cloneWithUsing(this.#e.queryNode, (0, P.JB)(e)),
          });
        }
        innerJoin(...e) {
          return this.#t("InnerJoin", e);
        }
        leftJoin(...e) {
          return this.#t("LeftJoin", e);
        }
        rightJoin(...e) {
          return this.#t("RightJoin", e);
        }
        fullJoin(...e) {
          return this.#t("FullJoin", e);
        }
        #t(e, t) {
          return new B({
            ...this.#e,
            queryNode: y.L.cloneWithJoin(this.#e.queryNode, (0, R.a)(e, t)),
          });
        }
        returning(e) {
          return new B({
            ...this.#e,
            queryNode: y.L.cloneWithReturning(this.#e.queryNode, (0, n.G)(e)),
          });
        }
        returningAll(e) {
          return new B({
            ...this.#e,
            queryNode: y.L.cloneWithReturning(this.#e.queryNode, (0, n.J)(e)),
          });
        }
        output(e) {
          return new B({
            ...this.#e,
            queryNode: y.L.cloneWithOutput(this.#e.queryNode, (0, n.G)(e)),
          });
        }
        outputAll(e) {
          return new B({
            ...this.#e,
            queryNode: y.L.cloneWithOutput(this.#e.queryNode, (0, n.J)(e)),
          });
        }
        clearReturning() {
          return new B({
            ...this.#e,
            queryNode: y.L.cloneWithoutReturning(this.#e.queryNode),
          });
        }
        clearLimit() {
          return new B({
            ...this.#e,
            queryNode: q.e.cloneWithoutLimit(this.#e.queryNode),
          });
        }
        orderBy(...e) {
          return new B({
            ...this.#e,
            queryNode: y.L.cloneWithOrderByItems(
              this.#e.queryNode,
              (0, $.xk)(e)
            ),
          });
        }
        clearOrderBy() {
          return new B({
            ...this.#e,
            queryNode: y.L.cloneWithoutOrderBy(this.#e.queryNode),
          });
        }
        limit(e) {
          return new B({
            ...this.#e,
            queryNode: q.e.cloneWithLimit(
              this.#e.queryNode,
              U.a.create((0, c.$s)(e))
            ),
          });
        }
        modifyEnd(e) {
          return new B({
            ...this.#e,
            queryNode: y.L.cloneWithEndModifier(
              this.#e.queryNode,
              e.toOperationNode()
            ),
          });
        }
        $call(e) {
          return e(this);
        }
        $if(e, t) {
          return e ? t(this) : new B({ ...this.#e });
        }
        $castTo() {
          return new B(this.#e);
        }
        $narrowType() {
          return new B(this.#e);
        }
        $assertType() {
          return new B(this.#e);
        }
        withPlugin(e) {
          return new B({
            ...this.#e,
            executor: this.#e.executor.withPlugin(e),
          });
        }
        toOperationNode() {
          return this.#e.executor.transformQuery(
            this.#e.queryNode,
            this.#e.queryId
          );
        }
        compile() {
          return this.#e.executor.compileQuery(
            this.toOperationNode(),
            this.#e.queryId
          );
        }
        async execute() {
          let e = this.compile(),
            t = await this.#e.executor.executeQuery(e, this.#e.queryId),
            { adapter: r } = this.#e.executor,
            i = e.query;
          return (i.returning && r.supportsReturning) ||
            (i.output && r.supportsOutput)
            ? t.rows
            : [new D(t.numAffectedRows ?? BigInt(0))];
        }
        async executeTakeFirst() {
          let [e] = await this.execute();
          return e;
        }
        async executeTakeFirstOrThrow(e = x.F) {
          let t = await this.executeTakeFirst();
          if (void 0 === t)
            throw (0, x.x)(e)
              ? new e(this.toOperationNode())
              : e(this.toOperationNode());
          return t;
        }
        async *stream(e = 100) {
          let t = this.compile();
          for await (let r of this.#e.executor.stream(t, e, this.#e.queryId))
            yield* r.rows;
        }
        async explain(e, t) {
          let r = new B({
            ...this.#e,
            queryNode: y.L.cloneWithExplain(this.#e.queryNode, e, t),
          });
          return await r.execute();
        }
      }
      var M = r(63309);
      class j {
        numUpdatedRows;
        numChangedRows;
        constructor(e, t) {
          (this.numUpdatedRows = e), (this.numChangedRows = t);
        }
      }
      class W {
        #e;
        constructor(e) {
          this.#e = (0, l.CN)(e);
        }
        where(...e) {
          return new W({
            ...this.#e,
            queryNode: y.L.cloneWithWhere(this.#e.queryNode, (0, k.GB)(e)),
          });
        }
        whereRef(e, t, r) {
          return new W({
            ...this.#e,
            queryNode: y.L.cloneWithWhere(
              this.#e.queryNode,
              (0, k.vC)(e, t, r)
            ),
          });
        }
        clearWhere() {
          return new W({
            ...this.#e,
            queryNode: y.L.cloneWithoutWhere(this.#e.queryNode),
          });
        }
        top(e, t) {
          return new W({
            ...this.#e,
            queryNode: y.L.cloneWithTop(this.#e.queryNode, (0, I.f)(e, t)),
          });
        }
        from(e) {
          return new W({
            ...this.#e,
            queryNode: M.U.cloneWithFromItems(this.#e.queryNode, (0, P.JB)(e)),
          });
        }
        innerJoin(...e) {
          return this.#t("InnerJoin", e);
        }
        leftJoin(...e) {
          return this.#t("LeftJoin", e);
        }
        rightJoin(...e) {
          return this.#t("RightJoin", e);
        }
        fullJoin(...e) {
          return this.#t("FullJoin", e);
        }
        #t(e, t) {
          return new W({
            ...this.#e,
            queryNode: y.L.cloneWithJoin(this.#e.queryNode, (0, R.a)(e, t)),
          });
        }
        orderBy(...e) {
          return new W({
            ...this.#e,
            queryNode: y.L.cloneWithOrderByItems(
              this.#e.queryNode,
              (0, $.xk)(e)
            ),
          });
        }
        clearOrderBy() {
          return new W({
            ...this.#e,
            queryNode: y.L.cloneWithoutOrderBy(this.#e.queryNode),
          });
        }
        limit(e) {
          return new W({
            ...this.#e,
            queryNode: M.U.cloneWithLimit(
              this.#e.queryNode,
              U.a.create((0, c.$s)(e))
            ),
          });
        }
        set(...e) {
          return new W({
            ...this.#e,
            queryNode: M.U.cloneWithUpdates(
              this.#e.queryNode,
              (function (...e) {
                return 2 === e.length
                  ? [g.create((0, w.$O)(e[0]), (0, c.$s)(e[1]))]
                  : b(e[0]);
              })(...e)
            ),
          });
        }
        returning(e) {
          return new W({
            ...this.#e,
            queryNode: y.L.cloneWithReturning(this.#e.queryNode, (0, n.G)(e)),
          });
        }
        returningAll(e) {
          return new W({
            ...this.#e,
            queryNode: y.L.cloneWithReturning(this.#e.queryNode, (0, n.J)(e)),
          });
        }
        output(e) {
          return new W({
            ...this.#e,
            queryNode: y.L.cloneWithOutput(this.#e.queryNode, (0, n.G)(e)),
          });
        }
        outputAll(e) {
          return new W({
            ...this.#e,
            queryNode: y.L.cloneWithOutput(this.#e.queryNode, (0, n.J)(e)),
          });
        }
        modifyEnd(e) {
          return new W({
            ...this.#e,
            queryNode: y.L.cloneWithEndModifier(
              this.#e.queryNode,
              e.toOperationNode()
            ),
          });
        }
        clearReturning() {
          return new W({
            ...this.#e,
            queryNode: y.L.cloneWithoutReturning(this.#e.queryNode),
          });
        }
        $call(e) {
          return e(this);
        }
        $if(e, t) {
          return e ? t(this) : new W({ ...this.#e });
        }
        $castTo() {
          return new W(this.#e);
        }
        $narrowType() {
          return new W(this.#e);
        }
        $assertType() {
          return new W(this.#e);
        }
        withPlugin(e) {
          return new W({
            ...this.#e,
            executor: this.#e.executor.withPlugin(e),
          });
        }
        toOperationNode() {
          return this.#e.executor.transformQuery(
            this.#e.queryNode,
            this.#e.queryId
          );
        }
        compile() {
          return this.#e.executor.compileQuery(
            this.toOperationNode(),
            this.#e.queryId
          );
        }
        async execute() {
          let e = this.compile(),
            t = await this.#e.executor.executeQuery(e, this.#e.queryId),
            { adapter: r } = this.#e.executor,
            i = e.query;
          return (i.returning && r.supportsReturning) ||
            (i.output && r.supportsOutput)
            ? t.rows
            : [new j(t.numAffectedRows ?? BigInt(0), t.numChangedRows)];
        }
        async executeTakeFirst() {
          let [e] = await this.execute();
          return e;
        }
        async executeTakeFirstOrThrow(e = x.F) {
          let t = await this.executeTakeFirst();
          if (void 0 === t)
            throw (0, x.x)(e)
              ? new e(this.toOperationNode())
              : e(this.toOperationNode());
          return t;
        }
        async *stream(e = 100) {
          let t = this.compile();
          for await (let r of this.#e.executor.stream(t, e, this.#e.queryId))
            yield* r.rows;
        }
        async explain(e, t) {
          let r = new W({
            ...this.#e,
            queryNode: y.L.cloneWithExplain(this.#e.queryNode, e, t),
          });
          return await r.execute();
        }
      }
      var F = r(53668),
        Q = r(82099);
      let z = (0, l.CN)({
        is: (e) => "CommonTableExpressionNameNode" === e.kind,
        create: (e, t) =>
          (0, l.CN)({
            kind: "CommonTableExpressionNameNode",
            table: Q.H.create(e),
            columns: t ? (0, l.CN)(t.map(s.Z.create)) : void 0,
          }),
      });
      var V = r(8036);
      let K = (0, l.CN)({
        is: (e) => "CommonTableExpressionNode" === e.kind,
        create: (e, t) =>
          (0, l.CN)({
            kind: "CommonTableExpressionNode",
            name: e,
            expression: t,
          }),
        cloneWith: (e, t) => (0, l.CN)({ ...e, ...t }),
      });
      class G {
        #e;
        constructor(e) {
          this.#e = (0, l.CN)(e);
        }
        materialized() {
          return new G({
            ...this.#e,
            node: K.cloneWith(this.#e.node, { materialized: !0 }),
          });
        }
        notMaterialized() {
          return new G({
            ...this.#e,
            node: K.cloneWith(this.#e.node, { materialized: !1 }),
          });
        }
        toOperationNode() {
          return this.#e.node;
        }
      }
      function H(e, t) {
        var r;
        let i = t((0, V.bl)()).toOperationNode();
        return (0, l.Tn)(e)
          ? e(
              ((r = i), (e) => new G({ node: K.create(J(e), r) }))
            ).toOperationNode()
          : K.create(J(e), i);
      }
      function J(e) {
        if (!e.includes("(")) return z.create(e);
        {
          let t = e.split(/[\(\)]/),
            r = t[0],
            i = t[1].split(",").map((e) => e.trim());
          return z.create(r, i);
        }
      }
      let Z = (0, l.CN)({
        is: (e) => "WithNode" === e.kind,
        create: (e, t) =>
          (0, l.CN)({ kind: "WithNode", expressions: (0, l.CN)([e]), ...t }),
        cloneWithExpression: (e, t) =>
          (0, l.CN)({ ...e, expressions: (0, l.CN)([...e.expressions, t]) }),
      });
      var Y = r(6710),
        X = r(83500),
        ee = r(57960);
      let et = (0, l.CN)({
        is: (e) => "MatchedNode" === e.kind,
        create: (e, t = !1) =>
          (0, l.CN)({ kind: "MatchedNode", not: e, bySource: t }),
      });
      var er = r(10132),
        ei = r(1045),
        en = r(74465);
      function es(e, t, r) {
        return en.t.create(
          (0, k.KN)(
            [
              et.create(!e.isMatched, e.bySource),
              ...(t && t.length > 0
                ? [
                    3 === t.length && r
                      ? (0, k.vC)(t[0], t[1], t[2])
                      : (0, k.GB)(t),
                  ]
                : []),
            ],
            "and",
            !1
          )
        );
      }
      function eo(e) {
        return (0, l.Kg)(e)
          ? ei.z.create([e], [])
          : (0, er.N)(e)
            ? e.toOperationNode()
            : e;
      }
      var ea = r(87201);
      class el {
        numChangedRows;
        constructor(e) {
          this.numChangedRows = e;
        }
      }
      class ec {
        #e;
        constructor(e) {
          this.#e = (0, l.CN)(e);
        }
        modifyEnd(e) {
          return new ec({
            ...this.#e,
            queryNode: y.L.cloneWithEndModifier(
              this.#e.queryNode,
              e.toOperationNode()
            ),
          });
        }
        top(e, t) {
          return new ec({
            ...this.#e,
            queryNode: y.L.cloneWithTop(this.#e.queryNode, (0, I.f)(e, t)),
          });
        }
        using(...e) {
          return new ed({
            ...this.#e,
            queryNode: ee.r.cloneWithUsing(
              this.#e.queryNode,
              (0, R.a)("Using", e)
            ),
          });
        }
        returning(e) {
          return new ec({
            ...this.#e,
            queryNode: y.L.cloneWithReturning(this.#e.queryNode, (0, n.G)(e)),
          });
        }
        returningAll(e) {
          return new ec({
            ...this.#e,
            queryNode: y.L.cloneWithReturning(this.#e.queryNode, (0, n.J)(e)),
          });
        }
        output(e) {
          return new ec({
            ...this.#e,
            queryNode: y.L.cloneWithOutput(this.#e.queryNode, (0, n.G)(e)),
          });
        }
        outputAll(e) {
          return new ec({
            ...this.#e,
            queryNode: y.L.cloneWithOutput(this.#e.queryNode, (0, n.J)(e)),
          });
        }
      }
      class ed {
        #e;
        constructor(e) {
          this.#e = (0, l.CN)(e);
        }
        modifyEnd(e) {
          return new ed({
            ...this.#e,
            queryNode: y.L.cloneWithEndModifier(
              this.#e.queryNode,
              e.toOperationNode()
            ),
          });
        }
        top(e, t) {
          return new ed({
            ...this.#e,
            queryNode: y.L.cloneWithTop(this.#e.queryNode, (0, I.f)(e, t)),
          });
        }
        whenMatched() {
          return this.#eI([]);
        }
        whenMatchedAnd(...e) {
          return this.#eI(e);
        }
        whenMatchedAndRef(e, t, r) {
          return this.#eI([e, t, r], !0);
        }
        #eI(e, t) {
          return new eu({
            ...this.#e,
            queryNode: ee.r.cloneWithWhen(
              this.#e.queryNode,
              es({ isMatched: !0 }, e, t)
            ),
          });
        }
        whenNotMatched() {
          return this.#eO([]);
        }
        whenNotMatchedAnd(...e) {
          return this.#eO(e);
        }
        whenNotMatchedAndRef(e, t, r) {
          return this.#eO([e, t, r], !0);
        }
        whenNotMatchedBySource() {
          return this.#eO([], !1, !0);
        }
        whenNotMatchedBySourceAnd(...e) {
          return this.#eO(e, !1, !0);
        }
        whenNotMatchedBySourceAndRef(e, t, r) {
          return this.#eO([e, t, r], !0, !0);
        }
        returning(e) {
          return new ed({
            ...this.#e,
            queryNode: y.L.cloneWithReturning(this.#e.queryNode, (0, n.G)(e)),
          });
        }
        returningAll(e) {
          return new ed({
            ...this.#e,
            queryNode: y.L.cloneWithReturning(this.#e.queryNode, (0, n.J)(e)),
          });
        }
        output(e) {
          return new ed({
            ...this.#e,
            queryNode: y.L.cloneWithOutput(this.#e.queryNode, (0, n.G)(e)),
          });
        }
        outputAll(e) {
          return new ed({
            ...this.#e,
            queryNode: y.L.cloneWithOutput(this.#e.queryNode, (0, n.J)(e)),
          });
        }
        #eO(e, t = !1, r = !1) {
          let i = {
            ...this.#e,
            queryNode: ee.r.cloneWithWhen(
              this.#e.queryNode,
              es({ isMatched: !1, bySource: r }, e, t)
            ),
          };
          return new (r ? eu : eh)(i);
        }
        $call(e) {
          return e(this);
        }
        $if(e, t) {
          return e ? t(this) : new ed({ ...this.#e });
        }
        toOperationNode() {
          return this.#e.executor.transformQuery(
            this.#e.queryNode,
            this.#e.queryId
          );
        }
        compile() {
          return this.#e.executor.compileQuery(
            this.toOperationNode(),
            this.#e.queryId
          );
        }
        async execute() {
          let e = this.compile(),
            t = await this.#e.executor.executeQuery(e, this.#e.queryId),
            { adapter: r } = this.#e.executor,
            i = e.query;
          return (i.returning && r.supportsReturning) ||
            (i.output && r.supportsOutput)
            ? t.rows
            : [new el(t.numAffectedRows)];
        }
        async executeTakeFirst() {
          let [e] = await this.execute();
          return e;
        }
        async executeTakeFirstOrThrow(e = x.F) {
          let t = await this.executeTakeFirst();
          if (void 0 === t)
            throw (0, x.x)(e)
              ? new e(this.toOperationNode())
              : e(this.toOperationNode());
          return t;
        }
      }
      class eu {
        #e;
        constructor(e) {
          this.#e = (0, l.CN)(e);
        }
        thenDelete() {
          return new ed({
            ...this.#e,
            queryNode: ee.r.cloneWithThen(this.#e.queryNode, eo("delete")),
          });
        }
        thenDoNothing() {
          return new ed({
            ...this.#e,
            queryNode: ee.r.cloneWithThen(this.#e.queryNode, eo("do nothing")),
          });
        }
        thenUpdate(e) {
          return new ed({
            ...this.#e,
            queryNode: ee.r.cloneWithThen(
              this.#e.queryNode,
              eo(
                e(
                  new W({
                    queryId: this.#e.queryId,
                    executor: ea.W,
                    queryNode: M.U.createWithoutTable(),
                  })
                )
              )
            ),
          });
        }
        thenUpdateSet(...e) {
          return this.thenUpdate((t) => t.set(...e));
        }
      }
      class eh {
        #e;
        constructor(e) {
          this.#e = (0, l.CN)(e);
        }
        thenDoNothing() {
          return new ed({
            ...this.#e,
            queryNode: ee.r.cloneWithThen(this.#e.queryNode, eo("do nothing")),
          });
        }
        thenInsertValues(e) {
          let [t, r] = f(e);
          return new ed({
            ...this.#e,
            queryNode: ee.r.cloneWithThen(
              this.#e.queryNode,
              eo(
                m.o.cloneWith(m.o.createWithoutInto(), {
                  columns: t,
                  values: r,
                })
              )
            ),
          });
        }
      }
      class ep {
        #e;
        constructor(e) {
          this.#e = (0, l.CN)(e);
        }
        selectFrom(e) {
          return (0, i.c)({
            queryId: (0, Y.a)(),
            executor: this.#e.executor,
            queryNode: F.L.createFrom((0, P.JB)(e), this.#e.withNode),
          });
        }
        selectNoFrom(e) {
          return (0, i.c)({
            queryId: (0, Y.a)(),
            executor: this.#e.executor,
            queryNode: F.L.cloneWithSelections(
              F.L.create(this.#e.withNode),
              (0, n.G)(e)
            ),
          });
        }
        insertInto(e) {
          return new L({
            queryId: (0, Y.a)(),
            executor: this.#e.executor,
            queryNode: m.o.create((0, P.M$)(e), this.#e.withNode),
          });
        }
        replaceInto(e) {
          return new L({
            queryId: (0, Y.a)(),
            executor: this.#e.executor,
            queryNode: m.o.create((0, P.M$)(e), this.#e.withNode, !0),
          });
        }
        deleteFrom(e) {
          return new B({
            queryId: (0, Y.a)(),
            executor: this.#e.executor,
            queryNode: q.e.create((0, P.JB)(e), this.#e.withNode),
          });
        }
        updateTable(e) {
          return new W({
            queryId: (0, Y.a)(),
            executor: this.#e.executor,
            queryNode: M.U.create((0, P.JB)(e), this.#e.withNode),
          });
        }
        mergeInto(e) {
          return new ec({
            queryId: (0, Y.a)(),
            executor: this.#e.executor,
            queryNode: ee.r.create((0, P.Xm)(e), this.#e.withNode),
          });
        }
        with(e, t) {
          let r = H(e, t);
          return new ep({
            ...this.#e,
            withNode: this.#e.withNode
              ? Z.cloneWithExpression(this.#e.withNode, r)
              : Z.create(r),
          });
        }
        withRecursive(e, t) {
          let r = H(e, t);
          return new ep({
            ...this.#e,
            withNode: this.#e.withNode
              ? Z.cloneWithExpression(this.#e.withNode, r)
              : Z.create(r, { recursive: !0 }),
          });
        }
        withPlugin(e) {
          return new ep({
            ...this.#e,
            executor: this.#e.executor.withPlugin(e),
          });
        }
        withoutPlugins() {
          return new ep({
            ...this.#e,
            executor: this.#e.executor.withoutPlugins(),
          });
        }
        withSchema(e) {
          return new ep({
            ...this.#e,
            executor: this.#e.executor.withPluginAtFront(new X.B(e)),
          });
        }
      }
    },
    98196: (e, t, r) => {
      r.d(t, { a: () => o, b: () => c, c: () => l, g: () => a });
      var i = r(49442),
        n = r(10257);
      function s(e, t = "/api/auth") {
        return !(function (e) {
          try {
            let t = new URL(e);
            return "/" !== t.pathname;
          } catch (t) {
            throw new n.B(
              `Invalid base URL: ${e}. Please provide a valid base URL.`
            );
          }
        })(e)
          ? ((t = t.startsWith("/") ? t : `/${t}`),
            `${e.replace(/\/+$/, "")}${t}`)
          : e;
      }
      function o(e, t, r) {
        if (e) return s(e, t);
        let o =
          i.e.BETTER_AUTH_URL ||
          i.e.NEXT_PUBLIC_BETTER_AUTH_URL ||
          i.e.PUBLIC_BETTER_AUTH_URL ||
          i.e.NUXT_PUBLIC_BETTER_AUTH_URL ||
          i.e.NUXT_PUBLIC_AUTH_URL ||
          ("/" !== i.e.BASE_URL ? i.e.BASE_URL : void 0);
        if (o) return s(o, t);
        let l = r?.headers.get("x-forwarded-host"),
          c = r?.headers.get("x-forwarded-proto");
        if (l && c) return s(`${c}://${l}`, t);
        if (r) {
          let e = a(r.url);
          if (!e)
            throw new n.B(
              "Could not get origin from request. Please provide a valid base URL."
            );
          return s(e, t);
        }
        if ("undefined" != typeof window && window.location)
          return s(window.location.origin, t);
      }
      function a(e) {
        try {
          return new URL(e).origin;
        } catch (e) {
          return null;
        }
      }
      function l(e) {
        try {
          return new URL(e).protocol;
        } catch (e) {
          return null;
        }
      }
      function c(e) {
        try {
          return new URL(e).host;
        } catch (t) {
          return e;
        }
      }
    },
    99144: (e, t, r) => {
      r.d(t, { B: () => s, q: () => o });
      var i = r(10132),
        n = r(96051);
      function s(e) {
        return (0, n.Gv)(e) && "expressionType" in e && (0, i.N)(e);
      }
      function o(e) {
        return (
          (0, n.Gv)(e) && "expression" in e && (0, n.Kg)(e.alias) && (0, i.N)(e)
        );
      }
    },
    99313: (e, t, r) => {
      r.d(t, { s: () => n });
      var i = r(96051);
      let n = (0, i.CN)({
        is: (e) => "ValueListNode" === e.kind,
        create: (e) =>
          (0, i.CN)({ kind: "ValueListNode", values: (0, i.CN)(e) }),
      });
    },
  });
